
declare namespace lcjs {
/**
 * @public
 */
declare interface AbstractAxisStrategy {
}
/**
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare class _AbstractAxisTick implements Disposable {
    /**
     * **Permanently** destroy the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @returns  Object itself for fluent interface
     * @public
     */
    dispose(): this;
}
/**
 * @public
 */
export declare abstract class AbstractCursor<CursorPositionType extends AbstractCursorPosition = AbstractCursorPosition, ResultTableBackgroundType extends UIBackground = UIBackground> implements Plotable, Hideable, DisposableEvents {
    /**
     * @public
     */
    readonly scale: ScaleXY;
    /**
     * Set cursor position.
     * @param   cursorPositions -   Abstract interface that describes cursor position. Actual type depends on type of cursor (XY, 3D, Polar, etc...)
     * @returns                     Object itself.
     * @public
     */
    abstract setPosition(...cursorPositions: CursorPositionType[]): this;
    /**
     * Check whether the object is disposed.
     * Disposed objects should not be used!
     *
     * @returns     `true` if object is disposed.
     * @public
     */
    isDisposed(): boolean;
    /**
     * Set point marker visible or not.
     *
     * @param   visible  -   Point marker visible?
     * @returns              Object itself.
     * @public
     */
    setPointMarkerVisible(visible: boolean): this;
    /**
     * Get point marker visible or not.
     *
     * @returns              Boolean.
     * @public
     */
    getPointMarkerVisible(): boolean;
    /**
     * Mutator function for Cursors PointMarker.
     * PointMarker is a visual that is displayed at the Cursors position
     * @param mutator - Mutator function for PointMarker
     * @returns Object itself for fluent interface
     * @public
     */
    setPointMarker(mutator: Mutator<PointMarker>): this;
    /**
     * Set result table visible or not.
     *
     * @param   visible   -  Result table visible?
     * @returns              Object itself.
     * @public
     */
    setResultTableVisible(visible: boolean): this;
    /**
     * Get result table visible or not.
     *
     * @returns              Boolean.
     * @public
     */
    getResultTableVisible(): boolean;
    /**
     * Mutator function for Cursors ResultTable.
     * ResultTable is a visual that displays currently pointed data next to its location
     * @param mutator - Mutator function for ResultTable
     * @returns Object itself for fluent interface
     * @public
     */
    setResultTable(mutator: Mutator<ResultTable<ResultTableBackgroundType>>): this;
    /**
     * @param enabled - Auto fitting enabled or disabled
     * @returns Object itself for fluent interface
     * @public
     */
    setAutoFit(enabled: boolean): this;
    /**
     * Get is auto-fit enabled.
     * @returns Boolean flag whether auto-fit is enabled
     * @public
     */
    getAutoFit(): boolean;
    /**
     * Set element visibility.
     *
     * @param state - `true` when element should be visible and `false` when element should be hidden.
     * @returns Object itself.
     * @public
     */
    setVisible(state: boolean): this;
    /**
     * Get element visibility.
     *
     * @returns `true` when element is set to be visible and `false` otherwise.
     * @public
     */
    getVisible(): boolean;
    /**
     * **Permanently** destroy the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @returns Object itself for fluent interface
     */
    dispose(): this;
    addEventListener<K extends keyof AbstractCursorEventMap>(type: K, listener: (event: AbstractCursorEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof AbstractCursorEventMap>(type: K, listener: (event: AbstractCursorEventMap[K], info: unknown) => unknown): void;
}
/**
 * Interface of events trackable by {@link AbstractCursor.addEventListener} and the respective Event types.
 * @public
 */
export declare interface AbstractCursorEventMap extends DisposableEventMap {
}
/**
 * @public
 */
declare interface AbstractCursorPosition {
    resultTable: Point;
    resultTableScale: UserScaleDefinition;
    pointMarkerFillStyle?: FillStyle;
    pointMarkerStrokeStyle?: LineStyle;
    pointMarkerShape?: PointShape;
    pointMarkerSize?: Point;
}
/**
 * End user managed Tick. Custom ticks are just like default ticks, except they can be completely controlled by the end user.
 *
 * For example, their position, text, text fill style, gridline style, etc. everything can be customized.
 * They can be created whenever and destroyed whenever.
 *
 * This definition of Custom Tick is abstract, meaning that it is not tied to any specific chart type.
 * See specific implementations:
 *
 * - {@link CustomTick}
 * - {@link CustomTick3D}
 * - {@link ParallelCoordinateAxisCustomTick}
 *
 * @public
 */
export declare interface AbstractCustomTick extends Disposable, DisposableEvents, Hideable, HideableEvents {
    /**
     * Set location of custom tick on its Axis.
     *
     * ```ts
     *  // Example usage
     *  CustomTick.setValue(5)
     * ```
     *
     * @param   value - Location on axis.
     * @returns         Object itself
     * @public
     */
    setValue(value: number): this;
    /**
     * Get location of custom tick on its Axis.
     * @returns         Location on axis.
     * @public
     */
    getValue(): number;
    /**
     * Set style of custom ticks tickline.
     * This line connects the text to its Axis, generally a very short line (6 pixels, or so).
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  CustomTick.setTickStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  CustomTick.setTickStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * ```ts
     *  // Example syntax, disable stroke
     *  CustomTick.setTickStyle(emptyLine)
     * ```
     *
     * @param   value   -   LineStyle or function which returns a LineStyle based on previous value.
     * @returns             Object itself.
     * @public
     */
    setTickStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of custom ticks tickline.
     * @returns         LineStyle
     * @public
     */
    getTickStyle(): LineStyle;
    /**
     * Set tickline length as pixels.
     *
     * ```ts
     *  // Example usage
     *  CustomTick.setTickLength(5)
     * ```
     *
     * @param   length -    Tickline length as pixels
     * @returns         Object itself
     * @public
     */
    setTickLength(length: number): this;
    /**
     * Get tickline length as pixels.
     * @returns         Tickline length as pixels.
     * @public
     */
    getTickLength(): number;
    /**
     * Set style of custom ticks gridline.
     * This line highlights the tick location under the series area.
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  CustomTick.setGridStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  CustomTick.setGridStrokeStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * ```ts
     *  // Example syntax, disable stroke
     *  CustomTick.setGridStrokeStyle(emptyLine)
     * ```
     *
     * @param   value   -   LineStyle or function which returns a LineStyle based on previous value.
     * @returns             Object itself.
     * @public
     */
    setGridStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of custom ticks gridline.
     * @returns         LineStyle
     * @public
     */
    getGridStrokeStyle(): LineStyle;
    /**
     * Set padding between CustomTick tickline and text.
     *
     * ```ts
     *  // Example usage
     *  CustomTick.setTextPadding(5)
     * ```
     *
     * @param   padding - Padding as pixels
     * @returns         Object itself
     * @public
     */
    setTextPadding(padding: number): this;
    /**
     * Get padding between CustomTick tickline and text.
     * @returns         Padding as pixels
     * @public
     */
    getTextPadding(): number;
    /**
     * Set custom tick text rotation as degrees.
     *
     * ```ts
     *  // Example usage
     *  CustomTick.setTextRotation(90)
     * ```
     *
     * @param   value - Rotation as degrees.
     * @returns         Object itself
     * @public
     */
    setTextRotation(value: number): this;
    /**
     * Get custom tick text rotation as degrees.
     * @returns         Rotation as degrees.
     * @public
     */
    getTextRotation(): number;
    /**
     * Set fill style of custom ticks text.
     *
     * ```ts
     *  // Example syntax, red fill
     *  CustomTick.setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     * ```
     *
     * ```ts
     *  // Example syntax, disable fill
     *  CustomTick.setTextFillStyle(emptyFill)
     * ```
     *
     * @param   value   -   FillStyle or function which returns a FillStyle based on previous value.
     * @returns             Object itself.
     * @public
     */
    setTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of custom ticks text.
     * @returns         FillStyle
     * @public
     */
    getTextFillStyle(): FillStyle;
    /**
     * Set font of custom ticks text.
     *
     * ```ts
     *  // Example syntax, specify FontSettings
     *  CustomTick.setTextFont(new FontSettings({
     *      size: 14,
     *      family: 'Arial',
     *      weight: 'normal',
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change to italic
     *  CustomTick.setTextFont(font => font.setStyle('italic'))
     * ```
     *
     * To remove custom tick text, use {@link setTextFillStyle}
     *
     * @param   value   -   FontSettings or function which returns a FontSettings based on previous value.
     * @returns             Object itself.
     * @public
     */
    setTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of custom ticks text.
     * @returns         FontSettings
     * @public
     */
    getTextFont(): FontSettings;
    /**
     * Set text formatting of custom tick as a callback function.
     *
     * ```ts
     *  // Example usage
     *  CustomTick.setTextFormatter((value) => `Custom tick at ${value.toFixed(1)}`)
     * ```
     *
     * The supplied callback function is called with the current axis location of the custom tick.
     * To provide hard defined text, just ignore the `value`.
     *
     * ```ts
     *  // Example, hard defined custom tick text.
     *  CustomTick.setTextFormatter(() => `My tick text`)
     * ```
     *
     * @param   textFormatter   -   Callback function which returns custom tick text as string.
     * @returns         Object itself
     * @public
     */
    setTextFormatter(textFormatter: (value: number) => string): this;
    /**
     * Set component mouse interactions enabled or disabled.
     *
     * Disabling mouse interactions means that the objects below this component can be interacted _through_ it.
     *
     * @param state - Specifies state of mouse interactions
     * @returns Object itself for fluent interface
     * @public
     */
    setPointerEvents(state: boolean): this;
    /**
     * Get mouse interactions enabled or disabled.
     * @returns Mouse interactions state
     * @public
     */
    getPointerEvents(): boolean;
    addEventListener(type: 'dispose', listener: (event: DisposeEvent, info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
    addEventListener(type: 'visiblechange', listener: (event: VisibleChangedEvent, info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
    addEventListener(type: 'valuechange', listener: (event: CustomTickValueChangeEvent, info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener(type: 'dispose', listener: (event: DisposeEvent, info: unknown) => unknown): void;
    removeEventListener(type: 'visiblechange', listener: (event: VisibleChangedEvent, info: unknown) => unknown): void;
    removeEventListener(type: 'valuechange', listener: (event: CustomTickValueChangeEvent, info: unknown) => unknown): void;
}
/**
 * Abstract base class for Point Series 3D implementations.
 *
 * Implements full series logic except for Point Style API and segment length.
 * @public
 */
declare abstract class AbstractPointSeries3D<Style extends TriangulatedPoints3D | PixelatedPoints3D> extends Series3D implements XYZDataInput {
    /**
     * Append a single `XYZ` coordinate or list of coordinates into the *series*.
     *
     * ```ts
     *  // Example, add single data point.
     *  pointSeries.add({ x: 0, y: 0, z: 0 })
     *
     *  // Example, add list of data points.
     *  pointSeries.add([
     *      { x: 0, y: 100, z: 50 },
     *      { x: 10, y: 50, z: 150 },
     *      { x: 20, y: 75, z: 100 },
     *  ])
     * ```
     *
     * Performance-wise, it is more efficient to call `add` just 1 time with an Array of points, instead of calling `add` several times with 1 point at a time.
     *
     * Data points can also be grouped with extra optional properties:
     * - `size` | Point size.
     * - `color` | Point color.
     * - `value` | Point value for dynamic coloring.
     *
     * {@link setPointStyle} method documentation contains detailed information about each of these features and how to use them.
     *
     * @param points - Single XYZ coordinate or list of coordinates.
     * @returns Object itself for fluent interface.
     * @public
     */
    add(data: Point3D | Point3D[]): this;
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  pointSeries.clear()
     * ```
     *
     * @returns Object itself for fluent interface.
     * @public
     */
    clear(): this;
    /**
     * Get amount of points that series currently has.
     * @returns Number of points
     * @public
     */
    getPointAmount(): number;
    addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResult3D) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResult3D) => unknown): void;
}
/**
 * Class for animation handling
 * @param delta - Delta time from start of animation
 * @param eases - Array of Eases animation functions
 * @param nextAnimations - Queue of future animations
 * @param action - Function for handling of interframe modification
 * @param duration - Animation duration in milliseconds
 * @param easing - Ease animation function factory
 * @public
 */
declare class Animation_2 {
    /**
     * @public
     */
    delta: number;
    /**
     * @public
     */
    eases: Array<Ease>;
    /**
     * @public
     */
    readonly nextAnimations: Animation_2[];
    /**
     * @public
     */
    readonly values: Array<[number, number]>;
    /**
     * @public
     */
    readonly action: AnimationFrameCallback;
    /**
     * @public
     */
    readonly duration: number;
    /**
     * @public
     */
    readonly easing: AnimationEasing;
    /**
     * Starts an animation
     * @returns Object itself for fluent interface
     * @public
     */
    start(): this;
    /**
     * Add animations which has to be executed subsequently
     * @param animations - Subsequent Animation or Array of them
     * @returns Object itself for fluent interface
     * @public
     */
    addNextAnimations(animations: Animation_2 | Array<Animation_2>): this;
    /**
     * Add and create animation which has to be executed subsequently
     * @param values - Array of start and end animation values
     * @param action - Function for handling of interframe modification
     * @returns new Animation
     * @public
     */
    NextAnimation(values: Array<[number, number]>, action: AnimationFrameCallback, duration?: number, easing?: AnimationEasing): Animation_2;
    /**
     * Finish current animation and start the next one on the sequence
     * @param emitEvents - Flag that tells whether the function should emit any events
     * @returns Future animations or undefined
     * @public
     */
    finish(emitEvents?: boolean): Animation_2 | undefined;
    /**
     * Finish all animations
     * @param emitEvents - Flag that tells whether the function should emit any events
     * @public
     */
    finishAll(emitEvents?: boolean): void;
    /**
     * Get is animation over and there are no queued animations
     * @public
     */
    isOver: () => boolean;
    /**
     * Get final value of queued animations
     * @returns Final values of the animations
     * @public
     */
    getFinalValues(): number[];
    /**
     * Get time until all queued animations will finish
     * @public
     */
    getTimeUntilFinish(): number;
    addEventListener<K extends keyof AnimatorEventMap>(type: K, listener: (event: AnimatorEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof AnimatorEventMap>(type: K, listener: (event: AnimatorEventMap[K], info: unknown) => unknown): void;
}
export { Animation_2 as Animation }
/**
 * Interface for {@link AnimationEasing}.
 *
 * See  {@link AnimationEasings} for a collection of default options.
 * @param start - Starting value of the animation
 * @param end - End value of the animation
 * @param duration - Animation Duration in milliseconds
 * @public
 */
export declare type AnimationEasing = (start: number, end: number, duration: number) => Ease;
/**
 * {@link AnimationEasing} collection to use with {@link Animator}.
 * @public
 */
export declare const AnimationEasings: {
    linear: (start: number, end: number, duration: number) => Ease;
    easeIn: (start: number, end: number, duration: number) => Ease;
    easeOut: (start: number, end: number, duration: number) => Ease;
    ease: (start: number, end: number, duration: number) => Ease;
    /**
     * Scroll easing factory for logarithmic axes.
     */
    logarithmic: (base: number) => AnimationEasing;
};
/**
 * Type of Animation Factory
 * @param values - Array of start and end animation values
 * @param action - Function for handling of interframe modification
 * @param customDuration - Override default duration of animation
 * @public
 */
export declare type AnimationFactory = (values: Array<[number, number]>, action: AnimationFrameCallback, customDuration?: number) => Animation_2;
/**
 * Function for handling of interframe modification
 * @param values - Values calculated by Ease function
 * @public
 */
export declare type AnimationFrameCallback = (values: Array<number>) => void;
/**
 * Animator factory.
 *
 * **Unpolished API, usage can be copied from Examples set but it is not further encouraged**.
 * @param afterUpdate - After all animation update callback
 * @param fps - Desirable frame rate for all animations (Limited to around 60fps by browser)
 * @public
 */
export declare const Animator: (afterUpdate: () => void, fps?: number) => (duration?: number, easing?: AnimationEasing) => AnimationFactory;
/**
 * Interface of events trackable by {@link Animator.addEventListener} and the respective Event types.
 * @public
 */
export declare interface AnimatorEventMap {
    start: {};
    end: {
        nextAnimation?: Animation_2;
    };
    everyAnimationEnd: {
        nextAnimation?: Animation_2;
    };
    allAnimationEnd: {};
}
/**
 * Application deployment license information.
 * @public
 */
export declare interface AppDeploymentLicenseInformation {
    /**
     * Company name
     */
    company: string;
    /**
     * Application title
     */
    appTitle: string;
    [key: string]: string;
}
/**
 * Rectangular area in cartesian coordinates
 * @param x - X position of the area
 * @param y - Y position of the area
 * @param width - Width of the area
 * @param height - Height of the area
 */
declare interface Area {
    x: number;
    y: number;
    width: number;
    height: number;
}
/**
 * Interface for a data-structure which represents a 2-dimensional location, but with one of the planes
 * having two values instead of just one to create an area in the given location.
 *
 * Used to supply points to AreaRangeSeries.
 * @public
 */
export declare interface AreaPoint {
    /**
     * Position of Point.
     */
    readonly position: number;
    /**
     * High value of Point in the given position.
     */
    readonly high: number;
    /**
     * Low value of Point in the given position.
     */
    readonly low: number;
}
/**
 * Implementation of *SeriesXY* for visualizing a collection of progressive *AreaPoints*
 * (which consist of one *X*-value, and two *Y*-values) by filling the area between the points two *Y*-values.
 *
 * Composed of the areas *fill* and *border*, both of which have two possible styles:
 * - **High**
 * - **Low**. This is used for *AreaPoints* whose *high*-value is **lower** than the *low*-value.
 *
 * *AreaRangeSeries* are created with {@link ChartXY.addAreaRangeSeries}.
 * @public
 */
export declare class AreaRangeSeries extends RangeSeries implements ObservableXYData<AreaPoint>, DataInputHighLow {
    solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultXY | undefined;
    /**
     * Add point or array of points to the dataset.
     *
     * ```ts
     *  // Example syntax
     *  AreaRangeSeries.add({ position: 0, low: 10, high: 100 })
     *
     *  AreaRangeSeries.add([
     *      { position: 0, low: 100, high: 200 },
     *      { position: 10, low: 50, high: 220 },
     *      { position: 20, low: 75, high: 250 },
     *  ])
     * ```
     *
     * **Data gaps**
     *
     * When using {@link LineSeries}, {@link AreaSeries}, {@link AreaRangeSeries} or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN`.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  AreaRangeSeries.add([
     *      { position: 0, low: 10, high: 30 },
     *      { position: 1, low: 12, high: 32 },
     *      { position: 2, low: Number.NaN, high: Number.NaN },
     *      { position: 10, low: 15, high: 38 },
     *      { position: 11, low: 20, high: 35 },
     *      { position: 12, low: 18, high: 30 }
     *  ])
     * ```
     * @param points - Single new point or an array of new points.
     * @returns Series itself for fluent interface.
     * @public
     */
    add(data: AreaPoint | AreaPoint[]): this;
    /**
     * Add two individual Arrays, one for high values, and another for low values.
     * @param arrayHigh - Array of High values.
     * @param arrayLow - Array of Low values. Length should be equal to length of *array1*.
     * @returns Object itself for fluent interface.
     * @public
     */
    addArraysHighLow(arrayHigh: number[] | TypedArray, arrayLow: number[] | TypedArray, step?: number, start?: number): this;
    /**
     * Set fill style of high area of the Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaRangeSeries.setHighFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaRangeSeries.setHighFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden
     * AreaRangeSeries.setHighFillStyle(emptyFill)
     * ```
     *
     * Supports following styles:
     * - {@link SolidFill}
     * - {@link LinearGradientFill}
     * - {@link RadialGradientFill}
     * - {@link PalettedFill} (x and y lookup modes)
     * - {@link emptyFill}
     *
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setHighFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set fill style of low area of the Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaRangeSeries.setLowFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaRangeSeries.setLowFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden
     * AreaRangeSeries.setLowFillStyle(emptyFill)
     * ```
     *
     * Supports following styles:
     * - {@link SolidFill}
     * - {@link LinearGradientFill}
     * - {@link RadialGradientFill}
     * - {@link PalettedFill} (x and y lookup modes)
     * - {@link emptyFill}
     *
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setLowFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set style of the Series high stroke.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * AreaRangeSeries.setHighStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaRangeSeries.setHighStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaRangeSeries.setHighStrokeStyle(transparentLine)
     * ```
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setHighStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Set style of the Series low stroke.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * AreaRangeSeries.setLowStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaRangeSeries.setLowStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaRangeSeries.setLowStrokeStyle(transparentLine)
     * ```
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setLowStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get a current fill style used for the coloring of the high area in the series.
     * @returns Current fill style used for the coloring of the high area in the series.
     * @public
     */
    getHighFillStyle(): FillStyle;
    /**
     * Get a current fill style used for the coloring of the low area in the series.
     * @returns Current fill style used for the coloring of the low area in the series.
     * @public
     */
    getLowFillStyle(): FillStyle;
    /**
     * Get a current line style of a stroke used for the coloring of the high border in the series.
     * @returns Current line style of a stroke used for the coloring of the high border.
     * @public
     */
    getHighStrokeStyle(): LineStyle;
    /**
     * Get a current line style of a border used for the coloring of the low border in the series.
     * @returns Current line style of a border used for the coloring of the low border.
     * @public
     */
    getLowStrokeStyle(): LineStyle;
    addEventListener<K extends keyof AreaRangeSeriesEventMap>(type: K, listener: (event: AreaRangeSeriesEventMap[K], info: SolveResultXY) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof AreaRangeSeriesEventMap>(type: K, listener: (event: AreaRangeSeriesEventMap[K], info: SolveResultXY) => unknown): void;
}
/**
 * Interface of events trackable by {@link AreaRangeSeries.addEventListener} and the respective Event types.
 * @public
 */
export declare interface AreaRangeSeriesEventMap extends RangeSeriesEventMap {
}
/**
 * Interface for supplying readonly configurations to a {@link AreaRangeSeries}.
 * @public
 */
export declare interface AreaRangeSeriesOptions extends SeriesOptionsXY {
}
/**
 * Object which can be attached to a Legend
 * @public
 */
export declare interface Attachable {
    /**
     * Get component visibility.
     */
    getVisible?: () => boolean;
    /**
     * Set component visibility.
     */
    setVisible?: (visible: boolean) => unknown;
    /**
     * Get component name for legend entry.
     */
    getName?: () => string;
}
/**
 * Data structure of a territory of Australia.
 * @public
 */
export declare interface AustraliaTerritory {
    /**
     * Name of the territory. Eq. 'Queensland'. This is case insensitive.
     */
    name: string;
}
/**
 * Interface for describing *auto dispose mode* of an UI element.
 *
 * Can be used to set a condition, where the UI element is automatically *disposed*, removing it from view.
 * Use with {@link UIElement.setAutoDispose}.
 *
 * ```ts
 *  // Example, remove UI element when it is larger than 20% of viewport.
 *  UIElement.setAutoDispose({
 *      type: 'max-width',
 *      maxWidth: 0.20,
 *  })
 * ```
 * @public
 */
export declare type AutoDisposeMode = undefined | {
    type: 'max-width';
    maxWidth: number;
} | {
    type: 'max-height';
    maxHeight: number;
};
/**
 * *Axis* is a child component of *ChartXY*. It defines a numeric range on a single plane (*X* or *Y*),
 * that will be used to scale attached *Series* to the *ChartXY*s viewport.
 *
 * The default `Axis` can be referenced with {@link ChartXY.getDefaultAxisX} and {@link ChartXY.getDefaultAxisY}.
 *
 * `ChartXY` doesn't have a limit on number of *axes*. Additional *axes* can be created with {@link ChartXY.addAxisX} and {@link ChartXY.addAxisY}.
 * Multiple *Axes* can be stacked on top of another, and *axes* can be positioned on either side of the *chart* (left, right, top, bottom, see {@link AxisOptions}).
 *
 * The visual components of *axis* are:
 * - Title. By default *axis* has no title. It can be enabled with {@link Axis.setTitle}.
 * - Axis line. A single horizontal line for *X axes*, and vertical line for *Y axes*. It can be styled with {@link Axis.setStrokeStyle}.
 * - [Ticks](#axis-ticks). Labels that help understand the data visualized along an axis.
 *   - [Numeric ticks](#numeric-ticks)
 *   - [Datetime ticks](#datetime-ticks)
 *   - [Custom ticks](#custom-ticks)
 *
 * - [Highlighters](#axis-highlighters). Can be used to highlight positions or areas on an *axis*.
 *
 * See [Scrolling and interval configuration](#axis-automatic-scrolling-and-axis-intervals-configuration) for detailed information about management of *axis interval*.
 *
 * #### Axis Ticks
 *
 * Ticks are labels attached to the *axis line* that visualize the progression of values along the *axis*. A tick consists of three individually stylable parts:
 * - Label (text)
 * - Tick line.
 * - Grid line.
 *
 * There are currently three different ways of managing axis ticks:
 * 1. Automatic numeric ticks (default).
 * 3. Automatic time ticks.
 * 2. Automatic datetime ticks.
 * 4. Custom ticks.
 *
 * ##### Numeric ticks
 *
 * Numeric ticks are enabled by default for all *axes*.
 * They are designed for depicting numeric values of all magnitudes.
 *
 * Configuring the ticks is done with {@link Axis.setTickStrategy}.
 *
 * ```typescript
 * Axis.setTickStrategy(AxisTickStrategies.Numeric, (strategy) => strategy
 *   // Configure NumericTickStrategy
 *   .setMinorFormattingFunction((tickPosition) => `X: ${tickPosition}`)
 *   .setMinorTickStyle((tickStyle: TickStyle) => tickStyle
 *     .setTickLength(12)
 *     .setTickPadding(2)
 *   )
 * )
 * ```
 *
 * Frequently used API:
 *
 * - {@link NumericTickStrategy.setMajorFormattingFunction} | set formatting of major ticks labels text.
 * - {@link NumericTickStrategy.setMinorFormattingFunction} | set formatting of minor ticks labels text.
 * - {@link NumericTickStrategy.setMajorTickStyle} | set style of major ticks.
 * - {@link NumericTickStrategy.setMinorTickStyle} | set style of minor ticks.
 *
 * For full list of configuration API, see {@link NumericTickStrategy}.
 *
 * Examples showcasing *numeric axes*:
 * - [Shared Axis example](https://lightningchart.com/lightningchart-js-interactive-examples/examples/lcjs-example-0007-sharedAxis.html)
 *
 * ##### Time ticks
 *
 * Time ticks are designed for depicting time ranges between hundreds of hours to individual nanoseconds.
 *
 * They are enabled, as well as configured, with {@link Axis.setTickStrategy}.
 *
 * ```typescript
 * Axis.setTickStrategy(AxisTickStrategies.Time, (strategy) => strategy
 *   // Configure TimeTickStrategy
 *   .setMinorFormattingFunction((tickPosition) => `X: ${tickPosition}`)
 *   .setMinorTickStyle((tickStyle: TickStyle) => tickStyle
 *     .setTickLength(12)
 *     .setTickPadding(2)
 *   )
 * )
 * ```
 *
 * Frequently used API:
 *
 * - {@link TimeTickStrategy.setMajorTickStyle} | set style of major ticks.
 * - {@link TimeTickStrategy.setMinorTickStyle} | set style of minor ticks.
 *
 * For full list of configuration API, see {@link TimeTickStrategy}.
 *
 * Examples showcasing `TimeTickStrategy`:
 * - No listed examples as of yet.
 *
 * ##### Datetime ticks
 *
 * DateTime ticks are enabled, as well as configured, with {@link Axis.setTickStrategy}.
 *
 * ```typescript
 * Axis.setTickStrategy(AxisTickStrategies.DateTime, (strategy) => strategy
 *   // Configure DateTimeTickStrategy
 *   .setMinorTickStyle((tickStyle: TickStyle) => tickStyle
 *     .setTickLength(12)
 *     .setTickPadding(2)
 *   )
 * )
 * ```
 *
 * Frequently used API:
 * - {@link DateTimeTickStrategy.setMajorTickStyle} | set style of major ticks.
 * - {@link DateTimeTickStrategy.setMinorTickStyle} | set style of minor ticks.
 * - {@link DateTimeTickStrategy.setDateOrigin} | set date origin (required for most applications with zooming enabled).
 *
 * For full list of configuration API, see {@link DateTimeTickStrategy}.
 *
 * Examples showcasing *datetime axes*:
 * - [Datetime Axis example](https://lightningchart.com/lightningchart-js-interactive-examples/examples/lcjs-example-0020-dateTimeAxis.html)
 *
 * ##### Custom ticks
 *
 * Automatic creation of ticks can be disabled with {@link Axis.setTickStrategy}:
 *
 * ```typescript
 * // Disable automatic axis ticks.
 * Axis.setTickStrategy(AxisTickStrategies.Empty)
 * ```
 *
 * *Custom ticks* can be created with {@link Axis.addCustomTick}:
 *
 * ```typescript
 * // Create custom ticks.
 * for (let x = 0; x < 100; x += 10) {
 *   const tick = Axis.addCustomTick(UIElementBuilders.AxisTickMajor)
 * }
 * ```
 *
 * Frequently used `CustomTick` API:
 * - {@link CustomTick.setValue} | configure position of tick on *axis*.
 * - {@link CustomTick.setTextFormatter} | configure text displayed by tick label using a callback function.
 * - {@link CustomTick.setTickLength} | configure length of tick line.
 * - {@link CustomTick.setGridStrokeStyle} | style tick grid line.
 * - {@link CustomTick.setMarker} | style tick label and/or tick line.
 * - {@link CustomTick.dispose} | destroy tick permanently
 *
 * Examples showcasing *custom axis ticks*:
 * - [Custom Axis Ticks example](https://lightningchart.com/lightningchart-js-interactive-examples/examples/lcjs-example-0011-customTicksScrolling.html)
 *
 * #### Axis automatic scrolling and Axis intervals configuration
 *
 * *Axis interval* is the range of data values that are visible on the *Axis*, they are referred to as *start* and *end*.
 *
 * By default, all *axes* fit the interval automatically to reveal all attached *series*. This behavior is called *fitting scroll strategy*.
 *
 * Automatic scrolling behavior can be controlled by selecting the *scroll strategy*, with {@link Axis.setScrollStrategy}:
 *
 * ```typescript
 * // Select scrolling strategy.
 * Axis.setScrollStrategy(AxisScrollStrategies.scrolling)
 * ```
 *
 * For different options see {@link AxisScrollStrategies}
 *
 * Axis interval can be manually set with {@link Axis.setInterval}:
 *
 * ```typescript
 * // Axis start = 0, end = 100.
 * Axis.setInterval({ start: 0, end: 100 })
 * ```
 *
 * Setting Axis interval stops axis scrolling by default. To specify axis interval and keep auto scrolling enabled, use the optional `stopAxisAfter` parameter:
 * ```typescript
 * Axis.setInterval({ start: 0, end: 100, stopAxisAfter: false })
 * ```
 *
 * Frequently used methods:
 * - {@link Axis.setScrollStrategy} | configure automatic scrolling behavior.
 * - {@link Axis.setInterval} | configure active axis interval.
 * - {@link Axis.getInterval} | get active axis interval.
 * - {@link Axis.fit} | fit axis interval to contain all attached series boundaries.
 * - {@link Axis.stop} | stop automatic scrolling momentarily.
 * - {@link Axis.onIntervalChange} | trigger a custom action whenever axis scale changes.
 * - {@link Axis.setAnimationScroll} | Enable/disable automatic scrolling animation.
 *
 * ##### Axis interval limitations
 *
 * *LightningChart JS* is easily the market leader in zooming interactions and visualization resolution, and contrary to most chart libraries, we are open about axis zooming limits;
 *
 * "Axis zooming limits" refer to constraints on the magnitude of Axis interval, which is calculated as `Math.abs(end - start)`.
 * When the limit is reached, the Axis will not be able to zoom in and out further by programmatic calls ({@link Axis.setInterval}) or user interactions.
 *
 * The constraints are primarily affected by two factors:
 * - Active *Tick Strategy*.
 * - Axis type.
 *
 * Both of these factors have their own definition of support minimum and maximum Axis interval, and when combined the lesser values are used.
 * For example, if *Tick Strategy* would allow min interval of `0.001` and *Axis type* `0.005`, effectively the min interval would be `0.001`.
 *
 * The Axis interval limits imposed by each available *Tick Strategy* are documented at {@link AxisTickStrategies}.
 *
 * The Axis interval limits imposed by *Axis Type* are documented at {@link AxisOptions}.
 *
 * #### Axis highlighters
 *
 * Two kinds of *highlighters* are supported:
 * - {@link ConstantLine} | highlights a position on the Axis.
 * - {@link Band} | highlights a range on the Axis.
 *
 * Examples showcasing *axis highlighters*:
 * - [Bands and ConstantLines example](https://lightningchart.com/lightningchart-js-interactive-examples/examples/lcjs-example-0701-bandsConstantlines.html)
 * @public
 */
export declare class Axis extends GenericAxis<LinearScale1D | LogarithmicScale1D, DimensionalAxisStrategy, Tick, _UpdateInputAxisXY, _TickPlottingVariablesXY, _TickXYInfo, _UpdateOutputAxisXY> implements Validatable, StylableAxisLine, Hideable, HideableEvents, Interactable, Highlightable {
    /**
     * @public
     */
    readonly isX: boolean;
    /**
     * @public
     */
    readonly isY: boolean;
    setHighlight(highlight: boolean | number): this;
    getHighlight(): number;
    /**
     * Configure whether axis should keep axis tick labels in its boundaries.
     * This is done by shifting the label so that it fits (doesn't go outside axis bounds).
     * This effect can cause labels to overlap with each other, but generally it does not occur in normal scenarios.
     * This is enabled by default.
     *
     * ```ts
     *  // Example, disable
     *  chart.axisX.setKeepTickLabelsInAxisBounds(false)
     * ```
     * @param enabled - Boolean
     * @returns Object itself
     * @public
     */
    setKeepTickLabelsInAxisBounds(enabled: boolean): this;
    /**
     * Check whether axis should keep axis tick labels in its boundaries.
     * This is done by shifting the label so that it fits (doesn't go outside axis bounds).
     * This effect can cause labels to overlap with each other, but generally it does not occur in normal scenarios.
     * This is enabled by default.
     * @returns Boolean
     * @public
     */
    getKeepTickLabelsInAxisBounds(): boolean;
    /**
     * Set *TickStrategy* of *Axis*.
     *
     * The *TickStrategy* defines the positioning and formatting logic of *Axis* ticks
     * as well as the style of created ticks.
     *
     * **Example usage**:
     *
     * **DateTime Axis**:
     * ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.DateTime )
     * ```
     *
     * **Disable automatic ticks completely**:
     * ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.Empty )
     * ```
     *
     * **Customized TickStrategy**:
     * ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.Numeric, ( tickStrategy: NumericTickStrategy ) => tickStrategy
     *      .setNumericUnits( true )
     *      .setMajorTickStyle( ( tickStyle ) => tickStyle
     *          .setLabelFont( ( font ) => font
     *              .setWeight( 'bold' )
     *          )
     *      )
     *  )
     * ```
     *
     * **Type table for optional second parameter ('styler')**:
     *
     * | tickStrategy   | styler                                                        |
     * | :------------- | :------------------------------------------------------------ |
     * | 'Numeric'      | `( tickStrategy: **NumericTickStrategy** ) => tickStrategy`   |
     * | 'Time'         | `( tickStrategy: **TimeTickStrategy** ) => tickStrategy`      |
     * | 'DateTime'     | `( tickStrategy: **DateTimeTickStrategy** ) => tickStrategy`  |
     * | 'Empty'        | `undefined`                                                   |
     *
     *
     * @param tickStrategy - Selected TickStrategy.
     *                          See {@link AxisTickStrategies} for a collection of options.
     * @param styler - Optional callback that can be used to customize the *TickStrategy*.
     *                          The type of supplied *TickStrategy* object depends on what was supplied to 'tickStrategy' parameter;
     *                          See the above method documentation for a value table.
     * @returns Object itself for fluent interface.
     * @public
     */
    setTickStrategy<TickStrategy extends TickStrategyType>(tickStrategy: TickStrategy, styler?: TickStrategyStyler<TickStrategyParameters, TickStrategy>): this;
    /**
     * Get the currently used tick strategy
     * @public
     */
    getTickStrategy(): TickStrategyType;
    /**
     * Add a highlighter Band to the Axis.
     * A Band can be used to highlight an interval on the Axis.
     *
     * @param onTop - Is Band rendered above Series, or below. Default to above.
     * @returns Band object.
     * @public
     */
    addBand(options?: {
        onTop?: boolean;
        legend?: LegendEntryOptions;
    }): Band;
    /**
     * Add a highlighter ConstantLine to the Axis.
     * A ConstantLine can be used to highlight a specific value on the Axis.
     *
     * @param onTop - Is ConstantLine rendered above Series, or below. Default to above.
     * @returns ConstantLine object.
     * @public
     */
    addConstantLine(options?: {
        onTop?: boolean;
        legend?: LegendEntryOptions;
    }): ConstantLine;
    /**
     * Get all Highlighters of Axis.
     * @returns array of highlighters
     * @public
     */
    getHighlighters(): Highlighter[];
    /**
     * Set Axis *thickness* as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax,
     *  Axis.setThickness( 60 )
     * ```
     *
     * @param thickness - Explicit thickness of Axis as pixels.
     * @returns Object itself for fluent interface.
     * @public
     */
    setThickness(thickness: number | undefined): this;
    /**
     * Configure Axis *thickness* min/max limits as pixels.
     *
     * The thickness of Axis is calculated based on ticks, title, axis line, etc.
     * By setting `min` and/or `max` thickness, the size allocated for Axis can be restricted to desired limits.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax, set axis to at least 100 px thick, but allow larger axis thickness if labels are large, or other such scenario.
     *  Axis.setThickness({ min: 100, max: undefined })
     * ```
     *
     * @param thickness - Explicit thickness of Axis as pixels.
     * @returns Object itself for fluent interface.
     * @public
     */
    setThickness(thickness: {
        min?: number;
        max?: number;
    }): this;
    /**
     * Get Axis *thickness* min/max limits as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * By default, Axis has no thickness restrictions, so `getThickness` should return `{ min: undefined, max: undefined }`.
     *
     * @returns Actively configured Axis thickness limits as pixels.
     * @public
     */
    getThickness(): {
        min: number | undefined;
        max: number | undefined;
    };
    /**
     * Used in phase 1: after we know what ticks will be displayed, formulate generic information for chart layout calculations (e.g. XY layout for XY charts).
     */
    protected _getAbstractUpdateResult(input: _UpdateInputAxisXY, ticksInfo: Map<Tick, _TickXYInfo>, updatedTicks: boolean): _UpdateOutputAxisXY;
    /**
     * Configure length of axis.
     * E.g. height for Y axis, width for X axis.
     *
     * Axis length can be set in two ways:
     * - Relative length
     * - Length as pixels
     *
     * **Relative length**
     *
     * Set relative size of axis in its own "Stack".
     *
     * For example, if you have a chart with 2 stacked Y axes, by default they will have equal heights.
     * By altering axis relative size, you can adjust how the chart height is distributed between these two axes.
     *
     * By default, every axis length is set to `{ relative: 1 }`
     *
     * ```ts
     *  // Example scenario
     *  const chart = lightningChart().ChartXY()
     *  const y1 = chart.getDefaultAxisY().setTitle('Y 1').setLength({ relative: 2 })
     *  const y2 = chart.addAxisY({ iParallel: 0, iStack: 1 }).setTitle('Y 2')
     * ```
     *
     * **Length as pixels**
     *
     * Hardcoded length as pixels.
     *
     * ```ts
     *  // Example scenario
     *  const chart = lightningChart().ChartXY()
     *  const y1 = chart.getDefaultAxisY().setTitle('Y 1').setLength({ pixels: 200 })
     *  const y2 = chart.addAxisY({ iParallel: 0, iStack: 1 }).setTitle('Y 2')
     * ```
     * @public
     */
    setLength(length: {
        pixels: number;
    } | {
        relative: number;
    }): this;
    /**
     * Get relative size of axis in its own "Stack".
     *
     * For example, if you have a chart with 2 stacked Y axes, by default they will have equal heights.
     * By altering axis relative size, you can adjust how the chart height is distributed between these two axes.
     *
     * Defaults always to `1`.
     * @public
     */
    getLength(): {
        pixels: number;
    } | {
        relative: number;
    };
    /**
     * Add empty space at either end of the axis, without affecting the relative size of the Axis.
     *
     * ```ts
     *  // Example, 20 pixels margin at "start" side of Axis.
     *  Axis.setMargins(20, 0)
     * ```
     *
     * @public
     */
    setMargins(startMarginPx: number, endMarginPx: number): this;
    /**
     * Get axis margins as set with {@link setMargins}.
     *
     * @public
     */
    getMargins(): {
        start: number;
        end: number;
    };
    /**
     * Get index of Axis in its own "Stack".
     * This simply retrieves same value which was used (or defaulted) when axis was created.
     * See {@link AxisOptions.iStack}.
     * @public
     */
    getStackIndex(): number;
    /**
     * Get index of Axis in its own "Parallel".
     * This simply retrieves same value which was used (or defaulted) when axis was created.
     * See {@link AxisOptions.iParallel}.
     * @public
     */
    getParallelIndex(): number;
    /**
     * Pan scale by pixel value delta.
     *
     * Used by ChartXY as well as Axis itself.
     * @param amount - Amount to shift scale of axis in pixels
     * @public
     */
    pan(amount: pixel, opts?: {
        releaseScrollingAxisIfLiveReached?: boolean;
    }): void;
    /**
     * Zoom scale from/to a position.
     *
     * Used by ChartXY as well as Axis itself.
     * @param referencePosition - Position to zoom towards or from on axis
     * @param zoomDirection - Amount and direction of zoom [-1, 1] as a guideline
     * @public
     */
    zoom(referencePosition: number, zoomDirection: number): void;
    /**
     * Add custom tick to Axis.
     * *Custom ticks* can be used to expand on default tick placement, or completely override Axis ticks placement with custom logic.
     *
     * Example usage:
     *
     * **Create custom tick, specify position on Axis and label text.**
     *
     * ```typescript
     *  const customTick = Axis.addCustomTick(UIElementBuilders.PointableTextBox)
     *      .setValue(5)
     *      // Label text is specified with a callback function.
     *      // This example formats Axis positions with one fraction, like this: "5.0"
     *      .setTextFormatter((value) => value.toFixed(1))
     * ```
     *
     * **Select CustomTick Marker type.**
     *
     * ```typescript
     *  // CustomTick shape can be changed by supplying a tick marker builder.
     *  // The supported values are 'AxisTickMajor', 'AxisTickMinor' and 'PointableTextBox'
     *  const customTick1 = Axis.addCustomTick(UIElementBuilders.AxisTickMajor)
     *  const customTick2 = Axis.addCustomTick(UIElementBuilders.AxisTickMinor)
     *  const customTick3 = Axis.addCustomTick(UIElementBuilders.PointableTextBox)
     * ```
     *
     * **Disable default ticks, and create custom positioned ticks.**
     *
     * ```typescript
     *  // Disable default Axis ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.Empty)
     *
     *  // Create a bunch of custom positioned ticks.
     *  for (let x = 0; x <= 100; x += 10) {
     *      Axis.addCustomTick()
     *          .setValue(x)
     *  }
     * ```
     *
     * For more information, like styling *custom ticks*, see {@link CustomTick}.
     *
     * @param markerBuilder - Optional builder for *TickMarker* of CustomTick (tick line, label, possible background).
     *                          Possible values are: {@link UIElementBuilders | `UIElementBuilders.AxisTickMajor`}, {@link UIElementBuilders | `UIElementBuilders.AxisTickMinor`}, {@link UIElementBuilders | `UIElementBuilders.PointableTextBox`}.
     *                          Default is `AxisTickMajor`
     * @returns CustomTick.
     * @public
     */
    addCustomTick(markerBuilder?: UIPointableBuilder<InternalTickMarker>): CustomTick;
    /**
     * Get all custom ticks added to the Axis.
     * @returns Array of CustomTick instances.
     * @public
     */
    getCustomTicks(): CustomTick[];
    /**
     * Set axis title position (if any)
     * ```
     *  // Example, place title inside series area.
     *  ChartXY.setTitlePosition(AxisXYTitlePositionOptions.Start)
     *
     *  ChartXY.setTitlePosition('end')
     * ```
     * @param   position   -    Position selection.
     * @returns     Object itself.
     * @public
     */
    setTitlePosition(position: AxisXYTitlePosition | undefined): this;
    /**
     * Get axis title position.
     * @returns     AxisXYTitlePosition
     * @public
     */
    getTitlePosition(): AxisXYTitlePosition;
    /**
     * Get position of axis on its chart as a %
     * @public
     */
    getUiPosition(): number;
    /**
     * Set style of Axis line stroke.
     *
     * Supported line styles:
     * - {@link SolidLine}
     * - {@link DashedLine}
     * - {@link emptyLine}
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  Axis.setStrokeStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * **Supported fill styles:**
     *
     * {@link SolidFill}:
     *
     * Solid fill color.
     *
     * ```ts
     *  // Example, solid colored line.
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * To learn more about available *Color* factories, see {@link ColorRGBA}
     *
     * {@link PalettedFill}:
     *
     * Color line stroke dynamically based on `x` or `y` coordinate.
     *
     * ```ts
     *  // Example, dynamic color by Y coordinates
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(255, 0, 0) },
     *                  { value: 10, color: ColorRGBA(0, 255, 0) },
     *              ]
     *          })
     *      })
     *  }))
     * ```
     *
     * To learn more about Color lookup tables, see {@link LUT}.
     *
     * {@link LinearGradientFill}:
     *
     * Color line stroke with a linear configurable gradient palette.
     *
     * ```ts
     *  // Example, linear gradient line color
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new LinearGradientFill()
     *  }))
     * ```
     *
     * To learn more about linear gradient configurations, see {@link LinearGradientFill}.
     *
     * {@link RadialGradientFill}:
     *
     * Color line stroke with a radial configurable gradient palette.
     *
     * ```ts
     *  // Example, radial gradient line color
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new RadialGradientFill()
     *  }))
     * ```
     *
     * To learn more about radial gradient configurations, see {@link RadialGradientFill}.
     *
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Object itself for fluent interface.
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @returns Axis stroke as a LineStyle object
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Get style of axis overlay (shown only when interacting with mouse / touch).
     * @returns FillStyle object
     * @public
     */
    getOverlayStyle(): FillStyle;
    /**
     * Set style of axis overlay (shown only when interacting with mouse / touch).
     * @param style - FillStyle object or mutator to modify existing one
     * @public
     */
    setOverlayStyle(style: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set component highlight animations enabled or not.
     * For most components this is enabled by default.
     *
     * ```ts
     *  // Example usage, disable highlight animations.
     *  component.setAnimationHighlight(false)
     * ```
     *
     * @param   enabled    - Animation enabled?
     * @returns            Object itself
     */
    setAnimationHighlight(enabled: boolean): this;
    /**
     * Get component highlight animations enabled or not.
     *
     * @returns      Animation enabled?
     */
    getAnimationHighlight(): boolean;
    /**
     * @returns Padding after axis ticks.
     * @public
     */
    getMarginAfterTicks(): number;
    /**
     * Specifies Padding after axis ticks.
     * @param margin - Gap after axis ticks
     * @returns Axis itself for fluent interface
     * @public
     */
    setMarginAfterTicks(margin: pixel): this;
    /**
     * @returns Padding after Axis title
     * @public
     */
    getMarginAfterTitle(): number;
    /**
     * Specifies padding after Axis title.
     * This is only accounted when title is visible.
     * @param margin - Gap between the title and the next axis in pixels. Can also affect chart margins
     * @returns Axis itself for fluent interface
     * @public
     */
    setMarginAfterTitle(margin: pixel): this;
    /**
     * **Permanently** destroy the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @returns Object itself for fluent interface
     * @public
     */
    dispose(): this;
    /**
     * Set element visibility.
     *
     * @param state - `true` when element should be visible and `false` when element should be hidden.
     * @returns Object itself.
     */
    setVisible(state: boolean): this;
    /**
     *  Disable/Enable all animations of the Chart.
     * @param animationsEnabled - Boolean value to enable/disable animations.
     * @returns Axis itself for fluent interface.
     * @public
     * @privateRemarks Override to also update highlight animation enabled status
     */
    setAnimationsEnabled(animationsEnabled: boolean): this;
    /**
     * Set highlight on mouse hover enabled or disabled.
     *
     * Mouse interactions have to be enabled on the component for this to function as expected.
     * See {@link setPointerEvents} for more information.
     *
     * @param state - True if highlighting on mouse hover, false if no highlight on mouse hover
     * @returns Object itself for fluent interface.
     * @public
     */
    setHighlightOnHover(state: boolean): this;
    /**
     * Get boolean flag for whether object should highlight on mouse hover
     * @returns Boolean for if object should highlight on mouse hover or not.
     * @public
     */
    getHighlightOnHover(): boolean;
    addEventListener<K extends keyof AxisEventMap>(type: K, listener: (event: AxisEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof AxisEventMap>(type: K, listener: (event: AxisEventMap[K], info: unknown) => unknown): void;
    /**
     * Set whether element can be target of pointer events or not.
     *
     * Disabling pointer events means that the objects below this component can be interacted _through_ it.
     *
     * @param state - Specifies state of mouse interactions
     * @returns Object itself for fluent interface
     * @public
     */
    setPointerEvents(state: boolean): this;
    /**
     * Get whether element can be target of pointer events or not.
     * @returns Pointer events state
     * @public
     */
    getPointerEvents(): boolean;
    set draggable(state: boolean);
    get draggable(): boolean;
    /**
     * Configure user interactions from a set of preset options.
     *
     * Without any explicit configuration, the charts select the default user interaction scheme based on available information,
     * such as axis types, attached series and data supplied to series.
     *
     * The `setUserInteraction` methods allow explicitly configuring the used interaction scheme.
     *
     * ```ts
     *  // Example, disable panning
     *  axis.setUserInteractions({
     *      pan: false
     *  })
     * ```
     *
     * ```ts
     *  // LMB pan, RMB rectangle zoom
     *  axis.setUserInteractions({
     *      pan: {
     *          lmb: { drag: true },
     *          rmb: false,
     *      },
     *      rectangleZoom: {
     *          lmb: false,
     *          rmb: { drag: true },
     *      },
     *  })
     * ```
     *
     * ```ts
     *  // Example, disable all interactions
     *  axis.setUserInteractions(undefined)
     * ```
     *
     * @param   config -    Option with any set of properties of {@link AxisXYUserInteractions} or `undefined` to disable all interactions.
     * @returns     Object itself.
     * @public
     * @beta    Introduced in v7.0.0. API may change according to user feedback.
     */
    setUserInteractions(config: Partial<AxisXYUserInteractions> | undefined): this;
    /**
     * Get active user interactions overrides for the Axis.
     * @public
     * @beta    Introduced in v7.0.0. API may change according to user feedback.
     */
    getUserInteractions(): AxisXYUserInteractions;
}
/**
 * Three-dimensional Axis, that resides inside Chart3D.
 * Can be either X, Y or Z. There is always exactly one Axis3D object for each dimension in a Chart3D.
 *
 * *Axes* have automatic scrolling logic to fit attached *Series*.
 * This can be modified with {@link setScrollStrategy} method.
 *
 * *Axes* are associated with a title, which can be enabled with {@link setTitle} method.
 *
 * Axis ticks can be altered with {@link setTickStrategy} and {@link addCustomTick} methods.
 *
 * @public
 */
export declare class Axis3D extends GenericAxis<UnitScale, AxisStrategy3D, _Tick3D, _Axis3DInput, _Axis3DPlottingVariables, _Axis3DTickInfo, _GenericAxisOutput<_Tick3D, _Axis3DTickInfo>> {
    /**
     * @public
     * @privateRemarks  Override property type
     */
    readonly chart: Chart3D;
    /**
     * Set *TickStrategy* of *Axis*.
     *
     * The *TickStrategy* defines the positioning and formatting logic of *Axis* ticks
     * as well as the style of created ticks.
     *
     * **Example usage**:
     *
     * **DateTime Axis**:
     * ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.DateTime )
     * ```
     *
     * **Disable automatic ticks completely**:
     * ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.Empty )
     * ```
     *
     * **Customized TickStrategy**:
     * ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.Numeric, ( tickStrategy: NumericTickStrategy ) => tickStrategy
     *      .setNumericUnits( true )
     *      .setMajorTickStyle( ( tickStyle ) => tickStyle
     *          .setLabelFont( ( font ) => font
     *              .setWeight( 'bold' )
     *          )
     *      )
     *  )
     * ```
     *
     * **Type table for optional second parameter ('styler')**:
     *
     * | tickStrategy   | styler                                                        |
     * | :------------- | :------------------------------------------------------------ |
     * | 'Numeric'      | `( tickStrategy: **NumericTickStrategy** ) => tickStrategy`   |
     * | 'Time'         | `( tickStrategy: **TimeTickStrategy** ) => tickStrategy`      |
     * | 'DateTime'     | `( tickStrategy: **DateTimeTickStrategy** ) => tickStrategy`  |
     * | 'Empty'        | `undefined`                                                   |
     *
     *
     * @param tickStrategy - Selected TickStrategy.
     *                          See {@link AxisTickStrategies} for a collection of options.
     * @param styler - Optional callback that can be used to customize the *TickStrategy*.
     *                          The type of supplied *TickStrategy* object depends on what was supplied to 'tickStrategy' parameter;
     *                          See the above method documentation for a value table.
     * @returns Object itself for fluent interface.
     * @public
     */
    setTickStrategy<TickStrategy extends TickStrategyType>(tickStrategy: TickStrategy, styler?: TickStrategyStyler<TickStrategyParameters, TickStrategy>): this;
    /**
     * Get the currently used tick strategy
     * @public
     */
    getTickStrategy(): TickStrategyType;
    /**
     * Add an end user managed tick to the axis.
     *
     * Custom ticks are just like default ticks, except they can be completely controlled by the end user.
     *
     * ```ts
     *  // Example
     *  const customTick = Axis3D.addCustomTick()
     *      // Tick position on Axis.
     *      .setValue(100)
     *      .setTextFormatter((value) => `Custom tick at ${value.toFixed(1)}`)
     * ```
     *
     * For full set of configuration API, see {@link CustomTick3D}.
     *
     * @returns     CustomTick3D.
     * @public
     */
    addCustomTick(): CustomTick3D;
    /**
     * Get all custom ticks added to the axis.
     * @returns Array of CustomTick3D instances.
     * @public
     */
    getCustomTicks(): CustomTick3D[];
    /**
     * Set style of Axis line stroke.
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  Axis.setStrokeStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * **Supported fill styles:**
     *
     * {@link SolidFill}:
     *
     * Solid fill color.
     *
     * ```ts
     *  // Example, solid colored line.
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * To learn more about available *Color* factories, see {@link ColorRGBA}
     *
     * {@link PalettedFill}:
     *
     * Color line stroke dynamically based on `x`, `y` or `z` coordinate.
     *
     * ```ts
     *  // Example, dynamic color by Y coordinates
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(255, 0, 0) },
     *                  { value: 10, color: ColorRGBA(0, 255, 0) },
     *              ]
     *          })
     *      })
     *  }))
     * ```
     *
     * To learn more about Color lookup tables, see {@link LUT}.
     *
     * {@link LinearGradientFill}:
     *
     * Color line stroke with a linear configurable gradient palette.
     *
     * ```ts
     *  // Example, linear gradient line color
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new LinearGradientFill()
     *  }))
     * ```
     *
     * To learn more about linear gradient configurations, see {@link LinearGradientFill}.
     *
     * {@link RadialGradientFill}:
     *
     * Color line stroke with a radial configurable gradient palette.
     *
     * ```ts
     *  // Example, radial gradient line color
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new RadialGradientFill()
     *  }))
     * ```
     *
     * To learn more about radial gradient configurations, see {@link RadialGradientFill}.
     *
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Object itself for fluent interface.
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @returns Style of Axis line.
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set element visibility.
     *
     * @param state - `true` when element should be visible and `false` when element should be hidden.
     * @returns Object itself.
     * @public
     */
    setVisible(state: boolean): this;
    /**
     * Used in phase 1: after we know what ticks will be displayed, formulate generic information for chart layout calculations (e.g. XY layout for XY charts).
     */
    protected _getAbstractUpdateResult(input: _Axis3DInput, ticksInfo: Map<_Tick3D, _Axis3DTickInfo>, updatedTicks: boolean): _GenericAxisOutput<_Tick3D, _Axis3DTickInfo>;
    /**
     * Pan scale, shifting its interval without changing the difference between end-start
     * @param amount - Amount, guideline ~1 for small panning adjustment
     * @public
     * @internal
     */
    _pan(amount: number): void;
    /**
     * Zoom scale from/to a position.
     *
     * @param referencePosition - Position to zoom towards or from on axis
     * @param zoomDirection - Direction of zoom (-1 or 1)
     * @public
     * @internal
     */
    _zoom(referencePosition: 'centered' | 'keep-start' | 'keep-end', zoomDirection: number, amt: number): void;
    addEventListener<K extends keyof GenericAxisEventMap>(type: K, listener: (event: GenericAxisEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof GenericAxisEventMap>(type: K, listener: (event: GenericAxisEventMap[K], info: unknown) => unknown): void;
    setPointerEvents(state: boolean): this;
    getPointerEvents(): boolean;
}
/**
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare interface _Axis3DInput extends _GenericAxisInput {
}
/**
 * Implementation specific values necessary for tick plotting.
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare interface _Axis3DPlottingVariables extends _GenericTickPlottingVariables {
}
/**
 * Variables calculated for each tick when plotting.
 *
 * Label : tick line + grid line positioning is split into two distinct phases for rendering optimizations,
 * these values are calculated when positioning the label and carried over to the line positioning phase.
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare interface _Axis3DTickInfo extends _GenericTickInfo {
}
/**
 * Interface of events trackable by {@link Axis.addEventListener} and the respective Event types.
 * @public
 */
export declare interface AxisEventMap extends GenericAxisEventMap, LCJSInteractionEventMap, HighlightableEventMap {
}
/**
 * Interval info for an Axis
 * @public
 */
export declare interface AxisInterval {
    /**
     * The start value of the axis scale interval.
     */
    start: number;
    /**
     * The end value of the axis scale interval.
     */
    end: number;
}
/**
 * Event that is triggered on change of the interval of an Axis
 * @public
 */
export declare interface AxisIntervalChangedEvent {
    start: number;
    end: number;
}
/**
 * Parameters for {@link Axis.setInterval} method.
 *
 * Examples:
 *
 * ```ts
 *  // Set interval start and end.
 *  Axis.setInterval({ start: 0, end: 5000 })
 * ```
 *
 * ```ts
 *  // Set interval end only.
 *  Axis.setInterval({ end: 5000 })
 * ```
 *
 * ```ts
 *  // Set interval but don't stop the axis from scrolling
 *  Axis.setInterval({ start: 0, end: 5000, stopAxisAfter: false })
 * ```
 *
 * ```ts
 *  // Set interval with 2000 milliseconds long animation
 *  Axis.setInterval({ start: 0, end: 5000, animate: 2000 })
 * ```
 *
 * @public
 */
export declare interface AxisIntervalConfiguration {
    /**
     * Axis interval start.
     *
     * For X axis this refers to LEFT, while for Y axis this refers to BOTTOM.
     */
    start?: number;
    /**
     * Axis interval end.
     *
     * For X axis this refers to RIGHT, while for Y axis this refers to TOP.
     */
    end?: number;
    /**
     * Should the change in axis interval be animated or not?
     *
     * Defaults to `false`.
     *
     * - `false` -\> Don't animate
     * - `true` -\> Default animation
     * - `1000` or other number -\> Animate with this duration as milliseconds
     */
    animate?: number | boolean;
    /**
     * Should the axis scrolling be stopped after applying the interval?
     *
     * Defaults to `true`.
     *
     * If `true`, whatever the active scroll strategy of the Axis is, it will not override the applied axis interval until the axis is released.
     */
    stopAxisAfter?: boolean;
}
/**
 * Interface for specifying Axis (XY) configurations that can't be changed after creation of the Axis.
 *
 * **Example usage**:
 *
 * - Configure default Y Axis of chart on opposite side to default configuration (right).
 *
 * ```typescript
 *  ChartXY({
 *      defaultAxisY: {
 *          opposite: true,
 *      }
 *  })
 * ```
 *
 * - Configure default X Axis of chart as logarithmic (10 base).
 *
 * ```typescript
 *  ChartXY({
 *      defaultAxisX: {
 *          type: 'logarithmic',
 *          base: 10,
 *      }
 *  })
 * ```
 *
 * - Configure newly created X Axis of chart as logarithmic (natural base).
 *
 * ```typescript
 *  ChartXY.addAxisX({
 *      type: 'logarithmic',
 *      base: 'natural',
 *  })
 * ```
 *
 * NOTE: Some series / features do not support all available non-default Axis types (logarithmic, high precision, ..).
 *
 * Additionally, there can be further limitations in combinations of two Axis types.
 * For example, as of now `logarithmic` and `linear-highPrecision` can't be combined as X + Y Axes.
 *
 * Refer to documentation of {@link AxisOptions."type"} for detailed information.
 * @public
 */
export declare interface AxisOptions {
    /**
     * Specify Axis position in chart.
     *
     * Default is bottom for X Axes, and left for Y Axes.
     *
     * Setting to `true` will result in the opposite side (top for X Axes, right for Y Axes).
     */
    opposite?: boolean;
    /**
     * Type of Axis.
     *
     * Each type section contains information about related Axis zooming limits,
     * as in constraints on the magnitude of Axis interval, which is calculated as `Math.abs(end - start)`.
     * When the limit is reached, the Axis will not be able to zoom in and out further by programmatic calls ({@link Axis.setInterval}) or user interactions.
     *
     * `linear`:
     *
     * Default Axis type. Same behavior as `type: undefined`.
     *
     * Achievable zoom range depends on the magnitude of Axis interval start;
     * Following table contains *reference values* on the achievable zoom ranges - in practice zoom range might be limited sooner or later.
     *
     * | Axis interval start | Min interval | Max interval |
     * | :------------------ | :----------- | :----------- |
     * | `0`                 | `1e-4`       | `1e+16`       |
     * | `100`               | `1e-2`       | `1e+16`       |
     * | `10 000`            | `1.00`       | `1e+16`       |
     * | `1 000 000`         | `100`        | `1e+16`       |
     * | `Date.now()` (UNIX) | `73600000`   | `1e+16`       |
     *
     * `logarithmic`:
     *
     * Logarithmic Axis. By default base number will be `10`.
     *
     * With Logarithmic Axis, **range must always start above 0!** (log is not defined at 0).
     *
     * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
     *
     * List of series that support logarithmic Axes:
     * - {@link LineSeries}
     * - {@link PointSeries}
     * - {@link PointLineSeries}
     * - {@link StepSeries}
     * - {@link SplineSeries}
     * - {@link AreaSeries}
     * - {@link AreaRangeSeries}
     * - {@link OHLCSeries} (Y Axis can be logarithmic, but not X Axis)
     * - {@link RectangleSeries}
     * - {@link SegmentSeries}
     *
     * List of series that do **not** support logarithmic Axes:
     * - {@link HeatmapGridSeriesIntensityValues}
     * - {@link HeatmapScrollingGridSeriesIntensityValues}
     *
     * As of yet `logarithmic` and `linear-highPrecision` can't be combined as X + Y Axes.
     *
     * `linear-highPrecision`:
     *
     * Behaves otherwise similarly as `linear`, but zoom range is significantly improved, with the drawback of a considerable performance drop.
     *
     * Achievable zoom range depends on the magnitude of Axis interval start;
     * Following table contains *reference values* on the achievable zoom ranges - in practice zoom range might be limited sooner or later.
     *
     * | Axis interval start | Min interval | Max interval |
     * | :------------------ | :----------- | :----------- |
     * | `0`                 | `1e-12`      | `1e+30`      |
     * | `100`               | `1e-10`      | `1e+30`      |
     * | `10 000`            | `1e-8`       | `1e+30`      |
     * | `1 000 000`         | `1e-6`       | `1e+30`      |
     * | `Date.now()` (UNIX) | `1.00`       | `1e+30`      |
     *
     * As of yet `logarithmic` and `linear-highPrecision` can't be combined as X + Y Axes.
     */
    type?: 'linear' | 'logarithmic' | 'linear-highPrecision';
    /**
     * Specification of Logarithmic Base number (e.g. 10, 2, natural log).
     *
     * Defaults to 10 if omitted.
     *
     * Examples:
     *
     * - `10` | powers of ten (1, 10, 100, 1000, 10000, ...).
     * - `e`  | natural logarithm (1e, 2e, 3e, 4e, ...)
     *
     * `type` must be set to `'logarithmic'` for this to effect!
     */
    base?: number | 'E' | 'e' | 'natural';
    /**
     * Axis index in direction parallel to axis.
     *
     * E.g. for Y axes this is index in Horizontal direction. Whereas for X axes this is index in Vertical direction.
     * This is also referenced as "legacy axis stacking", as this direction of axis stacking has been around since LightningChart JS v1.0,
     * whereas the other stacking mode, {@link iStack} was first introduced only in v5.2.0.
     */
    iParallel?: number;
    /**
     * Axis index in same plane as the Axis direction.
     *
     * E.g. for Y axes this is index in Vertical direction. Whereas for X axes this is index in Horizontal direction.
     */
    iStack?: number;
}
/**
 * Axis positioning Enum
 * @public
 */
export declare enum AxisPosition {
    Top = 0,
    Bottom = 1,
    Left = 2,
    Right = 3
}
/**
 * Object that describes an Axis interval (start, end).
 * @public
 */
declare interface AxisScale {
    /**
     * Get Scale start value.
     * @returns number.
     * @public
     */
    getInnerStart(): number;
    /**
     * Get Scale end value.
     * @returns number.
     * @public
     */
    getInnerEnd(): number;
}
/**
 * Collection of available *AxisScrollStrategies*.
 *
 * *AxisScrollStrategies* can be used to customize the behavior of *Axis scrolling*.
 *
 * Use with {@link Axis.setScrollStrategy}
 * @public
 */
export declare const AxisScrollStrategies: {
    /**
     * Axis will always display all visible data.
     *
     * ```ts
     *  axis.setScrollStrategy(AxisScrollStrategies.fitting)
     * ```
     *
     * This is the default option for majority of Axes.
     *
     * Optional extra parameters:
     *  - `start` - whether should affect Axis interval start (left side for X axis, bottom side for Y axis). Defaults to `true`
     *  - `end` - whether should affect Axis interval end (right side for X axis, top side for Y axis). Defaults to `true`
     *  - `considerVisibleRangeOnly` -  whether axis scrolling should only consider data in visible range, rather than entire data set which may be partly outside the view.
     *
     * ```ts
     *  axis.setScrollStrategy(AxisScrollStrategies.fitting({ start: false }))
     *  axis.setScrollStrategy(AxisScrollStrategies.fitting({ considerVisibleRangeOnly: false }))
     * ```
     * @public
     */
    fitting: (opts?: {
        /**
         * Should apply to Axis interval start (left side for X axis, bottom side for Y axis). Defaults to `true`
         */
        start?: boolean;
        /**
         * Should apply to Axis interval end (right side for X axis, top side for Y axis). Defaults to `true`
         */
        end?: boolean;
        /**
         * Whether axis scrolling should only consider data in visible range, rather than entire data set which may be partly outside the view.
         * This is enabled by default.
         *
         * **Important: Only {@link PointLineAreaSeries} actually supports range calculations for visible range only**
         * For series which don't support this, this flag will not have any effect.
         *
         * ```ts
         *  // Example, change from default to fitting based on whole data set rather than only view
         *  chart.axisY.setScrollStrategy(AxisScrollStrategies.fitting({ considerVisibleRangeOnly: false }))
         * ```
         */
        considerVisibleRangeOnly?: boolean;
    }) => AxisScrollStrategy;
    /**
     * Axis scrolls to reveal new data but keeps its interval (start - end) constant.
     *
     * ```ts
     *  axis.setScrollStrategy(AxisScrollStrategies.scrolling)
     * ```
     *
     * Optional extra parameters:
     *  - `progressive` - whether axis should scroll towards higher data value, or lower data value. Defaults to `true` which means towards higher data value.
     *  - `realTime` - if set to `true` axis will automatically scroll according to real time, rather than jumping to latest data point immediately. This is intended for applications where data arrives in chunks (for example, every 1 second). **This assumes that Axis interval represents milliseconds!**
     *
     * ```ts
     *  // Example, real-time scrolling Axis
     *  axis
     *      .setTickStrategy(AxisTickStrategies.DateTime)
     *      .setDefaultInterval((state) => ({
     *          start: (state.dataMax ?? 0) - 10_000,
     *          end: state.dataMax,
     *          stopAxisAfter: false
     *      }))
     *      .setScrollStrategy(AxisScrollStrategies.scrolling({ realTime: true }))
     * ```
     *
     * By default, real time scrolling is configured for data points arriving around once every second.
     * If data points arrive significantly more infrequently (e.g. every 5 seconds, 10 seconds, 1 minute, ...) then you should configure catch up threshold:
     *
     * ```ts
     *  // Example, catch up if gap between last data point is more than 10 seconds
     *  axis.setScrollStrategy(AxisScrollStrategies.scrolling({
     *      realTime: { catchUpThresholdMs: 10_000 }
     *  }))
     * ```
     *
     * This value is required to cope with situations where data flow is interrupted, and later continues, so that axis can "catch up" to live data.
     * Alternatively, catching up can be disabled by setting the threshold value to an extremely large number.
     *
     * @public
     */
    scrolling: (opts?: {
        progressive?: boolean;
        realTime?: boolean | {
            catchUpThresholdMs?: number;
        };
    }) => AxisScrollStrategy;
    /**
     * *Axis* will scroll to fit *Series* that are out of view, but it won't shrink even if there is empty space (like "fitting" does).
     * @public
     */
    expansion: (opts?: {
        /**
         * Should apply to Axis interval start (left side for X axis, bottom side for Y axis). Defaults to `true`
         */
        start?: boolean;
        /**
         * Should apply to Axis interval end (right side for X axis, top side for Y axis). Defaults to `true`
         */
        end?: boolean;
    }) => AxisScrollStrategy;
    /**
     * Same as {@link fitting} but sets axis `end` side to next power of 10 from attached data.
     * @public
     * @beta    Introduced in v7.0. Feature might change according to user feedback.
     */
    nextPowerOf10: {
        id: string;
        start: (scaleStart: number, scaleEnd: number, contentMin: number, contentMax: number) => number;
        end: (scaleStart: number, scaleEnd: number, contentMin: number, contentMax: number) => number;
        allowIntervalLengthChange: boolean;
    };
    /**
     * Same as {@link fitting} but operates in larger _steps_. So instead of always moving to show exact data range,
     * all steps are done by either halving or doubling the active axis range.
     *
     * Useful when you want to reduce the amount of visual disruption to users, but don't know the exact ranges of data.
     * @public
     * @beta    Introduced in v7.0. Feature might change according to user feedback.
     */
    fittingStepped: (opts?: {
        /**
         * Should apply to Axis interval start (left side for X axis, bottom side for Y axis). Defaults to `true`
         */
        start?: boolean;
        /**
         * Should apply to Axis interval end (right side for X axis, top side for Y axis). Defaults to `true`
         */
        end?: boolean;
    }) => AxisScrollStrategy;
};
/**
 * Type definition for options of {@link AxisScrollStrategies}.
 *
 * While technically it is possible to define custom axis scroll strategies by passing an object that satisfies this interface,
 * **this is not recommended**.
 *
 * All known use cases can be realized with built-in scroll strategies.
 * If you believe this is not the case, please contact us https://lightningchart.com/js-charts/docs/contact/
 * @public
 */
export declare interface AxisScrollStrategy {
    /**
     * Just a means to identify built-in scroll strategies.
     */
    readonly id: string;
    readonly apply: (info: {
        axis: GenericAxis;
        curStart: number;
        curEnd: number;
        seriesDataRange: Interval<number> | undefined;
    }) => {
        start: number;
        end: number;
        allowIntervalLengthChange: boolean;
        keepScrolling?: boolean;
        allowAnimation?: boolean;
    } | undefined;
    readonly init?: (info: {
        axis: GenericAxis;
    }) => unknown;
    readonly dispose?: (info: {
        axis: GenericAxis;
    }) => unknown;
    readonly considerVisibleRangeOnly: boolean;
}
/**
 * Interface that describes state of Axis, as in is it scrolling, is user panning it, etc.
 *
 * Used for passing realtime Axis information to rendering Engine for application and situation specific optimizations.
 * @public
 */
declare interface AxisState {
}
/**
 * Event when Axis is stopped or released.
 *
 * This event is triggered when `Axis.setStopped` method is used (and state actually changes), or the Axis is stopped/released by a built-in user interaction.
 * @public
 */
export declare interface AxisStoppedChangedEvent {
    isStopped: boolean;
}
/**
 * Interface for a strategy which defines Axis dimension
 * @public
 */
declare interface AxisStrategy extends AbstractAxisStrategy {
    /**
     * Mouse style when dragging over axis
     * @public
     */
    readonly defaultDragMouseStyle: string;
    /**
     * Used internally for rendering the axis title text at a specified angle
     * @param direction - Axis direction factor
     * @returns Configured title text rotation in degrees
     * @public
     */
    readonly getTitleTextRotation: (direction: 1 | -1) => number;
}
/**
 * Interface for a strategy which represents the logic that is different between X, Y and Z Axes.
 * @public
 */
export declare interface AxisStrategy3D extends AbstractAxisStrategy {
}
/**
 * Collection of available *AxisTickStrategies*.
 *
 * *AxisTickStrategies* modify logic of drawing *Axis Ticks* and formatting to better suit different user applications.
 * For example, a *DateTime Axis* is created by selecting `AxisTickStrategies.DateTime`.
 * @public
 */
export declare const AxisTickStrategies: {
    /**
     * Disables all automatic creation of Axis ticks.
     *
     * *CustomTicks* can still be created manually.
     *
     * Example usage:
     *
     * ```typescript
     * Axis.setTickStrategy( AxisTickStrategies.Empty )
     * ```
     */
    Empty: "Empty";
    /**
     * *Axis Tick Strategy* that is designed for depicting numeric values of all magnitudes.
     *
     * **`NumericTickStrategy` is the default selection for all Axes**.
     *
     * Axis interval ranges supported by `NumericTickStrategy`:
     * - Minimum: `10e-9`
     * - Maximum: Unlimited.
     *
     * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to {@link Axis} documentation for more information.
     *
     * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
     *
     * ```js
     *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks)
     * ```
     *
     * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
     * see example below for the idea:
     *
     * ```js
     *  // Specify TickStrategy and use callback to style automatic ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks
     *      // All methods of `NumericTickStrategy` can be used here for styling ticks.
     *      .setMajorTickStyle((majorTicks) => majorTicks
     *          .setLabelFont((font) => font
     *              .setWeight('bold')
     *          )
     *      )
     *  )
     * ```
     *
     * For configuration API, see {@link NumericTickStrategy}.
     */
    Numeric: "Numeric";
    /**
     * *Axis Tick Strategy* that is designed for depicting date and time.
     *
     * Axis values are interpreted as UNIX timestamps similarly as with JavaScript Date API.
     *
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
     *
     * Axis interval ranges supported by `DateTimeTickStrategy`:
     * - Minimum: 1 second (`1000`).
     * - Maximum: 1000 years (*really big number*).
     *
     * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to {@link Axis} documentation for more information.
     *
     * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
     *
     * ```js
     *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (dateTimeTicks) => dateTimeTicks)
     * ```
     *
     * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
     * see example below for the idea:
     *
     * ```js
     *  // Specify TickStrategy and use callback to style automatic ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (dateTimeTicks) => dateTimeTicks
     *      // All methods of `DateTimeTickStrategy` can be used here for styling ticks.
     *      .setMajorTickStyle((majorTicks) => majorTicks
     *          .setLabelFont((font) => font
     *              .setWeight('bold')
     *          )
     *      )
     *  )
     * ```
     *
     * For configuration API, see {@link DateTimeTickStrategy}.
     */
    DateTime: "DateTime";
    /**
     * *Axis Tick Strategy* that is designed for depicting time ranges between hundreds of hours to individual nanoseconds.
     *
     * Axis values are interpreted as milliseconds, for example:
     * - `0` -\> `00:00:00`
     * - `1 000` -\> `00:00:01`
     * - `3 600 000` -\> `01:00:00`
     * - `1` -\> `00:00:00.001`
     * - `0.001` -\> `00:00:00.000001`
     *
     * **When `TimeTickStrategy` is active, Axis interval will be always restricted to max. 100 hours interval and min. 100 nanoseconds interval.**
     *
     * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
     *
     * ```js
     *  Axis.setTickStrategy(AxisTickStrategies.Time, (timeTicks) => timeTicks)
     * ```
     *
     * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
     * see example below for the idea:
     *
     * ```js
     *  // Specify TickStrategy and use callback to style automatic ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.Time, (timeTicks) => timeTicks
     *      // All methods of `TimeTickStrategy` can be used here for styling ticks.
     *      .setMajorTickStyle((majorTicks) => majorTicks
     *          .setLabelFont((font) => font
     *              .setWeight('bold')
     *          )
     *      )
     *  )
     * ```
     *
     * For configuration API, see {@link TimeTickStrategy}.
     */
    Time: "Time";
};
/**
 * Used with {@link Axis.setUnits}.
 * @public
 */
export declare interface AxisUnitsBehavior {
    /**
     * Defaults to `true`
     * @public
     */
    displayOnAxis?: boolean;
    /**
     * Defaults to `true`
     *
     * This only affects built-in cursor formatters.
     * @public
     */
    displayInCursor?: boolean;
}
/**
 * @public
 * @beta    Introduced in v7.0.0. API may be changed according to user feedback.
 */
export declare interface AxisXYLayoutInfo {
    /**
     * Offset in pixels from charts left edge to axes left edge.
     */
    left: number;
    /**
     * Offset in pixels from charts right edge to axes right edge.
     */
    right: number;
    /**
     * Offset in pixels from charts bottom edge to axes bottom edge.
     */
    bottom: number;
    /**
     * Offset in pixels from charts top edge to axes top edge.
     */
    top: number;
    width: number;
    height: number;
}
/**
 * Type union for possible ways to describe location of title in ChartXY Axis.
 *
 * Use with {@link Axis.setTitlePosition}
 * @public
 */
export declare type AxisXYTitlePosition = EnumToStringUnion<AxisXYTitlePositionOptions>;
/**
 * Enum for selecting position of ChartXY Axis Title.
 *
 * Use with {@link Axis.setTitlePosition}
 * @public
 */
export declare enum AxisXYTitlePositionOptions {
    /**
     * X axis: Left
     *
     * Y axis: Bottom
     */
    Start = "start",
    /**
     * Title centered along Axis
     */
    Center = "center",
    /**
     * X axis: Right
     *
     * Y axis: Top
     */
    End = "end",
    /**
     * Title centered within the Chart
     */
    CenterChart = "center-chart"
}
/**
 * @public
 * @beta    Introduced in v7.0.0. API may change according to user feedback.
 */
export declare interface AxisXYUserInteractions {
    pan?: false | InteractionConfigWithOverrides<{
        sensitivity?: number;
        stopScroll?: boolean;
        cursor?: CSSStyleDeclaration['cursor'] | null;
    }, 'drag' | 'wheel'>;
    zoom?: false | InteractionConfigWithOverrides<{
        sensitivity?: number;
        mode?: 'toward-pointer' | 'centered' | 'keep-start' | 'keep-end';
        stopScroll?: boolean;
        cursor?: CSSStyleDeclaration['cursor'] | null | ((zoomType: 'in' | 'out') => CSSStyleDeclaration['cursor'] | null);
    }, 'drag' | 'wheel'>;
    rectangleZoom?: false | InteractionConfigWithOverrides<{
        stopScroll?: boolean;
        animationsEnabled?: boolean;
        /**
         * Callback function which is fired when the interaction is started.
         */
        start?: (args: {
            event: Event | undefined;
        }) => unknown;
        cursor?: CSSStyleDeclaration['cursor'] | null;
    }, 'drag'>;
    restoreDefault?: false | InteractionConfigWithOverrides<{
        doubleClick?: boolean;
        animationsEnabled?: boolean;
        stopScroll?: boolean;
        cursor?: CSSStyleDeclaration['cursor'] | null;
    }, never, 'ctrl' | 'shift' | 'alt'>;
    /**
     * Axis specific flags which can be used to individually disable axes from being affected by chart-level interactions
     * e.g. panning inside chart area, rather than on a specific axis.
     *
     * This is NOT intended for activating desired interactions on any axis.
     * Rather, it should be specifically used to DISABLE interactions on very specific axis,
     * in use cases where some axis need interactions and others don't.
     */
    chartInteractions?: false | {
        pan?: boolean;
        paginate?: boolean;
        zoom?: boolean;
        rectangleZoom?: boolean;
        restoreDefault?: boolean;
        restorePrevious?: boolean;
    };
}
/**
 * Type of Background constructor
 * @public
 */
declare type BackgroundConstructor<T extends UIBackground = UIBackground> = new (layer: unknown, renderingScale: unknown, scale: unknown, remove: unknown, theme: unknown) => T;
/**
 * Axis Highlighter that highlights an interval on the Axis.
 * @public
 */
export declare class Band extends Highlighter {
    /**
     * Set start value of Band. This is in values of its owning Axis.
     * @param valueStart - Value on Axis.
     * @returns Object itself for fluent interface.
     * @public
     */
    setValueStart(valueStart: number): this;
    /**
     * Get start value of Band. This is in values of its owning Axis.
     * @returns Value on Axis.
     * @public
     */
    getValueStart(): number;
    /**
     * Set end value of Band. This is in values of its owning Axis.
     * @param valueEnd - Value on Axis.
     * @returns Object itself for fluent interface.
     * @public
     */
    setValueEnd(valueEnd: number): this;
    /**
     * Get end value of Band. This is in values of its owning Axis.
     * @returns Value on Axis.
     * @public
     */
    getValueEnd(): number;
    /**
     * Set fill style of Band.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * Band.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * Band.setFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * Band.setFillStyle(transparentFill)
     * ```
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Object itself for fluent interface.
     * @public
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Band.
     * @returns Normal FillStyle
     * @public
     */
    getFillStyle(): FillStyle;
    /**
     * Set stroke style of Band.
     *
     * Supported line styles:
     * - {@link SolidLine}
     * - {@link emptyLine}
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * Band.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * Band.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * Band.setStrokeStyle(transparentLine)
     * ```
     * @param value - Either a LineStyle object or a function, which will be used to create a new SolidLine based on current value.
     * @returns Chart itself
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Band.
     * @returns Normal StrokeStyle
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Configure user interactions from a set of preset options.
     *
     * Without any explicit configuration, the charts select the default user interaction scheme based on available information,
     * such as axis types, attached series and data supplied to series.
     *
     * The `setUserInteraction` methods allow explicitly configuring the used interaction scheme.
     *
     * ```ts
     *  // Example, disable default interactions
     *  band.setUserInteractions(undefined)
     * ```
     *
     * ```ts
     *  // Example, scale interaction only
     *  band.setUserInteractions({
     *      scale: false,
     *  })
     * ```
     *
     *
     * @param   config -    Option with any set of properties of {@link BandInteractions} or `undefined` to disable all interactions.
     * @returns     Object itself.
     * @public
     * @beta    Introduced in v7.0.0. API may change according to user feedback.
     */
    setUserInteractions(config: Partial<BandInteractions> | undefined): this;
    /**
     * Get currently active user interaction scheme.
     * This does NOT return the last value supplied to {@link setUserInteractions}.
     * Rather, it considers the current structure of the chart, all built-in defaults as well as overrides supplied by the user
     * and returns the currently used interaction scheme.
     *
     * @returns     BandInteractions
     * @public
     * @beta    Introduced in v7.0.0. API may change according to user feedback.
     */
    getUserInteractions(): BandInteractions;
    addEventListener<K extends keyof BandEventMap>(type: K, listener: (event: BandEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof BandEventMap>(type: K, listener: (event: BandEventMap[K], info: unknown) => unknown): void;
}
/**
 * Interface of events trackable by {@link Band.addEventListener} and the respective Event types.
 * @public
 */
export declare interface BandEventMap extends ChartComponentEventMap {
    /**
     * Event fired when Band value (start or end) changes.
     *
     * ```ts
     *  // Example usage
     *  chart.addEventListener('valuechange', (event) => {
     *      console.log(event)
     *  })
     * ```
     */
    valuechange: BandValueChangeEvent;
}
/**
 * @public
 * @beta    Introduced in v7.0.0. API may change according to user feedback.
 */
export declare interface BandInteractions {
    move?: false | InteractionConfigWithOverrides<{}, 'drag'>;
    scale?: false | InteractionConfigWithOverrides<{}, 'drag'>;
}
/**
 * @public
 */
export declare interface BandValueChangeEvent {
    start: number;
    end: number;
}
/**
 * Chart type for visualizing categorical data as Bars.
 * Supports Positive and Negative data sets (baseline 0), and Bipolar data sets. These are automatically detected.
 *
 * `BarChart` can be created in two different ways - to learn more about creation time configuration of `BarChart`, please refer to:
 * - {@link LightningChart.BarChart} (stand-alone chart).
 * - {@link Dashboard.createBarChart} (chart inside *dashboard*).
 *
 * **BarChart features**
 *
 * 1. Axes
 *
 * `BarChart` has a Category Axis and Value Axis.
 * These can be referenced with {@link BarChart.categoryAxis} and {@link BarChart.valueAxis} properties.
 * For their available APIs, see {@link BarChartCategoryAxis} and {@link BarChartValueAxis} respectively.
 *
 * 2. Data input
 *
 * `BarChart` supports a handful of different syntaxes for data input.
 * See {@link BarChart.setData} for more details.
 *
 * 3. Cursor
 *
 * *Auto cursor* is activated when the users mouse is over a bar.
 * It displays information about the hovered bar to the user over the chart in a *result table*.
 *
 * *Auto cursor* can be configured in a variety of ways;
 * - {@link BarChart.setCursorMode} | set auto cursor behavior.
 * - {@link BarChart.setCursor} | style auto cursor.
 * - {@link BarChart.setCursorResultTableFormatter} | configure formatting of *result table* contents.
 *
 * 4. Title
 *
 * `BarChart` has a built-in *title* component, which can be configured using {@link BarChart.setTitle}.
 *
 * 5. Backgrounds
 *
 * `BarChart` contains two separate *background* components:
 * - *Background* ({@link BarChart.setBackgroundFillStyle}).
 * - *Series Background* ({@link BarChart.setSeriesBackgroundFillStyle}).
 *
 * 6. UI Elements
 *
 * Custom *UI elements* can be placed on `BarChart` in same way as all other *charts*, using {@link BarChart.addUIElement}.
 *
 * 7. Sorting
 *
 * `BarChart` has built-in sorting functionality, which can be configured with {@link BarChart.setSorting}.
 *
 * 8. Bar styling
 *
 * Each bar in `BarChart` can be individually styled. See {@link BarChartBar} for more details.
 *
 * **Other APIs worthy of mention:**
 *
 * - Labels can be configured with {@link BarChart.setCategoryLabels}, {@link BarChart.setValueLabels} and {@link BarChart.setLabelFittingEnabled}.
 * - Empty space around `BarChart` can be configured with {@link BarChart.setPadding}.
 * - Additional margin around *chart title* can be configured with {@link BarChart.setTitleMargin}.
 * - All animations can be conveniently controlled with {@link BarChart.setAnimationsEnabled}.
 * - `BarChart` can be removed permanently with {@link BarChart.dispose}.
 * - Some useful events that can be subscribed to:
 *      * *Resize events* ({@link BarChart.onResize}).
 *      * *Background events* ({@link BarChart.onBackgroundMouseMove}).
 *      * *Series Background events* ({@link BarChart.onSeriesBackgroundMouseMove}).
 *
 * @public
 */
export declare class BarChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithSeries<BarChartBar> implements ChartWithCursor<CursorResultTableBackgroundType, CursorPosition2D, Cursor2D<CursorResultTableBackgroundType>, SolveResultBar>, RoundableCorners {
    /**
     * Selector for coordinate system of the Bars.
     *
     * This selector can be used for translating locations relative to Bars to other coordinate systems and vice versa.
     *
     * For example, in order to:
     * - Position LCJS UI elements in relative to Bar locations.
     * - Find client coordinate relative to a Bar, for example to position external HTML content above them.
     * - etc.
     *
     * See {@link translateCoordinate} for more detailed use case information and example usage.
     *
     * @public
     */
    readonly coordsBars: CoordinateSystemBarChart;
    /**
     * Reference to the Value Axis of bar chart.
     * @public
     */
    readonly valueAxis: BarChartValueAxis;
    /**
     * Reference to the Category Axis of bar chart.
     * @public
     */
    readonly categoryAxis: BarChartCategoryAxis;
    /**
     * Get series of a chart
     * @returns Array of series
     * @public
     */
    getSeries(): BarChartBar[];
    setCornerRadius(radius: number | undefined): this;
    getCornerRadius(): number | undefined;
    setCursor(mutator: Mutator<Cursor2D<CursorResultTableBackgroundType>>): this;
    getCursor(): Cursor2D<CursorResultTableBackgroundType>;
    setCursorMode(mode: SolveNearestMode | undefined): this;
    getCursorMode(): SolveNearestMode | undefined;
    setCustomCursor(clbk: undefined | ((event: CursorTargetChangedEvent<SolveResultBar>) => unknown)): this;
    setCursorDynamicBehavior(value: CursorDynamicBehavior): this;
    /**
     * Set cursor formatting, controlling the text displayed in built-in cursor.
     *
     * ```ts
     *  chart.setCursorFormatting((_, hit, hits) => {
     *      return [
     *          ['Cursor pointing at'],
     *          [hit.series], // returning a series will display the series color and its name automatically.
     *          ['X', '', hit.axisX.formatValue(hit.x)], // utilizing axis formatValue is useful for considering active zoom level and type of axis
     *          ['Y', '', hit.y.toFixed(2)], // empty string '' results in gap between cells
     *          [{ text: 'Example', font: { weight: 'bold' }, fillStyle: fillRed }] // any cell can also be styled individually
     *      ]
     *  })
     * ```
     *
     * Before overriding default cursor formatting, it is recommended to check if using {@link GenericAxis.setUnits} or configuring Axis cursor formatting would be enough.
     *
     * In order to use series specific data properties (e.g. Heatmap sample "intensity"),
     * you should use type guards to assert the type of the `SolveResult`:
     *
     * ```ts
     *  // Example of using type guard in cursor formatter
     *  Chart.setCursorFormatting((chart, hit, hits) => {
     *      if (!isHitHeatmap(hit)) return undefined
     *      return [hit.intensity.toFixed(1)]
     *  })
     * ```
     *
     * More details in Developer documentation (Features \> Cursor).
     * @param   formatter -     Callback function for cursor formatting.
     * @returns     Object itself
     * @public
     */
    setCursorFormatting(formatter: CursorFormatterBarChart): this;
    /**
     * Get active cursor formatter.
     * @returns     Cursor formatter.
     * @public
     */
    getCursorFormatting(): CursorFormatterBarChart;
    /**
     * Add manually controlled Cursor object.
     * These have exactly same functions as built-in cursors but they can be freely controlled by application logic.
     *
     * ```ts
     *  const cursor = chart.addCursor()
     * ```
     *
     * Styling works same as built-in cursors (e.g. {@link setCursor}).
     *
     * Position is set using `setPosition` method and displayed content using `setResultTable(table => table.setContent(...))`
     * For more details, see Developer documentation \> Features \> Cursor \> Manual cursors
     *
     * @param   cursorBuilder -     Builder for cursor. Can be used to tweak a handful of properties which can't be changed during runtime.
     * @returns     Cursor object.
     * @public
     */
    addCursor<ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: CursorBuilder2D<ResultTableBackgroundType>): Cursor2D<ResultTableBackgroundType>;
    /**
     * Set margin around each bar along category axis as percentage of the bar thickness.
     * For example, `0.1` = on both left and right side of bar there is a 10% margin.
     * Actual thickness of bar depends on chart size, but for 100 px bar that would be 10 px + 10 px margin.
     *
     * Valid value range is between [0, 0.49].
     *
     * ```ts
     *  // Example, no margin between bars.
     *  BarChart.setBarsMargin(0)
     * ```
     *
     * ```ts
     *  // Example, increased space between bars.
     *  BarChart.setBarsMargin(0.20)
     * ```
     *
     * @param   margin - Margin around each bar along category axis as percentage of bar thickness.
     * @returns     Object itself.
     * @public
     */
    setBarsMargin(margin: number): this;
    /**
     * Get margin around each bar along category axis as percentage of the bar thickness.
     * For example, `0.1` = on both left and right side of bar there is a 10% margin.
     * Actual thickness of bar depends on chart size, but for 100 px bar that would be 10 px + 10 px margin.
     *
     * Valid value range is between [0, 0.49].
     *
     * @returns     Margin around each bar along category axis as percentage of bar thickness.
     * @public
     */
    getBarsMargin(): number;
    /**
     * Set theme effect enabled on component or disabled.
     *
     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * ```ts
     *  // Example, disable theme effect from a particular component.
     *  Component.setEffect(false)
     * ```
     *
     * For the most part, theme effects are **enabled** by default on most components.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     *
     * @param enabled - Theme effect enabled
     * @returns          Object itself.
     * @public
     * @privateRemarks  Override
     */
    setBarsEffect(enabled: boolean): this;
    /**
     * Get theme effect enabled on component or disabled.
     *
     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * ```ts
     *  // Example, disable theme effect from a particular component.
     *  Component.setEffect(false)
     * ```
     *
     * For the most part, theme effects are **enabled** by default on most components.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     *
     * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
     * @public
     */
    getBarsEffect(): boolean;
    /**
     * Set `BarChart` data, updating the visible bars.
     *
     * This method signature takes in an array of objects with `category` and optional `value` properties.
     *
     * ```ts
     *  // Example usage
     *  barChart.setData([
     *      { category: 'Category 1', value: 10 },
     *      { category: 'Category 2', value: 12 },
     *  ])
     * ```
     *
     * In use cases with real-time updates, the recommended way to push value updates to existing bars is to call `setData` again.
     *
     * See also:
     *  {@link setDataStacked}
     *  {@link setDataGrouped}
     *
     * @param   arg     - Array of objects with category and value properties.
     * @returns         Object itself
     * @public
     */
    setData(arg: {
        category: string;
        value?: number;
    }[]): this;
    /**
     * Set `BarChart` data, updating the visible bars.
     *
     * This method signature takes a single object that can have any number of keys.
     * Each key is interpreted as a category, and the respective value as the bar value.
     *
     * ```ts
     *  // Example usage
     *  barChart.setData({
     *      'Category 1': 10,
     *      'Category 2': 12,
     *  })
     * ```
     *
     * In use cases with real-time updates, the recommended way to push value updates to existing bars is to call `setData` again.
     *
     * See also:
     *  {@link setDataStacked}
     *  {@link setDataGrouped}
     *
     * @param   arg     - Object with string keys and number values.
     * @returns         Object itself
     * @public
     */
    setData(arg: {
        [key: string]: unknown;
    }): this;
    /**
     * Set `BarChart` data, updating the visible bars.
     *
     * This method signature takes an array of numbers, where each number is a value for a bar.
     * In this case, each bar is just assigned an automatic category like "Category 1".
     *
     * ```ts
     *  // Example usage
     *  barChart.setData([10, 12])
     * ```
     *
     * In use cases with real-time updates, the recommended way to push value updates to existing bars is to call `setData` again.
     *
     * See also:
     *  {@link setDataStacked}
     *  {@link setDataGrouped}
     *
     * @param   arg     - Number array of bar values.
     * @returns         Object itself
     * @public
     */
    setData(arg: number[]): this;
    /**
     * Set `BarChart` data, updating the visible bars.
     *
     * This method signature takes in an array of strings as Categories, without any Values.
     * It can be used to initialize the categories before data is available.
     *
     * See also:
     *  {@link setDataStacked}
     *  {@link setDataGrouped}
     *
     * @param   arg     - Array of strings as categories
     * @returns         Object itself
     * @public
     */
    setData(arg: string[]): this;
    /**
     * Set `BarChart` data, updating the visible bars.
     * This method accepts data for a **Stacked Bar Chart**, displaying it as such.
     *
     * ```ts
     *  BarChart.setDataStacked(
     *      ['category 1' , 'category 2'],
     *      [
     *          { subCategory: 'sub category 1', values: [1, 2] },
     *          { subCategory: 'sub category 2', values: [3, 4] },
     *          { subCategory: 'sub category 3', values: [5, 6] },
     *      ]
     *  )
     * ```
     *
     * See also:
     *  {@link setData}
     *  {@link setDataGrouped}
     *
     * @public
     * @beta    Released to public beta in v5.1.0. May be reworked according to customer feedback and experiences.
     */
    setDataStacked(categories: string[], data: {
        subCategory: string;
        values: number[];
    }[]): this;
    /**
     * Set `BarChart` data, updating the visible bars.
     * This method accepts data for a **Grouped Bar Chart**, displaying it as such.
     *
     * ```ts
     *  BarChart.setDataGrouped(
     *      ['category 1' , 'category 2'],
     *      [
     *          { subCategory: 'sub category 1', values: [1, 2] },
     *          { subCategory: 'sub category 2', values: [3, 4] },
     *          { subCategory: 'sub category 3', values: [5, 6] },
     *      ]
     *  )
     * ```
     *
     * See also:
     *  {@link setData}
     *  {@link setDataStacked}
     *
     * @public
     * @beta    Released to public beta in v5.1.0. May be reworked according to customer feedback and experiences.
     */
    setDataGrouped(categories: string[], data: {
        subCategory: string;
        values: number[];
    }[]): this;
    /**
     * Configure how category labels are displayed in the `BarChart`.
     * To see all configuration options, see {@link BarChartCategoryLabels}.
     *
     * To display labels inside or after bars, see {@link setValueLabels}.
     *
     * ```ts
     *  // Example, hide labels
     *  barChart.setCategoryLabels(undefined)
     * ```
     *
     * ```ts
     *  // Example, change label color
     *  barChart.setCategoryLabels({
     *      labelFillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  })
     * ```
     *
     * ```ts
     *  // Example, change label font size. In this case, the previous label configuration is used as a reference so callback function is convenient.
     *  barChart.setCategoryLabels((labels) => ({
     *      labelFont: labels.labelFont.setSize(10)
     *  }))
     * ```
     *
     * ```ts
     *  // Example, configure formatting
     *  barChart.setCategoryLabels({
     *      formatter: (info) => `${info.category} (${(info.value / 1000).toFixed(1)} k)`,
     *  })
     * ```
     *
     * - To learn more of font configurations, see {@link FontSettings}.
     * - To learn more of fill style configurations, see {@link FillStyle}.
     * - To disable automatic label fitting, use {@link setLabelFittingEnabled}.
     *
     * @param   config - `undefined` to hide labels, or alternatively a valid {@link BarChartCategoryLabels} configuration OR a callback function which receives the current label configuration and returns a new one to use.
     * @returns     Object itself.
     * @public
     */
    setCategoryLabels(config: undefined | Partial<BarChartCategoryLabels> | ImmutableMutator<BarChartCategoryLabels, Partial<BarChartCategoryLabels>>): this;
    /**
     * Get current category labels configuration.
     * @returns     BarChartCategoryLabels object or undefined if labels are hidden.
     * @public
     */
    getCategoryLabels(): BarChartCategoryLabels | undefined;
    /**
     * Configure how value labels are displayed in the `BarChart`.
     *
     * There are a handful of different value label positioning types in `BarChart`, which you can find in {@link BarChartValueLabels}.
     * Labels can also be separately displayed before bars on the other side of category axis, see {@link setCategoryLabels}.
     *
     * ```ts
     *  // Example, hide labels
     *  barChart.setValueLabels(undefined)
     * ```
     *
     * ```ts
     *  // Example, display value labels after bars
     *  barChart.setValueLabels({
     *      position: 'after-bar'
     *  })
     * ```
     *
     * ```ts
     *  // Example, display value labels inside bars with black color
     *  barChart.setValueLabels({
     *      position: 'inside-bar',
     *      labelFillStyle: new SolidFill({ color: ColorRGBA(0, 0, 0) })
     *  })
     * ```
     *
     * ```ts
     *  // Example, change label font size. In this case, the previous label configuration is used as a reference so callback function is convenient.
     *  barChart.setValueLabels((labels) => ({
     *      labelFont: labels.labelFont.setSize(10)
     *  }))
     * ```
     *
     * ```ts
     *  // Example, configure formatting
     *  barChart.setValueLabels({
     *      formatter: (info) => `${info.category} (${(info.value / 1000).toFixed(1)} k)`,
     *  })
     * ```
     *
     * - To learn more of font configurations, see {@link FontSettings}.
     * - To learn more of fill style configurations, see {@link FillStyle}.
     * - To disable automatic label fitting, use {@link setLabelFittingEnabled}.
     *
     * @param   config - `undefined` to hide labels, or alternatively a valid {@link BarChartValueLabels} configuration OR a callback function which receives the current label configuration and returns a new one to use.
     * @returns     Object itself.
     * @public
     */
    setValueLabels(config: undefined | Partial<BarChartValueLabels> | ImmutableMutator<BarChartValueLabels, Partial<BarChartValueLabels>>): this;
    /**
     * Get current value labels configuration.
     * @returns     BarChartValueLabels object or undefined if labels are hidden.
     * @public
     */
    getValueLabels(): BarChartValueLabels | undefined;
    /**
     * Enable or disable automatic label fitting.
     *
     * This is enabled by default.
     *
     * ```ts
     *  // Example, disable automatic label fitting
     *  barChart.setLabelFittingEnabled(false)
     * ```
     * @param   enabled - true or false.
     * @returns     Object itself.
     * @public
     */
    setLabelFittingEnabled(enabled: boolean): this;
    /**
     * Get state of automatic label fitting.
     *
     * This is enabled by default.
     *
     * @returns     true or false
     * @public
     */
    getLabelFittingEnabled(): boolean;
    /**
     * Set label fitting margins.
     * This is only relevant if label fitting is enabled {@link setLabelFittingEnabled}.
     * This is true by default.
     *
     * These margins describe extra space that is added around every labels collision box.
     *
     * ```ts
     *  // Example, configure specific fitting margin (10 pixels)
     *  barChart.setLabelFittingMargins(10)
     *
     * // Example, configure non-symmetric margins
     *  barChart.setLabelFittingMargins({ left: 5, right: 5, top: 0, bottom: 0 })
     * ```
     *
     * @param margins -     Margins as pixels or `undefined` to restore default behavior.
     * @returns     Object itself.
     * @public
     */
    setLabelFittingMargins(margins: number | Margin | undefined): this;
    /**
     * Get label fitting margins.
     * @returns     Margins as pixels.
     * @public
     */
    getLabelFittingMargins(): Margin;
    /**
     * Get reference to a particular {@link BarChartBar}.
     * The match is done against the `category` of bars and optionally also with `subCategory`.
     *
     * ```ts
     *  // Example
     *  barChart.setData([
     *      { category: 'Category 1', value: 10 },
     *      { category: 'Category 2', value: 12 },
     *  ])
     *  const bar = barChart.getBar('Category 1')
     * ```
     *
     * ```ts
     *  // Example, grouped bar chart
     *  barChart.setDataGrouped(
     *      ['Cat 1', 'Cat 2'],
     *      [
     *          { subCategory: 'Scat 1', values: [10, 20] },
     *          { subCategory: 'Scat 2', values: [5, 6] },
     *      ]
     *  )
     *  const bar = barChart.getBar('Cat 1', 'Scat 2')
     * ```
     *
     * This method throws an error if the Bar is not found or input arguments are ambiguous (for example, stacked bar chart and sub category wasn't supplied).
     *
     * @param   category - Category that is attempted to match against existing bars.
     * @param   subCategory - Sub category that is attempted to match against existing bars.
     * @returns     Reference to the BarChartBar with matching category.
     * @public
     */
    getBar(category: string, subCategory?: string): BarChartBar;
    /**
     * Get reference to all currently existing {@link BarChartBar}s.
     *
     * @returns     Array with all existing BarChartBar references.
     * @public
     */
    getBars(): BarChartBar[];
    /**
     * Configure automatic sorting of bars.
     *
     * The default value is {@link BarChartSorting.Descending}.
     *
     * ```ts
     *  // Example, disable sorting
     *  barChart.setSorting(BarChartSorting.None)
     * ```
     *
     * ```ts
     *  // Example, ascending sorting
     *  barChart.setSorting(BarChartSorting.Ascending)
     * ```
     *
     * ```ts
     *  // Example, descending sorting
     *  barChart.setSorting(BarChartSorting.Descending)
     * ```
     *
     * ```ts
     *  // Example, alphabetical sorting
     *  barChart.setSorting(BarChartSorting.Alphabetical)
     * ```
     *
     * ```ts
     *  // Example, custom sorting (ascending implementation)
     *  barChart.setSorting((a, b) => a.value - b.value)
     * ```
     *
     * @param   sorter - Sorting function or undefined to disable sorting.
     * @returns     Object itself.
     * @public
     */
    setSorting(sorter: undefined | BarChartSorter): this;
    /**
     * Get current sorting configuration.
     * @returns     undefined or {@link BarChartSorter}.
     * @public
     */
    getSorting(): undefined | BarChartSorter;
    /**
     * Enable/disable animation of bar category positions.
     * This is enabled by default.
     *
     * ```ts
     *  // Example, disable category position animation.
     *  BarChart.setAnimationCategoryPosition(false)
     * ```
     * @param   enabled -   Boolean
     * @param   speedMultiplier     - Optional multiplier for category animation speed. `1` matches default speed.
     * @returns     Object itself.
     */
    setAnimationCategoryPosition(enabled: boolean, speedMultiplier?: number): this;
    /**
     * Enable/disable animation of bar values.
     * This is enabled by default.
     *
     * ```ts
     *  // Example, disable value animation.
     *  BarChart.setAnimationValues(false)
     * ```
     * @param   enabled -   Boolean
     * @param   speedMultiplier     - Optional multiplier for animation speed. `1` matches default speed.
     * @returns     Object itself.
     */
    setAnimationValues(enabled: boolean, speedMultiplier?: number): this;
    /**
     * Translate a coordinate in HTML client coordinate system to another coordinate system.
     *
     * **(1) bars coordinate system:**
     *
     * ```ts
     *  BarChart.seriesBackground.addEventListener('click', event => {
     *      const locationBars = chart.translateCoordinate(event, chart.coordsBars)
     *      // locationBars tells the clicked location relative to Bar Chart value and category axes.
     *  })
     * ```
     *
     * **(2) relative control coordinate system:**
     *
     * ```ts
     *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
     *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
     *  // locationRelative is in pixels relative to bottom left corner of the chart
     * ```
     *
     * Relative coordinates can be used for positioning LightningChart JS UI components:
     *
     * ```ts
     *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
     *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
     *      .setOrigin(UIOrigins.LeftBottom)
     *      .setPosition({ x: 20, y: 20 })
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     */
    translateCoordinate<T extends CoordinateSystemRelative | CoordinateSystemBarChart>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : T extends CoordinateSystemBarChart ? CoordinateBarChart : never;
    /**
     * Translate a coordinate in Bars coordinate system to another coordinate system.
     *
     * **(1) HTML client coordinate system:**
     *
     * ```ts
     *  const locationBars = { iCategory: 0, value: 100 }
     *  const locationClient = chart.translateCoordinate(locationBars, chart.client)
     * ```
     *
     * Client coordinates can be used to absolute position HTML elements using CSS, for example.
     *
     * ```ts
     *  myHTMLElement.style.position = 'absolute'
     *  myHTMLElement.style.left = locationClient.clientX
     *  myHTMLElement.style.top = locationClient.clientY
     * ```
     *
     * **(2) relative control coordinate system:**
     *
     * ```ts
     *  const locationBars = { iCategory: 0, value: 100 }
     *  const locationRelative = chart.translateCoordinate(locationBars, chart.coordsRelative)
     *  // locationRelative is in pixels relative to bottom left corner of the chart
     * ```
     *
     * Relative coordinates can be used for positioning LightningChart JS UI components:
     *
     * ```ts
     *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
     *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
     *      .setOrigin(UIOrigins.LeftBottom)
     *      .setPosition({ x: 20, y: 20 })
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     */
    translateCoordinate<T extends CoordinateSystemRelative | CoordinateSystemClient>(coordinate: CoordinateBarChart, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : T extends CoordinateSystemClient ? CoordinateClient : never;
    /**
     * Translate a coordinate from relative control coordinates to another coordinate system.
     *
     * ```ts
     *  // 10 pixels left and 20 pixels up from controls bottom left corner
     *  const locationRelative = { x: 10, y: 20 }
     *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
     * ```
     *
     * Client coordinates can be used to absolute position HTML elements using CSS, for example.
     *
     * ```ts
     *  myHTMLElement.style.position = 'absolute'
     *  myHTMLElement.style.left = locationClient.clientX
     *  myHTMLElement.style.top = locationClient.clientY
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     */
    translateCoordinate<T extends CoordinateSystemBarChart | CoordinateSystemClient>(coordinate: CoordinateXY, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : T extends CoordinateSystemBarChart ? CoordinateBarChart : never;
    /**
     * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
     *
     * ```ts
     *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
     *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
     *  // locationRelative is in pixels relative to bottom left corner of the chart
     * ```
     *
     * Relative coordinates can be used for positioning LightningChart JS UI components:
     *
     * ```ts
     *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
     *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
     *      .setOrigin(UIOrigins.LeftBottom)
     *      .setPosition({ x: 20, y: 20 })
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     * @privateRemarks  This is a super method signature. It has to also be listed here to satisfy TypeScript even though it adds no additional functionality to the previous signatures.
     */
    translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
    /**
     * Translate a coordinate from relative control coordinates to HTML client coordinate system.
     *
     * ```ts
     *  // 10 pixels left and 20 pixels up from controls bottom left corner
     *  const locationRelative = { x: 10, y: 20 }
     *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
     * ```
     *
     * Client coordinates can be used to absolute position HTML elements using CSS, for example.
     *
     * ```ts
     *  myHTMLElement.style.position = 'absolute'
     *  myHTMLElement.style.left = locationClient.clientX
     *  myHTMLElement.style.top = locationClient.clientY
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     * @privateRemarks  This is a super method signature. It has to also be listed here to satisfy TypeScript even though it adds no additional functionality to the previous signatures.
     */
    translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
    /**
     * Disable/Enable all animations of the Chart.
     * @param animationsEnabled - Boolean value to enable or disable animations.
     * @returns Chart itself for fluent interface.
     * @public
     * @privateRemarks  Override
     */
    setAnimationsEnabled(animationsEnabled: boolean): this;
    /**
     * **Permanently** destroy the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...BarChart()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @returns Object itself for fluent interface
     * @public
     */
    dispose(): this;
    /**
     * Get minimum size of Chart.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @returns Vec2 minimum size or undefined if unimplemented
     */
    getMinimumSize(): Point | undefined;
    addEventListener<K extends keyof BarChartEventMap>(type: K, listener: (event: BarChartEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof BarChartEventMap>(type: K, listener: (event: BarChartEventMap[K], info: unknown) => unknown): void;
}
/**
 * End user reference to 1 Bar in a {@link BarChart}
 *
 * Reference to a `BarChartBar` can be fetched using {@link BarChartBar.getBar} or {@link BarChartBar.getBars} methods.
 *
 * Possibly useful methods:
 *  - {@link BarChartBar.setFillStyle} | set fill style
 *  - {@link BarChartBar.setStrokeStyle} | set border style
 *  - {@link BarChartBar.onMouseClick} | Add events to interactions on a specific bar
 *
 * Changing bar values, or removing bars should be generally done directly using {@link BarChart.setData} method, rather than methods of `BarChartBar`!
 * However, it is also possible to directly change value of an existing bar with {@link BarChartBar.setValue}.
 *
 * @public
 */
export declare class BarChartBar extends Series2D<SolveResultBar> implements _InternalSeriesWithCursor<SolveResultBar> {
    /**
     * The category of the bar, as parsed through user input to {@link BarChart.setData} method.
     * @public
     */
    readonly category: string;
    /**
     * The sub category of the bar, as parsed through user input to {@link BarChart.setDataStacked} / {@link BarChart.setDataGrouped} methods.
     * @public
     */
    readonly subCategory?: string;
    /**
     * @public
     */
    readonly chart: BarChart;
    /**
     * Set value of the Bar.
     *
     * This can also be achieved with {@link BarChart.setData}.
     *
     * @param   value - New value for the bar.
     * @public
     */
    setValue(value: number): this;
    /**
     * Get value of the bar.
     * @returns     Value of the bar.
     * @public
     */
    getValue(): number;
    /**
     * @public
     */
    get value(): number;
    /**
     * Set fill style of the Bar.
     *
     * ```ts
     *  // Example usage
     *  bar.setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     * ```
     *
     * - To learn more of fill styles, see {@link FillStyle}.
     * - For highlighting use cases, you can also use {@link setHighlight}.
     *
     * @param   value - FillStyle or callback function which takes current fill style and returns a new one.
     * @returns     Object itself.
     * @public
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of the Bar.
     * @returns     FillStyle.
     * @public
     */
    getFillStyle(): FillStyle;
    /**
     * Set border style of the Bar.
     *
     * ```ts
     *  // Example usage
     *  bar.setStrokeStyle(new SolidLine({
     *      thickness: 1,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * ```ts
     *  // Example, remove border
     *  bar.setStrokeStyle(emptyLine)
     * ```
     *
     * - To learn more of line styles, see {@link LineStyle}.
     *
     * @param   value - LineStyle or callback function which takes current line style and returns a new one.
     * @returns     Object itself.
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get border style of the Bar.
     * @returns     LineStyle.
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set theme effect enabled on component or disabled.
     *
     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * ```ts
     *  // Example, disable theme effect from a particular component.
     *  Component.setEffect(false)
     * ```
     *
     * For the most part, theme effects are **enabled** by default on most components.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     *
     * **NOTE: Disabling/Enabling effects on 1 Bar currently results in same action applied to ALL Bars in the same chart. This can not be prevented at the moment.**
     *
     * @param enabled - Theme effect enabled
     * @returns          Object itself.
     * @public
     * @privateRemarks  Override
     */
    setEffect(enabled: boolean): this;
    addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultBar) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultBar) => unknown): void;
}
/**
 * Class that represents a {@link BarChart}s Category Axis.
 * It can be accessed through {@link BarChart.categoryAxis} property, and provides methods for configuring axis style and title.
 *
 * Useful methods:
 * - {@link setTitle} | set title text
 * - {@link setTitleFillStyle} | set title fill style
 * - {@link setTitleFont} | set title font
 * - {@link setStrokeStyle} | set style of axis line
 * @public
 */
export declare class BarChartCategoryAxis extends GenericAxis<LinearScale1D, AbstractAxisStrategy, _AbstractAxisTick, _BarChartCategoryInput, _GenericTickPlottingVariables, _GenericTickInfo, _BarChartCategoryOutput> {
    /**
     * Set Axis *thickness* as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax,
     *  Axis.setThickness( 60 )
     * ```
     *
     * @param thickness - Explicit thickness of Axis as pixels.
     * @returns Object itself for fluent interface.
     * @public
     */
    setThickness(thickness: number): this;
    /**
     * Configure Axis *thickness* min/max limits as pixels.
     *
     * The thickness of Axis is calculated based on ticks, title, axis line, etc.
     * By setting `min` and/or `max` thickness, the size allocated for Axis can be restricted to desired limits.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax, set axis to at least 100 px thick, but allow larger axis thickness if labels are large, or other such scenario.
     *  Axis.setThickness({ min: 100, max: undefined })
     * ```
     *
     * @param thickness - Explicit thickness of Axis as pixels.
     * @returns Object itself for fluent interface.
     * @public
     */
    setThickness(thickness: {
        min?: number;
        max?: number;
    }): this;
    /**
     * Get Axis *thickness* min/max limits as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * By default, Axis has no thickness restrictions, so `getThickness` should return `{ min: undefined, max: undefined }`.
     *
     * @returns Actively configured Axis thickness limits as pixels.
     * @public
     */
    getThickness(): {
        min: number | undefined;
        max: number | undefined;
    };
    /**
     * Set style of Axis line stroke.
     *
     * Supported line styles:
     * - {@link SolidLine}
     * - {@link DashedLine}
     * - {@link emptyLine}
     *
     * ```ts
     *  // Example syntax, hide axis line
     *  barChart.categoryAxis.setStrokeStyle(emptyLine)
     * ```
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  barChart.categoryAxis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  barChart.categoryAxis.setStrokeStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * - To learn more about line styles, see {@link LineStyle}.
     * - Sometimes the axis stroke style is confused together with the border style of {@link BarChart.setSeriesBackgroundStrokeStyle | series background border}
     *
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Object itself for fluent interface.
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @returns Axis stroke style as a LineStyle object
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Used in phase 1: after we know what ticks will be displayed, formulate generic information for chart layout calculations (e.g. XY layout for XY charts).
     */
    protected _getAbstractUpdateResult(input: _BarChartCategoryInput, ticksInfo: Map<_AbstractAxisTick, _GenericTickInfo>, updatedTicks: boolean): _BarChartCategoryOutput;
    addEventListener<K extends keyof GenericAxisEventMap>(type: K, listener: (event: GenericAxisEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof GenericAxisEventMap>(type: K, listener: (event: GenericAxisEventMap[K], info: unknown) => unknown): void;
    setPointerEvents(state: boolean): this;
    getPointerEvents(): boolean;
}
/**
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare interface _BarChartCategoryInput extends _GenericAxisInput {
}
/**
 * Type definition for a function that formats text displayed in bar chart category label.
 *
 * See examples in {@link BarChart.setCategoryLabels}.
 * @public
 */
export declare type BarChartCategoryLabelFormatter = (category: string, categoryValuesTotal: number) => string;
/**
 * Interface for configuration of Bar Chart category labels.
 *
 * Used with {@link BarChart.setCategoryLabels}.
 * @public
 */
export declare interface BarChartCategoryLabels {
    /**
     * Label text formatter.
     * See {@link BarChartLabelFormatter} for examples.
     */
    formatter: BarChartCategoryLabelFormatter;
    /**
     * Label fill style.
     * See {@link FillStyle} for examples.
     */
    labelFillStyle: FillStyle;
    /**
     * Not to be confused with {@link GlowEffect}
     * @public
     * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
     */
    labelShadow: Color | undefined;
    /**
     * Label font.
     * See {@link FontSettings} for examples.
     */
    labelFont: FontSettings;
    /**
     * Pixels margin before label.
     */
    labelMargin: number;
    /**
     * Label rotation as degrees.
     */
    labelRotation: number;
    /**
     * Label alignment along category axis (value between -1, 1)
     */
    labelAlignment: number;
    /**
     * Tick line style.
     * See {@link LineStyle} for examples.
     */
    tickStyle: LineStyle;
    /**
     * Length of tick line as pixels.
     */
    tickLength: number;
}
/**
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare interface _BarChartCategoryOutput extends _GenericAxisOutput {
}
/**
 * Interface that can be used to define {@link BarChart} configurations, when inside a {@link Dashboard},
 * that can't be changed after creation.
 * @public
 */
export declare interface BarChartDashboardOptions extends DashboardCellOptions, BarChartOptions {
}
/**
 * Interface of events trackable by {@link BarChart.addEventListener} and the respective Event types.
 * @public
 */
export declare interface BarChartEventMap extends ChartWithSeriesEventMap<BarChartBar>, ChartWithCursorEventMap<SolveResultBar> {
}
/**
 * Type definition for a function that formats text displayed in bar chart labels.
 *
 * See examples in {@link BarChart.setCategoryLabels} and {@link BarChart.setValueLabels}.
 * @public
 */
export declare type BarChartLabelFormatter = (info: {
    chart: BarChart;
    category: string;
    value: number;
    bar: BarChartBar | undefined;
    subCategory: string | undefined;
}) => string;
/**
 * Interface for readonly configuration of {@link BarChart}.
 *
 * Some properties of `BarChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example, configure bar chart orientation.
 *  const chart = lightningChart().BarChart({
 *      type: BarChartTypes.Horizontal
 *  })
 * ```
 *
 * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
 *
 * For *standalone* `BarChart`, more parameters are documented in {@link LightningChart.BarChart}.
 *
 * For *dashboard* `BarChart`, more parameters are documented in {@link Dashboard.createBarChart}.
 *
 *
 * **Commonly used properties:**
 *
 * - {@link BarChartOptions.theme}: Specify chart color *theme*.
 * - {@link BarChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
 * - {@link BarChartOptions.type}: Configure bar chart orientation.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create chart with default configuration.
 *  const chart = lightningChart().BarChart({})
 * ```
 *
 * ```typescript
 *  // Example 2, create chart with specified color theme.
 *  const chart = lightningChart().BarChart({
 *      theme: Themes.light,
 *  })
 * ```
 *
 * ```typescript
 *  // Example 3, create chart with specified orientation
 *  const chart = lightningChart().BarChart({
 *      type: BarChartTypes.Horizontal,
 *  })
 * ```
 * @public
 */
export declare interface BarChartOptions<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
    /**
     * Specify orientation of bar chart (vertical or horizontal).
     *
     * ```ts
     *  // Example usage
     *  const chart = lightningChart().BarChart({ type: BarChartTypes.Horizontal })
     * ```
     * @public
     */
    readonly type?: BarChartType;
    /**
     * Interface for supplying read-only configurations for the Value Axis. These can only be specified when the chart is created.
     * See {@link BarChartValueAxisOptions} for more information.
     * @public
     */
    readonly valueAxis?: BarChartValueAxisOptions;
    /**
     * Builder for the charts' *auto cursor*.
     *
     * For most use cases, it is not recommended to use this, but rather {@link BarChart.setCursor} for a more convenient API.
     * @public
     */
    readonly cursorBuilder?: CursorBuilder2D<CursorResultTableBackgroundType>;
}
/**
 * Type definition for a function that sorts bar charts.
 *
 * Works similar JavaScript [Array.sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort), but each entry is given an object with `category` and `value` properties.
 *
 * See examples in {@link BarChart.setSorting}.
 * @public
 */
export declare type BarChartSorter = (a: {
    category: string;
    value: number;
}, b: {
    category: string;
    value: number;
}) => number;
/**
 * Built-in options for {@link BarChartSorter}s.
 *
 * See examples in {@link BarChart.setSorting}.
 * @public
 */
export declare const BarChartSorting: {
    Disabled: undefined;
    None: undefined;
    Ascending: BarChartSorter;
    Descending: BarChartSorter;
    Alphabetical: BarChartSorter;
};
/**
 * Selector for Bar chart orientation (vertical or horizontal bars).
 *
 * See {@link BarChart} on how to supply the desired option.
 * @public
 */
export declare type BarChartType = (typeof BarChartTypes)[keyof typeof BarChartTypes];
/**
 * Selectors for Bar chart orientation (vertical or horizontal bars).
 *
 * See {@link BarChart} on how to supply the desired option.
 * @public
 */
export declare const BarChartTypes: {
    Horizontal: "horizontal";
    Vertical: "vertical";
};
/**
 * Class that represents a {@link BarChart}s Value Axis.
 * It can be accessed through {@link BarChart.valueAxis} property, and provides methods for configuring axis style, ticks and title.
 *
 * Useful methods:
 * - {@link setTitle} | set title text
 * - {@link setTitleFillStyle} | set title fill style
 * - {@link setTitleFont} | set title font
 * - {@link setStrokeStyle} | set style of axis line
 * - {@link setTickStrategy} | configure ticks
 * - {@link fit} | fit axis to visible data immediately
 * - {@link setAnimationScroll} | disable scroll animation
 * @public
 */
export declare class BarChartValueAxis extends GenericAxis<LinearScale1D | LogarithmicScale1D, AbstractAxisStrategy, _AbstractAxisTick, _BarChartValueInput, _BarChartValueTickPlottingVariables, _BarChartValueTickInfo, _BarChartValueOutput> {
    /**
     * Set Axis *thickness* as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax,
     *  Axis.setThickness( 60 )
     * ```
     *
     * @param thickness - Explicit thickness of Axis as pixels.
     * @returns Object itself for fluent interface.
     * @public
     */
    setThickness(thickness: number): this;
    /**
     * Configure Axis *thickness* min/max limits as pixels.
     *
     * The thickness of Axis is calculated based on ticks, title, axis line, etc.
     * By setting `min` and/or `max` thickness, the size allocated for Axis can be restricted to desired limits.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax, set axis to at least 100 px thick, but allow larger axis thickness if labels are large, or other such scenario.
     *  Axis.setThickness({ min: 100, max: undefined })
     * ```
     *
     * @param thickness - Explicit thickness of Axis as pixels.
     * @returns Object itself for fluent interface.
     * @public
     */
    setThickness(thickness: {
        min?: number;
        max?: number;
    }): this;
    /**
     * Get Axis *thickness* min/max limits as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * By default, Axis has no thickness restrictions, so `getThickness` should return `{ min: undefined, max: undefined }`.
     *
     * @returns Actively configured Axis thickness limits as pixels.
     * @public
     */
    getThickness(): {
        min: number | undefined;
        max: number | undefined;
    };
    /**
     * Set style of Axis line stroke.
     *
     * Supported line styles:
     * - {@link SolidLine}
     * - {@link DashedLine}
     * - {@link emptyLine}
     *
     * ```ts
     *  // Example syntax, hide axis line
     *  barChart.valueAxis.setStrokeStyle(emptyLine)
     * ```
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  barChart.valueAxis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  barChart.valueAxis.setStrokeStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * - To learn more about line styles, see {@link LineStyle}.
     * - Sometimes the axis stroke style is confused together with the border style of {@link BarChart.setSeriesBackgroundStrokeStyle | series background border}
     *
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Object itself for fluent interface.
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @returns Axis stroke style as a LineStyle object
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set *TickStrategy* of *Axis*.
     *
     * The *TickStrategy* defines the positioning and formatting logic of *Axis* ticks
     * as well as the style of created ticks.
     *
     * ```ts
     *  // Example, disable ticks
     *  barChart.valueAxis.setTickStrategy(AxisTickStrategies.Empty)
     * ```
     *
     * ```ts
     *  // Example, customize tick labels formatting
     *  barChart.valueAxis.setTickStrategy(AxisTickStrategies.Numeric, ticks => ticks
     *      ticks
     *          .setMajorFormattingFunction((value) => `${value.toFixed(1)} `)
     *          .setMinorFormattingFunction((value) => `${value.toFixed(1)} `)
     *  )
     * ```
     *
     * ```ts
     *  // Example, set tick label fill style
     *  barChart.valueAxis.setTickStrategy(AxisTickStrategies.Numeric, ticks => ticks
     *      .setMajorTickStyle((major) => major.setLabelFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) })))
     *      .setMinorTickStyle((minor) => minor.setLabelFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) })))
     *  )
     * ```
     *
     * ```ts
     *  // Example, set tick label font size
     *  barChart.valueAxis.setTickStrategy(AxisTickStrategies.Numeric, ticks => ticks
     *      .setMajorTickStyle((major) => major.setLabelFont((font) => font.setSize(12)))
     *      .setMinorTickStyle((minor) =>  minor.setLabelFont((font) => font.setSize(10)))
     *  )
     * ```
     *
     * - To learn more of font configurations, see {@link FontSettings}.
     * - To learn more of fill style configurations, see {@link FillStyle}.
     *
     * @param tickStrategy - TickStrategy, either `AxisTickStrategies.Numeric` or `AxisTickStrategies.Empty`
     * @param styler - Optional callback that can be used to customize the *TickStrategy*.
     * @returns Object itself for fluent interface.
     * @public
     */
    setTickStrategy<TickStrategy extends 'Numeric' | 'Empty'>(tickStrategy: TickStrategy, styler?: TickStrategyStyler<TickStrategyParameters, TickStrategy>): this;
    /**
     * Used in phase 1: after we know what ticks will be displayed, formulate generic information for chart layout calculations (e.g. XY layout for XY charts).
     */
    protected _getAbstractUpdateResult(input: _BarChartValueInput, ticksInfo: Map<_AbstractAxisTick, _BarChartValueTickInfo>, updatedTicks: boolean): _BarChartValueOutput;
    addEventListener<K extends keyof GenericAxisEventMap>(type: K, listener: (event: GenericAxisEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof GenericAxisEventMap>(type: K, listener: (event: GenericAxisEventMap[K], info: unknown) => unknown): void;
    setPointerEvents(state: boolean): this;
    getPointerEvents(): boolean;
}
/**
 * Interface for supplying read-only configurations for the Value Axis. These can only be specified when the chart is created.
 *
 * ```ts
 *  // Example, logarithmic value axis
 *  const barChart = lightningChart().BarChart({
 *      valueAxis: {
 *          type: 'logarithmic',
 *          base: 10
 *      }
 *  })
 * ```
 * @public
 */
export declare interface BarChartValueAxisOptions {
    /**
     * Type of Axis.
     *
     * `linear`:
     *
     * Default Axis type. Same behavior as `type: undefined`.
     *
     * `logarithmic`:
     *
     * Logarithmic Axis. By default base number will be `10`.
     */
    type?: 'linear' | 'logarithmic';
    /**
     * Specification of Logarithmic Base number (e.g. 10, 2, natural log).
     *
     * Defaults to 10 if omitted.
     *
     * Examples:
     *
     * - `10` | powers of ten (1, 10, 100, 1000, 10000, ...).
     * - `e`  | natural logarithm (1e, 2e, 3e, 4e, ...)
     *
     * `type` must be set to `'logarithmic'` for this to effect!
     */
    base?: number | 'E' | 'e' | 'natural';
}
/**
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare interface _BarChartValueInput extends _GenericAxisInput {
}
/**
 * Interface for describing style of bar chart value labels.
 *
 * Used with {@link BarChart.setValueLabels}.
 *
 * There are currently 2 different value label positioning options available:
 * - {@link BarChartValueLabelsAfterBars}.
 * - {@link BarChartValueLabelsInsideBars}.
 * @public
 */
export declare type BarChartValueLabels = BarChartValueLabelsAfterBars | BarChartValueLabelsInsideBars;
/**
 * Interface for describing style of bar chart value labels when they are positioned after bars.
 *
 * Used with {@link BarChart.setValueLabels}.
 * @public
 */
export declare interface BarChartValueLabelsAfterBars {
    position: 'after-bar';
    /**
     * Label text formatter.
     * See {@link BarChartLabelFormatter} for examples.
     */
    formatter: BarChartLabelFormatter;
    /**
     * Label fill style.
     * See {@link FillStyle} for examples.
     */
    labelFillStyle: FillStyle;
    /**
     * Not to be confused with {@link GlowEffect}
     * @public
     * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
     */
    labelShadow: Color | undefined;
    /**
     * Label font.
     * See {@link FontSettings} for examples.
     */
    labelFont: FontSettings;
    /**
     * Pixels margin before label.
     */
    labelMargin: number;
    /**
     * Label rotation as degrees.
     */
    labelRotation: number;
    /**
     * Label alignment along category axis (value between -1, 1).
     */
    labelAlignment: number;
    /**
     * Only applies to stacked bar charts;
     * is a label displayed for the sum value of a stack?
     *
     * Sum label is always positioned after the very last bar in a stack.
     */
    displayStackedSum: boolean;
    /**
     * Only applies to stacked bar charts;
     * is a label displayed for each individual sub category value?
     */
    displayStackedIndividuals: boolean;
}
/**
 * Interface for describing style of bar chart value labels when they are positioned inside bars.
 *
 * Used with {@link BarChart.setValueLabels}.
 * @public
 */
export declare interface BarChartValueLabelsInsideBars {
    position: 'inside-bar' | 'inside-bar-end' | 'inside-bar-centered' | 'inside-bar-start';
    /**
     * Label text formatter.
     * See {@link BarChartLabelFormatter} for examples.
     */
    formatter: BarChartLabelFormatter;
    /**
     * Label fill style.
     * See {@link FillStyle} for examples.
     */
    labelFillStyle: FillStyle;
    /**
     * Not to be confused with {@link GlowEffect}
     * @public
     * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
     */
    labelShadow: Color | undefined;
    /**
     * Label font.
     * See {@link FontSettings} for examples.
     */
    labelFont: FontSettings;
    /**
     * Pixels margin before label. Exact behavior depends on value of `position`.
     *
     * - `'inside-bar-end'` - margin applied between bar end and label.
     * - `'inside-bar-centered'` - no effect.
     * - `'inside-bar-start'` - margin applied between bar start and label.
     * - `'inside-bar'` - same as `'inside-bar-end'`
     */
    labelMargin: number;
    /**
     * Label rotation as degrees.
     */
    labelRotation: number;
    /**
     * Label alignment along category axis (value between -1, 1).
     */
    labelAlignment: number;
    /**
     * Only applies to stacked bar charts;
     * is a label displayed for the sum value of a stack?
     *
     * Sum label is always positioned after the very last bar in a stack.
     */
    displayStackedSum: boolean;
    /**
     * Only applies to stacked bar charts;
     * is a label displayed for each individual sub category value?
     */
    displayStackedIndividuals: boolean;
}
/**
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare interface _BarChartValueOutput extends _GenericAxisOutput<_AbstractAxisTick, _BarChartValueTickInfo> {
}
/**
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare interface _BarChartValueTickInfo extends _GenericTickInfo {
}
/**
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare interface _BarChartValueTickPlottingVariables extends _GenericTickPlottingVariables {
}
/**
 * Abstract Picture with stylable border.
 * @public
 */
export declare abstract class BorderedPicture extends Picture {
    /**
     * Set stoke style of Picture
     * @param value - LineStyle object or function which modifies it
     * @returns Object itself for fluent interface
     * @public
     */
    abstract setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Picture
     * @public
     */
    abstract getStrokeStyle(): LineStyle;
}
/**
 * Interface for non-geometric properties of a *box*.
 *
 * Box geometry can be specified in a variety of ways, namely:
 * - {@link BoxDataCentered}.
 * - {@link BoxDataBounds}.
 * @public
 */
export declare interface BoxData {
    /**
     * Color of this box, when the *series* is styled as {@link IndividualPointFill}.
     */
    color?: Color;
    /**
     * Look-up value for this box, when the *series* is styled as {@link PalettedFill}.
     *
     * Determines the color of the box.
     */
    value?: number;
    /**
     * Identifier of this box.
     *
     * Can be used to alter the boxes' properties afterwards.
     */
    id?: string | number;
}
/**
 * Interface for specifying properties of a *box*.
 *
 * Non-geometry properties are explained in {@link BoxData} interface.
 *
 * This interface defines the box using *coordinate boundaries*. For another geometry definitions, see:
 * - {@link BoxDataCentered}.
 * @public
 */
export declare interface BoxDataBounds extends BoxData {
    /**
     * Minimum X coordinate.
     */
    xMin: number;
    /**
     * Minimum Y coordinate.
     */
    yMin: number;
    /**
     * Minimum Z coordinate.
     */
    zMin: number;
    /**
     * Maximum X coordinate.
     */
    xMax: number;
    /**
     * Maximum Y coordinate.
     */
    yMax: number;
    /**
     * Maximum Z coordinate.
     */
    zMax: number;
}
/**
 * Interface for specifying properties of a *box*.
 *
 * Non-geometry properties are explained in {@link BoxData} interface.
 *
 * This interface defines the box using a *center coordinate* and *size*. For another geometry definitions, see:
 * - {@link BoxDataBounds}.
 * @public
 */
export declare interface BoxDataCentered extends BoxData {
    /**
     * Center X coordinate of Box.
     */
    xCenter: number;
    /**
     * Center Y coordinate of Box.
     */
    yCenter: number;
    /**
     * Center Z coordinate of Box.
     */
    zCenter: number;
    /**
     * X size of Box. Applied both ways from 'xCenter' divided by 2.
     */
    xSize: number;
    /**
     * Y size of Box. Applied both ways from 'yCenter' divided by 2.
     */
    ySize: number;
    /**
     * Z size of Box. Applied both ways from 'zCenter' divided by 2.
     */
    zSize: number;
}
/**
 * @public
 */
export declare class BoxFigure extends Figure<SolveResultBoxSeries> implements BoxFigureDimensions {
    /**
     * Boundaries of BoxFigure.
     * Constant and computed in constructor.
     * @public
     */
    readonly boundaries: Interval<Point>;
    /**
     * @public
     */
    readonly scale: LinearScaleXY;
    /**
     * @public
     */
    readonly dimensionStrategy: MultidimensionalStrategy;
    /**
     * @public
     */
    readonly start: number;
    /**
     * @public
     */
    readonly end: number;
    /**
     * @public
     */
    readonly lowerExtreme: number;
    /**
     * @public
     */
    readonly lowerQuartile: number;
    /**
     * @public
     */
    readonly median: number;
    /**
     * @public
     */
    readonly upperQuartile: number;
    /**
     * @public
     */
    readonly upperExtreme: number;
    /**
     * Get boundaries that contain figure.
     * @returns Interval<Point>
     * @public
     */
    _getBoundaries(): Interval<Point>;
    /**
     * Set width of box body as a % of the width of its interval width.
     * @param width - Ratio between box body width and the segments interval
     * @returns Object itself
     * @public
     */
    setBodyWidth(width: number): this;
    /**
     * Get width of box body as a % of the width of its interval width.
     * @returns Ratio between box body width and the segments interval
     * @public
     */
    getBodyWidth(): number;
    /**
     * Set fill style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * BoxAndWhiskers.setBodyFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * BoxAndWhiskers.setBodyFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * BoxAndWhiskers.setBodyFillStyle(transparentFill)
     * ```
     * @param value - FillStyle which has to be used for recoloring or mutator to modify existing one.
     * @returns Series itself for fluent interface.
     * @public
     */
    setBodyFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of box body when not highlighted.
     * @returns FillStyle object
     * @public
     */
    getBodyFillStyle(): FillStyle;
    /**
     * Set border style of Series.
     *
     *```javascript
     * // Specified SolidLine
     * BoxAndWhiskers.setBodyStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * BoxAndWhiskers.setBodyStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * BoxAndWhiskers.setBodyStrokeStyle(transparentLine)
     * ```
     * @param value - LineStyle which has to be used for recoloring or mutator to modify existing one.
     * @returns Series itself for fluent interface.
     * @public
     */
    setBodyStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of box body when not highlighted.
     * @returns LineStyle object
     * @public
     */
    getBodyStrokeStyle(): LineStyle;
    /**
     * Set width of box tails as a % of the width of its interval width.
     * @param width - Ratio between box tail width and the segments interval
     * @returns Object itself
     * @public
     */
    setTailWidth(width: number): this;
    /**
     * Get width of box tails as a % of the width of its interval width.
     * @returns Ratio between box tail width and the segments interval
     * @public
     */
    getTailWidth(): number;
    /**
     * Set stroke style of Series whiskers and tails.
     *
     * Supported line styles:
     * - {@link SolidLine}
     * - {@link emptyLine}
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * BoxAndWhiskers.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * BoxAndWhiskers.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * BoxAndWhiskers.setStrokeStyle(transparentLine)
     * ```
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Chart itself
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of box whiskers and tails when not highlighted.
     * @returns LineStyle object
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of Series median line.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * BoxAndWhiskers.setMedianStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * BoxAndWhiskers.setMedianStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * BoxAndWhiskers.setMedianStrokeStyle(transparentLine)
     * ```
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Chart itself
     * @public
     */
    setMedianStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of box median line when not highlighted.
     * @returns LineStyle object
     * @public
     */
    getMedianStrokeStyle(): LineStyle;
    /**
     * Return some dominant fill style of the segment
     * @returns FillStyle object
     * @public
     */
    getDominantStyle(): FillStyle;
}
/**
 * Data structure that defines the dimensions of a Box Figure.
 * Used to feed segment data to Box Series.
 * @public
 */
export declare interface BoxFigureDimensions {
    readonly start: number;
    readonly end: number;
    readonly lowerExtreme: number;
    readonly lowerQuartile: number;
    readonly median: number;
    readonly upperQuartile: number;
    readonly upperExtreme: number;
}
/**
 * BoxSeries class.
 * Takes in types of 'BoxFigureDimensions' and plots it using 'StatisticFigure'
 *
 * Currently always on X
 * @public
 */
export declare class BoxSeries extends FigureSeries<SolveResultBoxSeries, BoxFigure, BoxFigureDimensions, LinearScaleXY> {
    solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultBoxSeries | undefined;
    /**
     * Add new figure to the series.
     * @param dimensions - Dimensions that figure must represent
     * @returns Created figure
     * @public
     */
    add(dimensions: BoxFigureDimensions): BoxFigure;
    addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultBoxSeries) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultBoxSeries) => unknown): void;
}
/**
 * Class for visualization of large sets of individually configurable 3D *Boxes*.
 *
 * Add data with {@link BoxSeries3D.invalidateData}.
 *
 * Style *boxes* with {@link BoxSeries3D.setFillStyle}.
 *
 * **Example usage:**
 *
 * ```ts
 *  // Construct a grid of vertical boxes.
 *  const data = [
 *      { x: 0, z: 0 },
 *      { x: 1, z: 0 },
 *      { x: 0, z: 1 },
 *      { x: 1, z: 1 }
 *  ]
 *      // Map coords into **BoxData**.
 *      .map( coords => {
 *      const height = Math.random() * 100
 *      return {
 *          xCenter: coords.x,
 *          yCenter: height / 2,
 *          zCenter: coords.z,
 *          xSize: 1,
 *          ySize: height,
 *          zSize: 1
 *      }
 *  })
 *  const chart = lightningChart().Chart3D()
 *  const boxSeries = chart.addBoxSeries()
 *      .invalidateData( data )
 * ```
 *
 * **Color shading style**.
 *
 * By default, `BoxSeries3D` uses _Phong_ shading style.
 *
 * This can be changed with `BoxSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())`
 * @public
 */
export declare class BoxSeries3D extends Series3D<SolveResultBoxSeries3D> {
    /**
     * Method for invalidating *Box* data. Accepts an *Array* of {@link BoxDataCentered} objects.
     *
     * **Properties that must be defined for each NEW Box**:
     * - **"xCenter", "yCenter", "zCenter"**  | coordinates of Box in Axis values.
     * - **"xSize", "ySize", "zSize"**        | size of Box in Axis values.
     *
     * ( if altering a previously created Box, these are not necessary )
     *
     * **Optional properties:**
     * - **"id"**:
     *  If supplied, the *Box* can be altered afterwards by supplying different data with the same **"id"**
     * - **"color"**:
     *  If supplied, the *Box* will be coloured with that *color*,
     *  **but only when the *BoxSeries* is styled as {@link IndividualPointFill}**
     * - **"value"**
     *  *Look-up value* to be used when the *BoxSeries* is styled as {@link PalettedFill}.
     *
     * **Example usage:**
     *
     * - Add an unidentified Box - in this case the Box can not be altered afterwards.
     *
     * ```ts
     *  BoxSeries3D.invalidateData([
     *      { xCenter: 0, yCenter: 0, zCenter: 0, xSize: 1, ySize: 1, zSize: 1 }
     *  ])
     * ```
     *
     * - Add an identified Box and alter its 'color' property afterwards.
     *
     * ```ts
     *  const id = "anything-unique"
     *  BoxSeries3D
     *      .setFillStyle( new IndividualPointFill() )
     *      .invalidateData([
     *          { id, xCenter: 0, yCenter: 0, zCenter: 0, xSize: 1, ySize: 1, zSize: 1 }
     *      ])
     *  setTimeout(() => {
     *      BoxSeries3D.invalidateData([ { id, color: ColorRGBA( 0, 255, 0 ) } ])
     *  }, 2000)
     * ```
     * @public
     */
    invalidateData(data: Partial<BoxDataCentered>[]): this;
    /**
     * Method for invalidating *Box* data. Accepts an *Array* of {@link BoxDataBounds} objects.
     *
     * NOTE: Internally transforms all data into {@link BoxDataCentered} format, meaning that this method is slightly
     * slower than the alternative.
     *
     * **Properties that must be defined for each NEW Box**:
     * - **"xMin", "xMax"**   | bounds of Box on X Axis.
     * - **"yMin", "yMax"**   | bounds of Box on X Axis.
     * - **"zMin", "zMax"**   | bounds of Box on X Axis.
     *
     * ( if altering a previously created Box, these are not necessary )
     *
     * **Optional properties:**
     * - **"id"**:
     *  If supplied, the *Box* can be altered afterwards by supplying different data with the same **"id"**
     * - **"color"**:
     *  If supplied, the *Box* will be coloured with that *color*,
     *  **but only when the *BoxSeries* is styled as {@link IndividualPointFill}**
     * - **"value"**
     *  *Look-up value* to be used when the *BoxSeries* is styled as {@link PalettedFill}.
     *
     * **Example usage:**
     *
     * - Add an unidentified Box - in this case the Box can not be altered afterwards.
     *
     * ```ts
     *  BoxSeries3D.invalidateData([
     *      { xMin: 0, yMin: 0, zMin: 0, xMax: 1, yMax: 1, zMax: 1 }
     *  ])
     * ```
     *
     * - Add an identified Box and alter its 'color' property afterwards.
     *
     * ```ts
     *  const id = "anything-unique"
     *  BoxSeries3D
     *      .setFillStyle( new IndividualPointFill() )
     *      .invalidateData([
     *          { id, xMin: 0, yMin: 0, zMin: 0, xMax: 1, yMax: 1, zMax: 1 }
     *      ])
     *  setTimeout(() => {
     *      BoxSeries3D.invalidateData([ { id, color: ColorRGBA( 0, 255, 0 ) } ])
     *  }, 2000)
     * ```
     * @public
     */
    invalidateData(data: Partial<BoxDataBounds>[]): this;
    /**
     * Clears all data from the series.
     * @returns Object itself for fluent interface.
     * @public
     */
    clear(): this;
    /**
     * Set *FillStyle* of *BoxSeries*.
     *
     * Supports following FillStyles:
     * - **{@link SolidFill}**:
     *  Single solid color for all *boxes*.
     * - **{@link IndividualPointFill}**:
     *  Each *box* is colored according to its **"color"** property.
     *  If the property is not present, the *box* is colored with the *IndividualPointFill* objects' fall-back color.
     * - **{@link PalettedFill}**:
     *  Each *box* is colored according to its **"value"** property and the *PalettedFill* objects'
     *  *look up table*.
     * @param value - FillStyle or function which creates a FillStyle based on previous value.
     * @returns Object itself.
     * @public
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get *FillStyle* of *BoxSeries*.
     *
     * Supports following FillStyles:
     * - **{@link SolidFill}**:
     *  Single solid color for all *boxes*.
     * - **{@link IndividualPointFill}**:
     *  Each *box* is colored according to its **"color"** property.
     *  If the property is not present, the *box* is colored with the *IndividualPointFill* objects' fall-back color.
     * - **{@link PalettedFill}**:
     *  Each *box* is colored according to its **"value"** property and the *PalettedFill* objects'
     *  *look up table*.
     * @returns FillStyle object.
     * @public
     */
    getFillStyle(): FillStyle;
    /**
     * Set rounded edges of Boxes.
     *
     * NOTE: Rounded edges result in increased geometry precision, which in turn uses more rendering resources.
     * @param roundness - Either a **number in range [0, 1]** describing the amount of rounding
     *                      or **undefined** to disable rounded edges.
     * @returns Object itself for fluent interface.
     * @public
     */
    setRoundedEdges(roundness: number | undefined): this;
    /**
     * Get rounded edges of Boxes.
     *
     * NOTE: Rounded edges result in increased geometry precision, which in turn uses more rendering resources.
     * @returns Either a **number in range [0, 1]** describing the amount of rounding
     *                      or **undefined** for disabled rounded edges.
     * @public
     */
    getRoundedEdges(): number | undefined;
    addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultBoxSeries3D) => unknown, options?: LCJSAddEventListenerOptions): void;
    removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultBoxSeries3D) => unknown): void;
}
/**
 * Interface can be used to define the X and Y Axis that a series should be attached to,
 * define type of StatisticFigure and type of dimensionStrategy.
 * @public
 */
export declare interface BoxSeriesOptions extends SeriesOptionsXY {
    /**
     * DimensionStrategy Strategy used for selecting between vertical and horizontal Box Series.
     * @public
     */
    dimensionStrategy?: MultidimensionalStrategy;
}
/**
 * @public
 */
export declare interface CameraChangeEvent {
    cameraLocation: Coordinate3D;
}
/**
 * Data structure of a province / territory of Canada.
 * @public
 */
export declare interface CanadaProvinceOrTerritory {
    /**
     * Name of the province / territory. Eq. 'Ontario'. This is case insensitive.
     */
    name: string;
}
/**
 * Chart abstraction layer that implements Chart title and padding.
 * @public
 */
export declare abstract class Chart extends Panel implements ChartAPI {
    /**
     * Add a new legend to the chart.
     * @public
     */
    addLegend(options?: LegendOptions & {
        customLegend?: LegendLogic;
    }): Legend;
    /**
     * Get minimum size of Chart.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @returns Vec2 minimum size or undefined if unimplemented
     */
    abstract getMinimumSize(): Point | undefined;
    /**
     * Disable/Enable all animations of the Chart.
     * @param animationsEnabled - Boolean value to enable or disable animations.
     * @returns Chart itself for fluent interface.
     * @public
     */
    setAnimationsEnabled(animationsEnabled: boolean): this;
    /**
     * Get animations disable/enable state.
     * @returns Animations default state.
     * @public
     */
    getAnimationsEnabled(): boolean;
    /**
     * Set text of Chart title.
     * @param title - Chart title as a string.
     * @returns Object itself for fluent interface.
     * @public
     */
    setTitle(title: string): this;
    /**
     * Get text of Chart title.
     * @returns Chart title as a string.
     * @public
     */
    getTitle(): string;
    /**
     * Get Chart title size.
     *
     * This depends on current title content, font and style.
     *
     * @returns Size of Chart title in pixels
     * @public
     */
    getTitleSize(): Point;
    /**
     * Set fill style of Chart Title.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * Chart.setTitleFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * Chart.setTitleFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * Chart.setTitleFillStyle(emptyFill)
     * ```
     *
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Chart itself
     * @public
     */
    setTitleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Chart Title.
     * @returns FillStyle object
     * @public
     */
    getTitleFillStyle(): FillStyle;
    /**
     * Not to be confused with {@link GlowEffect}
     * @public
     * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
     */
    setTitleShadow(color: Color | undefined): this;
    /**
     * Not to be confused with {@link GlowEffect}
     * @public
     * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
     */
    getTitleShadow(): Color | undefined;
    /**
     * Set font of Chart Title.
     *
     * Example usage:
     *```javascript
     * // Create a new FontSettings
     * Chart.setTitleFont(new FontSettings({ size: 24, style: 'italic' }))
     * // Change existing settings
     * Chart.setTitleFont((fontSettings) => fontSettings.setWeight('bold'))
     * ```
     *
     * @param value - Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
     * @returns Chart itself
     * @public
     */
    setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Chart title.
     * @returns FontSettings object
     * @public
     */
    getTitleFont(): FontSettings;
    /**
     * Set rotation of Chart title.
     * @param value - Rotation in degrees
     * @returns Object itself
     * @public
     */
    setTitleRotation(value: number): this;
    /**
     * Get rotation of Chart title.
     * @returns Rotation in degrees
     * @public
     */
    getTitleRotation(): number;
    /**
     * Set theme effect enabled on component or disabled.
     *
     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * ```ts
     *  // Example, disable theme effect from a particular component.
     *  Component.setEffect(false)
     * ```
     *
     * For the most part, theme effects are **enabled** by default on most components.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     *
     * @param enabled - Theme effect enabled
     * @returns          Object itself.
     * @public
     */
    setTitleEffect(enabled: boolean): this;
    /**
     * Get theme effect enabled on component or disabled.
     *
     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * ```ts
     *  // Example, disable theme effect from a particular component.
     *  Component.setEffect(false)
     * ```
     *
     * For the most part, theme effects are **enabled** by default on most components.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     *
     * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
     * @public
     */
    getTitleEffect(): boolean;
    /**
     * Specifies padding after chart title.
     *
     * This does not have an effect if title is hidden (empty FillStyle).
     *
     * ```typescript
     *  // Example 1, specify vertical margins
     *  ChartXY.setTitleMargin({ top: 0, bottom: 10 })
     *
     *  // Example 2, specify margins for all sides with same value for Title.
     *  ChartXY.setTitleMargin(40)
     * ```
     *
     * @param marginPixels - Gap after the chart title in pixels.
     * @returns Chart itself for fluent interface
     * @public
     */
    setTitleMargin(marginPixels: Partial<Margin> | pixel): this;
    /**
     * @returns Padding after Chart title
     * @public
     */
    getTitleMargin(): Partial<Margin>;
    /**
     * Set padding around Chart in pixels.
     *
     * ```typescript
     *  // Example 1, specify complete padding (four sides).
     *  ChartXY.setPadding({ left: 16, right: 16, top: 32, bottom: 8 })
     * ```
     *
     * ```typescript
     *  // Example 2, specify only single padding.
     *  ChartXY.setPadding({ right: 64 })
     * ```
     *
     * @param padding - Number with pixel margins for all sides or datastructure with individual pixel paddings
     *                      for each side. Any side can be omitted, only passed values will be overridden.
     * @returns Object itself
     * @public
     */
    setPadding(padding: Partial<Margin> | number): this;
    /**
     * Get padding around Chart in pixels.
     * @returns Padding datastructure
     * @public
     */
    getPadding(): Margin;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @returns Object itself for fluent interface
     * @public
     */
    dispose(): this;
    /**
     * Interface for attaching listeners to user interaction events (`click`, `pointerenter`, etc.) on chart title.
     *
     * ```ts
     *  // Example syntax
     *  chart.title.addEventListener('click', (event) => {
     *      console.log(event)
     *  })
     * ```
     *
     * For syntax examples, refer to {@link EventInterface}.
     * Available event keys are listed under {@link LCJSInteractionEventMap}
     * @public
     */
    readonly title: Eventer<LCJSInteractionEventMap, any>;
}
/**
 * Chart for visualizing data in a 3-dimensional scene, with camera and light source(s).
 *
 * Camera can be moved around with user interactions (mouse & touch). It is always oriented to face the center of the scene.
 *
 * Light source is always located at the location of the Camera, and directed towards the center of *Axes*.
 *
 * Data can be added to the *Chart* via various *Series* types, each with their own method of visualization:
 *
 * ```javascript
 *  const pointLineSeries3D = chart3D.addPointLineSeries()
 *      .add( [
 *          { x: 0, y: 0, z: 0 },
 *          { x: 1, y: 0, z: 0 },
 *          { x: 2, y: 1, z: 0 }
 *      ] )
 * ```
 * @public
 */
export declare class Chart3D<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithSeries<Series3D> implements ChartWithAxis<Axis3D>, ChartWithCursor<CursorResultTableBackgroundType, CursorPosition3D, Cursor3D<CursorResultTableBackgroundType>, SolveResult3D> {
    /**
     * Distance that static light source is behind camera always. In World Units.
     */
    private readonly _lightSourceDistanceFromCamera;
    /**
     * Is zoom animation enabled.
     *
     * Zoom animation is applied on mouse wheel and trackpad zooming interactions.
     */
    private _zoomAnimationEnabled;
    private _isMouseZoomingEnabled;
    /**
     * Flag for Rotating mouse-interaction enabled:
     * Rotating axes with mouse-drag.
     */
    private _isRotateEnabled;
    /**
     * Velocity counter for zoom animation.
     */
    private _zoomAnimationVelocity;
    /**
     * 3D Coordinate system selector to use with {@link translateCoordinate} function, which lets users translate coordinates between different 3D coordinate systems.
     * @public
     */
    readonly coordsAxis: CoordinateSystemDefinition3D;
    /**
     * 3D Coordinate system selector to use with {@link translateCoordinate} function, which lets users translate coordinates between different 3D coordinate systems.
     * @public
     */
    readonly coordsWorld: CoordinateSystemDefinition3D;
    /**
     * Restore previous zoom state of all Axes.
     *
     * `Chart3D` automatically follows the state of its axes. The previous state can be restored using this method.
     *
     * ```ts
     *  // Example usage
     *  chart.restorePreviousZoomState()
     * ```
     *
     * ```ts
     *  // Example, all properties
     *  chart.restorePreviousZoomState({
     *      animate: 1000, // 1000 ms animation
     *      stopAxisAfter: true
     *  })
     * ```
     *
     * @param   opts -  Optional extra control options.
     * @returns     Object itself.
     * @public
     * @beta    Introduced in v7.0.0. API may change according to user feedback.
     */
    restorePreviousZoomState(opts?: {
        whitelist: Axis3D[];
    } & AxisIntervalConfiguration): this;
    /**
     * Clear zoom state history which is used by {@link restorePreviousZoomState} as well as any built-in "restorePrevious" user interactions.
     *
     * ```ts
     *  // Example usage, set axis interval and ensure any previous zoom state history is deleted.
     *  chart.axisX.setInterval({ start: 0, end: 100 })
     *  chart.clearPreviousZoomStateHistory()
     * ```
     *
     * The order of above operations is important.
     *
     * @returns     Object itself.
     * @public
     * @beta    Introduced in v7.0.0. API may change according to user feedback.
     */
    clearPreviousZoomStateHistory(): this;
    /**
     * Configure user interactions from a set of preset options.
     *
     * Without any explicit configuration, the charts select the default user interaction scheme based on available information,
     * such as axis types, attached series and data supplied to series.
     *
     * The `setUserInteraction` methods allow explicitly configuring the used interaction scheme.
     *
     * This is not a definitive operation, but rather modifies the current state.
     * For example, modifying `pan` interaction does not affect the state of any other interactions.
     *
     * ```ts
     *  // Example, disable all user interactions
     *  chart.setUserInteractions(undefined)
     * ```
     *
     * ```ts
     *  // Example, enable camera zoom on mouse wheel
     *  chart.setUserInteractions({
     *      zoom: {
     *          wheel: {
     *              camera: true,
     *          },
     *      },
     *  })
     * ```
     *
     * ```ts
     *  // Example, restore default interactions
     *  chart.setUserInteractions({})
     * ```
     *
     * @param   config -    Option with any set of properties of {@link Chart3DUserInteractions} or `undefined` to disable all interactions.
     * @returns     Object itself.
     * @public
     * @beta    Introduced in v7.0.0. API may change according to user feedback.
     */
    setUserInteractions(config: Partial<Chart3DUserInteractions> | undefined): this;
    /**
     * Get currently active user interaction scheme.
     * This does NOT return the last value supplied to {@link setUserInteractions}.
     * Rather, it considers the current structure of the chart, all built-in defaults as well as overrides supplied by the user
     * and returns the currently used interaction scheme.
     *
     * @returns     Chart3DUserInteractions
     * @public
     * @beta    Introduced in v7.0.0. API may change according to user feedback.
     */
    getUserInteractions(): Chart3DUserInteractions;
    /**
     * Select 3D projection type.
     *
     * Defaults to `'perspective'`
     * @param   projection - Projection type.
     * @returns     Object itself.
     */
    setProjection(projection: 'perspective' | 'orthographic'): this;
    /**
     * Get 3D projection type.
     *
     * Defaults to `'perspective'`
     * @returns   Projection type.
     */
    getProjection(): 'perspective' | 'orthographic';
    setCursor(mutator: Mutator<Cursor3D<CursorResultTableBackgroundType>>): this;
    getCursor(): Cursor3D<CursorResultTableBackgroundType>;
    setCursorMode(mode: SolveNearestMode | undefined): this;
    getCursorMode(): SolveNearestMode | undefined;
    setCustomCursor(clbk: undefined | ((event: CursorTargetChangedEvent<SolveResult3D>) => unknown)): this;
    setCursorDynamicBehavior(value: CursorDynamicBehavior): this;
    /**
     * Set cursor formatting, controlling the text displayed in built-in cursor.
     *
     * ```ts
     *  chart.setCursorFormatting((_, hit, hits) => {
     *      return [
     *          ['Cursor pointing at'],
     *          [hit.series], // returning a series will display the series color and its name automatically.
     *          ['X', '', hit.axisX.formatValue(hit.x)], // utilizing axis formatValue is useful for considering active zoom level and type of axis
     *          ['Y', '', hit.y.toFixed(2)], // empty string '' results in gap between cells
     *          [{ text: 'Example', font: { weight: 'bold' }, fillStyle: fillRed }] // any cell can also be styled individually
     *      ]
     *  })
     * ```
     *
     * Before overriding default cursor formatting, it is recommended to check if using {@link GenericAxis.setUnits} or configuring Axis cursor formatting would be enough.
     *
     * In order to use series specific data properties (e.g. Heatmap sample "intensity"),
     * you should use type guards to assert the type of the `SolveResult`:
     *
     * ```ts
     *  // Example of using type guard in cursor formatter
     *  Chart.setCursorFormatting((chart, hit, hits) => {
     *      if (!isHitHeatmap(hit)) return undefined
     *      return [hit.intensity.toFixed(1)]
     *  })
     * ```
     *
     * More details in Developer documentation (Features \> Cursor).
     * @param   formatter -     Callback function for cursor formatting.
     * @returns     Object itself
     * @public
     */
    setCursorFormatting(formatter: CursorFormatterChart3D): this;
    /**
     * Get active cursor formatter.
     * @returns     Cursor formatter.
     * @public
     */
    getCursorFormatting(): CursorFormatterChart3D;
    /**
     * Add manually controlled Cursor object.
     * These have exactly same functions as built-in cursors but they can be freely controlled by application logic.
     *
     * ```ts
     *  const cursor = chart.addCursor()
     * ```
     *
     * Styling works same as built-in cursors (e.g. {@link setCursor}).
     *
     * Position is set using `setPosition` method and displayed content using `setResultTable(table => table.setContent(...))`
     * For more details, see Developer documentation \> Features \> Cursor \> Manual cursors
     *
     * @param   cursorBuilder -     Builder for cursor. Can be used to tweak a handful of properties which can't be changed during runtime.
     * @returns     Cursor object.
     * @public
     */
    addCursor<ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: CursorBuilder3D<ResultTableBackgroundType>): Cursor3D<ResultTableBackgroundType>;
    /**
     * Method for adding a new `PointSeries3D` to the chart.
     * This series type for visualizing a collection of `{ x, y, z }` coordinates by different markers.
     *
     * `PointSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to {@link PointSeries3D}.
     *
     * **Readonly configuration:**
     *
     * Some properties of `PointSeries3D` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const pointCloudSeries3D = Chart3D.addPointSeries({
     *      // Specify point series type as point cloud.
     *      type: PointSeriesTypes3D.Pixelated
     *  })
     * ```
     *
     * To learn about available properties, refer to {@link PointSeriesOptions3D}.
     *
     * @param options - Optional object with readonly configuration arguments for `PointSeries3D`.
     * @returns New series.
     * @public
     */
    addPointSeries<T extends PointSeriesTypes3D = typeof PointSeries3D>(options?: PointSeriesOptions3D<T>): InstanceType<T>;
    /**
     * Method for adding a new `LineSeries3D` to the chart.
     * This Series type for visualizing a collection of `{ x, y, z }` coordinates by a continuous line stroke.
     *
     * `LineSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to {@link LineSeries3D}.
     *
     * @returns New series.
     * @public
     */
    addLineSeries(options?: LineSeriesOptions3D): LineSeries3D;
    /**
     * Method for adding a new `PointLineSeries3D` to the chart.
     * This Series type for visualizing a collection of `{ x, y, z }` coordinates by a continuous line stroke and markers.
     *
     * `PointLineSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to {@link PointLineSeries3D}.
     *
     * @returns New series.
     * @public
     */
    addPointLineSeries(options?: LineSeriesOptions3D): PointLineSeries3D;
    /**
     * Add a Series for visualizing a *Surface Grid* with a static column and grid count. Has API for fast modification of cell Y and Intensity values.
     *
     * The grid is defined by imagining a plane along X and Z axis, split to \< COLUMNS \> (cells along X axis) and \< ROWS \> (cells along Z axis)
     *
     * The total amount of \< CELLS \> in a surface grid is calculated as `columns * rows`. Each \< CELL \> can be associated with DATA from an user data set.
     *
     * This series is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in tens of millions range is rendered in a matter of seconds.
     * - A data set in tens of millions range can be updated in less than a second.
     * - Maximum data set size is entirely limited by available memory (RAM).
     *   Even billion (1 000 000 000) data points have been visualized on a personal computer.
     *   Interacting with massive surface charts (more than tens of millions data points) requires a powerful GPU !
     *
     * To learn more about its features and usage, refer to {@link SurfaceGridSeries3D}.
     *
     *
     * **Readonly configuration:**
     *
     * Some properties of `SurfaceGridSeries3D` can only be configured when it is created. Some of these arguments are optional, while some are required.
     * They are all wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
     *      columns: 100,
     *      rows: 200,
     *  })
     * ```
     *
     * To learn about these properties, refer to {@link SurfaceGridSeries3DOptions}.
     *
     *
     * For *scrolling surface grid*, see {@link addSurfaceScrollingGridSeries}.
     *
     * @param options - Configuration parameters for Surface Grid Series.
     * @returns Surface Grid Series.
     * @public
     */
    addSurfaceGridSeries(options: SurfaceGridSeries3DOptions): SurfaceGridSeries3D;
    /**
     * Add a Series for visualizing a *Surface Grid* with API for pushing data in a scrolling manner (append new data on top of existing data).
     *
     * The grid is defined by imagining a plane along X and Z axis, split to \< COLUMNS \> (cells along X axis) and \< ROWS \> (cells along Z axis)
     *
     * The total amount of \< CELLS \> in a surface grid is calculated as `columns * rows`. Each \< CELL \> can be associated with DATA from an user data set.
     *
     * This series is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A data set of tens of millions data points is rendered in a matter of seconds.
     * - Maximum data set size is entirely limited by available memory (RAM).
     *   Even billion (1 000 000 000) data points have been visualized on a personal computer.
     *   Interacting with massive surface charts (more than tens of millions data points) requires a powerful GPU !
     * - Scrolling Surface Grid input stream rate is virtually unlimited - even 10 million incoming data points **per second** can easily be processed.
     *   Application limitations usually come from previously mentioned RAM and/or GPU bottlenecks.
     *
     * To learn more about its features and usage, refer to {@link SurfaceScrollingGridSeries3D}.
     *
     *
     * **Readonly configuration:**
     *
     * Some properties of `SurfaceScrollingGridSeries3D` can only be configured when it is created. Some of these arguments are optional, while some are required.
     * They are all wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const surfaceScrollingGridSeries = Chart3D.addSurfaceScrollingGridSeries({
     *      columns: 100,
     *      rows: 200,
     *  })
     * ```
     *
     * To learn about these properties, refer to {@link SurfaceScrollingGridSeries3DOptions}.
     *
     *
     * For *static surface grid*, see {@link addSurfaceGridSeries}.
     *
     * @param options - Configuration parameters for Surface Scrolling Grid Series.
     * @returns Surface Scrolling Grid Series.
     * @public
     */
    addSurfaceScrollingGridSeries(options: SurfaceScrollingGridSeries3DOptions): SurfaceScrollingGridSeries3D;
    /**
     * Create Series for visualization of large sets of individually configurable 3D *Boxes*.
     *
     * **Example usage:**
     *
     * ```ts
     *  // Construct a grid of vertical boxes.
     *  const data = [
     *      { x: 0, z: 0 },
     *      { x: 1, z: 0 },
     *      { x: 0, z: 1 },
     *      { x: 1, z: 1 }
     *  ]
     *      // Map coords into **BoxData**.
     *      .map( coords => {
     *      const height = Math.random() * 100
     *      return {
     *          xCenter: coords.x,
     *          yCenter: height / 2,
     *          zCenter: coords.z,
     *          xSize: 1,
     *          ySize: height,
     *          zSize: 1
     *      }
     *  })
     *  const chart = lightningChart().Chart3D()
     *  const boxSeries = chart.addBoxSeries()
     *      .invalidateData( data )
     * ```
     *
     * @returns BoxSeries3D.
     * @public
     */
    addBoxSeries(options?: SeriesOptions): BoxSeries3D;
    /**
     * Add a 3D Object Model to the chart.
     * See more details in {@link MeshModel3D}.
     *
     * @param   options     - Readonly options for the created series.
     * @returns MeshModel3D series.
     * @public
     */
    addMeshModel(options?: MeshModel3DOptions): MeshModel3D;
    /**
     * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
     *
     * ```ts
     *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
     *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
     *  // locationRelative is in pixels relative to bottom left corner of the chart
     * ```
     *
     * Relative coordinates can be used for positioning LightningChart JS UI components:
     *
     * ```ts
     *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
     *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
     *      .setOrigin(UIOrigins.LeftBottom)
     *      .setPosition({ x: 20, y: 20 })
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     * @privateRemarks  This definition of the method originates from the super class.
     */
    translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
    /**
     * Translate a coordinate from relative control coordinates to HTML client coordinate system.
     *
     * ```ts
     *  // 10 pixels left and 20 pixels up from controls bottom left corner
     *  const locationRelative = { x: 10, y: 20 }
     *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
     * ```
     *
     * Client coordinates can be used to absolute position HTML elements using CSS, for example.
     *
     * ```ts
     *  myHTMLElement.style.position = 'absolute'
     *  myHTMLElement.style.left = locationClient.clientX
     *  myHTMLElement.style.top = locationClient.clientY
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     * @privateRemarks  This definition of the method originates from the super class.
     */
    translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
    /**
     * Translate `x, y, z` coordinates between different 3D coordinate systems and HTML client coordinate system.
     *
     * ```ts
     *  // Example, translate coordinate from Chart3D Axes to World Space.
     *  const coordWorld = Chart3D.translateCoordinate(
     *      // Coordinate on Axes.
     *      { x: 10, y: 5, z: 25 },
     *      // Source coordinate system.
     *      chart3D.coordsAxis,
     *      // Target coordinate system.
     *      chart3D.coordsWorld
     *  )
     * ```
     *
     * ```ts
     *  // Example, translate coordinate from Chart3D Axes to HTML client coordinate system.
     *  const locClient = Chart3D.translateCoordinate(
     *      // Coordinate on Axes.
     *      { x: 10, y: 5, z: 25 },
     *      // Source coordinate system.
     *      chart3D.coordsAxis,
     *      // Target coordinate system.
     *      chart3D.coordClient
     *  )
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     */
    translateCoordinate<T extends CoordinateSystemDefinition3D | CoordinateSystemClient | CoordinateSystemRelative>(coordinate: Coordinate3D, srcCoordinateSystem: CoordinateSystemDefinition3D, targetCoordinateSystem: T): T extends CoordinateSystemDefinition3D ? Coordinate3D : T extends CoordinateSystemClient ? CoordinateClient : T extends CoordinateSystemRelative ? CoordinateXY : never;
    /**
     * Get Axis X.
     * @returns Axis3D object.
     * @public
     */
    getDefaultAxisX(): Axis3D;
    /**
     * Get Axis Y.
     * @returns Axis3D object.
     * @public
     */
    getDefaultAxisY(): Axis3D;
    /**
     * Get Axis Z.
     * @returns Axis3D object.
     * @public
     */
    getDefaultAxisZ(): Axis3D;
    /**
     * Convenience getter property that does the same as {@link getDefaultAxisX}.
     * @public
     */
    get axisX(): Axis3D;
    /**
     * Convenience getter property that does the same as {@link getDefaultAxisX}.
     * @public
     */
    get xAxis(): Axis3D;
    /**
     * Convenience getter property that does the same as {@link getDefaultAxisX}.
     * @public
     */
    get axisY(): Axis3D;
    /**
     * Convenience getter property that does the same as {@link getDefaultAxisX}.
     * @public
     */
    get yAxis(): Axis3D;
    /**
     * Convenience getter property that does the same as {@link getDefaultAxisX}.
     * @public
     */
    get axisZ(): Axis3D;
    /**
     * Convenience getter property that does the same as {@link getDefaultAxisX}.
     * @public
     */
    get zAxis(): Axis3D;
    /**
     * Convenience method to get a tuple of the Charts X, Y and Z axes.
     *
     * Equal to `[Chart3D.getDefaultAxisX(), Chart3D.getDefaultAxisY(), Chart3D.getDefaultAxisZ()]`
     *
     * Intended for conveniently applying same modifications to all axes.
     *
     * @returns [Chart3D.getDefaultAxisX(), Chart3D.getDefaultAxisY(), Chart3D.getDefaultAxisZ()]
     * @public
     */
    getDefaultAxes(): [Axis3D, Axis3D, Axis3D];
    /**
     * Set the location of camera in _World Space_, a coordinate system that is not tied to 3D Axes.
     *
     * The camera always faces (0, 0, 0) coordinate.
     *
     * The light source is always a set distance behind the camera.
     * @param cameraLocation - Camera location in 3D space. Valid values are in the range **[1, 5]**.
     *                          Note, that placing the camera too close to the bounding box is restricted.
     * @public
     */
    setCameraLocation(cameraLocation: Point3D): this;
    /**
     * Get the location of camera in _World Space_, a coordinate system that is not tied to 3D Axes.
     * @returns Camera location in 3D space.
     * @public
     */
    getCameraLocation(): Point3D;
    /**
     * Get the direction of camera in _World Space_, a coordinate system that is not tied to 3D Axes.
     *
     * The direction is set according to the location of the camera, so that it is facing (0, 0, 0).
     * @returns Camera direction in 3D space. Always an unit vector.
     * @public
     */
    getCameraDirection(): Point3D;
    /**
     * Set automatic camera fitting enabled. This is enabled as the default configuration.
     * Note that zooming in or out disables it automatically.
     * @param enabled - Boolean.
     * @returns Object itself for fluent interface.
     * @public
     */
    setCameraAutomaticFittingEnabled(enabled: boolean): Chart3D;
    /**
     * Get automatic camera fitting enabled. This is enabled as the default configuration.
     * Note that zooming in or out disables it automatically.
     * @returns Boolean.
     * @public
     */
    getCameraAutomaticFittingEnabled(): boolean;
    /**
     * Set style of 3D bounding box.
     *
     * The bounding box is a visual reference that all the data of the Chart is depicted inside of. The Axes of the
     * 3D chart are always positioned along the sides of the bounding box.
     *
     * Example usage:
     *
     * - **Specify explicit LineStyle object**
     * ```typescript
     *  Chart3D.setBoundingBoxStrokeStyle(new SolidLine({
     *      fillStyle: new SolidFill({ color: ColorHEX('#61ff61') }),
     *      thickness: 5
     *  }))
     * ```
     *
     * - **Modify default style**
     * ```typescript
     *  // Default value is SolidLine (note that a soft type cast is required for *TypeScript*).
     *  Chart3D.setBoundingBoxStrokeStyle(( line: SolidLine ) => line
     *      .setThickness( 10 )
     *  )
     * ```
     * @param value - {@link LineStyle} object or function that modifies previous value.
     *                  Value defaults to {@link SolidLine}.
     * @returns Object itself for fluent interface.
     * @public
     */
    setBoundingBoxStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of 3D bounding box.
     *
     * The bounding box is a visual reference that all the data of the Chart is depicted inside of. The Axes of the
     * 3D chart are always positioned along the sides of the bounding box.
     *
     * @returns {@link LineStyle} object.
         * @public
         */
     getBoundingBoxStrokeStyle(): LineStyle;
     /**
      * Set the dimensions of the Scenes bounding box.
      *
      * The bounding box is a visual reference that all the data of the Chart is depicted inside of. The Axes of the
      * 3D chart are always positioned along the sides of the bounding box.
      *
      * Example usage:
      * - **Symmetric bounding box**
      * ```javascript
      *  setBoundingBox( { x: 1.0, y: 1.0, z: 1.0 } )
      * ```
      * - **Bounding box whose Y dimension is 4 times that of the others**
      * ```javascript
      *  setBoundingBox( { x: 1.0, y: 4.0, z: 1.0 } )
      * ```
      *
      * @param dimensions - Dimensions of bounding box. These values do not represent any "unit", only their relative
      *                          ratios are considered.
      * @returns Object itself for fluent interface
      * @public
      */
     setBoundingBox(dimensions: Point3D): this;
     /**
      * Get dimensions of Scenes "bounding box".
      * Bounding box defines the space allocated for the Charts 3D Axes.
      *
      * It is visualized with a wireframe, as well as 3D Axes on its sides.
      * @returns Dimensions of bounding box as World Units.
      * @public
      */
     getBoundingBox(): Point3D;
     /**
      * **Permanently** destroy the component.
      *
      * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
      * **to the component and its children** in application code.
      * ```javascript
      * let chart = ...ChartXY()
      * let axisX = chart.getDefaultAxisX()
      * // Dispose Chart, and remove all references so that they can be garbage-collected.
      * chart.dispose()
      * chart = undefined
      * axisX = undefined
      * ```
      * @returns Object itself for fluent interface
      * @public
      */
     dispose(): this;
     /**
      * NOTE: Not just Chart3D, but also 2D !! _updateScale must be called, when padding/margin/title, etc are changed !!!
      * Event handler to update 3D viewport when Chart is resized.
      */
     private _handleResize;
     /**
      * Operate on each axis of chart, x and y
      * @param clbk - Callback function for axis
      * @public
      */
     forEachAxis(clbk: (axis: Axis3D) => void): this;
     /**
      * Get series of a chart
      * @returns Array of series
      * @public
      */
     getSeries(): Series3D[];
     /**
      * Get minimum size of Chart.
      * Depending on the type of class this value might be automatically computed to fit different elements.
      * @returns Vec2 minimum size or undefined if unimplemented
      * @public
      */
     getMinimumSize(): Point | undefined;
     /**
      * Disable/Enable all animations for the chart.
      *
      * Affects:
      * - Axis animations.
      * - Zoom animation.
      * - Series highlight animations.
      *
      * @param animationsEnabled - Boolean value to enable/disable all animations
      * @returns Chart itself for fluent interface.
      * @public
      * @privateRemarks  Override to also apply to axes and zoom.
      */
     setAnimationsEnabled(animationsEnabled: boolean): this;
     /**
      * Set Chart3D zoom animation enabled.
      *
      * When enabled, zooming with mouse wheel or trackpad will include a short animation.
      *
      * This is enabled by default.
      *
      * ```typescript
      *  // Example syntax, disable zoom animation.
      *  chart3D.setAnimationZoom(false)
      * ```
      * @param animationsEnabled - Boolean.
      * @returns Chart itself for fluent interface.
      * @public
      */
     setAnimationZoom(animationsEnabled: boolean | undefined): this;
     /**
      * Get Chart3D zoom animation enabled.
      *
      * When enabled, zooming with mouse wheel or trackpad will include a short animation.
      *
      * This is enabled by default.
      *
      * ```typescript
      *  // Example syntax, disable zoom animation.
      *  chart3D.setAnimationZoom(false)
      * ```
      * @returns Boolean.
      * @public
      */
     getAnimationZoom(): boolean;
     addEventListener<K extends keyof Chart3DEventMap>(type: K, listener: (event: Chart3DEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
     removeEventListener<K extends keyof Chart3DEventMap>(type: K, listener: (event: Chart3DEventMap[K], info: unknown) => unknown): void;
    }
    /**
     * Interface that can be used to define {@link ChartOptions3D} configurations, when inside a {@link Dashboard},
     * that can't be changed after creation.
     * @public
     */
    export declare interface Chart3DDashboardOptions extends DashboardCellOptions, ChartOptions3D {
    }
    /**
     * Interface of events trackable by {@link Chart3D.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface Chart3DEventMap extends ChartWithSeriesEventMap<Series3D>, ChartWithCursorEventMap<SolveResult3D> {
        /**
         * Event fired when the Chart3D camera location changes
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('camerachange', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        camerachange: CameraChangeEvent;
    }
    /**
     * @public
     * @beta    Introduced in v7.0.0. API may change according to user feedback.
     */
    export declare interface Chart3DUserInteractions {
        rotate?: false | InteractionConfigWithOverrides<{
            sensitivity?: number;
        }, 'drag' | 'pinch'>;
        pan?: false | InteractionConfigWithOverrides<{
            sensitivity?: number;
            stopScroll?: boolean;
            x?: boolean;
            y?: boolean;
            z?: boolean;
        }, 'drag' | 'wheel' | 'pinch'>;
        zoom?: false | InteractionConfigWithOverrides<{
            sensitivity?: number;
            stopScroll?: boolean;
            mode?: 'centered' | 'keep-start' | 'keep-end';
            x?: boolean;
            y?: boolean;
            z?: boolean;
            camera?: boolean;
        }, 'drag' | 'wheel' | 'pinch'>;
        restoreDefault?: false | InteractionConfigWithOverrides<{
            singleClick?: boolean;
            doubleClick?: boolean;
            animationsEnabled?: boolean;
            stopScroll?: boolean;
            x?: boolean;
            y?: boolean;
            z?: boolean;
            camera?: boolean;
            /**
             * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
             */
            code?: string;
            cursor?: CSSStyleDeclaration['cursor'] | null;
        }, never>;
        restorePrevious?: false | InteractionConfigWithOverrides<{
            singleClick?: boolean;
            doubleClick?: boolean;
            animationsEnabled?: boolean;
            stopScroll?: boolean;
            /**
             * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
             */
            code?: string;
        }, never>;
    }
    /**
     * Interface that defines end user API for a 'Chart'.
     * @public
     */
    export declare interface ChartAPI {
        /**
         * Set text displayed by charts built-in title component.
         *
         * ```typescript
         *  // Example, set title.
         *  ChartXY.setTitle('Realtime traffic visualization')
         * ```
         *
         * **NOTE: To hide title, AND remove padding around it, ** use `setTitleFillStyle(emptyFill)`
         *
         * @param title - Chart title as a string.
         * @returns Object itself for fluent interface.
         * @public
         */
        setTitle(title: string): this;
        /**
         * Get text of Chart title.
         * @returns Chart title as a string.
         * @public
         */
        getTitle(): string;
        /**
         * Set fill style of Chart Title.
         *
         * Example usage:
         *```javascript
         * // Create a new style
         * setTitleFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
         * // Change transparency
         * setTitleFillStyle((solidFill) => solidFill.setA(80))
         * // Set hidden
         * setTitleFillStyle(emptyFill)
         * ```
         * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
         * @returns Chart itself
         * @public
         */
        setTitleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of Chart Title.
         * @returns FillStyle object
         * @public
         */
        getTitleFillStyle(): FillStyle;
        /**
         * Set font of Chart Title.
         *
         * Example usage:
         *```javascript
         * // Create a new FontSettings
         * setTitleFont(new FontSettings({ size: 24, style: 'italic' }))
         * // Change existing settings
         * setTitleFont((fontSettings) => fontSettings.setWeight('bold'))
         * ```
         *
         * @param value - Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
         * @returns Chart itself
         * @public
         */
        setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Get font of Chart title.
         * @returns FontSettings object
         * @public
         */
        getTitleFont(): FontSettings;
        /**
         * Specifies Margins after chart title. This can be used to account for extra space around the title as well as tweak its position.
         *
         * This does not have an effect if title is hidden (empty FillStyle or text content `''`).
         *
         * ```typescript
         *  // Example 1, specify complete margin for Title (four sides).
         *  ChartXY.setTitleMargin({ left: 16, right: 16, top: 32, bottom: 8 })
         * ```
         *
         * ```typescript
         *  // Example 2, specify only single margin for Title.
         *  ChartXY.setTitleMargin({ right: 64 })
         * ```
         * ```typescript
         *  // Example 3, specify margins for all sides with same value for Title.
         *  ChartXY.setTitleMargin(40)
         * ```
         *
         * ```typescript
         *  // Example 4, reset to default margins.
         *  ChartXY.setTitleMargin({})
         * ```
         *
         * @param marginPixels - Gap after the chart title in pixels.
         * @returns Chart itself for fluent interface
         * @public
         */
        setTitleMargin(marginPixels: Partial<Margin> | pixel): this;
        /**
         * Get title margins.
         *
         * `undefined` values refer to default title margins.
         * @returns Margin after Chart title
         * @public
         */
        getTitleMargin(): Partial<Margin>;
        /**
         * Set padding around Chart in pixels.
         *
         * ```typescript
         *  // Example 1, specify complete padding (four sides).
         *  ChartXY.setPadding({ left: 16, right: 16, top: 32, bottom: 8 })
         * ```
         *
         * ```typescript
         *  // Example 2, specify only single padding.
         *  ChartXY.setPadding({ right: 64 })
         * ```
         * @param padding - Number with pixel margins for all sides or datastructure with individual pixel paddings
         *                      for each side. Any side can be omitted, only passed values will be overridden.
         * @returns Object itself for fluent interface
         * @public
         */
        setPadding(padding: Partial<Margin> | number): this;
        /**
         * Get padding around Chart in pixels.
         * @returns Padding datastructure
         * @public
         */
        getPadding(): Margin;
        /**
         * Set {@link FillStyle} of chart background.
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 80, 0, 0 ) }))
         * ```
         *
         * **Related API:**
         * - Use {@link SolidFill} to describe a solid fill color.
         * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
         *
         * @param value - `FillStyle` or function which mutates the active `FillStyle`.
         * @returns Object itself
         * @public
         */
        setBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fillstyle of chart background.
         * @returns FillStyle
         * @public
         */
        getBackgroundFillStyle(): FillStyle;
        /**
         * Set {@link LineStyle} of chart background border stroke.
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.setBackgroundStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
         *  }))
         * ```
         *
         * **Related API:**
         * - Use {@link SolidLine} to describe a solid line style.
         * - Use {@link SolidFill} to describe a solid fill color.
         * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
         *
         * @param value - `LineStyle` or function which mutates the active `LineStyle`.
         * @returns Object itself
         * @public
         */
        setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style of chart background.
         * @returns LineStyle
         * @public
         */
        getBackgroundStrokeStyle(): LineStyle;
    }
    /**
     * Abstract base class for "Chart components".
     * Chart component is defined as a mouse-interactable component of a Chart.
     * ChartComponent is a public class, so users can have access to it.
     * @public
     */
    export declare abstract class ChartComponent<SolveResultType extends SolveResult = SolveResult> implements Interactable, Attachable, Highlightable, Hideable, HideableEvents, Disposable, DisposableEvents, ComponentWithEffects {
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getEffect(): boolean;
        /**
         * Set icon of the chart component. This is displayed in legends and by default cursor formatters.
         *
         * ```ts
         *  const image = new Image()
         *  image.src = 'image.png'
         *  const icon = chart.engine.addCustomIcon(image)
         *  ChartComponent.setIcon(icon)
         * ```
         * @param icon - Icon
         * @returns     Object itself.
         * @public
         */
        setIcon(icon: Icon | undefined): this;
        /**
         * Set icon of the chart component. This is displayed in legends and by default cursor formatters.
         * @returns     Icon object or undefined.
         */
        getIcon(): Icon | undefined;
        /**
         * Sets the name of the Component
         * @param name - Name of the Component
         * @returns Object itself
         * @public
         */
        setName(name: string): this;
        /**
         * Get the name of the Component.
         * @returns The name of the Component.
         * @public
         */
        getName(): string;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @returns Object itself.
         * @public
         */
        setVisible(state: boolean): this;
        /**
         * Get element visibility.
         *
         * @returns `true` when element is set to be visible and `false` otherwise.
         * @public
         */
        getVisible(): boolean;
        /**
         * Set state of component highlighting.
         *
         * ```ts
         *  // Example usage
         *
         *  component.setHighlight(true)
         *
         *  component.setHighlight(0.5)
         * ```
         *
         * If highlight animations are enabled (which is true by default), the transition will be animated.
         * As long as the component is highlighted, the active highlight intensity will be animated continuously between 0 and the configured value.
         * Highlight animations can be disabled with {@link setAnimationHighlight}
         *
         * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
         * @returns Object itself
         * @public
         */
        setHighlight(highlight: boolean | number): this;
        /**
         * Get state of component highlighting.
         *
         * In case highlight animations are enabled, this method returns the **unanimated highlight value**.
         *
         * @returns Number between 0 and 1, where 1 is fully highlighted.
         * @public
         */
        getHighlight(): number;
        /**
         * Set component highlight animations enabled or not.
         * For most components this is enabled by default.
         *
         * ```ts
         *  // Example usage, disable highlight animations.
         *  component.setAnimationHighlight(false)
         * ```
         *
         * @param   enabled    - Animation enabled?
         * @returns            Object itself
         */
        setAnimationHighlight(enabled: boolean): this;
        /**
         * Get component highlight animations enabled or not.
         *
         * @returns      Animation enabled?
         */
        getAnimationHighlight(): boolean;
        /**
         * Set whether element can be target of pointer events or not.
         *
         * Disabling pointer events means that the objects below this component can be interacted _through_ it.
         *
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setPointerEvents(state: boolean): this;
        /**
         * Get whether element can be target of pointer events or not.
         * @returns Pointer events state
         * @public
         */
        getPointerEvents(): boolean;
        /**
         * Get boolean flag that is `true` when a Pointer device is over the chart component.
         * In order for this method to work, the components pointer event tracking must be enabled ({@link getPointerEvents})
         * @returns     Boolean
         * @public
         */
        getPointed(): boolean;
        /**
         * Set highlight on mouse hover enabled or disabled.
         *
         * Mouse interactions have to be enabled on the component for this to function as expected.
         * See {@link setPointerEvents} for more information.
         *
         * @param state - True if highlighting on mouse hover, false if no highlight on mouse hover
         * @returns Object itself for fluent interface.
         * @public
         */
        setHighlightOnHover(state: boolean | HighlightModes): this;
        /**
         * Get boolean flag for whether object should highlight on mouse hover
         * @returns Boolean for if object should highlight on mouse hover or not.
         * @public
         */
        getHighlightOnHover(): boolean;
        /**
         * Check whether the object is disposed.
         * Disposed objects should not be used!
         *
         * @returns     `true` if object is disposed.
         * @public
         */
        isDisposed(): boolean;
        abstract addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        abstract removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: unknown) => unknown): void;
        set draggable(state: boolean);
        get draggable(): boolean;
    }
    /**
     * Interface of events trackable by {@link ChartComponent.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface ChartComponentEventMap extends LCJSInteractionEventMap, HideableEventMap, DisposableEventMap, HighlightableEventMap {
    }
    /**
     * Interface that can be used to define {@link ChartXY} configurations, when inside a {@link Dashboard},
     * that can't be changed after creation. For example:
     *
     * - Specifying TickStrategies for default X or Y Axes'. This is mostly used for creating DateTime Axes.
     *
     * - Supplying a custom Builder for the Cursor of Chart. This can be used to modify the Cursor on a level,
     * which can't be done during runtime. For example, changing the shape of ResultTable Background, Etc.
     *
     *
     *  Example usage:
     *```javascript
     * // Default
     * undefined
     * // Specified Cursor ResultTable Background
     * { chartXYOptions: { cursorBuilder: CursorBuilders.XY.setResultTableBackground(UIBackgrounds.Circle) } }
     * ```
     * @public
     */
    export declare interface ChartOptions<CursorResultTableBackgroundType extends UIBackground> extends DashboardCellOptions, ChartXYOptions<CursorResultTableBackgroundType> {
    }
    /**
     * Interface for readonly configuration of {@link Chart3D}.
     *
     * Some properties of `Chart3D` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, specify chart color theme.
     *  const chart = LightningChart.Chart3D({
     *      theme: Themes.light
     *  })
     * ```
     *
     * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
     *
     * For *standalone* `Chart3D`, more parameters are documented in {@link LightningChart.Chart3D}.
     *
     * For *dashboard* `Chart3D`, more parameters are documented in {@link Dashboard.createChart3D}.
     *
     *
     * **Commonly used properties:**
     *
     * - [theme]({@link ChartOptions3D.theme}): Specify chart color *theme*.
     * - [animationsEnabled]({@link ChartOptions3D.animationsEnabled}): Convenience flag to disable all animations from chart.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, create chart with default configuration.
     *  const chart = LightningChart.Chart3D({})
     * ```
     *
     * ```typescript
     *  // Example 2, create chart with specified color theme.
     *  const chart = LightningChart.Chart3D({
     *      theme: Themes.light,
     *  })
     * ```
     * @public
     */
    export declare interface ChartOptions3D<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
        /**
         * Builder for the charts' *auto cursor*. Use {@link CursorBuilders | CursorBuilders.D3} to modify the default builder, using methods of {@link CursorBuilder3D}.
         *
         * ```typescript
         *  // Example, change cursor ResultTable background shape.
         *  const chart = LightningChart.Chart3D({
         *      cursorBuilder: CursorBuilders.D3
         *          .setResultTableBackground(UIBackgrounds.Circle)
         *  })
         * ```
         */
        cursorBuilder?: CursorBuilder3D<CursorResultTableBackgroundType>;
    }
    /**
     * Type requirement for Charts that own Axes.
     * @public
     */
    export declare interface ChartWithAxis<AxisType extends GenericAxis = GenericAxis> extends ChartWithSeries {
        /**
         * Iterate over each Axis of Chart.
         * @param clbk - Callback function for each Axis.
         * @returns Object itself.
         * @public
         */
        forEachAxis(clbk: (axis: AxisType) => void): this;
    }
    /**
     * Interface for a chart that has built-in cursor.
     * @public
     */
    export declare interface ChartWithCursor<CursorResultTableBackgroundType extends UIBackground = UIBackground, CursorPositionType extends AbstractCursorPosition = AbstractCursorPosition, CursorType extends AbstractCursor<CursorPositionType, CursorResultTableBackgroundType> = AbstractCursor<CursorPositionType, CursorResultTableBackgroundType>, SolveResultType extends SolveResult = SolveResult> extends Chart, EventInterface<ChartWithCursorEventMap<SolveResultType>> {
        /**
         * Style chart cursor using a callback function.
         * Available style APIs can depend on the type of chart.
         *
         * ```typescript
         *  // Example syntax
         *  chart.setCursor((cursor) => cursor
         *      .setGridStrokeXStyle(new SolidLine({
         *          thickness: 1,
         *          fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
         *      }))
         *  )
         * ```
         *
         * See {@link Cursor2D}, {@link CursorXY} or {@link Cursor3D} for all available methods for configuring the cursor.
         *
         * **Example usage:**
         *
         * ```typescript
         *  // Example 1, disable Y Axis tick marker & grid line.
         *  chart.setCursor((cursor) => cursor
         *      .setTickMarkerYVisible(false)
         *      .setGridStrokeYStyle(emptyLine)
         *  )
         * ```
         *
         * ```typescript
         *  // Example 2, style cursor ResultTable.
         *  chart.setCursor((cursor) => cursor
         *      .setResultTable((resultTable) => resultTable
         *          .setOrigin(UIOrigins.LeftTop)
         *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         *          .setTextFont((font) => font
         *              .setSize(12)
         *              .setFamily('sans-serif')
         *          )
         *          .setBackground((background) => background
         *              .setFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 0) }))
         *          )
         *      )
         *  )
         * ```
         *
         * ```typescript
         *  // Example 3, style cursor TickMarker X.
         *  chart.setCursor((cursor) => cursor
         *      .setTickMarkerX((tickMarker: UIPointableTextBox) => tickMarker
         *          .setTextFont((font) => font.setWeight('bold'))
         *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(0, 255, 0) }))
         *          .setBackground((background) => background.setFillStyle(emptyFill).setStrokeStyle(emptyLine)),
         *      )
         *  )
         * ```
         *
         * @param mutator - Callback function that receives reference to the charts `cursor`.
         * @returns Object itself for fluent interface.
         * @public
         */
        setCursor(mutator: Mutator<CursorType>): this;
        /**
         * Get reference to the built-in cursor object of the chart.
         * @returns     Generic cursor object.
         * @public
         */
        getCursor(): CursorType;
        /**
         * Set cursor behavior. This affects both built-in cursor as well as any custom cursor connected using {@link setCustomCursor}.
         *
         * For possible values see {@link SolveNearestMode}.
         * Additionally, you can supply `undefined` value to disable cursor completely.
         *
         * ```ts
         *  // Example, show 1 nearest solve result only
         *  chart.setCursorMode('show-nearest')
         * ```
         *
         * ```ts
         *  // Example, disable cursor
         *  chart.setCursorMode(undefined)
         * ```
         *
         * ```ts
         *  // Example, enable interpolation
         *  chart.setCursorMode('show-all-interpolated')
         * ```
         *
         * @param mode - SolveNearestMode or undefined
         * @returns     Object itself
         * @public
         */
        setCursorMode(mode: SolveNearestMode | undefined): this;
        /**
         * Get current cursor behavior.
         * @returns     SolveNearestMode or undefined
         * @public
         */
        getCursorMode(): SolveNearestMode | undefined;
        /**
         * Connect a custom cursor to the chart. This has 2 effects:
         *
         * 1. The built-in cursor is disabled.
         * 2. The provided callback function is called whenever the custom cursor should be updated, along with the data that the cursor should be pointing at.
         *
         * Custom cursors are still affected by other cursor behavior controls such as:
         * - {@link setCursorMode}
         * - Series `setCursorEnabled`
         *
         * The custom cursor can be anything defined by the user, such as:
         * - Using other LCJS means of displaying the cursor, like custom ticks, constant lines, text boxes, etc.
         * - Displaying a cursor using HTML/JS/CSS
         * - Displaying a cursor using UI framework, like Angular, React, Vue, Next, ...
         *
         * ```ts
         *  // Example of plugging in a custom cursor
         *  chart.setCustomCursor((event) => {
         *      if (event) {
         *          // Display custom cursor
         *      } else {
         *          // Hide custom cursor
         *      }
         *  })
         * ```
         *
         * @param   clbk   - `undefined` to restore built-in cursor or callback function that should be triggered to display custom cursor.
         * @returns     Object itself
         * @public
         */
        setCustomCursor(clbk: undefined | ((event: CursorTargetChangedEvent<SolveResultType>) => unknown)): this;
        /**
         * Set dynamic cursor behavior (i.e. automatically displaying different colored content based on pointed data)
         *
         * ```ts
         *  // Example syntax
         *  chart.setCursorDynamicBehavior({
         *            pointMarkerFill: (dataColor) =>
         *                new SolidFill({ color: interpolateColor(dataColor, colorBlack, 0.2, 230) }),
         *            pointMarkerStroke: (dataColor) =>
         *                new SolidLine({
         *                    thickness: 2,
         *                    fillStyle: new SolidFill({
         *                        color: interpolateColor(dataColor, colorWhite, 0.8, 204),
         *                    }),
         *                }),
         *        })
         * ```
         *
         * ```ts
         *  // Disable dynamic behavior
         *  chart.setCursorDynamicBehavior(undefined)
         * ```
         *
         * @param   value - dynamic behavior configuration
         * @returns     Object itself
         * @public
         */
        setCursorDynamicBehavior(value: CursorDynamicBehavior): this;
        addEventListener<K extends keyof PanelEventMap>(type: K, listener: (event: PanelEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        addEventListener<K extends keyof ChartWithCursorEventMap<SolveResultType>>(type: K, listener: (event: ChartWithCursorEventMap<SolveResultType>[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof PanelEventMap>(type: K, listener: (event: PanelEventMap[K], info: unknown) => unknown): void;
        removeEventListener<K extends keyof ChartWithCursorEventMap<SolveResultType>>(type: K, listener: (event: ChartWithCursorEventMap<SolveResultType>[K], info: unknown) => unknown): void;
    }
    /**
     * Interface of events trackable by {@link ChartWithCursor.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface ChartWithCursorEventMap<T extends SolveResult> {
        /**
         * Event fired when information displayed by cursor is changed.
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('cursortargetchange', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        cursortargetchange: CursorTargetChangedEvent<T>;
    }
    /**
     * Class abstraction layer for Charts that have Series.
     *
     * NOTE: Sub classes are responsible for calling series_.beforePlot and series._afterPlot !!
     * @public
     * @privateRemarks  Adds shared functionalities for: Series Background, attaches Series to Legends
     */
    export declare abstract class ChartWithSeries<_SeriesType extends _InternalSeries = _InternalSeries> extends Chart implements ChartWithStylableSeriesBackground {
        /**
         * Get series of a chart
         * @returns Array of series
         * @public
         */
        abstract getSeries(): _SeriesType[];
        /**
         * Disable/Enable all animations of the Chart.
         * @param animationsEnabled - Boolean value to enable or disable animations.
         * @returns Chart itself for fluent interface.
         * @public
         * @privateRemarks  Override to also apply state to series.
         */
        setAnimationsEnabled(animationsEnabled: boolean): this;
        /**
         * Set {@link FillStyle} of *series background* (area behind *series*).
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 60, 0, 0 ) }))
         * ```
         *
         * **Related API:**
         * - Use {@link SolidFill} to describe a solid fill color.
         * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
         *
         * **Transparent chart backgrounds:**
         *
         * LightningChart JS charts can be configured to be fully or partially transparent.
         *
         * ```ts
         *  // Example, partially transparent chart
         *
         *  // Engine background exists under all LCJS components. In case of Dashboard, there is only 1 shared engine background.
         *  chart.engine.setBackgroundFillStyle(emptyFill)
         *  // Chart background covers every 1 chart. In case of Dashboard, every chart has its own chart background.
         *  chart.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
         *  // Some charts also have a separate series background.
         *  chart.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
         * ```
         *
         * @param value - `FillStyle` or function which mutates the active `FillStyle`.
         * @returns Object itself
         * @public
         */
        setSeriesBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get FillStyle of Series background area (area behind series).
         * @returns FillStyle
         * @public
         */
        getSeriesBackgroundFillStyle(): FillStyle;
        /**
         * Set {@link LineStyle} of series background border stroke.
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.setSeriesBackgroundStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
         *  }))
         * ```
         *
         * **Related API:**
         * - Use {@link SolidLine} to describe a solid line style.
         * - Use {@link SolidFill} to describe a solid fill color.
         * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
         *
         * @param value - `LineStyle` or function which mutates the active `LineStyle`.
         * @returns Object itself
         * @public
         */
        setSeriesBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get Stroke style of Series background area (area behind series).
         * @returns LineStyle
         * @public
         */
        getSeriesBackgroundStrokeStyle(): LineStyle;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setSeriesBackgroundEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getSeriesBackgroundEffect(): boolean;
        /**
         * Set the state for all Series in the Chart to highlight on mouse hover.
         * @param state - True if all Series should be highlighted on mouse hover, false if not.
         * @returns Object itself for fluent interface.
         * @public
         */
        setSeriesHighlightOnHover(state: boolean): this;
        /**
         * **Permanently** dispose the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Interface for attaching listeners to user interaction events (`click`, `pointerenter`, etc.) on chart series background (area enclosed by axes).
         *
         * ```ts
         *  // Example syntax
         *  chart.seriesBackground.addEventListener('click', (event) => {
         *      console.log(event)
         *  })
         * ```
         *
         * For more syntax examples, refer to {@link EventInterface}.
         * Available event keys are listed under {@link LCJSInteractionEventMap}
         * @public
         */
        readonly seriesBackground: Eventer<LCJSInteractionEventMap, any>;
        abstract addEventListener<K extends keyof ChartWithSeriesEventMap<_SeriesType>>(type: K, listener: (event: ChartWithSeriesEventMap<_SeriesType>[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        abstract removeEventListener<K extends keyof ChartWithSeriesEventMap<_SeriesType>>(type: K, listener: (event: ChartWithSeriesEventMap<_SeriesType>[K], info: unknown) => unknown): void;
    }
    /**
     * Interface of events trackable by {@link ChartWithSeries.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface ChartWithSeriesEventMap<SeriesType> extends PanelEventMap {
        /**
         * Event fired when a new series is added
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('seriesadd', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        seriesadd: SeriesAddedEvent<SeriesType>;
        /**
         * Event fired when a series is disposed
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('seriesdispose', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        seriesdispose: SeriesDisposedEvent<SeriesType>;
    }
    /**
     * Interface for Chart with stylable series background (area behind series).
     * @public
     */
    export declare interface ChartWithStylableSeriesBackground {
        /**
         * Set {@link FillStyle} of *series background* (area behind *series*).
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 60, 0, 0 ) }))
         * ```
         *
         * **Related API:**
         * - Use {@link SolidFill} to describe a solid fill color.
         * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
         *
         * @param value - `FillStyle` or function which mutates the active `FillStyle`.
         * @returns Object itself
         * @public
         */
        setSeriesBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get FillStyle of Series background area (area behind series).
         * @returns FillStyle
         * @public
         */
        getSeriesBackgroundFillStyle(): FillStyle;
        /**
         * Set {@link LineStyle} of series background border stroke.
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.setSeriesBackgroundStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
         *  }))
         * ```
         *
         * **Related API:**
         * - Use {@link SolidLine} to describe a solid line style.
         * - Use {@link SolidFill} to describe a solid fill color.
         * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
         *
         * @param value - `LineStyle` or function which mutates the active `LineStyle`.
         * @returns Object itself
         * @public
         */
        setSeriesBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get Stroke style of Series background area (area behind series).
         * @returns LineStyle
         * @public
         */
        getSeriesBackgroundStrokeStyle(): LineStyle;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setSeriesBackgroundEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getSeriesBackgroundEffect(): boolean;
    }
    /**
     * Chart type for visualizing data between two dimensions, **X** and **Y**.
     * It has built-in *Axis* functionality, and supports a large set of *series* types.
     *
     * `ChartXY` can be created in two different ways - to learn more about creation time configuration of `ChartXY`, please refer to:
     * - {@link LightningChart.ChartXY} (stand-alone chart).
     * - {@link Dashboard.createChartXY} (chart inside *dashboard*).
     *
     * **ChartXY features**
     *
     * 1. Axes
     *
     * `ChartXY` always has at least one X and Y *axes*.
     *
     * The default `Axis` can be referenced with {@link ChartXY.getDefaultAxisX} and
     * {@link ChartXY.getDefaultAxisY}.
     * See {@link Axis} for features of *axis*.
     *
     * `ChartXY` doesn't have a limit on number of *axes*.
     * Additional *axes* can be created with {@link ChartXY.addAxisX} and
     * {@link ChartXY.addAxisY}.
     * Multiple *Axes* can be stacked on top of another, and *axes* can be positioned on either side of
     * the *chart* (left, right, top, bottom, see {@link AxisOptions}).
     *
     * 2. Series
     *
     * `ChartXY` supports a variety of different *series* types, each with their own method of data visualization.
     * *Series* are created with `ChartXY.add...Series` methods, for example:
     * - {@link ChartXY.addLineSeries}
     * - {@link ChartXY.addPointSeries}
     * - {@link ChartXY.addHeatmapGridSeries}
     * - {@link ChartXY.addOHLCSeries}
     *
     * When created, a *series* is always attached to a pair of *X* and *Y Axes*.
     * The *Axes* can be specified by user, or the *chart default Axes* will be used.
     *
     * 3. Cursor
     *
     * `ChartXY` has built-in cursor functionality for displaying data on user interaction above charts.
     * This can be controlled using:
     * - {@link setCursorMode}
     * - {@link setCursor}
     * - {@link setCursorFormatting}
     *
     * 4. Title
     *
     * `ChartXY` has a built-in *title* component, which can be configured using {@link ChartXY.setTitle}.
     *
     * 5. Backgrounds
     *
     * `ChartXY` contains two separate *background* components:
     * - *Background* ({@link ChartXY.setBackgroundFillStyle}).
     * - *Series Background* ({@link ChartXY.setSeriesBackgroundFillStyle}).
     *
     * 6. UI Elements
     *
     * Custom *UI elements* can be placed on `ChartXY` in same way as all other *charts*, using {@link ChartXY.addUIElement}.
     *
     * **Other APIs worthy of mention:**
     *
     * - Empty space around `ChartXY` can be configured with {@link ChartXY.setPadding}.
     * - Additional margin around *chart title* can be configured with {@link ChartXY.setTitleMargin}.
     * - All animations can be conveniently controlled with {@link ChartXY.setAnimationsEnabled}.
     * - `ChartXY` can be removed permanently with {@link ChartXY.dispose}.
     * - Some useful events that can be subscribed to:
     *      * *Resize events* ({@link ChartXY.onResize}).
     *      * *Background events* ({@link ChartXY.onBackgroundMouseMove}).
     *      * *Series Background events* ({@link ChartXY.onSeriesBackgroundMouseMove}).
     *
     * @public
     */
    export declare class ChartXY<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithSeries<SeriesXY> implements ChartWithAxis<Axis>, ChartWithCursor<CursorResultTableBackgroundType, CursorPositionXY, CursorXY<CursorResultTableBackgroundType>, SolveResultXY> {
        /**
         * Selector for default Axis Coordinate System, measured along the active default X and Y axes of the chart.
         *
         * This is a convenience selector that is equal to following declaration:
         *
         * ```ts
         *  { x: ChartXY.getDefaultAxisX(), y: ChartXY.getDefaultAxisY() }
         * ```
         *
         * This selector can be used for translating Axis coordinates to other coordinate systems and vice versa.
         * For example, in order to:
         * - Position LCJS UI elements in Axis coordinates
         * - Find client coordinate that matches an X and Y location along the Axes
         * - Translating user click event location to a pair of Axes
         * - etc.
         *
         * See {@link translateCoordinate} for more detailed use case information and example usage.
         *
         * @public
         */
        get coordsAxis(): CoordinateSystemAxis;
        /**
         * Get series of a chart
         * @returns Array of series
         * @public
         */
        getSeries(): SeriesXY[];
        /**
         * Restore previous zoom state of all Axes.
         *
         * `ChartXY` automatically follows the state of its axes. The previous state can be restored using this method.
         *
         * ```ts
         *  // Example usage
         *  chart.restorePreviousZoomState()
         * ```
         *
         * ```ts
         *  // Example, all properties
         *  chart.restorePreviousZoomState({
         *      whitelist: [specificAxis],
         *      animate: 1000, // 1000 ms animation
         *      stopAxisAfter: true
         *  })
         * ```
         *
         * @param   opts -  Optional extra control options.
         * @returns     Object itself.
         * @public
         * @beta    Introduced in v7.0.0. API may change according to user feedback.
         */
        restorePreviousZoomState(opts?: {
            whitelist: Axis[];
        } & AxisIntervalConfiguration): this;
        /**
         * Clear zoom state history which is used by {@link restorePreviousZoomState} as well as any built-in "restorePrevious" user interactions.
         *
         * ```ts
         *  // Example usage, set axis interval and ensure any previous zoom state history is deleted.
         *  chart.axisX.setInterval({ start: 0, end: 100 })
         *  chart.clearPreviousZoomStateHistory()
         * ```
         *
         * The order of above operations is important.
         *
         * @returns     Object itself.
         * @public
         * @beta    Introduced in v7.0.0. API may change according to user feedback.
         */
        clearPreviousZoomStateHistory(): this;
        setCursor(mutator: Mutator<CursorXY<CursorResultTableBackgroundType>>): this;
        getCursor(): CursorXY<CursorResultTableBackgroundType>;
        setCursorMode(mode: SolveNearestMode | undefined): this;
        getCursorMode(): SolveNearestMode | undefined;
        setCustomCursor(clbk: undefined | ((event: CursorTargetChangedEvent<SolveResultXY>) => unknown)): this;
        setCursorDynamicBehavior(value: CursorDynamicBehavior): this;
        /**
         * Set cursor formatting, controlling the text displayed in built-in cursor.
         *
         * ```ts
         *  chart.setCursorFormatting((_, hit, hits) => {
         *      return [
         *          ['Cursor pointing at'],
         *          [hit.series], // returning a series will display the series color and its name automatically.
         *          ['X', '', hit.axisX.formatValue(hit.x)], // utilizing axis formatValue is useful for considering active zoom level and type of axis
         *          ['Y', '', hit.y.toFixed(2)], // empty string '' results in gap between cells
         *          [{ text: 'Example', font: { weight: 'bold' }, fillStyle: fillRed }] // any cell can also be styled individually
         *      ]
         *  })
         * ```
         *
         * Before overriding default cursor formatting, it is recommended to check if using {@link GenericAxis.setUnits} or configuring Axis cursor formatting would be enough.
         *
         * In order to use series specific data properties (e.g. Heatmap sample "intensity"),
         * you should use type guards to assert the type of the `SolveResult`:
         *
         * ```ts
         *  // Example of using type guard in cursor formatter
         *  Chart.setCursorFormatting((chart, hit, hits) => {
         *      if (!isHitHeatmap(hit)) return undefined
         *      return [hit.intensity.toFixed(1)]
         *  })
         * ```
         *
         * More details in Developer documentation (Features \> Cursor).
         * @param   formatter -     Callback function for cursor formatting.
         * @returns     Object itself
         * @public
         */
        setCursorFormatting(formatter: CursorFormatterChartXY): this;
        /**
         * Get active cursor formatter.
         * @returns     Cursor formatter.
         * @public
         */
        getCursorFormatting(): CursorFormatterChartXY;
        /**
         * Method for solving the nearest data point from all existing series relative to a given coordinate on screen.
         *
         * ```ts
         *  // Example syntax
         *  chart.onSeriesBackgroundMouseClick((_, event) => {
         *      const solve1 = chart.solveNearest(event, 'show-nearest')    // solve nearest location (1)
         *      const solve2 = chart.solveNearest(event, 'show-all')        // solve all locations
         *  })
         * ```
         *
         * @param   from -  Reference coordinate on web page as client coordinates. This can for example be directly an `Event` object. `undefined` results in using last registered mouse location.
         * @param   solveMode -     Optional control for solve nearest behavior
         * @returns     SolveResult object.
         * @public
         */
        solveNearest(from?: CoordinateClient, solveMode?: SolveNearestMode): SolveResultXY[];
        /**
         * Add manually controlled Cursor object.
         * These have exactly same functions as built-in cursors but they can be freely controlled by application logic.
         *
         * ```ts
         *  const cursor = chart.addCursor()
         * ```
         *
         * Styling works same as built-in cursors (e.g. {@link setCursor}).
         *
         * Position is set using `setPosition` method and displayed content using `setResultTable(table => table.setContent(...))`
         * For more details, see Developer documentation \> Features \> Cursor \> Manual cursors
         *
         * @param   cursorBuilder -     Builder for cursor. Can be used to tweak a handful of properties which can't be changed during runtime.
         * @returns     Cursor object.
         * @public
         */
        addCursor<ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: CursorBuilderXY<ResultTableBackgroundType>): CursorXY<ResultTableBackgroundType>;
        /**
         * Get minimum size of Panel.
         * Depending on the type of class this value might be automatically computed to fit different elements.
         * @returns Vec2 minimum size or undefined if unimplemented
         * @public
         */
        getMinimumSize(): Point | undefined;
        /**
         * Get chart layout information.
         * This is a getter variant of {@link ChartXYLayoutChangedEvent}. In most cases, `ChartXYLayoutChangedEvent` is more convenient as it fires whenever the layout changes.
         * For more information about the returned value and use cases, please read {@link ChartXYLayoutChangedEvent}.
         *
         * ```ts
         *  // Example syntax
         *  chart.getLayout().then(layout => {
         *      console.log(layout)
         *  })
         * ```
         *
         * @returns     Promise of layout information.
         * @public
         * @beta    Introduced in v7.0.0. API may be changed according to user feedback.
         */
        getLayout(): Promise<ChartXYLayoutInfo>;
        /**
         * Add new *X Axis* to the *Chart*.
         *
         * **Example usage**:
         *
         * - Configure Axis on opposite side to default configuration (right).
         *
         * ```typescript
         *  ChartXY.addAxisX({
         *      opposite: true,
         *  })
         * ```
         *
         * - Configure Axis as logarithmic (10 base).
         *
         * ```typescript
         *  ChartXY.addAxisX({
         *      type: 'logarithmic',
         *      base: 10,
         *  })
         * ```
         *
         * - Configure Axis as logarithmic (natural base).
         *
         * ```typescript
         *  ChartXY.addAxisX({
         *      type: 'logarithmic',
         *      base: 'natural',
         *  })
         * ```
         *
         * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
         *
         * List of series that support logarithmic Axes:
         * - {@link LineSeries}
         * - {@link PointSeries}
         * - {@link PointLineSeries}
         * - {@link StepSeries}
         * - {@link SplineSeries}
         * - {@link AreaSeries}
         * - {@link AreaRangeSeries}
         * - {@link OHLCSeries} (Y Axis can be logarithmic, but not X Axis)
         * - {@link RectangleSeries}
         * - {@link SegmentSeries}
         *
         * List of series that do **not** support logarithmic Axes:
         * - {@link HeatmapGridSeriesIntensityValues}
         * - {@link HeatmapScrollingGridSeriesIntensityValues}
         *
         * @param opts - Optional {@link AxisOptions} object for specifying Axis configurations that can't be changed
         *                  during runtime.
         * @returns *Axis* object.
         * @public
         */
        addAxisX(opts?: AxisOptions): Axis;
        /**
         * Add new *Y Axis* to the *Chart*.
         *
         * **Example usage**:
         *
         * - Configure Axis on opposite side to default configuration (right).
         *
         * ```typescript
         *  ChartXY.addAxisY({
         *      opposite: true,
         *  })
         * ```
         *
         * - Configure Axis as logarithmic (10 base).
         *
         * ```typescript
         *  ChartXY.addAxisY({
         *      type: 'logarithmic',
         *      base: 10,
         *  })
         * ```
         *
         * - Configure Axis as logarithmic (natural base).
         *
         * ```typescript
         *  ChartXY.addAxisY({
         *      type: 'logarithmic',
         *      base: 'natural',
         *  })
         * ```
         *
         * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
         *
         * List of series that support logarithmic Axes:
         * - {@link LineSeries}
         * - {@link PointSeries}
         * - {@link PointLineSeries}
         * - {@link StepSeries}
         * - {@link SplineSeries}
         * - {@link AreaSeries}
         * - {@link AreaRangeSeries}
         * - {@link OHLCSeries} (Y Axis can be logarithmic, but not X Axis)
         * - {@link RectangleSeries}
         * - {@link SegmentSeries}
         *
         * List of series that do **not** support logarithmic Axes:
         * - {@link HeatmapGridSeriesIntensityValues}
         * - {@link HeatmapScrollingGridSeriesIntensityValues}
         *
         * @param opts - Optional {@link AxisOptions} object for specifying Axis configurations that can't be changed
         *                  during runtime.
         * @returns *Axis* object.
         * @public
         */
        addAxisY(opts?: AxisOptions): Axis;
        /**
         * Swap the positions of two Axes.
         *
         * Only supports swapping between same planes of Axis. For example, two X axes, or two Y axes.
         *
         * Currently also doesn't support swapping between different modes of `opposite` axes. For example, between X axis on left and X axis on right.
         *
         * @param axis1 - First axis
         * @param axis2 - Second axis
         * @returns     Object itself
         */
        swapAxes(axis1: Axis, axis2: Axis): this;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Get reference to the *default X Axis* of the `ChartXY`.
         *
         * This will always return reference to the *visible X Axis* that is closest to the chart (starting from bottom).
         * @returns Default X Axis of chart.
         * @public
         */
        getDefaultAxisX(): Axis;
        /**
         * Convenience getter property that does the same as {@link getDefaultAxisX}.
         * @public
         */
        get axisX(): Axis;
        /**
         * Convenience getter property that does the same as {@link getDefaultAxisX}.
         * @public
         */
        get xAxis(): Axis;
        /**
         * Get reference to the *default Y Axis* of the `ChartXY`.
         *
         * This will always return reference to the *visible Y Axis* that is closest to the chart (starting from left).
         * @returns Default Y Axis of chart.
         * @public
         */
        getDefaultAxisY(): Axis;
        /**
         * Convenience getter property that does the same as {@link getDefaultAxisY}.
         * @public
         */
        get axisY(): Axis;
        /**
         * Convenience getter property that does the same as {@link getDefaultAxisY}.
         * @public
         */
        get yAxis(): Axis;
        /**
         * Convenience method to get a tuple of the Charts default X and Y axes.
         *
         * Equal to `[ChartXY.getDefaultAxisX(), ChartXY.getDefaultAxisY()]`
         *
         * Intended for conveniently applying same modifications to both X and Y axes.
         *
         * @returns [chart.getDefaultAxisX(), chart.getDefaultAxisY()]
         * @public
         */
        getDefaultAxes(): [Axis, Axis];
        /**
         * @param axisPositions - array of axis positions which have to be included to the output
         *                          empty array indicates all of positions are included
         * @returns An array of axis. Sorted to increasing order based on `iStack` in case of multiple axis results.
         * @public
         */
        getAxes(...axisPositions: AxisPosition[]): Axis[];
        /**
         * Operate on each x axis of chart
         * @param clbk - Callback function for axis
         * @public
         */
        forEachAxisX(clbk: (axis: Axis, i: number, allAxes: Axis[]) => void): void;
        /**
         * Operate on each y axis of chart
         * @param clbk - Callback function for axis
         * @public
         */
        forEachAxisY(clbk: (axis: Axis, i: number, allAxes: Axis[]) => void): void;
        /**
         * Set position of ChartXY title.
         *
         * ```ts
         *  // Example usage
         *  ChartXY.setTitlePosition(ChartXYTitlePositionOptions.LeftTop)
         *
         * // Or
         *  ChartXY.setTitlePosition('left-top')
         *
         * ```
         *
         * For available options, see {@link ChartXYTitlePosition}
         *
         * To tweak title position, you may use {@link ChartXY.setTitleMargin}
         *
         * @param pos - Title position.
         * @public
         */
        setTitlePosition(pos: ChartXYTitlePosition): this;
        /**
         * Get position of ChartXY title.
         *
         * @returns Title position.
         * @public
         */
        getTitlePosition(): ChartXYTitlePosition;
        /**
         * Add series that can visualize any combination of Lines, Points and Area filling.
         * Supports both real-time and static data visualization.
         *
         * Also supports different preprocessing options (step/spline/disabled).
         *
         * Some properties of `PointLineAreaSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const series = ChartXY.addPointLineAreaSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link PointLineAreaSeriesOptions}.
         * Examples:
         *
         * Different data visualizations can be achieved simply by changing the style of the series.
         *
         * ```ts
         *  // Area series
         *  const series = ChartXY.addPointLineAreaSeries()
         * ```
         *
         * ```ts
         *  // Point-Line series
         *  const series = ChartXY.addPointLineAreaSeries()
         *      .setAreaFillStyle(emptyFill)
         * ```
         *
         * ```ts
         *  // Point series
         *  const series = ChartXY.addPointLineAreaSeries()
         *      .setAreaFillStyle(emptyFill)
         *      .setStrokeStyle(emptyLine)
         * ```
         *
         * ```ts
         *  // Step series
         *  const series = ChartXY.addPointLineAreaSeries()
         *      .setAreaFillStyle(emptyFill)
         *      .setCurvePreprocessing({ type: 'step', step: 'middle' })
         * ```
         *
         * ```ts
         *  // Spline series
         *  const series = ChartXY.addPointLineAreaSeries()
         *      .setAreaFillStyle(emptyFill)
         *      .setCurvePreprocessing({ type: 'spline' })
         * ```
         *
         * For convenience, you can also use series creation methods: {@link addLineSeries}, {@link addPointSeries}, {@link addAreaSeries}, etc.
         * These are only convenience methods for creating differently styled `PointLineAreaSeries`.
         *
         * More detailed documentation can be found at:
         *  - https://lightningchart.com/js-charts/docs/features/xy/line/
         * @param options - Readonly options for series that can't be changed afterwards
         * @returns     Series object
         * @public
         */
        addPointLineAreaSeries(options?: PointLineAreaSeriesOptions): PointLineAreaSeries;
        /**
         * Short-hand for:
         *
         * ```ts
         *  const lineSeries = chart.addPointLineAreaSeries().setAreaFillStyle(emptyFill).setPointFillStyle(emptyFill)
         * ```
         * @param options - Readonly options for series that can't be changed afterwards
         * @returns     Series object
         * @public
         */
        addLineSeries(options?: PointLineAreaSeriesOptions): PointLineAreaSeries;
        /**
         * Short-hand for:
         *
         * ```ts
         *  const pointSeries = chart.addPointLineAreaSeries().setAreaFillStyle(emptyFill).setStrokeStyle(emptyLine)
         * ```
         * @param options - Readonly options for series that can't be changed afterwards
         * @returns     Series object
         * @public
         */
        addPointSeries(options?: PointLineAreaSeriesOptions): PointLineAreaSeries;
        /**
         * Short-hand for:
         *
         * ```ts
         *  const pointLineSeries = chart.addPointLineAreaSeries().setAreaFillStyle(emptyFill)
         * ```
         * @param options - Readonly options for series that can't be changed afterwards
         * @returns     Series object
         * @public
         */
        addPointLineSeries(options?: PointLineAreaSeriesOptions): PointLineAreaSeries;
        /**
         * Short-hand for:
         *
         * ```ts
         *  const stepSeries = chart.addPointLineAreaSeries(options).setAreaFillStyle(emptyFill).setCurvePreprocessing({ type: 'step' })
         * ```
         * @param options - Readonly options for series that can't be changed afterwards
         * @returns     Series object
         * @public
         */
        addStepSeries(options?: PointLineAreaSeriesOptions): PointLineAreaSeries;
        /**
         * Short-hand for:
         *
         * ```ts
         *  const splineSeries = chart.addPointLineAreaSeries(options).setAreaFillStyle(emptyFill).setCurvePreprocessing({ type: 'spline' })
         * ```
         * @param options - Readonly options for series that can't be changed afterwards
         * @returns     Series object
         * @public
         */
        addSplineSeries(options?: PointLineAreaSeriesOptions): PointLineAreaSeries;
        /**
         * Short-hand for:
         *
         * ```ts
         *  const areaSeries = chart.addPointLineAreaSeries().setPointFillStyle(emptyFill)
         * ```
         * @param options - Readonly options for series that can't be changed afterwards
         * @returns     Series object
         * @public
         */
        addAreaSeries(options?: PointLineAreaSeriesOptions): PointLineAreaSeries;
        /**
         * Method for adding a new `RectangleSeries` to the chart. This series type visualizes a collection of *rectangles*.
         *
         * To learn more about its features and usage, refer to {@link RectangleSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `RectangleSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const rectSeries = ChartXY.addRectangleSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link RectangleSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `RectangleSeries`.
         * @returns New series.
         * @public
         */
        addRectangleSeries(options?: RectangleSeriesOptions): RectangleSeries;
        /**
         * Method for adding a new `PolygonSeries` to the chart. This series type visualizes a collection of *polygons*.
         *
         * To learn more about its features and usage, refer to {@link PolygonSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `PolygonSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const polygonSeries = ChartXY.addPolygonSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link PolygonSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `PolygonSeries`.
         * @returns New series.
         * @public
         */
        addPolygonSeries(options?: PolygonSeriesOptions): PolygonSeries;
        /**
         * Method for adding a new `SegmentSeries` to the chart. This series type visualizes a collection of *line segments* (A -\> B).
         *
         * To learn more about its features and usage, refer to {@link SegmentSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `SegmentSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const series = ChartXY.addSegmentSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link SegmentSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `SegmentSeries`.
         * @returns New series.
         * @public
         */
        addSegmentSeries(options?: SegmentSeriesOptions): SegmentSeries;
        /**
         * Method for adding a new `EllipseSeries` to the chart. This series type visualizes a collection of *ellipses*.
         *
         * To learn more about its features and usage, refer to {@link EllipseSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `EllipseSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const series = ChartXY.addEllipseSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link EllipseSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `EllipseSeries`.
         * @returns New series.
         * @public
         */
        addEllipseSeries(options?: EllipseSeriesOptions): EllipseSeries;
        /**
         * Method for adding a new `BoxSeries` to the chart. This series type is used for visualizing data groups through quartiles.
         *
         * To learn more about its features and usage, refer to {@link BoxSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `BoxSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const series = ChartXY.addBoxSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link BoxSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `BoxSeries`.
         * @returns New series.
         * @public
         */
        addBoxSeries(options?: BoxSeriesOptions): BoxSeries;
        /**
         * Method for adding a new `TextSeries` to the chart. This series type can be used to display a set of Text objects inside the series area.
         *
         * To learn more about its features and usage, refer to {@link TextSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `TextSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const rectSeries = ChartXY.addTextSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link TextSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `TextSeries`.
         * @returns New series.
         * @public
         */
        addTextSeries(options?: TextSeriesOptions): TextSeries;
        /**
         * Method for adding a new `AreaRangeSeries` to the chart. This series type is used for visualizing bands of data between two curves of data.
         * `AreaRangeSeries` is optimized for *large* amounts of data - here are some reference specs to give an idea:
         *
         * - A static data set in millions range is rendered in a matter of seconds.
         * - With streaming data, tens of thousands data points can be streamed in every second, while retaining an interactive document.
         *
         * To learn more about its features and usage, refer to {@link AreaRangeSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `AreaRangeSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const series = ChartXY.addAreaRangeSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link AreaRangeSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `AreaRangeSeries`.
         * @returns New series.
         * @public
         */
        addAreaRangeSeries: (options?: AreaRangeSeriesOptions) => AreaRangeSeries;
        /**
         * Add a Series for visualizing a *Heatmap Grid* with a static column and grid count. Has API for fast modification of cell values.
         *
         * `HeatmapGridSeries` is optimized for *massive* amounts of data - here are some reference specs on average PC to give an idea:
         *
         * - Heatmap Chart with 1 million data points (`1000x1000`) is cold started in ~0.3 seconds.
         * - Heatmap Chart with 1 million data points (`1000x1000`) is re-populated (change data set) in ~0.050 seconds.
         * - Heatmap Chart with 16 million data points (`4000x4000`) is cold started in ~2.0 seconds.
         * - Heatmap Chart with 16 million data points (`4000x4000`) is re-populated (change data set) in ~0.5 seconds.
         *
         * `HeatmapGridSeries` max data amount is entirely restricted by the client hardware RAM and more specifically amount of RAM usable by the context running LightningChart JS.
         * If by increasing the amount of `columns` and `rows` you encounter suddenly weak performance, it is likely that there is not enough RAM memory available.
         *
         * To learn more about its features and usage, refer to {@link HeatmapGridSeriesIntensityValues}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `HeatmapSeries` can only be configured when it is created. Some of these arguments are **mandatory**, while some are optional.
         * They are wrapped in a single object parameter:
         *
         * ```js
         *  // Example,
         *  const series = ChartXY.addHeatmapGridSeries({
         *      columns: 100,
         *      rows: 100
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link HeatmapGridSeriesOptions}.
         *
         * Heatmap data format is specified with `heatmapDataType: 'intensity'` property;
         * in this case, each cell of the heatmap is associated with a *numeric intensity value*, which can be used in conjuction with a
         * Color look up table ({@link LUT}).
         *
         * For *scrolling heatmap grids*, see {@link addHeatmapScrollingGridSeries}.
         *
         * @param options - Configuration parameters for Heatmap Grid Series.
         * @returns Heatmap Grid Series.
         * @public
         */
        addHeatmapGridSeries(options: HeatmapGridSeriesOptions<'intensity'>): HeatmapGridSeriesIntensityValues;
        /**
         * Add a Series for visualizing a *Heatmap Grid*, with API for pushing data in a scrolling manner (append new data on top of existing data).
         *
         * `HeatmapScrollingGridSeries` is optimized for *massive* amounts of data - here are some reference specs on average PC to give an idea:
         *
         * - Scrolling Heatmap Chart with 2 million incoming data points **per second** (`rows: 2048`, 1000 columns/s) runs consistently and smoothly with 60 FPS and no stuttering. CPU usage stays easily below 40%.
         * - Scrolling Heatmap Chart with 8 million incoming data points **per second** (`rows: 4096`, 2000 columns/s) runs consistently and smoothly with 60 FPS and minor stuttering.
         *
         * `HeatmapScrollingGridSeries` max data amount is entirely restricted by the client hardware RAM and more specifically amount of RAM usable by the context running LightningChart JS.
         * If performance suddenly plummets at some approximate data threshold, then it is likely that there is not enough RAM available.
         * Use data cleaning configuration and suitable Axis intervals to adjust to your hardware limitations.
         *
         * To learn more about its features and usage, refer to {@link HeatmapScrollingGridSeriesIntensityValues}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `ScrollingHeatmapSeries` can only be configured when it is created. Some of these arguments are **mandatory**, while some are optional.
         * They are wrapped in a single object parameter:
         *
         * ```js
         *  // Example,
         *  const series = ChartXY.addHeatmapGridSeries({
         *      resolution: 100
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link HeatmapScrollingGridSeriesOptions}.
         *
         * Heatmap data format is specified with `heatmapDataType: 'intensity'` property;
         * in this case, each cell of the heatmap is associated with a *numeric intensity value*, which can be used in conjuction with a
         * Color look up table ({@link LUT}).
         *
         * For *static heatmap grids*, see {@link addHeatmapGridSeries}.
         *
         * @param options - Configuration parameters for Heatmap Grid Series.
         * @returns Scrolling Heatmap Grid Series.
         * @public
         */
        addHeatmapScrollingGridSeries(options: HeatmapScrollingGridSeriesOptions<'intensity'>): HeatmapScrollingGridSeriesIntensityValues;
        /**
         * Method for adding a new `OHLCSeries` to the chart. This series type is used for visualizing trading figures in large quantities and/or with real-time data input.
         *
         * **OHLC Series is only usable with a Trading license for LightningChart JS**
         *
         * To learn more about its features and usage, refer to {@link OHLCSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `OHLCSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const series = ChartXY.addOHLCSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link OHLCSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `OHLCSeries`.
         * @returns New series.
         * @public
         */
        addOHLCSeries<Type extends OHLCSeriesTypes = typeof OHLCSeriesCandlesticks>(options?: OHLCSeriesOptions<Type>): InstanceType<Type>;
        /**
         * Api to add OSM menu to the chart
         *
         * @param controls - A 2d array which describes the type of buttons to be added and their positions (row, column).
         * @param osmButtonShape - Optional parameter to specify the shape of the on-screen menu icons.
         * @beta                    This feature is considered experimental and might be changed in minor release.
         */
        addOnScreenMenu(controls: (OnScreenMenuButtonType | OnScreenMenuCustomButtonParams)[][], osmButtonShape?: OnScreenMenuButtonShape): OnScreenMenu;
        /**
         * Set fillStyle for zooming rectangle when zooming.
         * @param value - FillStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setZoomingRectangleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fillStyle for zooming rectangle when zooming.
         * @returns FillStyle
         * @public
         */
        getZoomingRectangleFillStyle(): FillStyle;
        /**
         * Set stroke style for zooming rectangle when zooming.
         * @param value - LineStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setZoomingRectangleStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style for zooming rectangle when zooming.
         * @returns LineStyle
         * @public
         */
        getZoomingRectangleStrokeStyle(): LineStyle;
        /**
         * Method pans axes by pixels.
         *
         * ```js
         * // Pan the chart 100 pixels to right.
         * chart.pan({x: 100, y: 0})
         * ```
         * @param delta - Amount to pan X/Y in pixels
         * @public
         */
        pan(delta: Point): void;
        /**
         * Method zooms axes by pixels.
         *
         * ```js
         * // Zoom the chart out.
         * chart.zoom({x: 500, y: 500}, {x: 1, y: 1})
         * ```
         * @param location - Origin location for zooming as viewport pixels
         * @param amount - Amount to zoom X/Y in pixels
         * @public
         */
        zoom(location: Point, amount: Point): void;
        /**
         * Disable/Enable all animations of the Chart.
         * @param animationsEnabled - Boolean value to enable or disable animations.
         * @returns Chart itself for fluent interface.
         * @public
         * @privateRemarks  Override to also apply state to axes.
         */
        setAnimationsEnabled(animationsEnabled: boolean): this;
        /**
         * Disable/Enable Cursor during Axis Animations.
         *
         * Axis Animations are Axis Scale changes that are animated, such as Zooming and Scrolling done by using API
         * (such as `Axis.setInterval`) or by using the mouse to click & drag on the Chart.
         * @param autoCursorEnabled - Boolean value to enable or disable Cursor during Axis Animations.
         * @returns Chart itself for fluent interface.
         * @public
         */
        setCursorEnabledDuringAxisAnimation(autoCursorEnabled: boolean): this;
        /**
         * Get current Cursor during Axis animations state.
         *
         * Axis Animations are Axis Scale changes that are animated, such as Zooming and Scrolling done by using API
         * (such as `Axis.setInterval`) or by using the mouse to click & drag on the Chart.
         * @returns True if Cursor is enabled during Axis Animations, false if not.
         * @public
         */
        getCursorEnabledDuringAxisAnimation(): boolean;
        /**
         * Operate on each axis of chart, x and y
         * @param clbk - Callback function for axis
         * @public
         */
        forEachAxis(clbk: (axis: Axis) => void): this;
        /**
         * Translate a coordinate in HTML client coordinate system to another coordinate system.
         *
         * **(1) arbitrary X and Y axes coordinate system:**
         *
         * ```ts
         *  ChartXY.onSeriesBackgroundMouseClick((_, event) => {
         *      const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
         *      // locationAxis tells the clicked location along Axis interval (in same value range as data points).
         *  })
         * ```
         *
         * `chart.coordsAxis` is a convenience selector for the active _default axes (X and Y)_. Arbitrary set of X and Y axes can be selected like this:
         *
         * ```ts
         *  const locationAxis = chart.translateCoordinate(event, { x: myAxisX, y: myAxisY })
         * ```
         *
         * **(2) relative control coordinate system:**
         *
         * ```ts
         *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
         *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
         *  // locationRelative is in pixels relative to bottom left corner of the chart
         * ```
         *
         * Relative coordinates can be used for positioning LightningChart JS UI components:
         *
         * ```ts
         *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
         *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 20, y: 20 })
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         */
        translateCoordinate<T extends CoordinateSystemRelative | CoordinateSystemAxis>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : T extends CoordinateSystemAxis ? CoordinateXY : never;
        /**
         * Translate a coordinate to another coordinate system.
         *
         * | Supported INPUT coordinate systems | Syntax | Syntax 2 |
         * |:----|:----|:----|
         * | arbitrary X and Y axes | `chart.coordsAxis` | `{ x: Axis, y: Axis }` |
         * | relative coordinates | `chart.coordsRelative` | |
         *
         * | Supported OUTPUT coordinate systems | Syntax | Syntax 2 |
         * |:----|:----|:----|
         * | arbitrary X and Y axes | `chart.coordsAxis` | `{ x: Axis, y: Axis }` |
         * | relative coordinates | `chart.coordsRelative` | |
         * | HTML client coordinates | `chart.coordsClient` | |
         *
         * Most common example use cases:
         *
         * **(1) Translate a coordinate from axes to HTML client coordinates**
         *
         * ```ts
         *  const locationAxis = { x: 2, y: 5 }
         *  const locationClient = chart.translateCoordinate(locationAxis, chart.coordsAxis, chart.coordsClient)
         * ```
         *
         * Client coordinates can be used to absolute position HTML elements using CSS, for example.
         *
         * ```ts
         *  myHTMLElement.style.position = 'absolute'
         *  myHTMLElement.style.left = locationClient.clientX
         *  myHTMLElement.style.top = locationClient.clientY
         * ```
         *
         * **(2) Translate a coordinate from HTML client coordinates to axes**
         *
         * ```ts
         *  ChartXY.onSeriesBackgroundMouseClick((_, event) => {
         *      const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
         *      // locationAxis tells the clicked location along Axis interval (in same value range as data points).
         *  })
         * ```
         *
         * **(3) Translate a coordinate from axes to relative chart coordinates**
         *
         * ```ts
         *  const locationAxis = { x: 2, y: 5 }
         *  const locationRelative = chart.translateCoordinate(locationAxis, chart.coordsAxis, chart.coordsRelative)
         * ```
         *
         * Relative coordinates can be used for positioning LightningChart JS UI components:
         *
         * ```ts
         *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
         *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 20, y: 20 })
         * ```
         *
         * **(4) Translate a coordinate from relative chart coordinates to axes**
         *
         * ```ts
         *  const locationRelative = { x: 0, y: 0 }
         *  const locationAxis = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsAxis)
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         */
        translateCoordinate<T extends CoordinateSystemClient | CoordinateSystemRelative | CoordinateSystemAxis>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemAxis | CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : T extends CoordinateSystemRelative ? CoordinateXY : T extends CoordinateSystemAxis ? CoordinateXY : never;
        /**
         * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
         *
         * ```ts
         *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
         *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
         *  // locationRelative is in pixels relative to bottom left corner of the chart
         * ```
         *
         * Relative coordinates can be used for positioning LightningChart JS UI components:
         *
         * ```ts
         *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
         *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 20, y: 20 })
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         * @privateRemarks  This definition of the method originates from the super class. Mention it last as the intention is that above declarations can also used for this declarations use case.
         */
        translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
        /**
         * Translate a coordinate from relative control coordinates to HTML client coordinate system.
         *
         * ```ts
         *  // 10 pixels left and 20 pixels up from controls bottom left corner
         *  const locationRelative = { x: 10, y: 20 }
         *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
         * ```
         *
         * Client coordinates can be used to absolute position HTML elements using CSS, for example.
         *
         * ```ts
         *  myHTMLElement.style.position = 'absolute'
         *  myHTMLElement.style.left = locationClient.clientX
         *  myHTMLElement.style.top = locationClient.clientY
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         * @privateRemarks  This definition of the method originates from the super class. Mention it last as the intention is that above declarations can also used for this declarations use case.
         */
        translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
        addEventListener<K extends keyof ChartXYEventMap>(type: K, listener: (event: ChartXYEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof ChartXYEventMap>(type: K, listener: (event: ChartXYEventMap[K], info: unknown) => unknown): void;
        /**
         * Configure user interactions from a set of preset options.
         *
         * Without any explicit configuration, the charts select the default user interaction scheme based on available information,
         * such as axis types, attached series and data supplied to series.
         *
         * The `setUserInteraction` methods allow explicitly configuring the used interaction scheme.
         *
         * This is not a definitive operation, but rather modifies the current state.
         * For example, modifying `pan` interaction does not affect the state of any other interactions.
         *
         * ```ts
         *  // Example, LMB pan, RMB rectangle zoom
         *  chart.setUserInteractions({
         *      pan: {
         *          lmb: { drag: true },
         *          rmb: false,
         *      },
         *      rectangleZoom: {
         *          lmb: false,
         *          rmb: {},
         *      },
         *  })
         * ```
         *
         * ```ts
         *  // Example, disable default "restore default view" interaction, enable "restore previous view"
         *  chart.setUserInteractions({
         *      restoreDefault: false,
         *      restorePrevious: {
         *          doubleClick: true,
         *          ctrlZ: true
         *      },
         *  })
         * ```
         *
         * ```ts
         *  // Example, disable all interactions
         *  chart.setUserInteractions(undefined)
         * ```
         *
         * ```ts
         *  // Example, restore default interactions
         *  chart.setUserInteractions({})
         * ```
         *
         * @param   config -    Option with any set of properties of {@link ChartXYUserInteractions} or `undefined` to disable all interactions.
         * @returns     Object itself.
         * @public
         * @beta    Introduced in v7.0.0. API may change according to user feedback.
         */
        setUserInteractions(config: Partial<ChartXYUserInteractions> | undefined): this;
        /**
         * Get currently active user interaction scheme.
         * This does NOT return the last value supplied to {@link setUserInteractions}.
         * Rather, it considers the current structure of the chart, all built-in defaults as well as overrides supplied by the user
         * and returns the currently used interaction scheme.
         *
         * @returns     ChartXYUserInteractions
         * @public
         * @beta    Introduced in v7.0.0. API may change according to user feedback.
         */
        getUserInteractions(): ChartXYUserInteractions;
    }
    /**
     * Interface of events trackable by {@link ChartXY.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface ChartXYEventMap extends ChartWithSeriesEventMap<SeriesXY>, ChartWithCursorEventMap<SolveResultXY> {
        /**
         * Event fired when a new axis is added
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('axisadd', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        axisadd: {
            axis: Axis;
        };
        /**
         * Event fired when the ChartXY layout is changed. This refers to positioning of axes, chart margins and viewport size.
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('layoutchange', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        layoutchange: ChartXYLayoutChangedEvent;
    }
    /**
     * Event fired when ChartXY layout is changed.
     * This means any change to the dimensions of:
     * - any axis
     * - any margin within chart
     * - chart container size
     *
     * The event is fired just before the chart proceeds to re-render.
     * This event is designed so that user can apply last minute layout changes in the callback function that will take immediate effect.
     * For example, user can change CSS or chart padding in the callback to make last minute corrections to the displayed layout.
     *
     * ```ts
     *  // Example syntax
     *  chart.addEventListener('layoutchanged', (event) => {
     *      console.log(event)
     *  })
     * ```
     *
     * If user modifies the chart layout in someway during the callback function, then the chart should be informed like this:
     *
     * ```ts
     *  chart.addEventListener('layoutchanged', (event) => {
     *      // Example, ensure that viewport is 500px wide
     *      chart.engine.container.style.width = `${ chart.engine.container.clientWidth + (500 - event.viewportWidth) }px`
     *      lc.layout() // if the CSS change may offset the position of OTHER charts than this one, then calling `layout` is essential to ensure they are also updated.
     *      event.userChangedLayout()
     *  })
     * ```
     *
     * Common use cases:
     * -----------------
     *
     * **Position UI elements:**
     *
     * ```ts
     *  const textBox = chart.addUIElement(undefined, chart.coordsRelative)
     *  chart.addEventListener('layoutchanged', (event) => {
     *      textBox.setOrigin(UIOrigins.LeftTop).setPosition({ x: event.margins.left, y: event.margins.bottom + event.viewportHeight })
     *  })
     * ```
     *
     * **Fixed aspect ratio:**
     *
     * ```ts
     *  // Example: Fixed aspect ratio, extra space is allocated as chart padding
     *  const aspectRatio = 1.8 // width / height
     *  chart.addEventListener('layoutchanged', (event) => {
     *      const spaceAvailable = { x: event.viewportWidth + chart.getPadding().right, y: event.viewportHeight + chart.getPadding().bottom }
     *      // Fit desired aspect ratio within space available in chart.
     *      let width
     *      let height
     *      if (spaceAvailable.x / spaceAvailable.y > aspectRatio) {
     *          height = spaceAvailable.y
     *          width = height * aspectRatio
     *      } else {
     *          width = spaceAvailable.x
     *          height = width / aspectRatio
     *      }
     *      chart.setPadding({
     *          right: chart.getPadding().right + (event.viewportWidth - width) + 20,
     *          bottom: chart.getPadding().bottom + (event.viewportHeight - height) + 20,
     *      })
     *  })
     * ```
     * @public
     */
    export declare interface ChartXYLayoutChangedEvent extends ChartXYLayoutInfo {
        userChangedLayout: () => void;
    }
    /**
     * @public
     * @beta    Introduced in v7.0.0. API may be changed according to user feedback.
     */
    export declare interface ChartXYLayoutInfo {
        /**
         * Width of chart viewport (area enclosed by axes) as pixels
         */
        viewportWidth: number;
        /**
         * Height of chart viewport (area enclosed by axes) as pixels
         */
        viewportHeight: number;
        /**
         * Width of whole chart as pixels
         */
        chartWidth: number;
        /**
         * Height of whole chart as pixels
         */
        chartHeight: number;
        /**
         * Margins around chart viewport (area enclosed by axes) as pixels on all 4 sides.
         */
        margins: Margin;
        /**
         * Map of all Axis position information.
         */
        axes: Map<Axis, AxisXYLayoutInfo>;
    }
    /**
     * Interface for readonly configuration of {@link ChartXY}.
     *
     * Some properties of `ChartXY` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, configure default X Axis.
     *  const chart = LightningChart.ChartXY({
     *      defaultAxisX: {
     *          type: 'linear',
     *      }
     *  })
     * ```
     *
     * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
     *
     * For *standalone* `ChartXY`, more parameters are documented in {@link LightningChart.ChartXY}.
     *
     * For *dashboard* `ChartXY`, more parameters are documented in {@link Dashboard.createChartXY}.
     *
     *
     * **Commonly used properties:**
     *
     * - {@link ChartXYOptions.theme}: Specify chart color *theme*.
     * - {@link ChartXYOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
     * - {@link ChartXYOptions.defaultAxisX}: Configure default X Axis.
     * - {@link ChartXYOptions.defaultAxisY}: Configure default Y Axis.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, create chart with default configuration.
     *  const chart = LightningChart.ChartXY({})
     * ```
     *
     * ```typescript
     *  // Example 2, create chart with specified color theme.
     *  const chart = LightningChart.ChartXY({
     *      theme: Themes.light,
     *  })
     * ```
     *
     * ```typescript
     *  // Example 3, create chart with specified default axis configurations.
     *  const chart = LightningChart.ChartXY({
     *      defaultAxisX: {
     *          type: 'linear',
     *      },
     *      defaultAxisY: {
     *          type: 'logarithmic',
     *          base: 10,
     *      }
     *  })
     * ```
     * @public
     */
    export declare interface ChartXYOptions<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
        /**
         * Builder for the charts' *auto cursor*. Use {@link CursorBuilders | CursorBuilders.XY} to modify the default builder, using methods of {@link CursorXYBuilder}.
         *
         * ```typescript
         *  // Example, change cursor ResultTable background shape.
         *  const chart = LightningChart.ChartXY({
         *      cursorBuilder: CursorBuilders.XY
         *          .setResultTableBackground(UIBackgrounds.Circle)
         *  })
         * ```
         */
        cursorBuilder?: CursorBuilderXY<CursorResultTableBackgroundType>;
        /**
         * Interface for specifying Axis X configurations that can't be changed after creation of the Axis.
         *
         * **Example usage**:
         *
         * - Configure default X Axis of chart on opposite side to default configuration (top).
         *
         * ```typescript
         *  ChartXY({
         *      defaultAxisX: {
         *          opposite: true,
         *      }
         *  })
         * ```
         *
         * - Configure default X Axis of chart as logarithmic (10 base).
         *
         * ```typescript
         *  ChartXY({
         *      defaultAxisX: {
         *          type: 'logarithmic',
         *          base: 10,
         *      }
         *  })
         * ```
         *
         * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
         *
         * List of series that support logarithmic Axes:
         * - {@link LineSeries}
         * - {@link PointSeries}
         * - {@link PointLineSeries}
         * - {@link StepSeries}
         * - {@link SplineSeries}
         * - {@link AreaSeries}
         * - {@link AreaRangeSeries}
         * - {@link OHLCSeries} (Y Axis can be logarithmic, but not X Axis)
         * - {@link RectangleSeries}
         * - {@link SegmentSeries}
         *
         * List of series that do **not** support logarithmic Axes:
         * - {@link HeatmapGridSeriesIntensityValues}
         * - {@link HeatmapScrollingGridSeriesIntensityValues}
         * - {@link PolygonSeries}
         */
        defaultAxisX?: AxisOptions;
        /**
         * Interface for specifying Axis Y configurations that can't be changed after creation of the Axis.
         *
         * **Example usage**:
         *
         * - Configure default Y Axis of chart on opposite side to default configuration (top).
         *
         * ```typescript
         *  ChartXY({
         *      defaultAxisY: {
         *          opposite: true,
         *      }
         *  })
         * ```
         *
         * - Configure default Y Axis of chart as logarithmic (10 base).
         *
         * ```typescript
         *  ChartXY({
         *      defaultAxisY: {
         *          type: 'logarithmic',
         *          base: 10,
         *      }
         *  })
         * ```
         *
         * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
         *
         * List of series that support logarithmic Axes:
         * - {@link LineSeries}
         * - {@link PointSeries}
         * - {@link PointLineSeries}
         * - {@link StepSeries}
         * - {@link SplineSeries}
         * - {@link AreaSeries}
         * - {@link AreaRangeSeries}
         * - {@link OHLCSeries} (Y Axis can be logarithmic, but not X Axis)
         * - {@link RectangleSeries}
         * - {@link SegmentSeries}
         *
         * List of series that do **not** support logarithmic Axes:
         * - {@link HeatmapGridSeriesIntensityValues}
         * - {@link HeatmapScrollingGridSeriesIntensityValues}
         * - {@link PolygonSeries}
         */
        defaultAxisY?: AxisOptions;
    }
    /**
     * Type union for possible ways to describe location of title in ChartXY.
     *
     * Use with {@link ChartXY.setTitlePosition}:
     *
     * ```
     *  // Example, place title inside series area.
     *  ChartXY.setTitlePosition(ChartXYTitlePositionOptions.SeriesCenterTop)
     *
     *  ChartXY.setTitlePosition('left-top')
     * ```
     *
     * ```
     *  // Example, align title with Y axis.
     *  ChartXY
     *      .setTitlePosition(ChartXYTitlePositionOptions.LeftTop)
     *      .setTitleMargin({ left: 60 })
     *      .getDefaultAxisY().setThickness(60)
     * ```
     * @public
     */
    export declare type ChartXYTitlePosition = EnumToStringUnion<ChartXYTitlePositionOptions>;
    /**
     * Enum for selecting position of Chart Title.
     *
     * This is currently only usable on {@link ChartXY.setTitlePosition} in {@link ChartXY}:
     *
     * ```ts
     *  ChartXY.setTitlePosition(ChartXYTitlePositionOptions.SeriesCenterBottom)
     * ```
     * @public
     */
    export declare enum ChartXYTitlePositionOptions {
        /**
         * Title horizontally centered, at the very top of the chart.
         *
         * This adds extra margin above series area, to make space for the title.
         */
        CenterTop = "center-top",
        /**
         * Title horizontally at right edge, at the very top of the chart.
         *
         * This adds extra margin above series area, to make space for the title.
         */
        RightTop = "right-top",
        /**
         * Title horizontally at left edge, at the very top of the chart.
         *
         * This adds extra margin above series area, to make space for the title.
         */
        LeftTop = "left-top",
        /**
         * Title horizontally centered, at the very bottom of the chart.
         *
         * This adds extra margin below series area, to make space for the title.
         */
        CenterBottom = "center-bottom",
        /**
         * Title horizontally at right edge, at the very bottom of the chart.
         *
         * This adds extra margin below series area, to make space for the title.
         */
        RightBottom = "right-bottom",
        /**
         * Title horizontally at left edge, at the very bottom of the chart.
         *
         * This adds extra margin below series area, to make space for the title.
         */
        LeftBottom = "left-bottom",
        /**
         * Title inside the series area, horizontally centered at the very top.
         */
        SeriesCenterTop = "series-center-top",
        /**
         * Title inside the series area, horizontally at right edge, at the very top.
         */
        SeriesRightTop = "series-right-top",
        /**
         * Title inside the series area, horizontally at left edge, at the very top.
         */
        SeriesLeftTop = "series-left-top",
        /**
         * Title inside the series area, horizontally centered, at the very bottom.
         */
        SeriesCenterBottom = "series-center-bottom",
        /**
         * Title inside the series area, horizontally at right edge, at the very bottom.
         */
        SeriesRightBottom = "series-right-bottom",
        /**
         * Title inside the series area, horizontally at left edge, at the very bottom.
         */
        SeriesLeftBottom = "series-left-bottom"
    }
    /**
     * @public
     * @beta    Introduced in v7.0.0. API may change according to user feedback.
     */
    export declare interface ChartXYUserInteractions {
        pan?: false | InteractionConfigWithOverrides<{
            sensitivity?: number;
            stopScroll?: boolean;
            x?: boolean;
            y?: boolean;
            cursor?: CSSStyleDeclaration['cursor'] | null;
        }, 'drag' | 'wheel' | 'pinch'>;
        paginate?: false | InteractionConfigWithOverrides<{
            sensitivity?: number;
            stopScroll?: boolean;
            x?: boolean;
            y?: boolean;
            forward?: {
                /**
                 * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
                 */
                code?: string;
            };
            backward?: {
                /**
                 * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
                 */
                code?: string;
            };
            cursor?: CSSStyleDeclaration['cursor'] | null;
        }, never>;
        zoom?: false | InteractionConfigWithOverrides<{
            sensitivity?: number;
            stopScroll?: boolean;
            mode?: 'toward-pointer' | 'centered' | 'keep-start' | 'keep-end';
            x?: boolean;
            y?: boolean;
            cursor?: CSSStyleDeclaration['cursor'] | null | ((zoomType: 'in' | 'out') => CSSStyleDeclaration['cursor'] | null);
        }, 'drag' | 'wheel' | 'pinch'>;
        rectangleZoom?: false | InteractionConfigWithOverrides<{
            animationsEnabled?: boolean;
            stopScroll?: boolean;
            x?: boolean;
            y?: boolean;
            /**
             * Callback function which is fired when the interaction is started.
             */
            start?: (args: {
                event: Event | undefined;
            }) => unknown;
            cursor?: CSSStyleDeclaration['cursor'] | null;
        }, never>;
        restoreDefault?: false | InteractionConfigWithOverrides<{
            singleClick?: boolean;
            doubleClick?: boolean;
            animationsEnabled?: boolean;
            stopScroll?: boolean;
            /**
             * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
             */
            code?: string;
            cursor?: CSSStyleDeclaration['cursor'] | null;
        }, never>;
        restorePrevious?: false | InteractionConfigWithOverrides<{
            singleClick?: boolean;
            doubleClick?: boolean;
            /**
             * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
             */
            code?: string;
            cursor?: CSSStyleDeclaration['cursor'] | null;
        }, never>;
        axes?: false | AxisXYUserInteractions;
        xAxis?: false | AxisXYUserInteractions;
        yAxis?: false | AxisXYUserInteractions;
    }
    /**
     * @public
     */
    export declare interface ClippableXY {
        /**
         * Configure whether rendering should be clipped to the area enclosed by its owning axes or not.
         * All rendering is ALWAYS clipped so that it doesn't leak outside the owning charts series area.
         * However, it is optional whether the rendering should be able to leak outside the owning axes viewport, which might be smaller than the charts viewport (for example, when using stacked axes).
         *
         * By default, clipping is enabled (`true`).
         *
         * ```ts
         *  // Example, disable clipping, allowing the rendering to leak outside its own axes.
         *  SeriesXY.setClipping(false)
         * ```
         *
         * @param clipping - Clipping enabled or disabled.
         * @returns     Object itself
         * @public
         */
        setClipping(clipping: boolean): this;
        /**
         * Read whether rendering should be clipped to the area enclosed by its owning axes or not.
         * All rendering is ALWAYS clipped so that it doesn't leak outside the owning charts series area.
         * However, it is optional whether the rendering should be able to leak outside the owning axes viewport, which might be smaller than the charts viewport (for example, when using stacked axes).
         *
         * By default, clipping is enabled (`true`).
         * @returns     True or false.
         * @public
         */
        getClipping(): boolean;
    }
    /**
     * Style class for describing a *color*.
     *
     * Instances of Color, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
     * but instead return a completely new modified object.
     *
     * **Color creation:**
     *
     * Create *LCJS colors* using any of the many available *factories*:
     * - {@link ColorRGBA}
     * - {@link ColorHEX}
     * - {@link ColorCSS}
     * - {@link ColorHSV}
     *
     * **Color usage:**
     *
     * *Watch out!* A common misuse is to attempt styling components directly with *color*.
     * *Color* is the lowest level style class in whole LCJS library, and is never used directly for styling components,
     * instead it must be wrapped within a more descriptive style type.
     * For example, {@link SolidFill} describes coloring with single, solid color.
     *
     * **Example usage:**
     *
     * Example 1, specifying chart title color using {@link ColorRGBA} and {@link SolidFill}
     *
     * ```typescript
     *  ChartXY.setTitleFillStyle( new SolidFill({
     *      color: ColorRGBA( 255, 0, 0 )
     *  }) )
     * ```
     *
     * Example 2, specifying line series stroke style using ColorRGBA, SolidFill and SolidLine
     *
     * ```typescript
     *  LineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({
     *          color: ColorRGBA( 255, 0, 0 )
     *      })
     *  }))
     * ```
     * @public
     */
    export declare class Color extends ColorRecord {
        /**
         * Get Uint32 representation of this Color object.
         * @returns     Number.
         */
        toUint32(): number;
        /**
         * Creates a new color that is equal to this but with a certain alpha value
         * @param alpha - Value of alpha channel [0-255]
         * @returns New Color object
         * @public
         */
        setA(alpha: number): Color;
        /**
         * Creates a new color that is equal to this but with a certain red value
         * @param red - Value of red channel [0-255]
         * @returns New Color object
         * @public
         */
        setR(red: number): Color;
        /**
         * Creates a new color that is equal to this but with a certain green value
         * @param green - Value of green channel [0-255]
         * @returns New Color object
         * @public
         */
        setG(green: number): Color;
        /**
         * Creates a new color that is equal to this but with a certain blue value
         * @param blue - Value of blue channel [0-255]
         * @returns New Color object
         * @public
         */
        setB(blue: number): Color;
        /**
         * @returns Value of alpha channel [0-255]
         * @public
         */
        getA(): number;
        /**
         * @returns Value of red channel [0-255]
         * @public
         */
        getR(): number;
        /**
         * @returns Value of green channel [0-255]
         * @public
         */
        getG(): number;
        /**
         * @returns Value of blue channel [0-255]
         * @public
         */
        getB(): number;
        /**
         * Compute a highlighted version of this Color.
         * @returns New Color object
         * @public
         */
        getHighlight(): Color;
        /**
         * Returns a slightly lighter version from a Color.
         * @returns New Color object
         * @public
         */
        getLighter(): Color;
        /**
         * Returns a slightly darker version from a Color.
         * @returns New Color object
         * @public
         */
        getDarker(): Color;
        /**
         * @returns Color string in format acceptable by CSS
         * @public
         */
        toRGBAString(): string;
    }
    /**
     * One of the many available factories for {@link Color}.
     * This variant has a single parameter that follows the *CSS* suite of describing colors.
     * Can be especially useful when tying *LightningChart JS* styling together with user front-end application CSS.
     *
     * **Example usage**:
     *
     * ```typescript
     *  const colorRed = ColorCSS('red')
     *  const colorTransparentGreen = ColorCSS('rgba(0, 255, 0, 0.5)')
     * ```
     *
     * **Supported formats:**
     *
     * Basically all commonly used CSS color syntaxes are supported, but here is a list for reference:
     *
     * - HEX ('#FF00AA')
     * - HEX with transparency ('#FF00AABB')
     * - RGBA ('rgba(132, 15, 4, 1.0)')
     * - HSL ('hsl(0,100%, 50%)')
     * - Color Name ('blue')
     *
     * For more convenience factories, see:
     * - {@link ColorRGBA}
     * - {@link ColorHEX}
     * - {@link ColorHSV}
     * - {@link ColorUint32}
     *
     * @param color - CSS string description of a color. For example, 'red'.
     * @returns *Color* object. Please refer to {@link Color} API document, on extended information how to use *LCJS Colors*.
     * @public
     */
    export declare const ColorCSS: (color: string) => Color;
    /**
     * One of the many available factories for {@link Color}.
     * This variant has a single parameter that follows the *CSS* suite of describing colors as *hexadecimal strings*.
     *
     * **Example usage**:
     *
     * ```typescript
     *  const colorRed = ColorHEX('#ff0000')
     *  const colorTransparentGreen = ColorHEX('#00ff0010')
     * ```
     *
     * **Supported formats:**
     *
     * Basically all commonly used hexadecimal color syntaxes are supported, but here is a full list:
     *
     * - '#RRGGBB'
     * - '#RRGGBBAA'
     * - '#RGB'
     * - '#RGBA'
     * - 'RRGGBB'
     * - 'RRGGBBAA'
     * - 'RGB'
     * - 'RGBA'
     * - '0xRRGGBB'
     * - '0xRRGGBBAA'
     * - '0xRGB'
     * - '0xRGBA'
     *
     * For more convenience factories, see:
     * - {@link ColorRGBA}
     * - {@link ColorCSS}
     * - {@link ColorHSV}
     * - {@link ColorUint32}
     *
     * @param hexColor - Hexadecimal value for constructing a Color. Eq. '#FF0000' = Red
     * @returns *Color* object. Please refer to {@link Color} API document, on extended information how to use *LCJS Colors*.
     * @public
     */
    export declare const ColorHEX: (hexColor: string) => Color;
    /**
     * One of the many available factories for {@link Color}.
     * This variant receives input arguments in *HSV* color space.
     * *HSV* is popular in generating smooth, looping color ranges, for example (red -\> green -\> blue -\> red).
     *
     * **Example usage**:
     *
     * ```typescript
     *  // Hue = angle of color circle where 0 deg = red, 120 deg = green, 240 deg = blue.
     *  const colorRed = ColorHSV(0)
     *  const colorYellow = ColorHSV(60)
     *
     *  // Generate a simple color palette.
     *  const colors10 = new Array(10).fill(undefined).map((_, iColor) =>
     *      // Array will receive colors starting from red, moving through green, blue and ending just before red.
     *      ColorHSV( 0 + (iColor / 10) * 360 )
     *  )
     *
     *  // 'saturation' and 'value' arguments can be supplied optionally.
     *  const colorRedDim = ColorHSV(0, 1.0, 0.5)
     * ```
     *
     * For more convenience factories, see:
     * - {@link ColorRGBA}
     * - {@link ColorHEX}
     * - {@link ColorCSS}
     * - {@link ColorUint32}
     *
     * @param hue - *Hue* value as degrees [0, 360] (0 = red, 120 = green, 240 = blue, 360 = red, and so on...).
     * @param saturation - Saturation in range [0, 1]. Defaults to 1.
     * @param value - Value in range [0, 1]. Defaults to 1.
     * @returns *Color* object. Please refer to {@link Color} API document, on extended information how to use *LCJS Colors*.
     * @public
     */
    export declare const ColorHSV: (hue: number, saturation?: number, value?: number) => Color;
    /**
     * Collection of default *Color* *PaletteFactories*.
     *
     * Items are mostly functions that take a single argument, *length*, and return a *Color* {@link Palette} of that given length.
     *
     * *Color* *Palettes* are functions that give a *Color* based on a given *index*.
     * @public
     */
    export declare const ColorPalettes: {
        warm: PaletteFactory<Color>;
        cold: PaletteFactory<Color>;
        fullSpectrum: PaletteFactory<Color>;
        reverseSpectrum: PaletteFactory<Color>;
        flatUI: PaletteFactory<Color>;
        arction: PaletteFactory<Color>;
        arctionWarm: PaletteFactory<Color>;
        sunset: PaletteFactory<Color>;
        dynamic: PaletteFactory<Color>;
        magenta: PaletteFactory<Color>;
        greyscale: PaletteFactory<Color>;
        frozen: PaletteFactory<Color>;
        retro: PaletteFactory<Color>;
        crayons: PaletteFactory<Color>;
        custom: PaletteFactory<Color>;
        sector: (start: number, end: number, saturation?: number, vibrance?: number) => PaletteFactory<Color>;
        auroraBorealis: PaletteFactory<Color>;
        blueSciFi: PaletteFactory<Color>;
        light: PaletteFactory<Color>;
        monochrome: PaletteFactory<Color>;
        night: PaletteFactory<Color>;
        sunset2: PaletteFactory<Color>;
    };
    /**
     * Interface for immutable data-structure which represents a 2-dimensional location and an associated Color.
     *
     * This can be used for Point-based series for coloring each point individually, when combined with usage of IndividualPointFill-style.
     * @public
     */
    export declare interface ColorPoint extends Point, ColorValue {
    }
    /**
     * Interface for defining an RGBA Color with channels ranging [0, 1].
     * @public
     */
    declare interface ColorProperties {
        type: 'color';
        /**
         * Red value from 0 to 1
         */
        r: number;
        /**
         * Green value from 0 to 1
         */
        g: number;
        /**
         * Blue value from 0 to 1
         */
        b: number;
        /**
         * Alpha value from 0 to 1
         */
        a: number;
    }
    /**
     * Record class for ColorProperties,
     * Used as base for Color
     * @public
     */
    declare const ColorRecord: Record_2.Factory<ColorProperties>;
    /**
     * One of the many available factories for {@link Color}. This variant receives individual values for *red*, *green*, *blue*, and optionally *alpha* channels.
     * **Input values are in range [0, 255].**
     *
     * **Example usage**:
     *
     * ```typescript
     *  // Create Color from RGB [0, 255] values (completely red).
     *  const color = ColorRGBA( 255, 0, 0 )
     *
     * // Create transparent Color.
     * const transparentColor = ColorRGBA( 255, 0, 0, 127 )
     * ```
     *
     * For more convenience factories, see:
     * - {@link ColorHEX}
     * - {@link ColorCSS}
     * - {@link ColorHSV}
     * - {@link ColorUint32}
     *
     * @param r - Red from 0 to 255
     * @param g - Green from 0 to 255
     * @param b - Blue from 0 to 255
     * @param a - Alpha from 0 to 255 (can be omitted, defaulting to 255)
     * @returns *Color* object. Please refer to {@link Color} API document, on extended information how to use *LCJS Colors*.
     * @public
     */
    export declare const ColorRGBA: (r: number, g: number, b: number, a?: number) => Color;
    /**
     * Type union of possible options for describing a 3D _color shading style_.
     *
     * Interacting with color shading styles is designed to be carried out via {@link ColorShadingStyles}.
     * @public
     */
    export declare type ColorShadingStyle = SimpleShadingStyle | PhongShadingStyle;
    /**
     * Object with different options for 3D series _color shading style_.
     *
     * Color shading style is specified with {@link Series3D.setColorShadingStyle} method.
     *
     * ```js
     *  // Example syntax, select simple color shading style.
     *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())
     * ```
     * @public
     */
    export declare const ColorShadingStyles: {
        /**
         * Simple color shading style.
         *
         * Colors each pixel exactly according to its material color.
         *
         * Colors are **not** affected by camera angle, lighting, etc.
         *
         * ```js
         *  // Example syntax, select simple color shading style.
         *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())
         * ```
         *
         * _Simple color shading_ is really fast, which can be a crucial difference especially on low end devices, like laptops and mobile phones.
         */
        Simple: typeof SimpleShadingStyle;
        /**
         * _Phong_ color shading style.
         *
         * Phong shading supports ambient and specular lighting, greatly increasing depth perception
         * capabilities.
         *
         * With Phong shading enabled, the color of each pixel is affected by angle to camera, as well as the various available
         * Phong shading properties, like light colors and reflection values.
         *
         * ```js
         *  // Example syntax, use default Phong shading.
         *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong())
         * ```
         *
         * ```js
         *  // Example syntax, use Phong shading with specific configuration.
         *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong({
         *      // Add specular reflection for "highlight" effect.
         *      specularReflection: 0.5,
         *      specularColor: ColorRGBA(255, 255, 255),
         *  }))
         * ```
         */
        Phong: typeof PhongShadingStyle;
    };
    /**
     * Interface representing a Color Stop.
     * Each ColorStop has a color and an offset.
     * @public
     */
    export declare interface ColorStop {
        /**
         * Color for the color stop.
         */
        color: Color;
        /**
         * Offset for the color stop
         */
        offset: number;
    }
    /**
     * One of the many available factories for {@link Color}.
     * This variant takes a single `number` parameter, which should be Uint32 RGBA value, where Red channel is least significant byte.
     *
     * **Example usage**:
     *
     * ```typescript
     *  const colorGreenOpaque = ColorUint32(0xff00ff00)
     * ```
     *
     * For more convenience factories, see:
     * - {@link ColorRGBA}
     * - {@link ColorHEX}
     * - {@link ColorHSV}
     * - {@link ColorCSS}
     *
     * @param uint32 - Single number which is Uint32, 4 bytes each is 1 color channel in order RGBA, where red is least significant byte.
     * @returns *Color* object. Please refer to {@link Color} API document, on extended information how to use *LCJS Colors*.
     * @public
     */
    export declare const ColorUint32: (uint32: number) => Color;
    /**
     * Interface for immutable data-structure which contains a color property.
     *
     * Can be used for individual data point coloring when styled with {@link IndividualPointFill}.
     *
     * For some series types, individual data point coloring might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     * @public
     */
    export declare interface ColorValue {
        /**
         * Data point color.
         *
         * Can be used for individual data point coloring when styled with {@link IndividualPointFill}.
         *
         * For some series types, individual data point coloring might have to be explicitly enabled when the series is created.
         * Refer to series documentation for more detailed information.
         */
        readonly color?: Color;
    }
    /**
     * Readonly configuration parameters that apply to all components.
     * @public
     */
    export declare interface CommonChartOptions {
        /**
         * Convenience flag that can be used to enable/disable all animations in a component.
         */
        animationsEnabled?: boolean;
        /**
         * Configuration for the chart legend.
         */
        legend?: LegendOptions & {
            customLegend?: LegendLogic;
        };
    }
    /**
     * Interface for component that can draw effects around it, such as glows and drop shadows.
     * @public
     */
    declare interface ComponentWithEffects {
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getEffect(): boolean;
    }
    /**
     * Axis Highlighter that highlights a single position on the Axis.
     * @public
     */
    export declare class ConstantLine extends Highlighter {
        /**
         * Set value of ConstantLine. This is in values of its owning Axis.
         * @param value - Value on Axis.
         * @returns Object itself for fluent interface.
         * @public
         */
        setValue(value: number): this;
        /**
         * Get value of ConstantLine. This is in values of its owning Axis.
         * @returns Value on Axis.
         * @public
         */
        getValue(): number;
        /**
         * Set stroke style of ConstantLine.
         *
         * Supported line styles:
         * - {@link SolidLine}
         * - {@link DashedLine}
         * - {@link emptyLine}
         *
         * Example usage:
         *```javascript
         * // Specified LineStyle
         * ConstantLine.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
         * // Changed thickness
         * ConstantLine.setStrokeStyle((solidLine) => solidLine.setThickness(5))
         * ```
         *
         * Supported line styles:
         * - {@link SolidLine}
         * - {@link DashedLine}
         * - {@link emptyLine}
         *
         *
         * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
         * @returns Chart itself
         * @public
         */
        setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style of ConstantLine.
         * @returns Normal StrokeStyle
         * @public
         */
        getStrokeStyle(): LineStyle;
        /**
         * Configure user interactions from a set of preset options.
         *
         * Without any explicit configuration, the charts select the default user interaction scheme based on available information,
         * such as axis types, attached series and data supplied to series.
         *
         * The `setUserInteraction` methods allow explicitly configuring the used interaction scheme.
         *
         * ```ts
         *  // Example, disable default interactions
         *  constant.setUserInteractions(undefined)
         * ```
         *
         * ```ts
         *  // Example, move only with Control down
         *  constant.setUserInteractions({
         *      move: {
         *          drag: false,
         *          ctrl: { drag: true }
         *      }
         *  })
         * ```
         *
         * @param   config -    Option with any set of properties of {@link ConstantLineInteractions} or `undefined` to disable all interactions.
         * @returns     Object itself.
         * @public
         * @beta    Introduced in v7.0.0. API may change according to user feedback.
         */
        setUserInteractions(config: Partial<ConstantLineInteractions> | undefined): this;
        /**
         * Get currently active user interaction scheme.
         * This does NOT return the last value supplied to {@link setUserInteractions}.
         * Rather, it considers the current structure of the chart, all built-in defaults as well as overrides supplied by the user
         * and returns the currently used interaction scheme.
         *
         * @returns     ConstantLineInteractions
         * @public
         * @beta    Introduced in v7.0.0. API may change according to user feedback.
         */
        getUserInteractions(): ConstantLineInteractions;
        addEventListener<K extends keyof ConstantLineEventMap>(type: K, listener: (event: ConstantLineEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof ConstantLineEventMap>(type: K, listener: (event: ConstantLineEventMap[K], info: unknown) => unknown): void;
    }
    /**
     * Interface of events trackable by {@link ConstantLine.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface ConstantLineEventMap extends ChartComponentEventMap {
        /**
         * Event fired when the ConstantLine value (position) changes
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('valuechange', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        valuechange: ConstantLineValueChangeEvent;
    }
    /**
     * @public
     * @beta    Introduced in v7.0.0. API may change according to user feedback.
     */
    export declare interface ConstantLineInteractions {
        move?: false | InteractionConfigWithOverrides<{}, 'drag'>;
    }
    /**
     * @public
     */
    export declare interface ConstantLineValueChangeEvent {
        value: number;
    }
    /**
     * @public
     */
    export declare interface ContourConfiguration {
        showLabels?: boolean;
        levels: Array<ContourLevel>;
        shadows?: Color | null;
    }
    /**
     * Translated Jason Davies' JavaScript version to TypeScript in 2015.
     * Erik Vullings
     *
     * Copyright (c) 2010, Jason Davies.
     *
     * All rights reserved.  This code is based on Bradley White's Java version,
     * which is in turn based on Nicholas Yue's C++ version, which in turn is based
     * on Paul D. Bourke's original Fortran version.  See below for the respective
     * copyright notices.
     *
     * See http://paulbourke.net/papers/conrec for the original
     * paper by Paul D. Bourke.
     *
     * The vector conversion code is based on http://apptree.net/conrec.htm by
     * Graham Cox.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *     * Redistributions of source code must retain the above copyright
     *       notice, this list of conditions and the following disclaimer.
     *     * Redistributions in binary form must reproduce the above copyright
     *       notice, this list of conditions and the following disclaimer in the
     *       documentation and/or other materials provided with the distribution.
     *     * Neither the name of the <organization> nor the
     *       names of its contributors may be used to endorse or promote products
     *       derived from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
     * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
     * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
     * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    /**
     * @public
     */
    export declare interface ContourLevel {
        value: number;
        strokeStyle?: LineStyle;
        label?: string;
        labelFont?: Partial<FontProperties> | FontSettings;
        labelColor?: Color;
    }
    /**
     * Interface to update contour lines.
     * @public
     */
    export declare interface ContourLines {
        /**
         * Set contour lines.
         *
         * ```ts
         *  // Example syntax
         *  heatmap.setContours({
         *      levels: [
         *          { value: 10 },
         *          {
         *              value: 40,
         *              label: 'Hey',
         *              labelFont: { family: 'Courier' },
         *              labelColor: ColorRGBA(255, 0, 0),
         *              strokeStyle: new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(0, 0, 0) }) })
         *          }
         *      ]
         *  })
         * ```
         * @param   config - Contour config
         * @returns Object itself.
         * @public
         */
        setContours(config: ContourConfiguration | undefined): this;
        /**
         * Get contour lines configuration.
         * @returns Contour config
         * @public
         */
        getContours(): ContourConfiguration | undefined;
    }
    /**
     * Convenience function for configuring heatmap contours display to match a LUT object.
     *
     * ```ts
     *  // Example usage
     *  heatmap.setContours(contoursFromLUT(lut))
     * ```
     * @param lut -     LUT object
     * @param customizeLevel -  Optional callback to apply overrides to created contour levels
     * @returns     Contour configuration
     * @public
     */
    export declare const contoursFromLUT: (lut: LUT, customizeLevel?: ((level: ContourLevel, step: LUTStep) => ContourLevel) | undefined) => ContourConfiguration;
    /**
     * Abstract super class for a Control.
     * Meaning a stand-alone Charting component, which owns a rendering Engine.
     * Eq. Panel, Dashboard, ...
     * @public
     */
    export declare interface Control extends Disposable, DisposableEvents {
        /**
         * Public, safe interface of rendering engine.
         * @public
         */
        readonly engine: PublicEngine;
        /**
         * Selector for "relative" _Coordinate System_.
         *
         * This coordinate system is relative to the bottom left corner of the Control (chart/dashboard/etc.), and is measured as pixels.
         * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from bottom.
         *
         * This selector can be used for two purposes:
         *
         * **Positioning LCJS UI elements in pixels:**
         *
         * ```ts
         *  // Position UI element in pixels by supplying `Control.coordsRelative` as its positioning system.
         *  const textBox = Control.addUIElement(UIElementBuilders.TextBox, Control.coordsRelative)
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 100, y: 20 })
         * ```
         *
         * **Translations between coordinate systems:**
         *
         * Use with {@link translateCoordinate} method to translate coordinates from "relative" to another coordinate system.
         *
         * @public
         */
        readonly coordsRelative: CoordinateSystemRelative;
        /**
         * Selector for "client" _Coordinate System_.
         *
         * This references the coordinate system used in HTML.
         * It starts at top left of the web page and is measured in pixels.
         * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
         *
         * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
         *
         * This selector can be used for translating client coordinates to other coordinate systems and vice versa.
         * For example, in order to:
         * - Position LCJS UI elements in client coordinates
         * - Find client coordinate that matches a location along LCJS Axis or Chart.
         * - etc.
         *
         * See {@link translateCoordinate} for more detailed use case information and example usage.
         *
         * @public
         */
        readonly coordsClient: CoordinateSystemClient;
        /**
         * Get size of control as pixels.
         *
         * For stand-alone component, the size will be equal to the size of its containing HTML \<div\> (`Control.engine.container`)
         *
         * For component inside Dashboard, the size will only include the component itself, so size can be less than the size of containing HTML \<div\>.
         *
         * @returns     Object with x and y properties `{ x: number, y: number }`, where both are pixel values.
         * @public
         */
        getSizePixels(): Point;
        /**
         * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
         *
         * ```ts
         *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
         *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
         *  // locationRelative is in pixels relative to bottom left corner of the chart
         * ```
         *
         * Relative coordinates can be used for positioning LightningChart JS UI components:
         *
         * ```ts
         *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
         *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 20, y: 20 })
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         */
        translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
        /**
         * Translate a coordinate from relative control coordinates to HTML client coordinate system.
         *
         * ```ts
         *  // 10 pixels left and 20 pixels up from controls bottom left corner
         *  const locationRelative = { x: 10, y: 20 }
         *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
         * ```
         *
         * Client coordinates can be used to absolute position HTML elements using CSS, for example.
         *
         * ```ts
         *  myHTMLElement.style.position = 'absolute'
         *  myHTMLElement.style.left = locationClient.clientX
         *  myHTMLElement.style.top = locationClient.clientY
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         */
        translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
        /**
         * Add a stand-alone *UIElement* using a *builder*.
         *
         * **Example usage:**
         *
         * 1) TextBox with default positioning coordinate system.
         *
         * ```typescript
         *  addUIElement( UIElementBuilders.TextBox )
         *      // Position = [0, 100] as percentages.
         *      .setPosition({ x: 50, y: 50 })
         * ```
         *
         * 2) Position in pixel coordinate system.
         *
         * ```typescript
         *  addUIElement( UIElementBuilders.TextBox, chart.coordsRelative )
         *      // Position = pixels.
         *      .setPosition({ x: 300, y: 100 })
         * ```
         *
         * 3) Position on Axes.
         *
         * ```typescript
         *  addUIElement( UIElementBuilders.TextBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
         *      // Position = Axis values.
         *      .setPosition({ x: 5, y: 5 })
         * ```
         *
         * @typeParam UIElementType - Type of *UIElement* that is specified by 'builder'-*parameter*.
         *
         * @param builder - *UIElementBuilder*. If omitted, *TextBoxBuilder* will be selected. Use {@link UIElementBuilders} for selection.
         * @param scale - Optional parameter for altering the coordinate system used for positioning the UIElement. Defaults to whole component in percentages [0, 100].
         * @returns Object that fulfills *interfaces*:  *UIElementType* (typeparam) and *UIElement*
         * @public
         */
        addUIElement<UIElementType extends UIPart = UITextBox>(uiElementBuilder?: UIElementBuilder<UIElementType>, scale?: UserScaleDefinition): UIElementType & UIElement;
        /**
         * Capture rendered state in an image file. Prompts the browser to download the created file.
         *
         * **NOTE: The download might be blocked by browser/plugins as harmful.**
         * To prevent this, only call the method in events tied to user-interactions.
         * From mouse-event handlers, for example.
         *
         * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
         * For supported image formats, compression quality, Etc. refer to:
         *
         * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
         *
         * Example usage:
         *```javascript
         * // Download 'screenshot.png'
         * saveToFile('screenshot')
         * // Attempt download 'maybeNotSupported.bmp'
         * saveToFile('maybeNotSupported', 'image/bmp')
         * // Attempt download jpeg.file with specified compression quality
         * saveToFile('fileName', 'image/jpeg', 0.50)
         * ```
         *
         * @remarks              **If 'type' is not supported by browser, an Error will be thrown.**
         *
         * @param fileName - Name of prompted download file as string. **File extension shouldn't be included**
         *                          as it is automatically detected from 'type'-argument.
         * @param type - A DOMString indicating the image format. The default format type is image/png.
         * @param encoderOptions - A Number between 0 and 1 indicating the image quality to use for image formats
         *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
         *                          the default value for image quality is used. The default value is 0.92.
         * @public
         */
        saveToFile(fileName: string, type?: string, encoderOptions?: number): this;
        /**
         * Returns the Theme currently being used.
         * @returns An object containing the Theme.
         * @public
         */
        getTheme(): Theme;
    }
    /**
     * Interface for a data-structure which represents a 3-dimensional location.
     *
     * **Required properties:**
     *
     * - {@link Coord3D.x} | coordinate along X Axis.
     * - {@link Coord3D.y} | coordinate along Y Axis.
     * - {@link Coord3D.z} | coordinate along Z Axis.
     * @public
     */
    export declare interface Coord3D {
        /**
         * Location in X-dimension.
         */
        readonly x: number;
        /**
         * Location in Y-dimension.
         */
        readonly y: number;
        /**
         * Location in Z-dimension.
         */
        readonly z: number;
    }
    /**
     * Interface for a ambiguous 3D coordinate.
     * Ambiguous meaning that it doesn't explicitly tell which coordinate system it belongs to.
     *
     * Intended to be used with {@link Chart3D.translateCoordinate}.
     * @public
     */
    export declare type Coordinate3D = {
        x: number;
        y: number;
        z: number;
    };
    /**
     * Interface for a coordinate in Bar chart coordinate system
     *
     * Here, coordinates are described with a combination of "category index" and "value".
     * For example, `{ iCategory: 0, value: 10 }` describes the coordinate at `10` along Value Axis and the **center** of the first category bar.
     *
     * Intended to be used with {@link BarChart.translateCoordinate}.
     * @public
     */
    export declare type CoordinateBarChart = {
        iCategory: number;
        value: number;
    };
    /**
     * Interface for a coordinate in HTML client coordinate system.
     *
     * This references the coordinate system used in HTML.
     * It starts at top left of the web page and is measured in pixels.
     * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
     *
     * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
     *
     * ```ts
     *  // Example of a CoordinateClient
     *  const coordinateClient = { clientX: 45, clientY: 10 }
     * ```
     *
     * Intended to be used with {@link Control.translateCoordinate}.
     * @public
     */
    export declare type CoordinateClient = {
        clientX: number;
        clientY: number;
    };
    /**
     * Interface for a coordinate in {@link PolarChart}.
     *
     * Polar coordinates are specified as a combination of `amplitude` and `angle`.
     * Their location on the web page depends on the location of the {@link PolarChart} as well as the interval of its Axes.
     *
     * ```ts
     *  // Example of a PolarCoordinate
     *  const polarCoordinate = { angle: 45, amplitude: 10 }
     * ```
     *
     * Intended to be used with {@link PolarChart.translateCoordinate}.
     * @public
     */
    export declare type CoordinatePolar = PolarPoint;
    /**
     * Type definition for describing a Coordinate System along an X and Y axis.
     *
     * Mainly related to {@link ChartXY.translateCoordinate}.
     *
     * Axis coordinates are specified as X and Y numbers.
     * Their location on the web page depends on the location of the {@link ChartXY} as well as the interval of its Axes.
     *
     * ```ts
     *  // Example of an Axis coordinate
     *  const axisCoordinate = { x: 45, y: 10 }
     * ```
     *
     * An Axis coordinate system can be specified in two ways:
     *
     * **(1) Select the default X and Y axes with a quick convenience selector:**
     *
     * ```ts
     *  ChartXY.translateCoordinate({ x: 0, y: 0 }, chart.coordsAxis, chart.coordsClient)
     * ```
     *
     * **(2) Specify arbitrary pair of X and Y Axes:**
     *
     * ```ts
     *  ChartXY.translateCoordinate({ x: 0, y: 0 }, { x: myAxisX, y: chart.getDefaultAxisX() }, chart.coordsClient)
     * ```
     *
     *
     * @public
     */
    export declare type CoordinateSystemAxis = {
        x: Axis;
        y: Axis;
    };
    /**
     * Type definition for selector of bar chart coordinate system.
     *
     * Here, coordinates are described with a combination of "category index" and "value".
     * For example, `{ iCategory: 0, value: 10 }` describes the coordinate at `10` along Value Axis and the **center** of the first category bar.
     *
     * By using {@link BarChart.translateCoordinate} method, client coordinates can be translated to other coordinate systems and vice versa.
     * For example, in order to:
     * - Position LCJS UI elements in relative to Bar locations.
     * - Find client coordinate relative to a Bar, for example to position external HTML content above them.
     * - etc.
     *
     * Users should not need to reference this type directly.
     * Instead, the convenience selector {@link BarChart.coordsBars} should be used.
     *
     * @public
     */
    export declare type CoordinateSystemBarChart = 'barChart';
    /**
     * Type definition for selector of HTML client coordinate system.
     *
     * This references the coordinate system used in HTML.
     * It starts at top left of the web page and is measured in pixels.
     * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
     *
     * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
     *
     * ```ts
     *  // Example of a CoordinateClient
     *  const coordinateClient = { clientX: 45, clientY: 10 }
     * ```
     *
     * By using {@link Control.translateCoordinate} method, client coordinates can be translated to other coordinate systems and vice versa.
     * For example, in order to:
     * - Position LCJS UI elements in client coordinates
     * - Find client coordinate that matches a location along LCJS Axis or Chart.
     * - etc.
     *
     * Users should not need to reference this type directly.
     * Instead, the convenience selector {@link Control.coordsClient} should be used.
     *
     * @public
     */
    export declare type CoordinateSystemClient = 'client';
    /**
     * Interface for a description of 3D coordinate system.
     *
     * Used with {@link Chart3D.translateCoordinate}.
     *
     * This should not be used directly. Instead, you should reference one of following properties:
     * - {@link Chart3D.coordsAxis}
     * - {@link Chart3D.coordsWorld}
     *
     * @public
     */
    export declare type CoordinateSystemDefinition3D = {
        id: 'world';
        chart: Chart3D;
    } | {
        id: 'axes';
        chart: Chart3D;
    };
    /**
     * Interface for a description of Polar coordinate system.
     *
     * Mainly related to {@link PolarChart.translateCoordinate}.
     *
     * Users should not need to reference this type directly.
     * Instead, the convenience selector {@link PolarChart.coordsAxis} should be used.
     *
     * Polar coordinates are specified as a combination of `amplitude` and `angle`.
     * Their location on the web page depends on the location of the {@link PolarChart} as well as the interval of its Axes.
     *
     * ```ts
     *  // Example of a PolarCoordinate
     *  const polarCoordinate = { angle: 45, amplitude: 10 }
     * ```
     *
     * @public
     */
    export declare type CoordinateSystemPolar = {
        axisAmplitude: PolarAxisAmplitude;
        axisRadial: PolarAxisRadial;
    };
    /**
     * Type definition for selector of relative coordinate system.
     *
     * This coordinate system is relative to the bottom left corner of the Control (chart/dashboard/etc.), and is measured as pixels.
     * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from bottom.
     *
     * ```ts
     *  // Example of a CoordinateRelative
     *  const coordinateRelative = { x: 45, y: 10 }
     * ```
     *
     * By using {@link Control.translateCoordinate} method, relative coordinates can be translated to other coordinate systems and vice versa.
     * For example, in order to:
     * - Position LCJS UI elements in pixels relative to control.
     * - Find locations expressed with other coordinate systems relative to the control.
     * - etc.
     *
     * Users should not need to reference this type directly.
     * Instead, the convenience selector {@link Control.coordsRelative} should be used.
     *
     * @public
     */
    export declare type CoordinateSystemRelative = 'relative';
    /**
     * Interface for an ambiguous coordinate with X and Y properties.
     * Ambiguous meaning that it doesn't explicitly tell which coordinate system it belongs to.
     *
     * Intended to be used with {@link Control.translateCoordinate}.
     * @public
     */
    export declare type CoordinateXY = {
        x: number;
        y: number;
    };
    /**
     * Data structure of a **country**.
     * @public
     */
    export declare interface Country {
        /**
         * Name of the country. Eq. 'Finland'. This is case insensitive.
         *
         * Roughly follows the [M49 standard](https://unstats.un.org/unsd/methodology/m49/).
         */
        name: string;
        /**
         * ISO_A3 code of the country. Eq. 'FIN'. This is case insensitive.
         *
         * Roughly follows the [M49 standard](https://unstats.un.org/unsd/methodology/m49/).
         */
        ISO_A3: string;
    }
    /**
     * Type definition for different configurations of 3D culling.
     *
     * Culling means skipping drawing of specific geometry parts, based on its orientation.
     *
     * `'disabled'` -\> full geometry is drawn.
     *
     * `'cull-back'` -\> the behind of geometry is **not** drawn.
     *
     * `'cull-front'` -\> the front of geometry is **not** drawn.
     * @public
     */
    export declare type CullMode3D = 'disabled' | 'cull-back' | 'cull-front';
    /**
     * @public
     */
    export declare class Cursor2D<ResultTableBackgroundType extends UIBackground = UIBackground> extends AbstractCursor<CursorPosition2D, ResultTableBackgroundType> {
        /**
         * Set cursor position.
         * @param   cursorPositions -   Cursor position.
         * @returns                     Object itself.
         * @public
         */
        setPosition(...cursorPositions: CursorPosition2D[]): this;
    }
    /**
     * @public
     */
    export declare class Cursor3D<ResultTableBackgroundType extends UIBackground = UIBackground> extends AbstractCursor<CursorPosition3D, ResultTableBackgroundType> {
        /**
         * Modify cursor ticks along X axis.
         * This covers elements like:
         * - gridlines
         * - ticklines
         * - label
         * - label background
         *
         * ```ts
         *  // Example syntax
         *  cursor.setTickX((tick) => tick
         *      .setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(255, 0,0 ) }))
         *  )
         * ```
         *
         * For available APIs refer to {@link CustomTick3D}.
         *
         * @param   callback -  Callback function that modifies the tick object(s).
         * @returns     Object itself.
         * @public
         */
        setTickX(callback: Mutator<CustomTick3D>): this;
        /**
         * Modify cursor ticks along Y axis.
         * This covers elements like:
         * - gridlines
         * - ticklines
         * - label
         * - label background
         *
         * ```ts
         *  // Example syntax
         *  cursor.setTickY((tick) => tick
         *      .setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(255, 0,0 ) }))
         *  )
         * ```
         *
         * For available APIs refer to {@link CustomTick3D}.
         *
         * @param   callback -  Callback function that modifies the tick object(s).
         * @returns     Object itself.
         * @public
         */
        setTickY(callback: Mutator<CustomTick3D>): this;
        /**
         * Modify cursor ticks along Z axis.
         * This covers elements like:
         * - gridlines
         * - ticklines
         * - label
         * - label background
         *
         * ```ts
         *  // Example syntax
         *  cursor.setTickZ((tick) => tick
         *      .setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(255, 0,0 ) }))
         *  )
         * ```
         *
         * For available APIs refer to {@link CustomTick3D}.
         *
         * @param   callback -  Callback function that modifies the tick object(s).
         * @returns     Object itself.
         * @public
         */
        setTickZ(callback: Mutator<CustomTick3D>): this;
        /**
         * Modify cursor ticks along every axis.
         * This covers elements like:
         * - gridlines
         * - ticklines
         * - label
         * - label background
         *
         * ```ts
         *  // Example syntax
         *  cursor.setTicks((tick) => tick
         *      .setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(255, 0,0 ) }))
         *  )
         * ```
         *
         * For available APIs refer to {@link CustomTick3D}.
         *
         * @param   callback -  Callback function that modifies the tick object(s).
         * @returns     Object itself.
         * @public
         */
        setTicks(callback: Mutator<CustomTick3D>): this;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Set position of the Cursor.
         * @param   positions -  CursorPosition3D
         * @returns     Object itself.
         * @public
         */
        setPosition(...positions: CursorPosition3D[]): this;
    }
    /**
     * @public
     */
    export declare class CursorBuilder2D<ResultTableBackgroundType extends UIBackground = UIBackground> {
        /**
         * Create new CursorBuilder with an additional styler.
         * @param cursorStyler - Cursor styler function
         * @returns CursorBuilder of same type
         * @public
         */
        addStyler: (cursorStyler: CursorStyler<Cursor2D<ResultTableBackgroundType>>) => CursorBuilder2D<ResultTableBackgroundType>;
        /**
         * Create new CursorBuilder with a different ResultTable Background.
         * @param resultTableBackgroundConstructor - Constructor for Background
         * @returns CursorBuilder of same type
         * @public
         */
        setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackgroundConstructor: BackgroundConstructor<T>) => CursorBuilder2D<T>;
    }
    /**
     * @public
     */
    export declare class CursorBuilder3D<ResultTableBackgroundType extends UIBackground = UIBackground> {
        /**
         * Create new CursorBuilder with an additional styler.
         * @param cursorStyler - Cursor styler function
         * @returns CursorBuilder of same type
         * @public
         */
        addStyler: (cursorStyler: CursorStyler<Cursor3D<ResultTableBackgroundType>>) => CursorBuilder3D<ResultTableBackgroundType>;
        /**
         * Create new CursorBuilder with a different ResultTable Background.
         * @param resultTableBackgroundConstructor - Constructor for Background
         * @returns CursorBuilder of same type
         * @public
         */
        setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackgroundConstructor: BackgroundConstructor<T>) => CursorBuilder3D<T>;
    }
    /**
     * Collection of *CursorBuilders*.
     *
     * *CursorBuilder*s are used to modify structure of *Cursor*s of *Chart*s, by passing one when the *Chart* is created.
     *
     * Each item is associated with a specific *Chart*-type, that it can only be used with.
     * @public
     */
    export declare const CursorBuilders: {
        /**
         * *CursorBuilder* for {@link ChartXY}.
         *
         * Used to modify structure of *Cursor*, by passing one when creating a {@link ChartXY}.
         */
        XY: CursorBuilderXY;
        /**
         * *CursorBuilder* for {@link SpiderChart}.
         *
         * Used to modify structure of *Cursor*, by passing one when creating a {@link SpiderChart}.
         */
        Spider: CursorBuilder2D;
        /**
         * *CursorBuilder* for {@link BarChart}.
         *
         * Used to modify structure of *Cursor*, by passing one when creating a {@link BarChart}.
         */
        BarChart: CursorBuilder2D;
        /**
         * *CursorBuilder* for {@link MapChart}.
         *
         * Used to modify structure of *Cursor*, by passing one when creating a {@link MapChart}.
         */
        Map: CursorBuilder2D;
        /**
         * *CursorBuilder* for {@link PolarChart}.
         *
         * Used to modify structure of *Cursor*, by passing one when creating a {@link PolarChart}.
         */
        Polar: CursorBuilder2D;
        /**
         * *CursorBuilder* for {@link Chart3D}.
         *
         * Used to modify structure of *Cursor*, by passing one when creating a {@link Chart3D}.
         */
        D3: CursorBuilder3D;
    };
    /**
     * @public
     */
    export declare class CursorBuilderXY<ResultTableBackgroundType extends UIBackground = UIBackground> {
        /**
         * Create new CursorBuilder with an additional styler.
         * @param cursorStyler - Cursor styler function
         * @returns CursorBuilder of same type
         * @public
         */
        addStyler: (cursorStyler: CursorStyler<CursorXY<ResultTableBackgroundType>>) => CursorBuilderXY<ResultTableBackgroundType>;
        /**
         * Create new CursorBuilder with a different ResultTable Background.
         * @param resultTableBackgroundConstructor - Constructor for Background
         * @returns CursorBuilder of same type
         * @public
         */
        setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackgroundConstructor: BackgroundConstructor<T>) => CursorBuilderXY<T>;
    }
    /**
     * API syntax for specifying dynamic behavior for cursors.
     * @public
     */
    export declare type CursorDynamicBehavior = undefined | {
        pointMarkerFill?: (dataColor: Color) => FillStyle;
        pointMarkerStroke?: (dataColor: Color) => LineStyle;
        pointMarkerSize?: (dataPointSize: number) => {
            x: number;
            y: number;
        };
        matchPointMarkerShape?: boolean;
    };
    /**
     * Callback function which is used to specify text and other content displayed in cursor result tables.
     * Receives 3 parameters:
     * 1. reference to owning chart
     * 2. generic `SolveResult` object that contains information about the pointed data
     * 3. list of `SolveResult` objects in case of `"show-all"` behavior
     *
     * In order to use series specific data properties (e.g. Heatmap sample "intensity"),
     * you should use type guards to assert the type of the `SolveResult`:
     *
     * ```ts
     *  // Example of using type guard in cursor formatter
     *  Chart.setCursorFormatting((chart, hit, hits) => {
     *      if (!isHitHeatmap(hit)) return undefined
     *      return [hit.intensity.toFixed(1)]
     *  })
     * ```
     * @public
     */
    export declare type CursorFormatter<ChartType extends ChartWithCursor, SolveResultType extends SolveResult> = (chart: ChartType, hit: SolveResultType, hits: SolveResultType[]) => ResultTableContent;
    /**
     * @public
     */
    export declare type CursorFormatterBarChart = CursorFormatter<BarChart, SolveResultBar>;
    /**
     * @public
     */
    export declare type CursorFormatterChart3D = CursorFormatter<Chart3D, SolveResult3D>;
    /**
     * @public
     */
    export declare type CursorFormatterChartXY = CursorFormatter<ChartXY, SolveResultXY>;
    /**
     * @public
     */
    export declare type CursorFormatterFunnelChart = CursorFormatter<FunnelChart, SolveResultFunnelChart>;
    /**
     * @public
     */
    export declare type CursorFormatterMapChart<SelectedMapType extends MapType = MapType> = CursorFormatter<MapChart, SolveResultMap<SelectedMapType>>;
    /**
     * @public
     */
    export declare type CursorFormatterParallelCoordinateChart = CursorFormatter<ParallelCoordinateChart, SolveResultParallelCoordinate>;
    /**
     * @public
     */
    export declare type CursorFormatterPieChart = CursorFormatter<PieChart, SolveResultPieChart>;
    /**
     * @public
     */
    export declare type CursorFormatterPolarChart = CursorFormatter<PolarChart, SolveResultPolar>;
    /**
     * @public
     */
    export declare type CursorFormatterPyramidChart = CursorFormatter<PyramidChart, SolveResultPyramidChart>;
    /**
     * Type definition for series specific cursor formatting override.
     * Used with {@link Series2D.setCursorFormattingOverride}
     * @public
     */
    export declare type CursorFormatterSeriesOverride<SolveResultType> = (hit: SolveResultType, before: ResultTableCellContent[][]) => ResultTableCellContent[][];
    /**
     * @public
     */
    export declare type CursorFormatterSpiderChart = CursorFormatter<SpiderChart, SolveResultSpider>;
    /**
     * @public
     */
    export declare type CursorFormatterTreeMapChart = CursorFormatter<TreeMapChart, SolveResultTreeMapChart>;
    /**
     * @public
     */
    declare interface CursorPosition2D extends AbstractCursorPosition {
        pointMarker: Point;
        pointMarkerScale: UserScaleDefinition;
    }
    /**
     * @public
     */
    export declare interface CursorPosition3D extends AbstractCursorPosition {
        axisLocation: Coord3D;
    }
    /**
     * @public
     */
    declare interface CursorPositionXY extends AbstractCursorPosition {
        pointMarker: Point;
        pointMarkerScale: {
            x: Axis;
            y: Axis;
        };
    }
    /**
     * Mutator function that is used for modifying a Cursor during runtime.
     * @public
     */
    export declare type CursorStyler<T extends AbstractCursor> = (cursor: T, theme: Theme) => unknown;
    /**
     * @public
     */
    export declare interface CursorTargetChangedEvent<T extends SolveResult> {
        hit: T | undefined;
        hits: T[] | undefined;
        mouseLocation: CoordinateClient;
    }
    /**
     * @public
     */
    export declare class CursorXY<ResultTableBackgroundType extends UIBackground = UIBackground> extends AbstractCursor<CursorPositionXY, ResultTableBackgroundType> {
        /**
         * Extended auto fit configuration; if true considers cursor "out of scale" if result table bounds
         * go outside currently nearest pointed AXIS bounds.
         * This is specifically intended for stacked axis use cases that utilize HTML interop
         * (meaning there is some HTML content that can block the cursor from being visible)
         */
        protected _keepCursorWithinPointedAxisBounds: boolean;
        /**
         * Method that allows enabling a secondary cursor auto fit behavior.
         * Normally, auto fitting tries to keep the cursor result table within the boundaries of the whole chart.
         *
         * By enabling this alternate behavior, the cursor will try to keep result table within the boundaries of pointed axes.
         * This means, for example:
         * - Result table will not extend further than axis area.
         * - If there are gaps between axes, result table will try to stay outside them. This is important if there is external HTML content positioned in those gaps, for example.
         *
         * ```ts
         *  // Example syntax
         *  chart.setCursor(cursor => cursor
         *      .setKeepWithinAxisBoundaries(true)
         *  )
         * ```
         *
         * @param state - Boolean
         * @returns Object itself.
         * @public
         * @beta Introduced in v6.1. May change according to user feedback.
         */
        setKeepWithinAxisBoundaries(state: boolean): this;
        /**
         * @public
         * @beta Introduced in v6.1. May change according to user feedback.
         */
        getKeepWithinAxisBoundaries(): boolean;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Set cursor position.
         * @param   cursorPositions -   Cursor position.
         * @returns                     Object itself.
         * @public
         */
        setPosition(...cursorPositions: CursorPositionXY[]): this;
        /**
         * Configure whether tick markers allocate space on Axis or not.
         * Defaults to false to prevent cursor visibility from changing chart layout.
         *
         * @param state - Boolean.
         * @returns     Object itself.
         * @public
         */
        setTickMarkersAllocateAxisSpace(state: boolean): this;
        /**
         * Configure whether tick markers allocate space on Axis or not.
         * Defaults to false to prevent cursor visibility from changing chart layout.
         *
         * @param state - Boolean.
         * @returns     Object itself.
         * @public
         */
        getTickMarkersAllocateAxisSpace(): boolean;
        /**
         * Set is GridStrokeX cut at cursor location.
         * @param cut - Boolean flag
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeXCut(cut: boolean): this;
        /**
         * Get is GridStrokeX cut at cursor location.
         * @returns Boolean flag
         * @public
         */
        getGridStrokeXCut(): boolean;
        /**
         * Set is GridStrokeY cut at cursor location.
         * @param cut - Boolean flag
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeYCut(cut: boolean): this;
        /**
         * Get is GridStrokeY cut at cursor location.
         * @returns Boolean flag
         * @public
         */
        getGridStrokeYCut(): boolean;
        /**
         * Set style of x gridstroke
         * @param value - LineStyle object
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeXStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of x gridstroke
         * @returns LineStyle of gridstroke
         * @public
         */
        getGridStrokeXStyle(): LineStyle;
        /**
         * Set lineStyle of y gridstroke
         * @param lineStyle - LineStyle object
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeYStyle(lineStyle: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of y gridstroke
         * @returns LineStyle of gridstroke
         * @public
         */
        getGridStrokeYStyle(): LineStyle;
        /**
         * Set tick marker X visible or not.
         *
         * @param   visible  -   Tick marker X visible?
         * @returns              Object itself
         * @public
         */
        setTickMarkerXVisible(visible: boolean): this;
        /**
         * Get tick marker X visible or not.
         *
         * @returns              Boolean.
         * @public
         */
        getTickMarkerXVisible(): boolean;
        /**
         * Set tick marker Y visible or not.
         *
         * @param   visible   -  Tick marker Y visible?
         * @returns              Object itself
         * @public
         */
        setTickMarkerYVisible(visible: boolean): this;
        /**
         * Get tick marker Y visible or not.
         *
         * @returns              Boolean.
         * @public
         */
        getTickMarkerYVisible(): boolean;
        /**
         * Mutator function for x tick marker.
         * Applies function to current tick marker if it exists and for any newly created
         * tick marker in order of adding.
         * @param mutator - Mutator function for TickMarker
         * @returns Object itself
         * @remarks          Method can't currently be implemented in a clean way so its usage currently will consume unneeded memory.
         *                      It's repeating usage should be avoided for now.
         * @public
         */
        setTickMarkerX(mutator: Mutator<TickMarker>): this;
        /**
         * Mutator function for y tick marker.
         * Applies function to current tick marker if it exists and for any newly created
         * tick marker in order of adding.
         * @param mutator - Mutator function for TickMarker
         * @returns Object itself
         * @remarks          Method can't currently be implemented in a clean way so its usage currently will consume unneeded memory.
         *                      It's repeating usage should be avoided for now.
         * @public
         */
        setTickMarkerY(mutator: Mutator<TickMarker>): this;
    }
    /**
     * Type union for {@link CurvePreprocessingSpline} and {@link CurvePreprocessingStep}
     * @public
     */
    export declare type CurvePreprocessing = CurvePreprocessingSpline | CurvePreprocessingStep;
    /**
     * Interface which can be used to describe a preprocessing mode for _Spline series_.
     * This is a variant of line series, where the transitions between data points are interpolated with bezier curves.
     *
     * Used with {@link PointLineAreaSeries.setCurvePreprocessing} method:
     *
     * ```ts
     *  // Example
     *  PointLineAreaSeries.setCurvePreprocessing({ type: 'spline' })
     * ```
     *
     * NOTE: Curve preprocessing is only supported for progressive data patterns. See {@link DataSetXYOptions} for more information.
     *
     * @public
     */
    export declare interface CurvePreprocessingSpline {
        /**
         * Identifier for spline preprocessing.
         */
        type: 'spline';
        /**
         * Number of interpolated coordinates between two real data points.
         *
         * Defaults to `20`.
         */
        resolution?: number;
    }
    /**
     * Interface which can be used to describe a preprocessing mode for Step series_.
     * This is a variant of line series, where the transitions between data points are not straight, but applied with 90 degree angles, so that every line segment is either fully horizontal or fully vertical.
     * Used with {@link PointLineAreaSeries.setCurvePreprocessing} method:
     *
     * ```ts
     *  // Example
     *  PointLineAreaSeries.setCurvePreprocessing({ type: 'step', step: 'middle' })
     * ```
     *
     * Supports three different stepping modes, {@link CurvePreprocessingStep.step}, 'before', 'middle' and 'after'.
     *
     * NOTE: Curve preprocessing is only supported for progressive data patterns. See {@link DataSetXYOptions} for more information.
     * @public
     */
    export declare interface CurvePreprocessingStep {
        /**
         * Identifier for step preprocessing.
         */
        type: 'step';
        /**
         * Stepping mode.
         * Behavior description for ProgressiveX data pattern:
         *
         * `'before'` -\>  After A coordinate, Y will first jump to B.y value, then X will move to B.x.
         *
         * `'middle'` -\>  After A coordinate, X will first move to the middle point between A.x and B.x, then Y will move to B.y and finally X will move to B.x.
         *
         * `'after'` -\>  After A coordinate, X will first move to B.x value, then Y will move to B.y.
         */
        step?: 'before' | 'middle' | 'after';
    }
    /**
     * Interface for object that has stylable and settable text.
     * @public
     */
    export declare type CustomizableText = StyleTextAPI & GettableText & SettableText;
    /**
     * Class that represents a single *Axis tick* that can be managed by the user.
     *
     * *Custom ticks* are created with {@link Axis.addCustomTick}.
     *
     * **Frequently used methods:**
     *
     * | Method | Purpose |
     * |------------ | ------------------------------ |
     * | {@link setValue} | Set tick position along Axis. |
     * | {@link setTextFormatter} | Set tick label text using a callback function. |
     * | {@link dispose} | Destroy tick permanently |
     * | {@link setGridStrokeStyle} | Set tick gridline style |
     * | {@link setTickLength} | Set tick line length as pixels |
     * | {@link setTickLabelPadding} | Set padding between tick line and label |
     *
     * **Styling CustomTicks:**
     *
     * Tick gridline can be styled with {@link CustomTick.setGridStrokeStyle}
     *
     * *TickMarker* (label, tick, possible background) are styled via {@link CustomTick.setMarker} as a callback function, like this:
     *
     * ```typescript
     *  CustomTick.setMarker((tickMarker) => tickMarker
     *      // Style TickMarker.
     *      .setTextFillStyle(new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }))
     *      .setFont((font) => font.setStyle( 'italic' ))
     *  )
     * ```
     *
     * See {@link TickMarker} for available customization API.
     *
     * **Styling specific TickMarkers:**
     *
     * When a *custom tick* is created, a *tick marker builder* can be specified.
     * This specifies the shape, and general visual look of the *custom tick*, and can also
     * expose a larger set of customization API for the *tick marker*.
     * To use the specific API, it is required to cast the *tick marker* object to the correct type (*TypeScript* users only):
     *
     * ```typescript
     *  const customTick = Axis.addCustomTick(UIElementBuilders.PointableTextBox)
     *  customTick.setMarker((tickMarker: UIPointableTextBox) => tickMarker
     *      // ^ Above type cast is necessary to access full configuration API of UIPointableTextBox
     *      // Style TickMarker background fill color.
     *      .setBackground((background) => background
     *          .setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0, 100) }))
     *      )
     *  )
     * ```
     *
     * For reference,
     * - CustomTick created with `UIElementBuilders.AxisTickMajor` or `UIElementBuilders.AxisTickMinor` will support API as described by {@link UITick}
     * - CustomTick created with `UIElementBuilders.PointableTextBox` will support API as described by {@link UIPointableTextBox}
     * @public
     */
    export declare abstract class CustomTick extends UIObject implements Disposable {
        /**
         * Axis that CustomTick belongs to.
         * @public
         */
        readonly axis: Axis;
        /**
         * @public
         */
        readonly axisScale: LinearScale1D | LogarithmicScale1D;
        /**
         * @public
         */
        readonly renderingScale: LinearScaleXY;
        /**
         * Sets the position of this custom tick on its Axis
         * @param value - Value in the units of main scale
         * @returns This for fluid interface
         * @remarks  Overrides text of CustomTicks Marker with formated value.
         * @public
         */
        setValue(value: number): this;
        /**
         * Value of CustomTick
         * @public
         */
        getValue(): number;
        /**
         * Set text of CustomTicks' Marker with a formatting function.
         *
         * Example usage:
         *```javascript
         * // Marker shows formatted position of CustomTick on its Axis
         * CustomTick.setTextFormatter((position, customTick) => customTick.axis.formatValue(position))
         * // Marker shows 'Hello world'
         * CustomTick.setTextFormatter((position, customTick) => 'Hello world')
         * ```
         * @param textFormatter - A function of type: *CustomTickTextFormatter*, that defines text of CustomTicks' Marker.
         * @returns Object itself
         * @public
         */
        setTextFormatter(textFormatter: CustomTickTextFormatter): this;
        /**
         * Set tick length as pixels.
         * @param length - Tick length as pixels.
         * @returns Object itself for fluent interface.
         * @public
         */
        setTickLength(length: pixel): this;
        /**
         * Get tick length as pixels.
         * @returns Tick length as pixels.
         * @public
         */
        getTickLength(): pixel;
        /**
         * Set alignment of Label respective to tick line.
         *
         * **after**: -1
         *
         * **center**: 0
         *
         * **before**: +1
         *
         * With XY axes, a second alignment value can additionally be passed, which is used along the other dimension (i.e. X for Y axes).
         *
         * @param alignment - Label alignment [-1, 1].
         * @param alignment2 - Opposite dimension label alignment [-1, 1], supported only by XY axes.
         * @returns New TickStyle object with modified Label alignment
         * @public
         */
        setTickLabelAlignment(alignment: number, alignment2?: number): this;
        /**
         * Get alignment of Label respective to tick line.
         *
         * @param alignment - Label alignment [-1, 1].
         * @returns New TickStyle object with modified Label alignment
         * @public
         */
        getTickLabelAlignment(): number;
        /**
         * Set pixel padding between tick line and label.
         * @public
         */
        setTickLabelPadding(padding: pixel): this;
        /**
         * Set rotation of tick label.
         * @param value - Rotation in degrees
         * @returns Object itself
         * @public
         */
        setTickLabelRotation(value: number): this;
        /**
         * Get rotation of tick label.
         * @returns Rotation in degrees
         * @public
         */
        getTickLabelRotation(): number;
        /**
         * Get pixel padding between tick line and label.
         * @public
         */
        getTickLabelPadding(): pixel;
        /**
         * Set length of grid stroke in percents
         * @param length - Grid line length as a % of viewport size
         * @returns This for fluent interface
         * @public
         */
        setGridStrokeLength(length: number): this;
        /**
         * @returns Grid stroke length as a % of the viewport size
         * @public
         */
        getGridStrokeLength(): number;
        /**
         * Set style of grid stroke.
         *
         * Supported line styles:
         * - {@link SolidLine}
         * - {@link DashedLine}
         * - {@link emptyLine}
         *
         * @param value - Grid stroke style
         * @returns This for fluent interface
         * @public
         */
        setGridStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * @returns Grid stroke style as a LineStyle object
         * @public
         */
        getGridStrokeStyle(): LineStyle;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Set marker visible or not.
         *
         * @param   visible    - Marker visible?
         * @returns              Object itself
         * @public
         */
        setMarkerVisible(visible: boolean): this;
        /**
         * Get marker visible or not.
         *
         * @returns              Boolean.
         * @public
         */
        getMarkerVisible(): boolean;
        /**
         * Configure *custom ticks* *TickMarker* (label, tick, possible background) via a callback function.
         *
         * **Example usage:**
         *
         * ```typescript
         *  CustomTick.setMarker((tickMarker) => tickMarker
         *      // Style TickMarker.
         *      .setTextFillStyle(new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }))
         *      .setFont((font) => font.setStyle( 'italic' ))
         *  )
         * ```
         *
         * See {@link TickMarker} for available customization API.
         *
         * **Styling specific TickMarkers:**
         *
         * When a *custom tick* is created, a *tick marker builder* can be specified.
         * This specifies the shape, and general visual look of the *custom tick*, and can also
         * expose a larger set of customization API for the *tick marker*.
         * To use the specific API, it is required to cast the *tick marker* object to the correct type (*TypeScript* users only):
         *
         * ```typescript
         *  const customTick = Axis.addCustomTick(UIElementBuilders.PointableTextBox)
         *  customTick.setMarker((tickMarker: UIPointableTextBox) => tickMarker
         *      // ^ Above type cast is necessary to access full configuration API of UIPointableTextBox
         *      // Style TickMarker background fill color.
         *      .setBackground((background) => background
         *          .setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0, 100) }))
         *      )
         *  )
         * ```
         *
         * For reference,
         * - CustomTick created with `UIElementBuilders.AxisTickMajor` will support API as described by {@link UITick}
         * - CustomTick created with `UIElementBuilders.PointableTextBox` will support API as described by {@link UIPointableTextBox}
         * @public
         */
        setMarker(mutator: Mutator<TickMarker>): this;
        /**
         * Get *custom ticks* *TickMarker* (label, tick, possible background).
         * @returns TickMarker object
         * @public
         */
        getMarker(): TickMarker;
        /**
         * Set mouse interactions enabled or disabled
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setPointerEvents(state: boolean): this;
        /**
         * @returns Mouse interactions state
         * @public
         */
        getPointerEvents(): boolean;
        /**
         * Set whether `CustomTick` should allocate space on its `Axis`.
         *
         * By default, this is `true`, which means that `Axis` will always make sure it is big enough to fit the tick.
         *
         * By setting to `false`, this particular `CustomTick` can be removed from this behaviour, which can be useful in applications
         * where some custom ticks are only enabled temporarily. Disabling this functionality can prevent the size of the Axis from changing in unwanted ways.
         *
         * ```ts
         *  // Example syntax, disable custom tick space allocation.
         *  CustomTick.setAllocatesAxisSpace(false)
         * ```
         * @param shouldAxisAllocateSpace - Boolean flag.
         * @returns Object itself for fluent interface.
         * @public
         */
        setAllocatesAxisSpace(shouldAxisAllocateSpace: boolean): this;
        /**
         * Get whether `CustomTick` should allocate space on its `Axis`.
         *
         * By default, this is `true`, which means that `Axis` will always make sure it is big enough to fit the tick.
         *
         * By setting to `false`, this particular `CustomTick` can be removed from this behaviour, which can be useful in applications
         * where some custom ticks are only enabled temporarily. Disabling this functionality can prevent the size of the Axis from changing in unwanted ways.
         *
         * @returns Boolean flag.
         * @public
         */
        getAllocatesAxisSpace(): boolean;
        /**
         * Check that customTick fit the main scale
         * @returns Boolean with the result
         * @public
         */
        isInScale(): boolean;
        addEventListener<K extends keyof CustomTickEventMap>(type: K, listener: (event: CustomTickEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof CustomTickEventMap>(type: K, listener: (event: CustomTickEventMap[K], info: unknown) => unknown): void;
    }
    /**
     * End user managed 3D Axis Tick. Custom ticks are just like default ticks, except they can be completely controlled by the end user.
     *
     * For example, their position, text, text fill style, gridline style, etc. everything can be customized.
     * They can be created whenever and destroyed whenever.
     *
     * They are created with {@link Axis3D.addCustomTick} method, and destroyed with {@link dispose} method.
     *
     * ```ts
     *  // Example
     *  const customTick = chart3D.getDefaultAxisX().addCustomTick()
     *      // Tick position on Axis.
     *      .setValue(100)
     *      .setTextFormatter((value) => `Custom tick at ${value.toFixed(1)}`)
     * ```
     *
     * Default 3D Axis ticks can be hidden by selecting empty tick strategy.
     *
     * ```ts
     *  // Remove default ticks.
     *  Chart3D.getDefaultAxisX().setTickStrategy(AxisTickStrategies.Empty)
     * ```
     *
     * @public
     * @privateRemarks  End user interface for 3D custom tick.
     */
    export declare interface CustomTick3D extends AbstractCustomTick {
        /**
         * Set fill style of background around ticks label.
         *
         * ```ts
         *  // Example syntax
         *  tick.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         *  tick.setBackgroundFillStyle((fill) => isSolidFill(fill) ? fill.setA(100) : fill)
         * ```
         *
         * @param   arg -   FillStyle or function that mutates current FillStyle
         * @returns     Object itself.
         * @public
         */
        setBackgroundFillStyle(arg: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of background around ticks label.
         * @returns     FillStyle
         * @public
         */
        getBackgroundFillStyle(): FillStyle;
        /**
         * Set stroke style of background around ticks label.
         *
         * ```ts
         *  // Example syntax
         *  tick.setBackgroundStrokeStyle(new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) }) }))
         *  tick.setBackgroundStrokeStyle((stroke) => stroke.setThickness(2))
         * ```
         *
         * @param   arg -   LineStyle or function that mutates current LineStyle
         * @returns     Object itself.
         * @public
         */
        setBackgroundStrokeStyle(arg: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style of background around ticks label.
         * @returns     FillStyle
         * @public
         */
        getBackgroundStrokeStyle(): LineStyle;
        /**
         * Set padding between tick label text and its background (if any).
         *
         * ```ts
         *  // Example syntax
         *  tick.setPadding(5)
         *  tick.setPadding({ left: 10, right: 10 })
         * ```
         *
         * @param   padding     - `number` for symmetric padding, or object with any of `left`, `right`, `top`, `bottom` paddings.
         * @returns     Object itself.
         * @public
         */
        setPadding(padding: Partial<Margin> | number): this;
        /**
         * Get padding between tick label text and its background (if any).
         * @returns     Object with `left`, `right`, `top`, `bottom` paddings
         * @public
         */
        getPadding(): Margin;
    }
    /**
     * Interface of events trackable by {@link AbstractCustomTick.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface CustomTickEventMap extends DisposableEventMap, HideableEventMap, UIObjectEventMap {
        /**
         * Event fired when the custom tick position is changed
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('valuechange', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        valuechange: CustomTickValueChangeEvent;
    }
    /**
     * Interface for function which specifies CustomTick text.
     * @public
     */
    export declare type CustomTickTextFormatter = (value: number, customTick: CustomTick) => string;
    /**
     * @public
     */
    export declare interface CustomTickValueChangeEvent {
        value: number;
    }
    /**
     * *Dashboard* is a component for flexible positioning of multiple *Chart*s efficiently.
     * It is created with {@link LightningChart.Dashboard} method.
     *
     * Upon its creation an amount of *columns* and *rows* is specified. *Charts* and other components can
     * then be placed in cells with given *column* and *row*-locations and sizes
     * (using methods of *Dashboard*. For example: {@link Dashboard.createChartXY}.
     *
     * The *Dashboard* will distribute the available space for *columns* and *rows*, which users can resize
     * with mouse and touch interactions or programmatically.
     * @public
     */
    export declare class Dashboard implements Control, Validatable {
        /**
         * Selector for "relative" _Coordinate System_.
         *
         * This coordinate system is relative to the bottom left corner of the Control (chart/dashboard/etc.), and is measured as pixels.
         * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from bottom.
         *
         * This selector can be used for two purposes:
         *
         * **Positioning LCJS UI elements in pixels:**
         *
         * ```ts
         *  // Position UI element in pixels by supplying `Control.coordsRelative` as its positioning system.
         *  const textBox = Control.addUIElement(UIElementBuilders.TextBox, Control.coordsRelative)
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 100, y: 20 })
         * ```
         *
         * **Translations between coordinate systems:**
         *
         * Use with {@link translateCoordinate} method to translate coordinates from "relative" to another coordinate system.
         *
         * @public
         */
        readonly coordsRelative: CoordinateSystemRelative;
        /**
         * Selector for "client" _Coordinate System_.
         *
         * This references the coordinate system used in HTML.
         * It starts at top left of the web page and is measured in pixels.
         * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
         *
         * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
         *
         * This selector can be used for translating client coordinates to other coordinate systems and vice versa.
         * For example, in order to:
         * - Position LCJS UI elements in client coordinates
         * - Find client coordinate that matches a location along LCJS Axis or Chart.
         * - etc.
         *
         * See {@link translateCoordinate} for more detailed use case information and example usage.
         *
         * @public
         */
        readonly coordsClient: CoordinateSystemClient;
        /**
         * Public, safe interface for Dashboards rendering engine.
         * @public
         */
        readonly engine: PublicEngine;
        /**
         * Scale that represents dashboard area in percents (0-100).
         *
         * While it is not functionally equal to this, using [[coordsRelative]] coordinate system is preferred (more confidence for long term support)
         * @public
         */
        readonly uiScale: LinearScaleXY;
        /**
         * Set the minimum and maximum boundaries for dashBoard horizontal size.
         * @param boundary - Single value for static engine size, or a tuple for size range [min, max] in pixels.
         * @public
         */
        setWidth(boundary: number | [number | undefined, number | undefined] | undefined): this;
        /**
         * Set the minimum and maximum boundaries for dashBoard vertical size.
         * @param boundary - Single value applied to both minimum and maximum size, or a tuple for [min, max] size in pixels.
         * @public
         */
        setHeight(boundary: number | [number | undefined, number | undefined] | undefined): this;
        /**
         * Get the minimum and maximum horizontal boundaries used for the Dashboard.
         * @returns Horizontal boundaries as a tuple [minSize, maxSize]
         * @public
         */
        getWidth(): [number | undefined, number | undefined] | undefined;
        /**
         * Get the minimum and maximum vertical boundaries used for the Dashboard.
         * @returns Vertical boundaries as a tuple [minSize, maxSize]
         * @public
         */
        getHeight(): [number | undefined, number | undefined] | undefined;
        /**
         * Set fillStyle of dashboard background.
         * @param fillStyle - FillStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setBackgroundFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fillStyle of dashboard
         * @returns FillStyle
         * @public
         */
        getBackgroundFillStyle(): FillStyle;
        /**
         * Set stroke style of dashboard background.
         * @param value - LineStyle
         * @returns Object itself
         * @public
         */
        setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style of dashboard background.
         * @returns LineStyle
         * @public
         */
        getBackgroundStrokeStyle(): LineStyle;
        /**
         * Get theme used for the dashboard.
         * @returns Theme
         * @public
         */
        getTheme(): Theme;
        /**
         * Set style of Dashboard splitters.
         *
         * Note, that highlighted splitters have a separate style {@link setSplitterStyleHighlight}.
         *
         * Example usage:
         *```javascript
         * // Specified LineStyle
         * Dashboard.setSplitterStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
         * // Changed thickness
         * Dashboard.setSplitterStyle((solidLine) => solidLine.setThickness(5))
         * // Hidden
         * Dashboard.setSplitterStyle(emptyLine)
         * ```
         * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
         * @returns Chart itself
         * @public
         */
        setSplitterStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of Dashboard splitters.
         * @returns LineStyle object
         * @public
         */
        getSplitterStyle(): LineStyle;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setSplitterEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getSplitterEffect(): boolean;
        /**
         * Set component highlight animations enabled or not.
         * For most components this is enabled by default.
         *
         * ```ts
         *  // Example usage, disable highlight animations.
         *  component.setAnimationHighlight(false)
         * ```
         *
         * @param   enabled    - Animation enabled?
         * @returns            Object itself
         */
        setAnimationHighlight(enabled: boolean): this;
        /**
         * Get component highlight animations enabled or not.
         *
         * @returns      Animation enabled?
         */
        getAnimationHighlight(): boolean;
        /**
         * Set width of a column in relation to other columns. By default all column widths are `1`.
         *
         * By changing one columns width to `2`, it would make that column allocate twice as much width as others.
         *
         * ```ts
         * // Example, Dashboard with 3 columns with widths (20%, 20%, 60%) of dashboard width
         * dashboard.setColumnWidth( 0, 1 )
         * dashboard.setColumnWidth( 1, 1 )
         * dashboard.setColumnWidth( 2, 3 )
         * ```
         * @param index - Index of the column (starts from 0)
         * @param relativeWidth - Relative width of the column, can be any number.
         * @public
         */
        setColumnWidth(index: number, relativeWidth: number): this;
        /**
         * Get width of a column in relation to other columns. By default all column widths are `1`.
         *
         * Example usage:
         * ```ts
         * dashboard.getColumnWidth( 0 )
         * ```
         * @param index - Index of the column (starts from 0)
         * @returns Relative width of the column.
         * @public
         */
        getColumnWidth(index: number): number;
        /**
         * Set height of a row in relation to other rows. By default all row heights are `1`.
         *
         * By changing one rows height to `2`, it would make that row allocate twice as much height as others.
         *
         * ```ts
         * // Dashboard with 3 rows with heights (20%, 20%, 60%) of dashboard height
         * dashboard.setRowHeight( 0, 1 )
         * dashboard.setRowHeight( 1, 1 )
         * dashboard.setRowHeight( 2, 3 )
         * ```
         * @param index - Index of the row (starts from 0)
         * @param relativeHeight - Relative height of the row
         * @public
         */
        setRowHeight(index: number, relativeHeight: number): this;
        /**
         * Get height of a row in relation to other rows. By default all row heights are `1`.
         *
         * Example usage:
         *```javascript
         * dashboard.getRowHeight( 0 )
         * ```
         * @param index - Index of the row (starts from 0)
         * @public
         */
        getRowHeight(index: number): number;
        /**
         * Get size of control as pixels.
         *
         * For stand-alone component, the size will be equal to the size of its containing HTML \<div\> (`Control.engine.container`)
         *
         * For component inside Dashboard, the size will only include the component itself, so size can be less than the size of containing HTML \<div\>.
         *
         * @returns     Object with x and y properties `{ x: number, y: number }`, where both are pixel values.
         * @public
         */
        getSizePixels(): Point;
        /**
         * Disable/Enable all animations of the Chart.
         * @param animationsEnabled - Boolean value to enable or disable animations.
         * @returns Chart itself for fluent interface.
         * @public
         */
        setAnimationsEnabled(animationsEnabled: boolean): this;
        /**
         * Get animations disable/enable state.
         * @returns Animations default state.
         * @public
         */
        getAnimationsEnabled(): boolean;
        /**
         * Get all defined cells in the dashboard.
         *
         * Further action can be done by testing the `cell.panel` for the instance type that you want to be interacting with.
         *
         * Example:
         * ```ts
         * const cells = dashboard.getCells()
         *
         * cells.forEach((cell) => {
         *     if (cell.panel instanceof Chart3D) {
         *         cell.panel.setBoundingBox({ x: 2, y: 1, z: 1 })
         *     }
         * })
         * ```
         * @returns All cells with content in dashboard
         * @public
         */
        getCells(): DashboardCell[];
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Check whether the object is disposed.
         * Disposed objects should not be used!
         *
         * @returns     `true` if object is disposed.
         * @public
         */
        isDisposed(): boolean;
        /**
         * Find if chart is currently considered to be in the browser viewport.
         * @returns `true` when panel is in view
         */
        getIsInView(): boolean;
        /**
         * Capture rendered state in an image file. Prompts the browser to download the created file.
         *
         * **NOTE: The download might be blocked by browser/plugins as harmful.**
         * To prevent this, only call the method in events tied to user-interactions.
         * From mouse-event handlers, for example.
         *
         * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
         * For supported image formats, compression quality, Etc. refer to:
         *
         * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
         *
         * Example usage:
         *```javascript
         * // Download 'screenshot.png'
         * Dashboard.saveToFile('screenshot')
         * // Attempt download 'maybeNotSupported.bmp'
         * Dashboard.saveToFile('maybeNotSupported', 'image/bmp')
         * // Attempt download jpeg.file with specified compression quality
         * Dashboard.saveToFile('fileName', 'image/jpeg', 0.50)
         * ```
         * @remarks              **If 'type' is not supported by browser, an Error will be thrown.**
         *
         * @param fileName - Name of prompted download file as string. **File extension shouldn't be included**
         *                          as it is automatically detected from 'type'-argument.
         * @param type - A DOMString indicating the image format. The default format type is image/png.
         * @param encoderOptions - A Number between 0 and 1 indicating the image quality to use for image formats
         *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
         *                          the default value for image quality is used. The default value is 0.92.
         * @param scale - Convenience output scaling factor. This doesn't actually stretch the result, but instead draws an altered scaled version and captures that.
         * @public
         */
        saveToFile(fileName: string, type?: string, encoderOptions?: number, scale?: number): this;
        /**
         * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
         *
         * ```ts
         *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
         *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
         *  // locationRelative is in pixels relative to bottom left corner of the chart
         * ```
         *
         * Relative coordinates can be used for positioning LightningChart JS UI components:
         *
         * ```ts
         *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
         *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 20, y: 20 })
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         */
        translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
        /**
         * Translate a coordinate from relative control coordinates to HTML client coordinate system.
         *
         * ```ts
         *  // 10 pixels left and 20 pixels up from controls bottom left corner
         *  const locationRelative = { x: 10, y: 20 }
         *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
         * ```
         *
         * Client coordinates can be used to absolute position HTML elements using CSS, for example.
         *
         * ```ts
         *  myHTMLElement.style.position = 'absolute'
         *  myHTMLElement.style.left = locationClient.clientX
         *  myHTMLElement.style.top = locationClient.clientY
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         */
        translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
        /**
         * Add a stand-alone *UIElement* using a *builder*.
         *
         * **Example usage:**
         *
         * 1) TextBox with default positioning coordinate system.
         *
         * ```typescript
         *  addUIElement( UIElementBuilders.TextBox )
         *      // Position = [0, 100] as percentages.
         *      .setPosition({ x: 50, y: 50 })
         * ```
         *
         * 2) Position in pixel coordinate system.
         *
         * ```typescript
         *  addUIElement( UIElementBuilders.TextBox, chart.coordsRelative )
         *      // Position = pixels.
         *      .setPosition({ x: 300, y: 100 })
         * ```
         *
         * 3) Position on Axes.
         *
         * ```typescript
         *  addUIElement( UIElementBuilders.TextBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
         *      // Position = Axis values.
         *      .setPosition({ x: 5, y: 5 })
         * ```
         *
         * @typeParam UIElementType - Type of *UIElement* that is specified by 'builder'-*parameter*.
         *
         * @param builder - *UIElementBuilder*. If omitted, *TextBoxBuilder* will be selected. Use {@link UIElementBuilders} for selection.
         * @param scale - Optional parameter for altering the coordinate system used for positioning the UIElement. Defaults to whole Dashboard in percentages [0, 100].
         * @returns Object that fulfills *interfaces*:  *UIElementType* (typeparam) and *UIElement*
         * @public
         */
        addUIElement<UiElementType extends UIPart = UITextBox>(uiElementBuilder?: UIElementBuilder<UiElementType>, scale?: UserScaleDefinition): UiElementType & UIElement;
        /**
         * Add new ChartXY to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a chartXY.
         * @returns ChartXY.
         * @public
         */
        createChartXY: <CursorResultTableBackgroundType extends UIBackground>(options: ChartOptions<CursorResultTableBackgroundType>) => ChartXY<CursorResultTableBackgroundType>;
        /**
         * Add new SpiderChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a Spider chart.
         * @returns SpiderChart.
         * @public
         */
        createSpiderChart: <CursorResultTableBackgroundType extends UIBackground>(options: SpiderOptions<CursorResultTableBackgroundType>) => SpiderChart<CursorResultTableBackgroundType>;
        /**
         * Add new PolarChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a PolarChart chart.
         * @returns PolarChart.
         * @public
         */
        createPolarChart: <CursorResultTableBackgroundType extends UIBackground>(options: PolarOptions<CursorResultTableBackgroundType>) => PolarChart<CursorResultTableBackgroundType>;
        /**
         * Add new PieChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a PieChart.
         * @returns PieChart.
         * @public
         */
        createPieChart: <PieChartType extends PieChartTypes = typeof PieChartWithLabelsOnSides>(options: PieOptions<PieChartType>) => InstanceType<PieChartType>;
        /**
         * Add new FunnelChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a FunnelChart.
         * @returns FunnelChart.
         * @public
         */
        createFunnelChart: <FunnelChartType extends FunnelChartTypes = typeof FunnelChartWithLabelsOnSides>(options: FunnelOptions<FunnelChartType>) => InstanceType<FunnelChartType>;
        /**
         * Add new PyramidChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboard's numberOfColumns/Rows.
         * @param options - Options object for creating a PyramidChart.
         * @returns PyramidChart
         * @public
         */
        createPyramidChart: <PyramidChartType extends PyramidChartTypes = typeof PyramidChartWithLabelsOnSides>(options: PyramidOptions<PyramidChartType>) => InstanceType<PyramidChartType>;
        /**
         * Create a container for UI objects on dashboard with specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a UIPanel.
         * @returns Panel.
         * @public
         */
        createUIPanel: (options: DashboardCellOptions) => UIPanel;
        /**
         * Create a new *legend box panel*, a convenience component for placing *legend box items*
         * from multiple different *charts* into a single *row layout*, to dashboard at specified location and span.
         *
         *
         * Refer to {@link UILegendPanel} for more information, like *example usage*.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a *legend box panel*.
         * @returns UILegendPanel.
         * @public
         */
        createLegendPanel: (options: DashboardCellOptions & {
            legend?: LegendOptions;
        }) => UILegendPanel;
        /**
         * Add new GaugeChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a GaugeChart.
         * @returns GaugeChart.
         * @public
         */
        createGaugeChart: (options: DashboardCellOptions) => GaugeChart;
        /**
         * Add new ZoomBandChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a ZoomBandChart.
         * @returns ZoomBandChart.
         * @public
         */
        createZoomBandChart: (options: ZoomBandChartDashboardOptions) => ZoomBandChart;
        /**
         * Factory for `MapChart`. This chart visualizes a Map of the selected part of the world. Defaults to the entire world.
         * It has built-in *cursor* functionality and supports dynamic region coloring.
         *
         * To learn more about its features, refer to {@link MapChart}.
         *
         * **Dashboard cell configuration:**
         *
         * When inside a `Dashboard`, the chart location relative to the `Dashboard` **must be supplied when it is created**.
         *
         * ```typescript
         *  // Example, dashboard cell configuration.
         *  const chart = Dashboard.createMapChart({
         *      // X location, 0 = left.
         *      columnIndex: 0,
         *      // Y location, 0 = top.
         *      rowIndex: 0,
         *      // Amount of X cells allocated for this chart.
         *      columnSpan: 1,
         *      // Amount of Y cells allocated for this chart.
         *      rowSpan: 1,
         *  })
         * ```
         *
         * **Readonly configuration:**
         *
         * Some properties of `MapChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, specify map type.
         *  const chart = LightningChart.Map({
         *      type: MapTypes.Europe
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `MapChart` specific properties, refer to {@link MapChartOptions}.
         *
         * @param options - Object with readonly configuration arguments for `MapChart`.
         * @returns Created chart.
         * @public
         */
        createMapChart: <SelectedMapType extends MapType, CursorResultTableBackgroundType extends UIBackground>(options: MapChartDashboardOptions<SelectedMapType, CursorResultTableBackgroundType>) => MapChart<SelectedMapType, CursorResultTableBackgroundType>;
        /**
         * Add new Chart3D to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a Chart3D.
         * @returns Chart3D.
         * @public
         */
        createChart3D: (options: Chart3DDashboardOptions) => Chart3D;
        /**
         * Add new DataGrid to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a DataGrid.
         * @returns             DataGrid.
         * @public
         */
        createDataGrid: (options: DataGridDashboardOptions) => DataGrid;
        /**
         * Add new BarChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a BarChart.
         * @returns             BarChart.
         * @public
         */
        createBarChart: (options: BarChartDashboardOptions) => BarChart;
        /**
         * Add new ParallelCoordinateChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a ParallelCoordinateChart.
         * @returns             ParallelCoordinateChart.
         * @public
         */
        createParallelCoordinateChart: (options: ParallelCoordinateChartDashboardOptions) => ParallelCoordinateChart;
        addEventListener<K extends keyof DashboardEventMap>(type: K, listener: (event: DashboardEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof DashboardEventMap>(type: K, listener: (event: DashboardEventMap[K], info: unknown) => unknown): void;
    }
    /**
     * Data structure that describes one cell in a Dashboard.
     *
     * Use `panel` property to get reference to the actual chart or other component that resides in the cell.
     * @public
     */
    export declare interface DashboardCell {
        readonly columnIndex: number;
        readonly rowIndex: number;
        readonly columnSpan: number;
        readonly rowSpan: number;
        readonly panel: DashboardPanel;
    }
    /**
     * Interface for minimum set of parameters required for adding charts / panels to a *dashboard cell*.
     *
     *  Example usage:
     *```javascript
     * // 1x1 component at top left cell
     * { columnIndex: 0, rowIndex: 0, columnSpan: 1, rowSpan: 1 }
     * // 4x1 component at top row
     * { columnIndex: 0, rowIndex: 0, columnSpan: 4, rowSpan: 1 }
     * ```
     * @public
     */
    export declare interface DashboardCellOptions {
        /**
         * Column index on dashboard (X location, 0 = left)
         */
        columnIndex: number;
        /**
         * Row index on dashboard (Y location, 0 = top)
         */
        rowIndex: number;
        /**
         * Column span (X width), default = 1
         */
        columnSpan?: number;
        /**
         * Row span (Y height), default = 1
         */
        rowSpan?: number;
        /**
         * Convenience flag that can be used to enable/disable all animations in a component.
         */
        animationsEnabled?: boolean;
    }
    /**
     * Interface of events trackable by {@link Dashboard.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface DashboardEventMap {
        /**
         * Event fired when component is disposed
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('dispose', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        dispose: DisposeEvent;
        /**
         * Event fired when the components visibility on web page changes.
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('inviewchange', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        inviewchange: InViewChangedEvent;
        /**
         * Event fired when components container size changes
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('resize', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        resize: ResizeEvent;
    }
    /**
     * Interface for readonly configuration of {@link Dashboard}.
     *
     * **Mandatory properties:**
     *
     * - [numberOfColumns]({@link DashboardOptions.numberOfColumns}): Number of *dashboard cells* along horizontal plane.
     * - [numberOfRows]({@link DashboardOptions.numberOfRows}): Number of *dashboard cells* along vertical plane.
     *
     * ```typescript
     *  // Example, Create a 3x3 dashboard.
     *  const dashboard = LightningChart.Dashboard({
     *      // Number of cells in X direction.
     *      numberOfColumns: 3,
     *      // Number of cells in Y direction.
     *      numberOfRows: 3,
     *  })
     * ```
     *
     * To learn about the effects of *columns* / *rows* configuration, please read more here {@link Dashboard}.
     *
     *
     * **Optional extra configuration:**
     *
     * - {@link DashboardOptions.theme}: Specify dashboard color *theme*.
     * - {@link DashboardOptions.disableAnimations}: Convenience flag to disable all animations from dashboard.
     *
     * ```typescript
     *  // Example 1, create dashboard with specified color theme.
     *  const dashboard = LightningChart.Dashboard({
     *      // Number of cells in X direction.
     *      numberOfColumns: 3,
     *      // Number of cells in Y direction.
     *      numberOfRows: 3,
     *      // Select color theme.
     *      theme: Themes.light,
     *  })
     * ```
     * @public
     */
    export declare interface DashboardOptions {
        /**
         * Number of *dashboard cells* along horizontal plane.
         *
         * To learn about the effects of *columns* / *rows* configuration, please read more here {@link Dashboard}.
         */
        readonly numberOfColumns: number;
        /**
         * Number of *dashboard cells* along vertical plane.
         *
         * To learn about the effects of *columns* / *rows* configuration, please read more here {@link Dashboard}.
         */
        readonly numberOfRows: number;
        /**
         * Convenience flag that can be used to enable/disable all animations in a component.
         */
        readonly animationsEnabled?: boolean;
        /**
         * Theme used to style all elements inside the component.
         * See {@link Themes} for pre-made options.
         */
        readonly theme?: Theme;
    }
    /**
     * A chart or other component that can exist inside a Dashboard cell.
     *
     * Use `instanceof` checks to confirm whether it is of an expected type.
     *
     * ```ts
     *  // Example usage
     *  if (panel instanceof ChartXY) {
     *      // ...
     *  }
     * ```
     * @public
     */
    export declare interface DashboardPanel {
        /**
         * Get minimum size of Panel.
         * Depending on the type of class this value might be automatically computed to fit different elements.
         * @returns Point minimum size or undefined if unimplemented
         * @public
         */
        getMinimumSize(): Point | undefined;
        /** @public */
        dispose(): unknown;
    }
    /**
     * Style class for describing a line that is partly hidden and partly visible. The pattern is repetitive and can be configured.
     *
     * Instances of DashedLine, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
     * but instead return a completely new modified object.
     *
     * **Properties of DashedLine:**
     * - `thickness`    : thickness of line as pixels.
     * - `fillStyle`    : description of line fill color. The supported fillStyles vary per component.
     * - `pattern`      : description of the repeating pattern of ON and OFF sections that defines the `DashedLine`.
     * - `patternScale` : scaling factor for the length of each repeating stipple pattern.
     *
     * **DashedLine Usage:**
     *
     * Use DashedLine with:
     * - `setStrokeStyle` methods:
     *      * {@link ConstantLine.setStrokeStyle}
     *      * {@link CustomTick.setGridStrokeStyle}
     *      * {@link LineSeries.setStrokeStyle}
     *      * etc.
     *
     * *Watch out!* A common misuse is to attempt styling strokes or borders directly using *fill style* or *color*.
     * Remember, when calling a `setStrokeStyle` method, a *line style* is expected! Carefully observe the order of wrapped styles: *line style \<- fill style \<- color*
     *
     * ```typescript
     *  // Example, set line series stroke style to 1px dashed red.
     *  LineSeries.setStrokeStyle(new DashedLine({
     *      thickness: 1,
     *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }),
     *      patternScale: StipplePatterns.DashedEqual,
     *      patternScale: 1,
     *  }))
     * ```
     *
     * ```ts
     *  // Example, change stroke style to DashedLine without changing color / thickness
     *  LineSeries.setStrokeStyle((stroke) => new DashedLine({
     *      thickness: stroke.getThickness(),
     *      fillStyle: stroke.getFillStyle(),
     *      pattern: StipplePatterns.Dashed,
     *      patternScale: 2,
     *  }))
     * ```
     *
     * **Related information:**
     *
     * For more *line styles*, see:
     * - {@link SolidLine}
     * - {@link emptyLine}
     *
     * @public
     */
    export declare class DashedLine extends DashedLineRecord implements LineStyle, StylePropFuncs<ThisType<DashedLine>, Omit<DashedLineProperties, 'type' | 'lineType'>> {
        /**
         * Construct a DashedLine object, specifying any amount of its properties.
         *
         * ```typescript
         *  // Example, 1px thick dashed red line.
         *  const solidRed = new DashedLine({
         *      thickness: 1,
         *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }),
         *      pattern: StipplePatterns.Dashed,
         *  })
         *
         *  Axis.setStrokeStyle(solidRed)
         * ```
         * @param   props - Object containing any amount of DashedLine properties.
         * @public
         */
        constructor(props?: Partial<Omit<DashedLineProperties, 'type' | 'lineType'>>);
        /**
         * Construct a new line style object based on this one, but with modified fill style.
         *
         * Example (SolidFill):
         * ```javascript
         * // specify new fillstyle
         * lineStyle.setFillStyle( new SolidFill({
         *  color: ColorHex('#F00')
         * }) )
         * // change fillstyle properties
         * lineStyle.setFillStyle(
         *  solidfill => solidfill.setA( 80 )
         * )
         * ```
         * @param   value -  Either a DashedLine object or a function, which will be used to create a new DashedLine based on current value.
         * @returns          New SolidLine object
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): DashedLine;
        /**
         * Get fill style of SolidLine.
         * @returns  FillStyle object
         * @public
         */
        getFillStyle(): FillStyle;
        /**
         * Construct a new DashedLine object based on this one, but with modified thickness.
         *
         * -1 can be used to signify smallest available thickness.
         * With most features, this will result in slightly better GPU performance, but less detailed line.
         *
         * @param   value -  Thickness as pixels.
         * @public
         */
        setThickness(value: number | ImmutableMutator<number>): this;
        /**
         * Get thickness of DashedLine
         * @returns  Thickness as pixels
         * @public
         */
        getThickness(): number;
        /**
         * Construct a new DashedLine object based on this one, but with modified stipple pattern.
         *
         * Use `StipplePatterns` to conveniently select from preset options.
         *
         * ```ts
         *  // Example usage
         *  const modifiedDashedLine = DashedLine.setPattern(StipplePatterns.Dashed)
         * ```
         * @param   value    -     Stipple pattern.
         * @returns                 New DashedLine object.
         * @public
         */
        setPattern(value: StipplePattern | ImmutableMutator<StipplePattern>): this;
        /**
         * Get stipple pattern of the DashedLine object.
         * @returns          -        Stipple pattern.
         * @public
         */
        getPattern(): StipplePattern;
        /**
         * Construct a new DashedLine object based on this one, but with modified stipple pattern scale.
         *
         * Scaling factor for the length of each repeating stipple pattern. By default `5`.
         * @param   value   -    Scaling factor.
         * @returns              New DashedLine object.
         * @public
         */
        setPatternScale(value: number | ImmutableMutator<number>): this;
        /**
         * Get stipple pattern scale of the DashedLine object.
         * @returns                  Stipple pattern scale.
         * @public
         */
        getPatternScale(): number;
    }
    /**
     * Interface for all properties of a DashedLine.
     * @public
     */
    export declare interface DashedLineProperties extends SolidLineStyleProperties {
        /**
         * _Stipple pattern_ that describes the repeating pattern of ON and OFF sections that defines the `DashedLine`.
         *
         * See {@link StipplePattern} for more information.
         *
         * Defaults to `StipplePatterns.DashedEqual`
         */
        pattern: StipplePattern;
        /**
         * Scaling factor for the length of each repeating stipple pattern.
         *
         * Defaults to `3`
         */
        patternScale: number;
    }
    /**
     * @public
     */
    declare const DashedLineRecord: Record_2.Factory<DashedLineProperties>;
    /**
     * Component for visualizing data inside a grid structure using a variety of methods.
     *
     * `DataGrid` can be created in two different ways - to learn more about creation time configuration of `DataGrid`, please refer to:
     * - {@link LightningChart.DataGrid} (stand-alone data grid).
     * - {@link Dashboard.createDataGrid} (data grid inside *dashboard*).
     *
     * `DataGrid` is built from any number of _Cells_, that are positioned across _Columns_, and _Rows_.
     * The number of cells is fully dynamic, and can be changed at any time.
     * Furthermore, cells can be merged to span over more than 1 column and/or row.
     *
     * Examples featuring some use cases of `DataGrid` can be found on the official {@link https://www.lightningchart.com/lightningchart-js-interactive-examples/search.html?t=valuegrid | LightningChart JS Interactive Examples gallery}.
     *
     * **DataGrid features**
     *
     * ## Cell content
     *
     * As mentioned, `DataGrid` is fully dynamic, as in cells can be created and removed at any time.
     * Cells are defined by specifying their {@link DataGridCellContent | _Content_}.
     *
     * Each cell can contain _text_, _numbers_, an _Icon_ or a _Spark Chart_.
     * To learn of _Spark Charts_, see their section below.
     *
     * There are several different methods for specifying cell content, here's a conclusive list:
     *
     * - {@link DataGrid.setCellContent} Set content of 1 cell. This method also allows definition of merged cells.
     * - {@link DataGrid.setColumnContent} Set contents of n cells along a single column.
     * - {@link DataGrid.setRowContent} Set contents of n cells along a single row.
     * - {@link DataGrid.setTableContent} Set contents of many cells by supplying a matrix.
     *
     * Cells can be emptied by setting their content to `undefined`, or completely removed with following methods:
     *
     * - {@link DataGrid.removeCell} Remove 1 cell.
     * - {@link DataGrid.removeColumn} Remove all cells along a single column.
     * - {@link DataGrid.removeRow} Remove all cells along a single row.
     * - {@link DataGrid.removeCells} Remove all cells.
     *
     * ## Cell style
     *
     * Each cell in a `DataGrid` can be styled individually.
     * Each cell has following style properties:
     *
     * - Padding
     * - Borders Visibility
     * - Text FillStyle
     * - Text Font
     * - Content Alignment
     * - Background FillStyle
     * - Highlighting
     *
     * Here are methods for setting the style of existing cells (cells whose content has been defined according to section #1):
     *
     * - {@link DataGrid.setCellPadding} Set padding of 1 cell.
     * - {@link DataGrid.setColumnPaddings} Set padding of all cells along a single column.
     * - {@link DataGrid.setRowPaddings} Set padding of all cells along a single row.
     * - {@link DataGrid.setCellBorders} Set border visibility of 1 cell.
     * - {@link DataGrid.setColumnBorders} Set border visibility of all cells along a single column.
     * - {@link DataGrid.setRowBorders} Set border visibility of all cells along a single row.
     * - {@link DataGrid.setCellTextFillStyle} Set text fill style of 1 cell.
     * - {@link DataGrid.setColumnTextFillStyle} Set text fill style of all cells along a single column.
     * - {@link DataGrid.setRowTextFillStyle} Set text fill style of all cells along a single row.
     * - {@link DataGrid.setCellTextFont} Set text font of 1 cell.
     * - {@link DataGrid.setColumnTextFont} Set text font of all cells along a single column.
     * - {@link DataGrid.setRowTextFont} Set text font of all cells along a single row.
     * - {@link DataGrid.setCellContentAlignment} Set content alignment of 1 cell.
     * - {@link DataGrid.setColumnContentAlignment} Set content alignment of all cells along a single column.
     * - {@link DataGrid.setRowContentAlignment} Set content alignment of all cells along a single row.
     * - {@link DataGrid.setCellBackgroundFillStyle} Set background fill style of 1 cell.
     * - {@link DataGrid.setColumnBackgroundFillStyle} Set background fill style of all cells along a single column.
     * - {@link DataGrid.setRowBackgroundFillStyle} Set background fill style of all cells along a single row.
     * - {@link DataGrid.setCellHighlight} Set highlighting of 1 cell.
     * - {@link DataGrid.setColumnHighlight} Set highlighting of all cells along a single column
     * - {@link DataGrid.setRowHighlight} Set highlighting of all cells along a single row
     *
     * The default style for new cells can be defined separately.
     * These methods both alter the styles of all existing cells, as well as any cells defined afterwards.
     *
     * - {@link DataGrid.setCellsPaddings} Set padding of all existing and future cells.
     * - {@link DataGrid.setCellsBorders} Set border visibility of all existing and future cells.
     * - {@link DataGrid.setCellsTextFillStyle} Set text fill style of all existing and future cells.
     * - {@link DataGrid.setCellsTextFont} Set text font of all existing and future cells.
     * - {@link DataGrid.setCellsAlignment} Set content alignment of all existing and future cells.
     * - {@link DataGrid.setCellsBackgroundFillStyle} Set background fill style of all existing and future cells.
     *
     * Apart from cell-specific styles, there are also more style setters on `DataGrid`, see next section.
     *
     * ## Data Grid style
     *
     * - {@link DataGrid.setGridBackgroundFillStyle} Set fill style of area behind all Data Grid cells.
     * - {@link DataGrid.setCellsBorderStrokeStyle} Set all cells border style. This is not configurable individually per-cell.
     *
     * ## Data Grid sizing
     *
     * By default, the Data Grid size is based on the size of its Cells (fit to content).
     * This can be altered by size instructions on any column, and/or row.
     *
     * - {@link DataGrid.setColumnWidth} Set width of 1 column as pixels.
     * - {@link DataGrid.setRowHeight} Set height of 1 row as pixels.
     *
     * Both of these methods accept several types of instructions:
     *
     * - Hard defined size as pixels `DataGrid.setColumnWidth(0, 200)`
     * - Min size as pixels `DataGrid.setColumnWidth(0, { min: 100 })`
     * - Max size as pixels `DataGrid.setColumnWidth(0, { max: 300 })`
     * - Min/Max range as pixels `DataGrid.setColumnWidth(0, { min: 100, max: 300 })`
     * - Restore default behavior (fit to content) `DataGrid.setColumnWidth(undefined)`
     *
     * ## Spark charts
     *
     * `DataGrid` supports placing miniature charts (Spark Chart) inside any number of cells.
     * These can be used to "show data at a glance".
     *
     * To place a Spark Chart, specify the content of a Cell like normal, but instead of supplying string or number, supply an object description of the Spark Chart:
     *
     * ```ts
     *  // Example, spark line chart
     *  DataGrid.setCellContent(0, 0, {
     *      type: 'spark-line',
     *      data: [0, 10, 6, 4, 9, 8, 3, 6]
     *  })
     * ```
     *
     * To learn of available types of Spark Charts as well as all optional configuration properties, see {@link SparkChart}.
     *
     * To update the data of a Spark Chart, simply redefine the cell content.
     *
     * ## User interactions
     *
     * `DataGrid` allows subscribing to user interaction events like most LightningChart JS components.
     *
     * Important note, for cell mouse interactions to work, their background must have a non empty fill style.
     * This is true by default. To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
     *
     * Use the following methods to attach event handlers to events:
     *
     * - {@link DataGrid.onCellMouseEnter} Event fired when mouse enters any cell in DataGrid (triggered again if different cell is under pointer)
     * - {@link DataGrid.onCellMouseLeave} Event fired when mouse leaves any cell in DataGrid (triggered again if different cell is under pointer)
     * - {@link DataGrid.onCellMouseClick} Event fired when mouse clicks any cell in DataGrid
     * - {@link DataGrid.onCellMouseDoubleClick} Event fired when mouse double clicks enters any cell in DataGrid
     * - {@link DataGrid.onCellMouseDown} Event fired when mouse presses down on any cell in DataGrid
     * - {@link DataGrid.onCellMouseUp} Event fired when mouse releases up on any cell in DataGrid
     * - {@link DataGrid.onCellMouseMove} Event fired when mouse moves above any cell in DataGrid
     * - {@link DataGrid.onCellMouseDrag} Event fired when mouse is dragged while holding a button above any cell in DataGrid
     * - {@link DataGrid.onCellMouseDragStart} Event fired when mouse drag is started on any cell in DataGrid
     * - {@link DataGrid.onCellMouseDragStop} Event fired when mouse drag stops on any cell in DataGrid
     * - {@link DataGrid.onCellMouseWheel} Event fired when mouse is wheeled above any cell in DataGrid
     * - {@link DataGrid.onCellTouchStart} Event fired when touch start event fires above any cell in DataGrid
     * - {@link DataGrid.onCellTouchMove} Event fired when touch move event fires above any cell in DataGrid
     * - {@link DataGrid.onCellTouchEnd} Event fired when touch end event fires above any cell in DataGrid
     *
     * To stop listening to an event, use the respective `off...` method, for example {@link DataGrid.offCellMouseEnter}.
     *
     * @public
     */
    export declare class DataGrid extends Chart {
        /**
         * Get minimum size of Chart.
         * Depending on the type of class this value might be automatically computed to fit different elements.
         * @returns  Vec2 minimum size or undefined if unimplemented
         */
        getMinimumSize(): Point | undefined;
        /**
         * Disable/Enable all animations of the Chart.
         *
         * NOTE: Data grid doesn't currently have any built in animations, so this method does not do anything.
         *
         * @returns                  Chart itself for fluent interface.
         * @public
         */
        setAnimationsEnabled(_: boolean | undefined): this;
        /**
         * **Permanently** dispose the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setBackgroundEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getBackgroundEffect(): boolean;
        /**
         * Configure user interactions from a set of preset options.
         *
         * Without any explicit configuration, the charts select the default user interaction scheme based on available information,
         * such as axis types, attached series and data supplied to series.
         *
         * The `setUserInteraction` methods allow explicitly configuring the used interaction scheme.
         *
         * ```ts
         *  // Example, disable all user interactions
         *  chart.setUserInteractions(undefined)
         * ```
         *
         * @param   config -    Option with any set of properties of {@link DataGridInteractions} or `undefined` to disable all interactions.
         * @returns     Object itself.
         * @public
         * @beta    Introduced in v7.0.0. API may change according to user feedback.
         */
        setUserInteractions(config: Partial<DataGridInteractions> | undefined): this;
        /**
         * Get currently active user interaction scheme.
         * This does NOT return the last value supplied to {@link setUserInteractions}.
         * Rather, it considers the current structure of the chart, all built-in defaults as well as overrides supplied by the user
         * and returns the currently used interaction scheme.
         *
         * @returns     DataGridInteractions
         * @public
         * @beta    Introduced in v7.0.0. API may change according to user feedback.
         */
        getUserInteractions(): DataGridInteractions;
        /**
         * Set fill style of the area behind all cells.
         * @param value - Fill style object or function which modifies it.
         * @returns         Object itself for fluent interface.
         * @public
         */
        setGridBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Gets the fill style of the area behind all cells.
         *
         * @returns Current fill style object
         * @public
         */
        getGridBackgroundFillStyle(): FillStyle;
        /**
         * Set content of a single cell at intersection of supplied column and row.
         *
         * This creates a new cell if it doesn't exist, and overrides any previously set content in the cell.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setCellContent(0, 0, 'First Name')
         *      .setCellContent(0, 1, 'John')
         * ```
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param content - Data grid cell content.
         * @public
         * {@label SINGLE_CELL}
         */
        setCellContent(column: number, row: number, content: DataGridCellContent): this;
        /**
         * Merge several cells together and set their content.
         * Any rectangular set of cells can be merged together, which results in the following effects:
         *  - Merged cells have shared content, style, borders and background.
         *      - Altering any of the cells will affect the merged cells as one unit.
         *      - Altering the content of any of the merged cells will undo the merge.
         *  - Merged cells width is equal to the sum of all its columns widths, and vice versa for height.
         *
         * This creates new cells where don't exist, and overrides any previously set content in the cell.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setCellContent(0, 0, 2, 2, 'Big header')
         *      .setCellContent(2, 0, 'Small header 1')
         *      .setCellContent(2, 1, 'Small header 2')
         * ```
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param columnSpan - Number of columns to fuse together.
         * @param rowSpan - Number of rows to fuse together.
         * @param content - Data grid cell content.
         * @returns              Object itself
         * @public
         * {@label MERGED_CELL}
         */
        setCellContent(column: number, row: number, columnSpan: number, rowSpan: number, content: DataGridCellContent): this;
        /**
         * Set contents of cells along a supplied column.
         *
         * This creates new cells where they don't exist, and overrides any previously set content over modified cells.
         *
         * Number of cells is supplied as an Array. If there are more cells that extend further than the supplied Array, they are untouched.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setColumnContent(0, ['First Name', 'Last Name'])
         *      .setColumnContent(1, ['John', 'Smith'])
         * ```
         *
         * @param column - Column index starting from 0.
         * @param content - Array of data grid cell content.
         * @returns              Object itself.
         * @public
         */
        setColumnContent(column: number, content: DataGridCellContent[]): this;
        /**
         * Set contents of cells along a supplied row.
         *
         * This creates new cells where they don't exist, and overrides any previously set content over modified cells.
         *
         * Number of cells is supplied as an Array. If there are more cells that extend further than the supplied Array, they are untouched.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setRowContent(0, ['First Name', 'Last Name'])
         *      .setRowContent(1, ['John', 'Smith'])
         * ```
         *
         * @param row - Row index starting from 0.
         * @param content - Array of data grid cell content.
         * @returns              Object itself.
         * @public
         */
        setRowContent(row: number, content: DataGridCellContent[]): this;
        /**
         * Set contents of a table of cells originating from column 0 and row 0.
         *
         * This creates new cells where they don't exist, and overrides any previously set content over the table area.
         *
         * This does not remove any cell content outside the table area.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setTableContent([
         *      ['First Name', 'Second Name'],
         *      ['John', 'Smith']
         *  ])
         * ```
         * @param content - 2D Array of data grid cell content.
         * @returns              Object itself.
         * @public
         */
        setTableContent(content: DataGridCellContent[][]): this;
        /**
         * Method sets width of a single column in Data Grid.
         *
         * Column width can be specified in several ways; width as pixels, fit to content, minimum width as pixels or maximum width as pixels.
         *
         * ```ts
         *  // Example usage, set first column width to exactly 200 pixels
         *  DataGrid.setColumnWidth(0, 200)
         * ```
         *
         * ```ts
         *  // Example usage, set first column max width to 200 pixels
         *  DataGrid.setColumnWidth(0, { max: 200 })
         * ```
         *
         * @param column - Index of column in Data Grid.
         * @param width - Width of column.
         * @returns         Object itself.
         * @public
         */
        setColumnWidth(column: number, width: number | undefined | {
            min?: number;
            max?: number;
        }): this;
        /**
         * Method sets width of a single row in Data Grid.
         *
         * Row width can be specified in several ways; height as pixels, fit to content, minimum height as pixels or maximum height as pixels.
         *
         * ```ts
         *  // Example usage, set first row height to exactly 200 pixels
         *  DataGrid.setRowHeight(0, 200)
         * ```
         *
         * ```ts
         *  // Example usage, set first row max height to 200 pixels
         *  DataGrid.setRowHeight(0, { max: 200 })
         * ```
         *
         * @param row - Index of row in Data Grid.
         * @param height - Height of row.
         * @returns         Object itself.
         * @public
         */
        setRowHeight(row: number, height: number | undefined | {
            min?: number;
            max?: number;
        }): this;
        /**
         * Set padding of all cells along a specified column.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setColumnPaddings(0, 5) // Sets all paddings to 5.
         *      .setColumnPaddings(0, { top: 2, bottom: 10, left: 5, right: 5 }) // Sets specific paddings.
         * ```
         *
         * @param column - Column index starting from 0.
         * @param padding - Either number as shorthand or @see Padding for padding along configurable directions.
         * @returns              Object itself.
         * @public
         */
        setColumnPaddings(column: number, padding: Partial<Padding> | number): this;
        /**
         * Set padding of all cells along a specified row.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setRowPaddings(0, 5) // Sets all paddings to 5.
         *      .setRowPaddings(0, { top: 2, bottom: 10, left: 5, right: 5 }) // Sets specific paddings.
         * ```
         *
         * @param row - Row index starting from 0.
         * @param padding - Either number as shorthand or @see Padding for padding along configurable directions.
         * @returns              Object itself.
         * @public
         */
        setRowPaddings(row: number, padding: Partial<Padding> | number): this;
        /**
         * Set padding of a cell at the intersection of the specified row and column.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setCellPadding(0, 5, 5) // Sets all paddings to 5.
         *      .setCellPadding(0, 10, { top: 2, bottom: 10, left: 5, right: 5 }) // Sets specific paddings.
         * ```
         *
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param padding - Either number as shorthand or @see Padding for padding along configurable directions.
         * @returns              Object itself.
         * @public
         */
        setCellPadding(column: number, row: number, padding: Partial<Padding> | number): this;
        /**
         * Sets the default padding for all cells.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setCellsPaddings(5) // Sets all paddings to 5.
         *      .setCellsPaddings({ top: 2, bottom: 10, left: 5, right: 5 }) // Sets specific paddings.
         * ```
         *
         * This method also modifies the default cell padding, which is carried over to any cells that are created afterwards.
         *
         * @param padding - Either number as shorthand or @see Padding for padding along configurable directions.
         * @returns              Object itself.
         * @public
         */
        setCellsPaddings(padding: Partial<Padding> | number): this;
        /**
         * Set selection of visible borders of a single cell at intersection of supplied column and row.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setCellBorders(0, 0, {top: false, bottom: true, })
         * ```
         *
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param borders - Object describing the selection of which borders to show, OR undefined as a shorthand for no borders (equivalent to `{top: false, bottom: false, right: false, left: false}`).
         * @public
         */
        setCellBorders(column: number, row: number, borders: DataGridCellBorders | undefined): this;
        /**
         * Set selection of visible borders of a row of cells at the supplied row index.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * ```ts
         *  DataGrid.setRowBorders(0, {top: false, bottom: true, })
         * ```
         *
         * @param row - Row index starting from 0.
         * @param borders - Object describing the selection of which borders to show, OR undefined as a shorthand for no borders (equivalent to `{top: false, bottom: false, right: false, left: false}`).
         * @public
         */
        setRowBorders(row: number, borders: DataGridCellBorders | undefined): this;
        /**
         * Set selection of visible borders of a column of cells at the supplied column index.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * ```ts
         *  DataGrid.setColumnBorders(0, {top: false, bottom: true, })
         * ```
         *
         * @param column - Column index starting from 0.
         * @param borders - Object describing the selection of which borders to show, OR undefined as a shorthand for no borders (equivalent to `{top: false, bottom: false, right: false, left: false}`).
         * @public
         */
        setColumnBorders(column: number, borders: DataGridCellBorders | undefined): this;
        /**
         * Set the default selection of which borders are shown for all cells.
         * This default setting is overridden by any methods that set explicit borders for 1 or several cells.
         *
         * ```ts
         *  DataGrid.setCellsBorders({top: false, bottom: true, })
         * ```
         *
         * This method also modifies the default cell borders, which is carried over to any cells that are created afterwards.
         *
         * @param borders - Object describing the selection of which borders to show, OR undefined as a shorthand for no borders (equivalent to `{top: false, bottom: false, right: false, left: false}`).
         * @public
         */
        setCellsBorders(borders: DataGridCellBorders | undefined): this;
        /**
         * Set the cell border stroke style for all cells.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setCellsBorderStrokeStyle(new SolidLine({thickness: 2}))
         * ```
         *
         * This applies to all existing cells as well as any cells that are created afterwards.
         *
         * @param value - LineStyle or function which modifies the current LineStyle.
         * @returns              Object itself.
         * @public
         */
        setCellsBorderStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Set text fill style of all cells along a specified column.
         *
         * This does not affect any cells that are defined after the method is called.
         * @param column - Column index starting from 0.
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @returns              Object itself.
         * @public
         */
        setColumnTextFillStyle(column: number, value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set text fill style of all cells along a specified row.
         *
         * This does not affect any cells that are defined after the method is called.
         * @param row - Row index starting from 0.
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @returns              Object itself.
         * @public
         */
        setRowTextFillStyle(row: number, value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set text fill style of a cell at the intersection of the specified row and column.
         *
         * This does not affect any cells that are defined after the method is called.
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @returns              Object itself.
         * @public
         */
        setCellTextFillStyle(column: number, row: number, value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Sets the default text fill style for all cells.
         *
         * This method also modifies the default cell text fill style, which is carried over to any cells that are created afterwards.
         *
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @returns              Object itself.
         * @public
         */
        setCellsTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set text font of all cells along a specified column.
         *
         * This does not affect any cells that are defined after the method is called.
         * @param column - Column index starting from 0.
         * @param value - FontSettings or function which modifies the current FontSettings.
         * @returns              Object itself.
         * @public
         */
        setColumnTextFont(column: number, value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Set text font of all cells along a specified row.
         *
         * This does not affect any cells that are defined after the method is called.
         * @param row - Row index starting from 0.
         * @param value - FontSettings or function which modifies the current FontSettings.
         * @returns              Object itself.
         * @public
         */
        setRowTextFont(row: number, value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Set text font of a cell at the intersection of the specified row and column.
         *
         * This does not affect any cells that are defined after the method is called.
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param value - FontSettings or function which modifies the current FontSettings.
         * @returns              Object itself.
         * @public
         */
        setCellTextFont(column: number, row: number, value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Sets the text font style of all cells.
         *
         * This method also modifies the default cell text font, which is carried over to any cells that are created afterwards.
         *
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @returns              Object itself.
         * @public
         */
        setCellsTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Set cell content alignment of all cells along a specified column.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setColumnContentAlignment(0, 'right-center')
         * ```
         *
         * This does not affect any cells that are defined after the method is called.
         * @param column - Column index starting from 0.
         * @param alignment - Cell content alignment options.
         * @returns              Object itself.
         * @public
         */
        setColumnContentAlignment(column: number, alignment: DataGridCellContentAlignment): this;
        /**
         * Set cell content alignment of all cells along a specified row.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setRowContentAlignment(1, 'top-left')
         * ```
         *
         * This does not affect any cells that are defined after the method is called.
         *
         *
         * @param row - Row index starting from 0.
         * @param alignment - Cell content alignment options.
         * @returns              Object itself.
         * @public
         */
        setRowContentAlignment(row: number, alignment: DataGridCellContentAlignment): this;
        /**
         * Set cell content alignment of a cell at the intersection of the specified row and column.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setCellContentAlignment(1, 2, 'top-left')
         * ```
         *
         * This does not affect any cells that are defined after the method is called.
         *
         *
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param alignment - Cell content alignment options.
         * @returns              Object itself.
         * @public
         */
        setCellContentAlignment(column: number, row: number, alignment: DataGridCellContentAlignment): this;
        /**
         * Sets the default content alignment for all cells.
         *
         * This method also modifies the default cell text alignment, which is carried over to any cells that are created afterwards.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setCellsContentAlignment('top-left')
         * ```
         *
         * @param alignment - Content alignment options.
         * @returns              Object itself.
         * @public
         */
        setCellsContentAlignment(alignment: DataGridCellContentAlignment): this;
        /**
         * Set background fill style of a single cell at intersection of supplied column and row.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @public
         */
        setCellBackgroundFillStyle(column: number, row: number, value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set background fill style of cells at the supplied column.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * @param column - Column index starting from 0.
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @public
         */
        setColumnBackgroundFillStyle(column: number, value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set background fill style of cells at the supplied row.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * @param row - Row index starting from 0.
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @public
         */
        setRowBackgroundFillStyle(row: number, value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set background fill style of all cells.
         *
         * This method also modifies the default cell background fill style, which is carried over to any cells that are created afterwards.
         *
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @public
         */
        setCellsBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set highlight state of a single cell at intersection of supplied column and row.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param highlight - Highlight state as number between `0` and `1` or `Boolean`.
         * @public
         */
        setCellHighlight(column: number, row: number, highlight: boolean | number): this;
        /**
         * Set highlight state of cells at the supplied column.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * @param column - Column index starting from 0.
         * @param highlight - Highlight state as number between `0` and `1` or `Boolean`.
         * @public
         */
        setColumnHighlight(column: number, highlight: boolean | number): this;
        /**
         * Set highlight state of cells at the supplied row.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * @param row - Row index starting from 0.
         * @param highlight - Highlight state as number between `0` and `1` or `Boolean`.
         * @public
         */
        setRowHighlight(row: number, highlight: boolean | number): this;
        /**
         * Remove the cell at the intersection of the specified column and row.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.removeCell(4,0)
         * ```
         *
         * @param column - Column index starting from 0.
         * @param row - Column index starting from 0.
         * @returns              Object itself.
         * @public
         */
        removeCell(column: number, row: number): this;
        /**
         * Remove all cells along a specified row.
         * Removing a row shifts the row indexes of all cells below the removed row.
         * ```ts
         *  // Example usage
         *  DataGrid.removeRow(5)
         * ```
         *
         * @param row - Column index starting from 0.
         * @returns              Object itself.
         * @public
         */
        removeRow(row: number): this;
        /**
         * Remove all cells along a specified column.
         * Removing a column shifts the column indexes of all cells to the right of the removed column.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.removeColumn(0)
         * ```
         *
         * @param column - Column index starting from 0.
         * @returns              Object itself.
         * @public
         */
        removeColumn(column: number): this;
        /**
         * Removes all cells.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.removeCells()
         * ```
         *
         * @returns              Object itself.
         * @public
         */
        removeCells(): this;
        /**
         * Get last column index in Data Grid, taking into account column span.
         *
         * The returned value identifies the last occupied column index.
         *
         * @returns      Last occupied column index in Data Grid.
         * @public
         */
        getColumnMax(): number;
        /**
         * Get last row index in Data Grid, taking into account row span.
         *
         * The returned value identifies the last occupied row index.
         *
         * @returns      Last occupied row index in Data Grid.
         * @public
         */
        getRowMax(): number;
        /**
         * Interface for attaching listeners to user interaction events (`click`, `pointerenter`, etc.) on cells of the data grid.
         *
         * ```ts
         *  // Example syntax
         *  dataGrid.cells.addEventListener('click', (event, cell) => {
         *      console.log(event, cell)
         *  })
         * ```
         *
         * For more syntax examples, refer to {@link EventInterface}.
         * Available event keys are listed under {@link LCJSInteractionEventMap}
         * @public
         */
        readonly cells: Eventer<LCJSInteractionEventMap, DataGridCell>;
        addEventListener<K extends keyof PanelEventMap>(type: K, listener: (event: PanelEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof PanelEventMap>(type: K, listener: (event: PanelEventMap[K], info: unknown) => unknown): void;
    }
    /**
     * Description of a single cell in a {@link DataGrid}.
     * @public
     */
    export declare interface DataGridCell {
        column: number;
        row: number;
    }
    /**
     * Data structure that describes border visibility of 1 cell in a {@link DataGrid}.
     *
     * Use with methods:
     *
     * - {@link DataGrid.setCellBorders}
     * - {@link DataGrid.setRowBorders}
     * - {@link DataGrid.setColumnBorders}
     * - {@link DataGrid.setCellsBorders}
     *
     * ```ts
     *  // Example, hide top border and show bottom border from cell at column 1 and row 1.
     *  DataGrid.setCellBorders(1, 1, { top: false, bottom: true })
     * ```
     *
     * @public
     */
    export declare type DataGridCellBorders = {
        top?: boolean;
        bottom?: boolean;
        right?: boolean;
        left?: boolean;
    };
    /**
     * Type definition of {@link DataGrid} cell content.
     *
     * `string`:
     *
     * Display supplied string inside cell. Text fill style, font and alignment can be customized.
     * See documentation of {@link DataGrid} for more details.
     *
     * `number`:
     *
     * Display supplied number inside cell. Text fill style, font and alignment can be customized.
     * See documentation of {@link DataGrid} for more details.
     *
     * `SparkChart`:
     *
     * Place a miniature chart (Spark Chart) inside the cell according to the provided description.
     *
     * ```ts
     *  // Example, spark line chart
     *  DataGrid.setCellContent(0, 0, {
     *      type: 'spark-line',
     *      data: [0, 10, 6, 4, 9, 8, 3, 6]
     *  })
     * ```
     *
     * To learn of available types of Spark Charts as well as all optional configuration properties, see {@link SparkChart}.
     *
     * `Icon`:
     *
     * Show an Icon inside the cell. Icon alignment can be customized with the same method as text.
     *
     * ```ts
     *  // Example, place an Icon inside a data grid cell.
     *  DataGrid.setCellContent(0, 0, myIcon)
     * ```
     *
     * To learn how to load Icons, see {@link PublicEngine.addCustomIcon}.
     *
     * `undefined`:
     *
     * Show nothing inside the cell. This retains style information of the cell, in contrast to {@link DataGrid.removeCell | _removing the cell_}.
     *
     * @public
     */
    export declare type DataGridCellContent = string | number | SparkChart | Icon | undefined;
    /**
     * Type definition of different options to aligning content inside a {@link DataGrid} cell.
     *
     * Use with methods:
     *
     * - {@link DataGrid.setCellContentAlignment}
     * - {@link DataGrid.setRowContentAlignment}
     * - {@link DataGrid.setColumnContentAlignment}
     * - {@link DataGrid.setCellsContentAlignment}
     *
     * ```ts
     *  // Example, apply 'right-center' content alignment in all cells that are currently defined on column 0.
     *  DataGrid.setColumnContentAlignment(0, 'right-center')
     * ```
     *
     * To access all run-time options of `DataGridCellContentAlignment`, see {@link DataGridCellContentAlignmentOptions}
     * @public
     */
    export declare type DataGridCellContentAlignment = EnumToStringUnion<DataGridCellContentAlignmentOptions>;
    /**
     * Enum of different options to aligning content inside a {@link DataGrid} cell.
     *
     * Use with methods:
     *
     * - {@link DataGrid.setCellContentAlignment}
     * - {@link DataGrid.setRowContentAlignment}
     * - {@link DataGrid.setColumnContentAlignment}
     * - {@link DataGrid.setCellsContentAlignment}
     *
     * ```ts
     *  // Example, apply 'right-center' content alignment in all cells that are currently defined on column 0.
     *  DataGrid.setColumnContentAlignment(0, 'right-center')
     * ```
     *
     * This is an enum type, which can be iterated during run time, for example when creating a menu selector for content alignment options.
     * Respective type definition is exported as {@link DataGridCellContentAlignment}.
     *
     * @public
     */
    export declare enum DataGridCellContentAlignmentOptions {
        Center = "center",
        RightCenter = "right-center",
        LeftCenter = "left-center",
        RightTop = "right-top",
        LeftTop = "left-top",
        RightBottom = "right-bottom",
        LeftBottom = "left-bottom",
        CenterTop = "center-top",
        CenterBottom = "center-bottom"
    }
    /**
     * Interface that can be used to define {@link DataGrid} configurations, when inside a {@link Dashboard},
     * that can't be changed after creation.
     * @public
     */
    export declare interface DataGridDashboardOptions extends DashboardCellOptions {
    }
    /**
     * @public
     * @beta    Introduced in v7.0.0. API may change according to user feedback.
     */
    export declare interface DataGridInteractions {
        scroll?: false | InteractionConfigWithOverrides<{
            x?: boolean;
            y?: boolean;
        }, 'wheel'>;
    }
    /**
     * Interface for supplying an Array of High Low data to a component.
     *
     * Given data is expected to be two number Arrays of equal length, which will be transformed into
     * a single array of AreaPoints.
     * This method is for end user utility, and simply transform given data to the format of *add()*.
     * As such, they cause additional performance overhead, so use *add()* whenever possible.
     * @public
     */
    export declare interface DataInputHighLow {
        /**
         * Add an Array of High Low values.
         * Each HighLow value will be paired with an automatically generated HighLow value, based on *step*-argument.
         * **For optimal performance, use add() if possible.**
         * @param arrayHigh - Array of first High values.
         * @param arrayLow - Array of Second Low values
         * @param step - Optional step between each HighLow coordinate. Defaults to 1.
         * @param start - Optional value for first generated HighLow value. Defaults to 0.
         * @returns Object itself for fluent interface.
         * @public
         */
        addArraysHighLow(arrayHigh: number[] | TypedArray, arrayLow: number[] | TypedArray, step?: number, start?: number): this;
    }
    /**
     * Type definition of XY **data mapping**.
     *
     * Specifies which data properties should be used and how in a series that actually visualizes the data.
     * At least `x` and `y` must be specified, others are optional (`color`, `rotation`, `size`, `lookupValue`)
     * @public
     */
    export declare type DataMappingXY = {
        x: string | number;
        y: string | number;
        color?: string | number;
        rotation?: string | number;
        size?: string | number;
        lookupValue?: string | number;
    };
    /**
     * Values used to describe patterns of a data property.
     *
     * - `'progressive'` -\> newer sample always has larger value.
     * - `'regressive'` -\> newer sample always has smaller value.
     * - `null` -\> no pattern.
     * @public
     */
    export declare type DataPattern = 'progressive' | 'regressive' | null;
    /**
     * Object that is used to store, manage and modify data sets used with XY data visualization features.
     * Can be visualized with {@link PointLineAreaSeries}.
     *
     * ```ts
     *  // Example, create a data set object.
     *  const dataSet = new DataSetXY({
     *      schema: {
     *          x: { pattern: 'progressive' },
     *          temperature: { pattern: null }
     *      }
     *  })
     *  PointLineAreaSeries.setDataSet(dataSet)
     *  dataSet.appendSamples({
     *      x: [0, 1, 2],
     *      temperature: [0, 5, 2],
     *  })
     * ```
     *
     * Alternatively, creating a `PointLineAreaSeries` will automatically create a data set, and it directly exposes all the same methods of a `DataSetXY`, so you can also do this for convenience:
     *
     * ```ts
     *  // Example, use data set created by series.
     *  const series = ChartXY.addLineSeries({
     *      schema: {
     *          x: { pattern: 'progressive' },
     *          temperature: { pattern: null }
     *      }
     *  })
     *      .appendSamples({
     *          x: [0, 1, 2],
     *          temperature: [0, 5, 2],
     *      })
     * ```
     *
     * Some properties of `DataSetXY` can only be configured when it is created. See {@link DataSetXYOptions} for more details.
     *
     * List of frequently needed methods:
     *
     * - {@link setMaxSampleCount} data cleaning / max sample count. Should be ALWAYS used in real-time applications.
     * - Methods used for specifying data:
     *      - {@link appendSamples}
     *      - {@link appendSample}
     *      - {@link appendJSON}
     *
     * @public
     */
    export declare class DataSetXY implements DataSetXYAPI {
        /**
         * @nternal
         */
        _mayIncludeNaN: boolean;
        /**
         * @public
         */
        constructor(options?: DataSetXYOptions);
        appendJSON(array: Array<Record<string | number, any>>, arg?: {
            start?: number;
            step?: number;
            whitelist?: string[];
            blacklist?: string[];
        }, fill?: Record<string, number | Color>): this;
        appendSample(sample: Record<string, any>, // number | Date | string but can't be written here because TS is fucking dumb
        opts?: {
            start?: number;
            step?: number;
            whitelist?: string[];
            blacklist?: string[];
        }): this;
        appendSamples(samples: Record<string, any>, opts?: {
            offset?: number;
            count?: number;
            offsetLookupValues?: number;
            offsetColors?: number;
            offsetIds?: number;
            offsetSizes?: number;
            offsetRotations?: number;
            start?: number;
            step?: number;
        }): this;
        fill(arg: Record<string, any>): this;
        setSamples(samples: Record<string | number, any>, //  number[] | Date[] | string[] | TypedArray
        opts?: {
            offset?: number;
            count?: number;
            start?: number;
            step?: number;
        }): this;
        alterSamplesStartingFrom(iSampleMin: number, samples: Record<string, any>, //  number[] | Date[] | string[] | TypedArray | number
        opts?: {
            offset?: number;
            count?: number;
            start?: number;
            step?: number;
        }): this;
        alterSamplesByIndex(sampleIndexes: TypedArray | number[], values: Record<string, any>): this;
        alterSamplesByMatch(matchKey: string, matchValues: TypedArray | number[], values: Record<string, any>): this;
        getSampleCount(): number;
        getNextSampleIndex(): number;
        setMaxSampleCount(maxSampleCount: number): this;
        setMaxSampleCount(arg: {
            mode: 'auto';
            max?: number;
            initial?: number;
        }): this;
        getMaxSampleCount(): number | undefined;
        clear(): this;
        /**
         * Read back the current contents of the data set.
         *
         * ```ts
         *  // Read back data
         *  const data = dataSet.readBack()
         *  console.log(data)
         * ```
         *
         * If data cleaning (max sample count) is enabled, this can result in allocating new memory (and thus be expensive).
         * Otherwise, a very efficient operation.
         *
         * The returned values should NOT be modified.
         *
         * Optionally, you can include the flag `onlyInRange` to find return only samples that are in specified range.
         * This is only supported if the specified data property has a progressive pattern.
         *
         * ```ts
         *  // Example, read back data that is visible
         *  chart.axisX.addEventListener('intervalchange', event => {
         *      const data = dataSet.readBack({ onlyInRange: { key: 'timestamps', start: event.start, end: event.end } })
         *      console.log(data)
         *  })
         * ```
         *
         * This operation is not "pixel perfect", meaning it can often return 1 extra sample that is not visible (the next and/or previous ones).
         *
         * @param arg -     Optional extra arguments.
         * @returns     Object with lists of each data property.
         * @public
         */
        readBack(arg?: {
            onlyInRange?: {
                key: string | number;
                start: number;
                end: number;
            };
        }): {
            data: Record<string | number, TypedArray>;
            iSampleFirst: number;
        };
        addEventListener<K extends keyof DataSetXYEventMap>(type: K, listener: (event: DataSetXYEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof DataSetXYEventMap>(type: K, listener: (event: DataSetXYEventMap[K], info: unknown) => unknown): void;
    }
    /**
     * @public
     */
    export declare interface DataSetXYAPI extends EventInterface<DataSetXYEventMap> {
        /**
         * Add several samples by reading from an Array of JavaScript objects.
         *
         * ```ts
         *  // Example, read x + y
         *  const arr = [{ x: 0, y: 0 }]
         *  DataSetXY.appendJSON(arr)
         * ```
         *
         * ```ts
         *  // Example, property names can be anything
         *  const arr = [{ timestamp: 0, voltage: 0 }]
         *  DataSetXY.appendJSON(arr)
         * ```
         *
         * ```ts
         *  // Input type can also be list of tuples
         *  const arr = [
         *      [0, 100],
         *      [1, 110]
         *  ]
         *  DataSetXY.appendJSON(arr)
         * ```
         *
         * `appendJSON` will by default store **all** supplied data properties.
         * If you only want to load specific properties into the data set, then you should whitelist them:
         *
         * ```ts
         * DataSetXY.appendJSON(data, { whitelist: ['index', 'value'] })
         * ```
         *
         * **Important:** the supplied objects' keys refer to keys of the data sets **schema**.
         * If schema is not defined, then this operation will set it according to supplied keys with default values.
         *
         * This operation will push data to a `DataSetXY` object (either directly or via series).
         * By default, series will connect to data properties that seem logical.
         * It is, however, recommended to explicitly connect X and Y (etc.) to the correct, specific data properties using **data mapping**:
         *
         * ```ts
         *  // Data mapping is specified on a series
         *  series.setDataMapping({ x: 'timestamp', y: 'voltage' })
         * ```
         *
         * Supported data property types:
         *  - `number`
         *  - `Date` object
         *  - ISO8601 Date time string
         *      - "2023-09-06T14:30:00.000Z"
         *      - "2023-09-06"
         *      - "2023-09-06T14:30:00.000+02:00"
         *  - `Color` object
         *      - Colors can also be loaded as single `number` (uint32, least significant byte = red). Using `Color` objects in large quantities should be avoided for performance reasons.
         *
         * For more detailed documentation, please see Developer documentation.
         *
         * @param   array   - Array with JSON objects which represent samples.
         * @param   opts    - Optional extra arguments.
         * @param   fill    - Optional data values to act as "fill behavior", i.e. fill same value for all added samples during this operation.
         * @returns     Object itself.
         * @public
         */
        appendJSON(array: Array<Record<string | number, any>>, opts?: {
            start?: number;
            step?: number;
            whitelist?: string[];
            blacklist?: string[];
        }, fill?: Record<string, number | Color>): this;
        /**
         * Add 1 sample to data set.
         *
         * ```ts
         *  // Example, basic usage
         *  DataSetXY.appendSample({ x: 0, y: 0 })
         * ```
         *
         * ```ts
         *  // Example, only 1 value
         *  DataSetXY.appendSample({ temperature: 0 })
         * ```
         *
         * `appendSample` will by default store **all** supplied data properties.
         * If you only want to load specific properties into the data set, then you should whitelist them:
         *
         * ```ts
         * DataSetXY.appendSample(sample, { whitelist: ['index', 'value'] })
         * ```
         *
         * **Important:** the supplied objects keys refer to keys of the data sets **schema**.
         * If schema is not defined, then this operation will set it according to supplied keys with default values.
         *
         * This operation will push data to a `DataSetXY` object (either directly or via series).
         * By default, series will connect to data properties that seem logical.
         * It is, however, recommended to explicitly connect X and Y (etc.) to the correct, specific data properties using **data mapping**:
         *
         * ```ts
         *  // Data mapping is specified on a series
         *  series.setDataMapping({ x: 'index', y: 'value' })
         * ```
         *
         * Supported data property types:
         *  - `number`
         *  - `Date` object
         *  - ISO8601 Date time string
         *      - "2023-09-06T14:30:00.000Z"
         *      - "2023-09-06"
         *      - "2023-09-06T14:30:00.000+02:00"
         *  - `Color` object
         *      - Colors can also be loaded as single `number` (uint32, least significant byte = red). Using `Color` objects in large quantities should be avoided for performance reasons.
         *
         * For more detailed documentation, please see Developer documentation.
         *
         * @param   arg -   JSON object which represents one sample.
         * @param   opts    - Optional extra arguments.
         * @returns     Object itself.
         * @public
         */
        appendSample(sample: Record<string, any>, opts?: {
            start?: number;
            step?: number;
            whitelist?: string[];
            blacklist?: string[];
        }): this;
        /**
         * Add a list of samples to data set.
         *
         * ```ts
         *  // Example, basic usage.
         *  DataSetXY.appendSamples({
         *      xValues: [0, 1, 2],
         *      yValues: [100, 101, 102],
         *  })
         * ```
         *
         * **Important:** the object keys ("xValues" in above example) refer to keys of the data sets **schema**.
         * If schema is not defined, then this operation will set it according to supplied keys with default values.
         *
         * This operation will push data to a `DataSetXY` object (either directly or via series).
         * By default, series will connect to data properties that seem logical.
         * It is, however, recommended to explicitly connect X and Y (etc.) to the correct, specific data properties using **data mapping**:
         *
         * ```ts
         *  // Data mapping is specified on a series
         *  series.setDataMapping({ x: 'xValues', y: 'yValues' })
         * ```
         *
         * More examples:
         *
         * ```ts
         *  // Example, only 1 value
         *  DataSetXY.appendSamples({
         *      temperatures: [100, 101, 102],
         *  })
         * ```
         *
         * ```ts
         *  // Example, typed array input.
         *  DataSetXY.appendSamples({
         *      temperatures: new Float32Array([100, 101, 102]),
         *  })
         * ```
         *
         * ```ts
         *  // Example, uint32 colors
         *  DataSetXY.appendSamples({
         *      x: [0, 1, 2],
         *      y: [100, 101, 102],
         *      colors: [0xff0000ff, 0xff00ff00, 0xffff0000]
         *  })
         * ```
         *
         * Passing arrays or single values can be freely alternated between, as long as at least one Array-like argument is supplied.
         * Single value means using same argument for every new sample defined in the method call.
         *
         * ```ts
         *  // Example, use same color for every sample
         *  DataSetXY.appendSamples({
         *      yValues: [0, 10, 5],
         *      color: ColorRGBA(255, 0, 0)
         *  })
         * ```
         *
         * Supported data property types:
         *  - Typed array
         *  - `number[]`
         *  - Single `number`
         *  - `Date[]`
         *  - ISO8601 Date time string array
         *      - "2023-09-06T14:30:00.000Z"
         *      - "2023-09-06"
         *      - "2023-09-06T14:30:00.000+02:00"
         *  - `Color` object or `Color[]`
         *      - Colors can also be loaded as single `number` (uint32, least significant byte = red). Using `Color` objects in large quantities should be avoided for performance reasons.
         *
         * `offset` property can optionally be used to start reading values from middle of input array.
         * Can be situationally useful.
         *
         * For more detailed documentation, please see Developer documentation.
         *
         * @param arg - Object with data properties and optional behavior configurations.
         * @param opts - Optional extra arguments.
         * @returns     Object itself.
         * @public
         */
        appendSamples(samples: Record<string, any>, //  number[] | Date[] | string[] | TypedArray
        opts?: {
            offset?: number;
            count?: number;
            start?: number;
            step?: number;
        }): this;
        /**
         * Load same value or many values to all samples that currently exist in the data set.
         *
         * ```ts
         *  // Example, set "size" of all samples to 5
         *  DataSetXY.fill({ size: 5 })
         * ```
         *
         * Supported data property types:
         *  - `number`
         *  - `Date` object
         *  - ISO8601 Date time string
         *      - "2023-09-06T14:30:00.000Z"
         *      - "2023-09-06"
         *      - "2023-09-06T14:30:00.000+02:00"
         *  - `Color` object
         *      - Colors can also be loaded as single `number` (uint32, least significant byte = red). Using `Color` objects in large quantities should be avoided for performance reasons.
         *
         * @public
         * @param   arg - Object with data properties.
         * @returns     Object itself.
         */
        fill(arg: Record<string, any>): this;
        /**
         * Re-specify all values in the data set.
         * This is a convenience method that is fundamentally equal to:
         *
         * ```ts
         *  DataSetXY.clear().appendSamples({ ... })
         * ```
         *
         * There are currently no performance differences between using "setSamples" versus "clear + append".
         * However, in future it is possible that `setSamples` can receive optimizations which would make it recommended over "clear + append".
         * In the mean-time, `setSamples` is recommended for simplicity and clarity in end user applications.
         *
         * For parameters documentation, refer to {@link appendSamples} method.
         *
         * @param arg - Object with data properties and optional behavior configurations.
         * @returns     Object itself.
         * @public
         */
        setSamples(samples: Record<string, any>, //  number[] | Date[] | string[] | TypedArray
        opts?: {
            offset?: number;
            count?: number;
            start?: number;
            step?: number;
        }): this;
        /**
         * Alter a continuous range of existing samples in the data set.
         * This method also supports automatically appending samples when attempting to alter samples that don't exist in data set.
         *
         * This method alters existing samples by referencing _sample indexes_.
         * This simply refers to a incrementing counter of when each sample was first introduced.
         * For example, `0` refers to first sample that was added to data set.
         * When data cleaning is enabled, sample indexes do NOT shift. They always point to unique samples, even if old samples are removed.
         *
         * ```ts
         *  // Example, basic usage - set first sample to { x: 0, y: 0 }
         *  DataSetXY.alterSamples(0, {
         *      x: [0],
         *      y: [1]
         *  })
         * ```
         *
         * ```ts
         *  // Example, alter several samples at once - set first sample to { x: 0, y: 10 }, second sample to { x: 1, y: 11 } and so on.
         *  DataSetXY.alterSamples(0, {
         *      x: [0, 1, 2],
         *      y: [10, 11, 12]
         *  })
         * ```
         *
         * ```ts
         *  // Example, alter last sample to have y = 0.
         *  DataSetXY.alterSamples(DataSetXY.getNextSampleIndex() - 1, {
         *      y: [0]
         *  })
         * ```
         *
         * See also:
         *
         *  - {@link alterSamplesByMatch}.
         *  - {@link alterSamplesByIndex}.
         *
         * @param   iSampleMin - First altered sample index.
         * @param   samples - Object with new sample values. Behaves same as {@link appendSamples}.
         * @param   opts - Extra options. Behaves same as {@link appendSamples}.
         * @returns Object itself.
         * @public
         */
        alterSamplesStartingFrom(iSampleMin: number, samples: Record<string, any>, //  number[] | Date[] | string[] | TypedArray
        opts?: {
            offset?: number;
            count?: number;
            start?: number;
            step?: number;
        }): this;
        /**
         * Alter existing samples in the data set by identifying them with their sample index.
         *
         * This simply refers to a incrementing counter of when each sample was first introduced.
         * For example, `0` refers to first sample that was added to data set.
         * When data cleaning is enabled, sample indexes do NOT shift. They always point to unique samples, even if old samples are removed.
         *
         * ```ts
         *  // Example, alter by sample index
         *  dataSet.alterSamplesByIndex([0, 10], {
         *      yValues: [20, 30]
         *  })
         * ```
         *
         * See also:
         *
         *  - {@link alterSamplesByMatch}.
         *  - {@link alterSamplesStartingFrom}.
         *
         * @param sampleIndexes - Array of sample indexes to alter.
         * @param values -      Values that are placed into selected samples, replacing previous values. Can be arrays, or a `number` to use same value for all altered samples.
         * @returns  Object itself.
         * @public
         */
        alterSamplesByIndex(sampleIndexes: TypedArray | number[], values: Record<string, any>): this;
        /**
         * Alter existing samples in the data set.
         *
         * This method alters existing samples after selecting them based on:
         * 1. the property key (e.g. `"x"`, `"id"`)
         * 2. that properties values (e.g. x=10).
         *
         * ```ts
         *  // Example, basic usage
         *  const dataSet = new DataSetXY()
         *  dataSet.appendSamples({
         *      ids: [0, 1, 2],
         *      yValues: [10, 12, 7],
         *  })
         *  dataSet.alterSamplesByMatch("ids", [1], {
         *      yValues: [20]
         *  })
         *  // result yValues = [10, 20, 7]
         * ```
         *
         * ```ts
         *  // Example, apply same value to all altered samples
         *  dataSet.alterSamplesByMatch("ids", [0, 1, 2], { size: 5 })
         * ```
         *
         * See also:
         *
         *  - {@link alterSamplesStartingFrom}.
         *  - {@link alterSamplesByIndex}.
         *
         * @param matchKey -    Data property that is used to select samples that should be altered.
         * @param matchValues - Array of values that are checked from `matchKey` data values to select samples that should be altered.
         * @param values -      Values that are placed into selected samples, replacing previous values. Can be arrays, or a `number` to use same value for all altered samples.
         * @returns  Object itself.
         * @public
         */
        alterSamplesByMatch(matchKey: string, matchValues: TypedArray | number[], values: Record<string, any>): this;
        /**
         * Get number of samples currently existing in the data set.
         * This does NOT count any samples that have been dropped out by data cleaning logic.
         * @returns     Number.
         * @public
         */
        getSampleCount(): number;
        /**
         * Get next new sample index.
         * This also counts old samples that have been dropped out by data cleaning logic.
         * @returns     Number.
         * @public
         */
        getNextSampleIndex(): number;
        /**
         * Clear all samples in the data set.
         * @returns     Object itself.
         * @public
         */
        clear(): this;
        /**
         * All real-time use cases (where data points are pushed in periodically) must define a "max sample count".
         * ```ts
         *  // Example, keep maximum 1 million samples
         *  PointLineAreaSeries.setMaxSampleCount(1_000_000)
         *  ```
         *
         * This allocates the required amount of memory beforehand, which is crucial to get the best performance.
         * After 1 million samples are reached, the oldest samples will start dropping out.
         *
         * Alternatively, if you are uncertain what value to use and don't want to allocate too much memory up-front, you can start small and automatically increase the buffer size as samples flow in:
         *
         * ```ts
         *  PointLineAreaSeries.setMaxSampleCount({ mode: 'auto', max: 10_000_000 })
         * ```
         *
         * This would first allocate only small amount of memory, progressively increase memory allocation as samples come in until eventually limiting sample count to 10 million.
         *
         * @param       maxSampleCount  - Max sample count.
         * @returns     Object itself.
         * @public
         */
        setMaxSampleCount(maxSampleCount: number): this;
        /**
         * All real-time use cases (where data points are pushed in periodically) must define a "max sample count".
         * ```ts
         *  // Example, keep maximum 1 million samples
         *  PointLineAreaSeries.setMaxSampleCount(1_000_000)
         * ```
         *
         * This allocates the required amount of memory beforehand, which is crucial to get the best performance.
         * After 1 million samples are reached, the oldest samples will start dropping out.
         *
         * Alternatively, if you are uncertain what value to use and don't want to allocate too much memory up-front, you can start small and automatically increase the buffer size as samples flow in:
         *
         * ```ts
         *  PointLineAreaSeries.setMaxSampleCount({ mode: 'auto', max: 10_000_000 })
         * ```
         *
         * This would first allocate only small amount of memory, progressively increase memory allocation as samples come in until eventually limiting sample count to 10 million.
         *
         * @param       arg -
         * @returns     Object itself.
         * @public
         */
        setMaxSampleCount(arg: {
            mode: 'auto';
            max?: number;
            initial?: number;
        }): this;
        /**
         * Get current configured maximum sample count.
         * See {@link setMaxSampleCount} for more information.
         * @returns     Number of `undefined`.
         * @public
         */
        getMaxSampleCount(): number | undefined;
    }
    /**
     * Configuration for automatic indexing of a data property.
     *
     * `true` is short-hand for `{ start: 0, step: 1 }`
     * @public
     */
    export declare type DataSetXYAutoPropertyConfig = boolean | {
        start?: number;
        step?: number;
    };
    /**
     * @public
     * @privateRemarks  Has to be public for typings
     */
    declare interface _DataSetXYChangedEvent {
        type: 'change';
        iDataStart: number;
        iDataEnd: number;
    }
    /**
     * Interface of events trackable by {@link DataSetXY.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface DataSetXYEventMap {
        /**
         * Event fired when the data set max sample count is exceeded.
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('maxsamplecountexceed', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        maxsamplecountexceed: DataSetXYMaxSampleCountExceededEvent;
        /**
         * Event fired when the data sets contents are changed
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('change', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        change: _DataSetXYChangedEvent;
        /**
         * Event fired when the data set is cleared
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('inviewchange', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        clear: {
            type: 'clear';
        };
        loop: {
            type: 'loop';
        };
    }
    /**
     * @public
     */
    export declare interface DataSetXYMaxSampleCountExceededEvent {
        type: 'maxsamplecountexceed';
        currentSampleCount: number;
        currentMaxSampleCount: number;
        newTotalSampleCount: number;
    }
    /**
     * Readonly options for {@link DataSetXY}.
     * These can only be specified when a DataSetXY is created, and can't be changed afterwards.
     *
     * These can also be specified when a {@link PointLineAreaSeries} is created, which passes them over to the internally created {@link DataSetXY}.
     * @public
     */
    export declare interface DataSetXYOptions {
        /**
         * Define what data can be stored in the data set.
         *
         * ```ts
         *  // Example
         *  const series = chart.addLineSeries({
         *      schema: {
         *          index: { auto: true },
         *          x: { pattern: 'progressive' },
         *          y: { storage: Float32Array },
         *          pointSize: {}
         *      }
         *  })
         * ```
         *
         * If schema is not defined, it is automatically configured to match first incoming data.
         * First pushed data can also expand the configured schema - meaning you can configure known data properties, and still be able to consume other data properties that you may not know beforehand.
         *
         * For more detailed documentation, please see Developer documentation.
         */
        schema?: DataSetXYSchema;
        /**
         * Controls whether automatic sorting of data according is enabled or disabled.
         * If `dataPattern` is any kind of progressive pattern, then input data can be automatically sorted to remain in that progressive order.
         * This can be useful when data is arriving in the application asynchronously and it can't be guaranteed that it arrives in the correct order.
         *
         * Please note that auto sorting only sorts by BATCH, not by SAMPLE.
         * For example, if you supply batches of for example 10 samples at a time, auto sorting is capable of identifying the scenario where a newer batch arrives before one that should be displayed first.
         * However, auto sorting is not capable of sorting any samples that are in wrong order within a BATCH.
         * This is intentional due to effects on performance, and since its not a realistic need scenario.
         *
         * Defaults to `true`.
         *
         * ```ts
         *  // Example, disable auto sorting.
         *  const dataSet = new DataSetXY({ autoSortingEnabled: false })
         * ```
         *
         * ```ts
         *  // Example, works same way if using series API directly instead of via DataSetXY
         *  const series = ChartXY.addLineSeries({ autoSortingEnabled: false })
         * ```
         *
         * Auto sorting is never applied on automatically detected data patterns.
         */
        autoSortingEnabled?: boolean;
        /**
         * Optional flag that can be used to prevent {@link DataSetXY} from modifying arrays that user passes to its methods.
         * This can happen when supplying Typed arrays to DataSetXY methods, for example:
         *
         * ```ts
         *  const myArr = new Float32Array([ 0, 1, 2, 3, 4 ])
         *  DataSetXY.appendSamples({ yValues: myArr })
         *  DataSetXY.alterSamples(...)
         *  // values inside `myArr` may be affected by operation!
         * ```
         *
         * Utilizing this behavior is under no circumstance recommended.
         * However, this flag is added in case this behavior would result in undesired consequences in an user application.
         * In this case, you can simply disable it:
         *
         * ```ts
         *  // Example, disallow DataSetXY methods from altering any data array supplied by user.
         *  const dataSet = new DataSetXY({ allowInputModification: false })
         * ```
         *
         * This can have some disadvantages to performance, but should not be anything too major.
         */
        allowInputModification?: boolean;
        /**
         * Optional flag that can be used to prevent automatic pattern detection.
         * This is useful in use cases where you don't exactly know what data properties will be received, or simply don't want to explicitly configure each one.
         *
         * ```ts
         *  // Example, specify any known progressive data properties, and prevent any others from being detected automatically
         *  const dataSet = new DataSetXY({
         *      schema: {
         *          time: { pattern: 'progressive' }
         *      },
         *      autoDetectPatterns: false
         *  })
         * ```
         */
        autoDetectPatterns?: boolean;
        /**
         * Optional flag that can be used to inform that data set will not include `NaN` values.
         * By default, it is assumed that the data provided might include `NaN` values.
         * This results in extra processing to properly handle `NaN` values.
         *
         * In case where you know that your data points will NOT include `NaN` values, you can set this to `false` for slight performance increase.
         *
         * ```ts
         *  const series = ChartXY.addLineSeries({ includesNaN: false })
         * ```
         */
        includesNaN?: boolean;
        /**
         * Optional flag that can be used to enable strict mode.
         *
         * By default, data set class is quite lenient in its use for purposes of backwards compatibility and easier learning curve.
         * If user wishes to ensure that data set is controlled very strictly, rather than leaning on automatic "quality of life" behaviors,
         * strict mode can be enabled.
         *
         * **Behavior differences if enabled:**
         *
         * - Schema must be defined when data set is created.
         * - All schema properties must include a data pattern specification.
         * - Schema can never be changed afterwards during runtime.
         * - Input data must always include all values as expected by the schema.
         * - Series data mapping must be explicitly specified.
         * - Data mapping must refer to properties that exist in the schema.
         *
         * If any condition is not respected, an Error will be thrown.
         */
        strictMode?: boolean;
        /**
         * Optional flag to allow disabling all data set related warnings.
         *
         * **Usage is strongly discouraged unless use case specifically needs it**
         *
         * In majority of cases Data set warnings should be disabled by applying proper configurations.
         * This bloats up application code a bit but is important for:
         *  - Ensuring application functions same regardless of what data is supplied (rather than automatic quality of life behaviors having chance of behaving differently)
         *  - Improving performance by disabling automatic quality of life checks.
         *
         * In use cases where your application doesn't know what data is coming and you need to prepare data set before first sample arrives, disabling warnings can be OK as long as you know what you are doing.
         */
        warnings?: boolean;
    }
    /**
     * Type definition of `DataSetXY` **schema**.
     * See {@link DataSetXYOptions.schema} for more information.
     * @public
     */
    export declare type DataSetXYSchema = Record<string | number, undefined | {
        pattern?: DataPattern;
        storage?: TypedArrayConstructor;
        auto?: DataSetXYAutoPropertyConfig;
        ensureNoDuplication?: boolean;
    }>;
    /**
     * Interface for a data point that contains an associated numeric data value.
     *
     * Can be used for dynamic per data point coloring when associated with a Color lookup table {@link LUT}.
     *
     * For some series types, dynamic data point coloring might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     * @public
     */
    export declare interface DataValue {
        /**
         * Numeric value associated with the data point.
         *
         * Can be used for dynamic per data point coloring when associated with a Color lookup table {@link LUT}.
         *
         * For some series types, dynamic data point coloring might have to be explicitly enabled when the series is created.
         * Refer to series documentation for more detailed information.
         */
        readonly value?: number;
    }
    /**
     * Type union of supported methods of defining a formatting behavior for *DateTime TickStrategy*.
     *
     * **1. Intl.DateTimeFormatOptions:**
     *
     *  Use JavaScript API for formatting logic by supplying a *Intl.DateTimeFormatOptions* object. Example usage:
     *
     * ```javascript
     *  // 'January 2015'
     *  { year: 'numeric', month: 'long' }
     * ```
     *
     * For complete documentation of valid keys and values, refer to
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     *
     * **2. Custom formatting function:**
     *
     * Specify custom formatting logic by supplying a *function* that returns a *string*. Example usage:
     *
     * ```javascript
     *  ( value, range ) => {
     *      // 'value' = number position of tick along the *Axis*.
     *      // 'range' = *FormattingRange* object that can be used to find the total range of the *Axis*, if needed.
     *
     *      // Return *string*.
     *      return "any string"
     *  }
     *
     *  ( value ) => {
     *      // JS *Date* API can be used to interpret numeric *Axis* positions as *UTC Date/Time*, exposing a multitude of handy methods.
     *      const date = new Date( value )
     *      return date.toLocaleTimeString()
     *  }
     * ```
     *
     * JS *Date* documentation: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
     * @public
     */
    export declare type DateTimeFormatter = Intl.DateTimeFormatOptions | FormattingFunction;
    /**
     * *Axis Tick Strategy* that is designed for depicting date and time.
     *
     * Axis values are interpreted as UNIX timestamps similarly as with JavaScript Date API.
     *
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
     *
     * Axis interval ranges supported by `DateTImeTickStrategy`:
     * - Minimum: 1 second (`1000`).
     * - Maximum: 1000 years (*really big number*).
     *
     * For reaching Axis ranges smaller than 1 second, {@link TimeTickStrategy} is recommended.
     *
     * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to {@link Axis} documentation for more information.
     *
     * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
     *
     * ```js
     *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (dateTimeTicks) => dateTimeTicks)
     * ```
     *
     * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
     * see example below for the idea:
     *
     * ```js
     *  // Specify TickStrategy and use callback to style automatic ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (dateTimeTicks) => dateTimeTicks
     *      // All methods of `DateTimeTickStrategy` can be used here for styling ticks.
     *      .setMajorTickStyle((majorTicks) => majorTicks
     *          .setLabelFont((font) => font
     *              .setWeight('bold')
     *          )
     *      )
     *  )
     * ```
     *
     * All available strategies for automatic Axis ticks creation can be referenced via {@link AxisTickStrategies}.
     * @public
     */
    export declare class DateTimeTickStrategy extends DateTimeTickStrategyRecord implements MutableAxisTickStrategy {
        /**
         * Set cursor formatter for this `DateTimeTickStrategy` object.
         *
         * This will override the date time formatting used by:
         * - Default cursor result table formatters.
         * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
         * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
         *
         * ```ts
         *  // Example syntax, specify cursor formatting to display week day, year, month, day, hour and minute.
         *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (ticks) => ticks
         *      .setCursorFormatter((value, range, locale) =>
         *          new Date(value).toLocaleDateString(locale, {
         *              weekday: 'long',
         *              year: 'numeric',
         *              month: 'numeric',
         *              day: 'numeric',
         *              minute: '2-digit',
         *              hour: '2-digit',
         *          })
         *      )
         *  )
         * ```
         * @param formatter - `FormattingFunction` or `undefined` to use default date time cursor formatting.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setCursorFormatter(formatter: FormattingFunction | undefined): this;
        /**
         * Get cursor formatter of this `DateTimeTickStrategy` object.
         *
         * @returns `FormattingFunction` as set by user, or `undefined` to indicate that the default date time cursor formatting is configured.
         * @public
         */
        getCursorFormatter(): FormattingFunction | undefined;
        /**
         * This is a convenience function which simultaneously applies all: {@link setGreatTickStyle}, {@link setMajorTickStyle} and {@link setMinorTickStyle}.
         *
         * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
         * @returns New *NumericTickStrategy* object.
         * @public
         */
        setTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified great tick style.
         *
         * *Great ticks* display the largest Date/Time information for the active time range.
         * There is always exactly one *great tick* in view.
         *
         * Example usage:
         *
         * **Disable great ticks**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setGreatTickStyle( emptyTick )
         * )
         * ```
         *
         * **Set font of great ticks**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setGreatTickStyle(( tickStyle: TickStyle ) => tickStyle
         *             .setLabelFont(( font ) => font
         *                 .setWeight( 'bold' )
         *             )
         *         )
         * )
         * ```
         * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setGreatTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
        /**
         * Get great tick style of this *DateTimeTickStrategy* object.
         *
         * *Great ticks* display the largest Date/Time information for the active time range.
         * There is always exactly one *great tick* in view.
         * @returns Great tick style.
         * @public
         */
        getGreatTickStyle(): TickStyle;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified major tick style.
         *
         * *Major ticks* display the next smaller Date/Time information after *Great ticks*.
         * Often times, they represent the most important information.
         *
         * Example usage:
         *
         * **Set font of major ticks**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setMajorTickStyle(( tickStyle ) => tickStyle
         *             .setLabelFont(( font ) => font
         *                 .setWeight( 'bold' )
         *             )
         *         )
         * )
         * ```
         * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setMajorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
        /**
         * Get major tick style of this *DateTimeTickStrategy* object.
         *
         * *Major ticks* display the next smaller Date/Time information after *Great ticks*.
         * Often times, they represent the most important information.
         * @returns Major tick style.
         * @public
         */
        getMajorTickStyle(): TickStyle;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified minor tick style.
         *
         * *Minor ticks* display the next smaller Date/Time information after *Major ticks*.
         *
         * Example usage:
         *
         * **Disable minor ticks**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setMinorTickStyle( emptyTick )
         * )
         * ```
         *
         * **Set font of minor ticks**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setMinorTickStyle(( tickStyle ) => tickStyle
         *             .setLabelFont(( font ) => font
         *                 .setWeight( 'bold' )
         *             )
         *         )
         * )
         * ```
         * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
         *                              Passing a function only works if the existing style is **not** *emptyTick*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setMinorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
        /**
         * Get minor tick style of this *DateTimeTickStrategy* object.
         *
         * *Minor ticks* display the next smaller Date/Time information after *Major ticks*.
         * @returns Minor tick style.
         * @public
         */
        getMinorTickStyle(): TickStyle;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified `utc`.
         *
         * See {@link DateTimeTickStrategyProperties.utc} for more information.
         *
         * Example usage:
         *
         * **Enable UTC mode**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setUTC(true)
         * )
         * ```
         *
         * @returns New *DateTimeTickStrategy* object.
         * @public
         * @beta
         */
        setUTC(utcMode: boolean): this;
        /**
         * Get UTC mode enabled.
         *
         * See {@link DateTimeTickStrategyProperties.utc} for more information.
         * @public
         * @beta
         */
        getUTC(): boolean;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified locale.
         *
         * The *locale* specifies a geographical, political or cultural region, affecting all formatting of *Tick labels*.
         *
         * All valid values can be found from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
         *
         * Example usage:
         *
         * **Use locale of browser**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setLocale( undefined )
         * )
         * ```
         *
         * **Use specific locale**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setLocale('en-US')
         * )
         * ```
         * @param locale - Valid JavaScript Date locale string, that specifies a geographical, political or cultural region.
         *                              All valid values can be found from
         *                              https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setLocale(locale: string | undefined): this;
        /**
         * Get locale of this *DateTimeTickStrategy* object.
         *
         * The *locale* specifies a geographical, political or cultural region, affecting all formatting of *Tick labels*.
         * @returns JavaScript Date locale string, that specifies a geographical, political or cultural region.
         * @public
         */
        getLocale(): string | undefined;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified dateOrigin.
         *
         * By default data-points are interpreted as *UTC dates* (milliseconds since January 1st 1970 GMT+0).
         * If a **dateOrigin** is defined, data-points will instead be interpreted as milliseconds since **dateOrigin**.
         *
         * Specifying a *dateOrigin* can be necessary in applications where there is a long range of date-time data,
         * and high resolution zooming is desired.
         *
         * Example usage:
         *
         * **Application with one day of high-density data starting in year 2020**:
         * ```javascript
         * // Without specifying a dateOrigin, zooming will be limited to minutes with this range.
         * // Milliseconds resolution can be reached by setting the dateOrigin to a Date
         * // that is closer to the actual data (instead of the default 1.1.1970).
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setDateOrigin( new Date( 2020, 0, 1 ) )
         * )
         * ```
         *
         * Check our DateTime Axis Interactive Example for a more thorough example on DateTime TickStrategy usage:
         * https://lightningchart.com/lightningchart-js-interactive-examples/examples/lcjs-example-0020-dateTimeAxis.html
         *
         * @param dateOrigin - A *JavaScript Date* object or *undefined*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setDateOrigin(dateOrigin: Date | undefined): this;
        /**
         * Get the *dateOrigin* of this *DateTimeTickStrategy* object.
         *
         * By default data-points are interpreted as *UTC dates* (milliseconds since January 1st 1970 GMT+0).
         * If a **dateOrigin** is defined, data-points will instead be interpreted as milliseconds since **dateOrigin**.
         * @returns A *JavaScript Date* object or *undefined*.
         * @public
         */
        getDateOrigin(): Date | undefined;
        /**
         * Utility method for setting *formatting function* of all tick levels (great, major, minor).
         *
         * This is applied to every zoom level, so regardless how you zoom the same formatting is used.
         *
         * If this is not desired, formatting for each zoom level can be individually overridden with following methods:
         * - {@link setFormattingDecade}
         * - {@link setFormattingYear}
         * - {@link setFormattingMonth}
         * - {@link setFormattingWeek}
         * - {@link setFormattingDay}
         * - {@link setFormattingHour}
         * - {@link setFormattingMinute}
         * - {@link setFormattingSecond}
         * - {@link setFormattingMilliSecond}
         * - {@link setCursorFormatter}
         *
         * @param greatTickFormattingOptions - Specify function for great ticks.
         * @param majorTickFormattingOptions - Specify function for major ticks.
         * @param minorTickFormattingOptions - Specify function for minor ticks.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormatting(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions?: DateTimeFormatter): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Major: Decades**
         * - **Minor: Years**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingDecade(
         *             { year: 'numeric' },
         *             { year: 'numeric' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         *
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingDecade(majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Major: Years**
         * - **Minor: Months**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingYear(
         *             { year: 'numeric' },
         *             { month: 'short' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingYear(majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Years**
         * - **Major: Months**
         * - **Minor: Weeks**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingMonth(
         *             { year: 'numeric' },
         *             { month: 'long' },
         *             { day: '2-digit' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingMonth(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Months**
         * - **Major: Weeks**
         * - **Minor: Days**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingWeek(
         *             { year: 'numeric', month: 'long' },
         *             { day: '2-digit' },
         *             { day: '2-digit' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingWeek(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Weeks**
         * - **Major: Days**
         * - **Minor: Hours**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingDay(
         *             { year: 'numeric', month: 'long' },
         *             { day: '2-digit' },
         *             { hour: '2-digit', minute: '2-digit' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingDay(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Days**
         * - **Major: Hours**
         * - **Minor: Minutes**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingHour(
         *             { year: 'numeric', month: 'long', day: '2-digit' },
         *             { hour: '2-digit', minute: '2-digit' },
         *             { hour: '2-digit', minute: '2-digit' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingHour(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Hours**
         * - **Major: Minutes**
         * - **Minor: Seconds**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingMinute(
         *             { year: 'numeric', month: 'long', day: '2-digit' },
         *             { hour: '2-digit', minute: '2-digit' },
         *             { hour: '2-digit', minute: '2-digit', second: '2-digit' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingMinute(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Minutes**
         * - **Major: Seconds**
         * - **Minor: Milliseconds**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingSecond(
         *             { year: 'numeric', month: 'long', day: '2-digit', hour: '2-digit', minute: '2-digit' },
         *             { hour: '2-digit', minute: '2-digit', second: '2-digit' },
         *             ( value ) => new Date( value ).getUTCMilliseconds(),
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingSecond(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions?: DateTimeFormatter): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Seconds**
         * - **Major: Every tenth MilliSecond**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingMilliSecond(
         *             { year: 'numeric', month: 'long', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' },
         *             ( value ) => new Date( value ).getUTCMilliseconds()
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @returns New *DateTimeTickStrategy* object.
         * @public
         * @deprecated  Deprecated in v6.0. Doesn't do anything anymore, will be removed later as part of larger refactoring.
         */
        setFormattingMilliSecond(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined): this;
    }
    /**
     * Modifiable properties of a DateTime *TickStrategy*.
     *
     * @public
     */
    declare interface DateTimeTickStrategyProperties {
        /**
         * Cursor formatter.
         *
         * This controls the date time formatting used by:
         * - Default cursor result table formatters.
         * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
         * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
         *
         * `undefined` means to use default date time cursor formatting.
         *
         * ```ts
         *  // Example value, cursor formatter to display week day, year, month, day, hour and minute.
         *  cursorFormatter: (value, range, locale) =>
         *      new Date(value).toLocaleDateString(locale, {
         *          weekday: 'long',
         *          year: 'numeric',
         *          month: 'numeric',
         *          day: 'numeric',
         *          minute: '2-digit',
         *          hour: '2-digit',
         *      })
         * ```
         */
        readonly cursorFormatter: FormattingFunction | undefined;
        /**
         * By default, `false`, which means that tick placement is applied according to clients local time-zone/region and possible day light saving cycle.
         *
         * When `true`, tick placement is applied in UTC which means:
         *  - no day light saving adjustments
         *  - timestamps are displayed as milliseconds without any time-zone region offsets.
         *
         * This is a beta feature (introduced in version 5.1.0).
         * As such, it may be removed or modified without following semantic versioning practices.
         * @beta
         * @public
         */
        readonly utc: boolean;
        /**
         * Style of Great ticks.
         *
         * To disable great ticks, set to **emptyTick**.
         *
         * **NOTE: Label alignment is overridden, and has no effect on this property.**
         */
        readonly greatTickStyle: TickStyle;
        /**
         * Style of Major ticks.
         */
        readonly majorTickStyle: TickStyle;
        /**
         * Style of Minor ticks.
         *
         * To disable minor ticks, set to **emptyTick**.
         */
        readonly minorTickStyle: TickStyle;
        /**
         * Valid javascript Date locale string, that specifies a geographical, political or cultural region.
         *
         * *undefined* passes the decision making to the browser.
         *
         * For example values, refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
         */
        readonly locale: string | undefined;
        /**
         * Optional "origin date" value.
         *
         * By default data-points are interpreted as *UTC dates* (milliseconds since January 1st 1970 GMT+0).
         * If a **dateOrigin** is defined, data-points will instead be interpreted as milliseconds since **dateOrigin**.
         */
        readonly dateOrigin: Date | undefined;
        /**
         * Formatter options for **major** ticks that are placed on relevant **century** intervals.
         */
        readonly formatOptionsMajorCentury: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **decade** intervals.
         */
        readonly formatOptionsMinorDecade: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **decade** intervals.
         */
        readonly formatOptionsMajorDecade: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **year** intervals.
         */
        readonly formatOptionsMinorYear: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **year** intervals.
         */
        readonly formatOptionsMajorYear: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **month** intervals.
         */
        readonly formatOptionsMinorMonth: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **year** intervals.
         */
        readonly formatOptionsGreatYear: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **month** intervals.
         */
        readonly formatOptionsMajorMonth: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **week** intervals.
         */
        readonly formatOptionsMinorWeek: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **month** intervals.
         */
        readonly formatOptionsGreatMonth: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **week** intervals.
         */
        readonly formatOptionsMajorWeek: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **day** intervals.
         */
        readonly formatOptionsMinorDay: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **week** intervals.
         */
        readonly formatOptionsGreatWeek: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **day** intervals.
         */
        readonly formatOptionsMajorDay: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **hour** intervals.
         */
        readonly formatOptionsMinorHour: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **day** intervals.
         */
        readonly formatOptionsGreatDay: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **hour** intervals.
         */
        readonly formatOptionsMajorHour: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **minute** intervals.
         */
        readonly formatOptionsMinorMinute: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **hour** intervals.
         */
        readonly formatOptionsGreatHour: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **minute** intervals.
         */
        readonly formatOptionsMajorMinute: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **second** intervals.
         */
        readonly formatOptionsMinorSecond: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **minute** intervals.
         */
        readonly formatOptionsGreatMinute: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **second** intervals.
         */
        readonly formatOptionsMajorSecond: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **millisecond** intervals.
         */
        readonly formatOptionsMinorMillisecond: DateTimeFormatter;
        readonly formatMillisecondRange: FormattingFunction;
        readonly formatMicrosecondRange: FormattingFunction;
        readonly formatNanosecondRange: FormattingFunction;
        /**
         * @deprecated  Deprecated in v6.0. Replaced by `formatOptionsMinorMillisecond`. Currently doesn't do anything.
         */
        readonly formatOptionsGreatSecond: DateTimeFormatter;
        /**
         * @deprecated  Deprecated in v6.0. Replaced by `formatOptionsMinorMillisecond`. Currently doesn't do anything.
         */
        readonly formatOptionsMajorMilliSecond: DateTimeFormatter;
    }
    /**
     * Default DateTime TickStrategy settings.
     * @public
     */
    declare const DateTimeTickStrategyRecord: Record_2.Factory<DateTimeTickStrategyProperties>;
    /**
     * Default configuration of `ChartXY` axis interval restrictions.
     * {@link Axis.setIntervalRestrictions}
     *
     * Can be used to explicitly enable default restrictions in use cases where they may be disabled due to automatic logics.
     * For example, using {@link Axis.setInterval} disables default interval restrictions because they may conflict,
     *
     * ```ts
     *  // Example, explicitly enable default interval restrictions. This means they can't be disabled automatically
     *  axis.setIntervalRestrictions(defaultAxisIntervalRestrictionsXY)
     * ```
     *
     * @public
     */
    export declare const defaultAxisIntervalRestrictionsXY: Parameters<Axis['setIntervalRestrictions']>[0];
    /**
     * Default background color for the On-screen menu div element.
     * @public
     */
    export declare const defaultOsmBackgroundColor = "#363636";
    /**
     * Union of Dimensional and Axis Strategies
     * @public
     */
    export declare type DimensionalAxisStrategy = MultidimensionalStrategy & AxisStrategy;
    /**
     * Interface specifies individual sizes for each dimension - width and height.
     * @public
     */
    export declare interface DimensionalEngineSize {
        /**
         * Specifies width of engine.
         */
        readonly width?: EngineDimension;
        /**
         * Specifies height of engine.
         */
        readonly height?: EngineDimension;
    }
    /**
     * Modify Theme to remove all text shadows.
     *
     * @param   theme - Theme to modify.
     * @returns         New theme object without text shadows.
     * @public
     * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
     */
    export declare const disableTextShadows: (theme: Theme) => Theme;
    /**
     * Modify Theme to remove any glow effects.
     *
     * ```ts
     *  // Example syntax
     *  const chart = lightningChart().ChartXY({
     *      theme: disableThemeEffects(Themes.cyberSpace)
     *  })
     * ```
     *
     * Internally all this does is the following:
     *
     * ```ts
     *  return { ...theme, effect: undefined }
     * ```
     *
     * If you don't want to disable effects entirely, but only on some components, see:
     *
     * - {@link Theme.effectsText}
     * - {@link Theme.effectsDashboardSplitters}
     * - {@link ChartComponent.setEffect}
     *
     * @param   theme - Theme to modify.
     * @returns         New theme object without glow effects.
     * @public
     */
    export declare const disableThemeEffects: (theme: Theme) => Theme;
    /**
     * Interface for object that can be _disposed_, destroying it permanently.
     * @public
     */
    export declare interface Disposable {
        /**
         * Permanently destroy the component.
         *
         * @returns Object itself for fluent interface.
         * @public
         */
        dispose(): this;
    }
    /**
     * @public
     */
    export declare interface DisposableEventMap {
        dispose: DisposeEvent;
    }
    /**
     * Interface for event methods for tracking when an object is _disposed_.
     * @public
     */
    export declare interface DisposableEvents extends EventInterface<DisposableEventMap> {
        /**
         * Check whether the object is disposed.
         * Disposed objects should not be used!
         *
         * @returns     `true` if object is disposed.
         * @public
         */
        isDisposed(): boolean;
    }
    /**
     * @public
     */
    export declare interface DisposeEvent {
    }
    /**
     * Interface for object that can be dragged by mouse.
     * @public
     */
    export declare interface Draggable {
        /**
         * Set dragging mode of object. Defines how the object can be dragged by mouse.
         *
         * See {@link UIDraggingModes} collection for options.
         * @param draggingMode - DraggingMode or undefined to disable dragging
         * @returns Object itself
         * @public
         */
        setDraggingMode(draggingMode?: UIDraggingModes): this;
        /**
         * Get dragging mode of object.
         * Defines how the object can be dragged by mouse.
         * @returns Object itself
         * @public
         */
        getDraggingMode(): UIDraggingModes;
    }
    /**
     * Type definition for a dynamic mouse style setting.
     * This allows for mouse styles that depend on situation.
     * @param uiElement - UIElement to apply
     * @returns Mouse style as string or undefined
     * @public
     */
    export declare type DynamicUIMouseStyle<T extends UIElement> = (uiElement: T) => string | undefined;
    /**
     * Ease Animation function
     * @param delta - Delta time from start of animation
     * @public
     */
    export declare type Ease = (delta: number) => number;
    /**
     * Type definition of an _Effect Configuration_.
     *
     * A theme can specify an Effect to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     * @public
     */
    export declare type Effect = GlowEffect;
    /**
     * Data type that defines a ellipse shape
     * @public
     */
    export declare interface EllipseDimensions {
        /**
         * X coordinate of ellipses center.
         */
        readonly x: number;
        /**
         * Y coordinate of ellipses center.
         */
        readonly y: number;
        /**
         * X radius of ellipse.
         */
        readonly radiusX: number;
        /**
         * Y radius of ellipse
         */
        readonly radiusY: number;
        /**
         * Optional parameter to control drawing precision.
         * This describes the number of sub divisions the ellipse is split into.
         * Should be a larger number for larger ellipses. Ideally users wouldn't see the step between divisions.
         * Defaults to `72`.
         */
        readonly drawSteps?: number;
    }
    /**
     * Class for series visual that is an Ellipse.
     * @public
     */
    export declare class EllipseFigure extends Figure<SolveResultEllipseSeries> {
        /**
         * @public
         */
        protected dimensions: EllipseDimensions;
        /**
         * @public
         */
        readonly scale: LinearScaleXY;
        /**
         * Get boundaries that contain figure.
         * @returns Interval<Point>
         * @public
         */
        _getBoundaries(): Interval<Point>;
        /**
         * Set new dimensions for figure.
         * @param dimensions - Dimensions
         * @returns Object itself
         * @remarks          Owning series will be informed of change in size, possible initiating scrolling.
         * @public
         */
        setDimensions(dimensions: EllipseDimensions): this;
        /**
         * Get current dimensions of figure.
         * @returns Dimensions
         * @public
         */
        getDimensions(): EllipseDimensions;
        /**
         * Set fill style of Ellipse.
         * @param value - FillStyle object or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of Ellipse.
         * @returns FillStyle object
         * @public
         */
        getFillStyle(): FillStyle;
        /**
         * Set stroke style of Ellipse.
         *
         * Supported line styles:
         * - {@link SolidLine}
         * - {@link emptyLine}
         *
         * @param value - LineStyle object or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style of Ellipse.
         * @returns LineStyle object
         * @public
         */
        getStrokeStyle(): LineStyle;
        /**
         * Return some dominant fill style of the figure
         * @returns FillStyle object
         * @public
         */
        getDominantStyle(): FillStyle;
    }
    /**
     * Implementation of EllipseSeries
     * @public
     */
    export declare class EllipseSeries extends FigureSeries<SolveResultEllipseSeries, EllipseFigure, EllipseDimensions, LinearScaleXY> {
        solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultEllipseSeries | undefined;
        /**
         * Add new figure to the series.
         * @param dimensions - Dimensions that figure must represent
         * @returns Created figure
         * @public
         */
        add(dimensions: EllipseDimensions): EllipseFigure;
        addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultEllipseSeries) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultEllipseSeries) => unknown): void;
    }
    /**
     * Interface for supplying readonly configurations to a {@link EllipseSeries}.
     * @public
     */
    export declare interface EllipseSeriesOptions extends SeriesOptionsXY {
    }
    /**
     * Abstract class which indicates that shape should not be filled.
     *
     * When *emptyFill* is used, the area that would be filled does **NOT** trigger mouse / touch -events, and
     * its rendering process is skipped, which results in saved performance.
     * @public
     */
    export declare class EmptyFill extends EmptyFillRecord implements FillStyle {
        /**
         * Get CSS representation of the FillStyle.
         * @public
         */
        toCSS(): string;
    }
    /**
     * Singleton object which indicates that component should not have *fill color*.
     *
     * When *emptyFill* is used, the area that would be filled does **NOT** trigger mouse / touch -events (if this is desired, use a transparent {@link SolidFill} instead).
     *
     * **emptyFill Usage:**
     *
     * Use emptyFill with:
     * - `setFillStyle` methods:
     *      * {@link PointSeries.setPointFillStyle}
     *      * {@link ChartXY.setTitleFillStyle}
     *
     * ```typescript
     *  // Example
     *  PointSeries.setPointFillStyle(emptyFill)
     * ```
     *
     * - {@link SolidLine}, or other *line styles*.
     *
     * ```typescript
     *  // Example, construct a SolidLine.
     *  const lineStyle = new SolidLine({
     *      thickness: 1,
     *      fillStyle: emptyFill
     *  })
     * ```
     *
     * **Related information:**
     *
     * For more *fill styles*, see:
     * - {@link SolidFill}
     * - {@link IndividualPointFill}
     * - {@link PalettedFill}
     * - {@link RadialGradientFill}
     * - {@link LinearGradientFill}
     * - {@link ImageFill}
     * @public
     */
    export declare const emptyFill: EmptyFill;
    /**
     * Interface for all properties of a empty FillStyle.
     * @public
     */
    declare const EmptyFillRecord: Record_2.Factory<{
        type: "fillstyle";
        fillType: "empty";
    }>;
    /**
     * @public
     */
    declare class EmptyLine extends EmptyLineRecord implements LineStyle, StylePropFuncs<ThisType<EmptyLine>, {}> {
        /**
         * @public
         */
        thickness: number;
        /** @public */
        setThickness(thickness: number): this;
        /** @public */
        getThickness(): number;
        /** @public */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * @returns Object itself, because the entire style does not have any color information.
         * @public
         */
        getFillStyle(): EmptyFill;
    }
    /**
     * Singleton object which specifies that a *line* should not be rendered.
     *
     * When *emptyLine* is used, the configured line does **NOT** trigger mouse / touch -events (if this is desired, use a transparent {@link SolidLine} instead).
     *
     * **emptyLine Usage:**
     *
     * Use emptyLine as argument of:
     * - `setStrokeStyle` methods:
     *      * {@link LineSeries.setStrokeStyle}
     *      * {@link Axis.setStrokeStyle}
     *      * {@link CustomTick.setGridStrokeStyle}
     *      * etc.
     *
     * ```typescript
     *  // Example
     *  LineSeries.setStrokeStyle(emptyLine)
     * ```
     *
     * **Related information:**
     *
     * For more *line styles*, see:
     * - {@link SolidLine}
     * - {@link DashedLine}
     * @public
     */
    export declare const emptyLine: EmptyLine;
    /**
     * Interface for all properties of a empty FillStyle.
     * @public
     */
    declare const EmptyLineRecord: Record_2.Factory<{
        type: "linestyle";
        lineType: "empty";
    }>;
    /**
     * *TickStyle* singleton, which can be used to indicate that *Ticks* shouldn't be displayed.
     *
     * Can be used with *TickStrategies*.
     *
     * Example usage:
     * ```javascript
     * // Get Default Y Axis of XY Chart.
     * chart.getDefaultAxisY()
     *   // Modify the Axis' TickStrategy.
     *   .setTickStrategy(
     *      // Using a Numeric TickStrategy, modify it's Styler.
     *      AxisTickStrategies.Numeric, ( numericTickStrategy ) => numericTickStrategy
     *          // Set the Minor TickStyle of the TickStrategy as EmptyTick.
     *          .setMinorTickStyle( emptyTick )
     * )
     * ```
     * @public
     */
    export declare const emptyTick: TickStyle;
    /**
     * *Axis Tick Strategy* to prevent any and all automatic tick creation.
     *
     * Still exposes way to configure cursor formatting of values along the Axis.
     *
     * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
     *
     * ```js
     *  Axis.setTickStrategy(AxisTickStrategies.Empty, (strategy) => strategy)
     * ```
     *
     * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
     * see example below for the idea:
     *
     * ```js
     *  // Specify TickStrategy and use callback to style automatic ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks
     *      // All methods of `NumericTickStrategy` can be used here for styling ticks.
     *      .setMajorTickStyle((majorTicks) => majorTicks
     *          .setLabelFont((font) => font
     *              .setWeight('bold')
     *          )
     *      )
     *  )
     * ```
     *
     * All available strategies for automatic Axis ticks creation can be referenced via {@link AxisTickStrategies}.
     * @public
     */
    export declare class EmptyTickStrategy extends EmptyTickStrategyRecord implements MutableAxisTickStrategy {
        /**
         * Set cursor formatter for this `TickStrategy` object.
         *
         * This will override the date time formatting used by:
         * - Default cursor result table formatters.
         * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
         * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
         *
         * ```ts
         *  // Example syntax, custom cursor formatting.
         *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
         *      .setCursorFormatter((value, range, locale) =>
         *          value.toFixed(3)
         *      )
         *  )
         * ```
         * @param formatter - `FormattingFunction` or `undefined` to use default numeric cursor formatting.
         * @returns New *NumericTickStrategy* object.
         * @public
         */
        setCursorFormatter(formatter: FormattingFunction | undefined): this;
        /**
         * Get cursor formatter of this `NumericTickStrategy` object.
         *
         * @returns `FormattingFunction` as set by user, or `undefined` to indicate that the default numeric cursor formatting is configured.
         * @public
         */
        getCursorFormatter(): FormattingFunction | undefined;
    }
    /**
     * Modifiable properties of a Empty *TickStrategy*.
     *
     * @public
     */
    export declare interface EmptyTickStrategyProperties {
        /**
         * Cursor formatter.
         *
         * This controls the formatting used by:
         * - Default cursor result table formatters.
         * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
         * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
         *
         * `undefined` means to use default cursor formatting.
         *
         * ```ts
         *  // Example value, custom cursor formatter
         *  cursorFormatter: (value, range, locale) => value.toFixed(3)
         * ```
         */
        readonly cursorFormatter: FormattingFunction | undefined;
    }
    /**
     * Default Empty TickStrategy settings.
     * @public
     */
    declare const EmptyTickStrategyRecord: Record_2.Factory<EmptyTickStrategyProperties>;
    /**
     * Empty UiElement
     * @public
     */
    export declare class EmptyUIElement extends InternalUIElement {
        /**
         * Set mouse interactions enabled or disabled
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setPointerEvents(state: boolean): this;
        /**
         * @returns Mouse interactions state
         * @public
         */
        getPointerEvents(): boolean;
    }
    /**
     * Type of dimension for engine; can be a tuple of boundaries, a single static dimension or undefined for container size.
     * When using a tuple to specify boundaries [min, max], actual size for engine will be the size of its container clamped to the specified
     * pixel boundaries. Any of the values inside the tuple can be undefined.
     * Using a single number will set a static size for engine dimension, meaning no resizing of engine will take effect.
     * @public
     */
    export declare type EngineDimension = [number | undefined, number | undefined] | undefined | number;
    /**
     * Interface that can be used to configure rendering Engine of LCJS *charts* and *dashboards*.
     *
     * **Commonly used properties:**
     *
     * - {@link FitEngineToDiv.container | container}: Specify DOM container for chart.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, create chart without specifying DOM container. LCJS will automatically append a <div> in the document.
     *  // Recommended for testing, mainly.
     *  const chart = LightningChart.ChartXY({})
     * ```
     *
     * ```typescript
     *  // Example 2, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
     *  const chart = LightningChart.ChartXY({
     *      // Argument can be either *element id* or actual reference to the HTML element.
     *      container: 'my-chart-div'
     *  })
     * ```
     * @public
     */
    export declare type EngineOptions = EngineSettings & (FitEngineToDiv | DimensionalEngineSize);
    /**
     * Interface specifies settings for Engine.
     * @public
     */
    export declare interface EngineSettings {
        /**
         * Max FPS (frames-per-second).
         * Setting this will postpone rendering events that would otherwise happen, if it would result in FPS higher than the value.
         *
         * NOTE: This property can't be used to accurately specify actual FPS as it is dictated by the browser. The purpose for 'maxFps' is
         * to limit unnecessary rendering loads where they are not needed.
         */
        readonly maxFps?: number;
        /**
         * Set preference for anti-aliasing.
         *
         * If set to true or undefined and browser supports anti-aliasing then the chart will be anti-aliased. If set to false or browser
         * doesn't support anti-aliasing then the chart will not be anti-aliased.
         */
        readonly antialias?: boolean;
        /**
         * Set preference for high quality line anti-aliasing.
         *
         * If set to true or undefined and browser supports OES_standard_derivatives or WebGL2 then the non-primitive lines (thickness !== -1) will be anti-aliased. If set to false or browser
         * doesn't support the OES_standard_derivatives extension or WebGl2 then the lines will not be anti-aliased with high quality but the line might me anti-aliased with default hardware anti-aliasing.
         *
         * Setting {@link EngineSettings.antialias} to `false` will also disable line anti-aliasing.
         */
        readonly lineAntiAlias?: boolean;
        /**
         * Configure device pixel ratio behavior.
         * By default, LightningChart acts according to meta tag "viewport" width=device-width.
         * If the tag is present, LightningChart will follow `window.devicePixelRatio`, otherwise defaulting to `1.0` device pixel ratio.
         *
         * ```html
         * <meta name="viewport" content="width=device-width, initial-scale=1.0">
         * ```
         *
         * You can also set this to a specific number if you want to use a specific device pixel ratio for some reason.
         *
         * By default if this option is not specified the ratio will be automatically decided based on the existence of the viewport meta tag
         * and the content of the tag if found. So default value is `true`.
         */
        readonly devicePixelRatio?: boolean | number;
        /**
         * *Color theme* for the component.
         *
         * A collection of default implementations can be accessed by {@link Themes}.
         *
         * ```typescript
         *  // Example, specify color theme of chart.
         *  const chart = LightningChart.ChartXY({
         *      theme: Themes.light
         *  })
         * ```
         *
         * For custom color themes, refer to Developer Documentation \> Themes section.
         */
        readonly theme?: Theme;
        /**
         * Specify precision level for interacting on charts with mouse, touch and other pointer devices.
         *
         * The required precision can have a significant effect on charts performance. By default, a relatively low precision is used.
         * When required, the precision can be increased by supplying a different value with this parameter.
         *
         * **Possible values:**
         *
         * - `undefined` | Default picking precision.
         * - `'low'` | Use lower precision than the default. This will result in better performance but less precision with mouse, touch and other pointers.
         * - `'high'` | Use higher precision than the default. This will result in decreased performance but better precision with mouse, touch and other pointers.
         * - `'best'` | Use the best available picking precision. This will result in decreased performance but better precision with mouse, touch and other pointers.
         *
         * **Example usage:**
         *
         * ```ts
         *  // Specify picking precision when a chart or dashboard is created.
         *  const chart = lightningChart().ChartXY({
         *      pickingPrecision: 'high'
         *  })
         * ```
         */
        readonly pickingPrecision?: 'best' | 'high' | 'low' | undefined;
        /**
         * Flag that can be used to disable all user interactions from created chart components.
         *
         * This can be useful in server side rendering applications and also on frontend side when the user interactions are not needed.
         *
         * Disabling user interactions can provide significant benefits to the performance and loading speed of charts.
         *
         * By default, charts are always interactable.
         *
         * ```ts
         *  // Example, create chart without user interactions.
         *  const chart = lightningChart().ChartXY({
         *      interactable: false,
         *  })
         * ```
         */
        readonly interactable?: boolean;
        /**
         * Text snapping to pixel enabled or disabled. By default `true`.
         *
         * Text quality is sharper and clearer with pixel snapping, but in some cases it can show as undesirable "moving" or "bouncing" of text.
         * So far this has been observed in _slowly scrolling applications_. If this becomes an issue in your application, try disabling text pixel snapping like below:
         *
         * ```ts
         *  // Example, disable text pixel snapping
         *  const chart = lightningChart().ChartXY({ textPixelSnappingEnabled: false })
         * ```
         *
         * This is an _experimental_ feature, meaning that if it should become deprecated it will likely be immediately removed even without a major release.
         * However, in this case an alternative method or fix to the issues solved with `textPixelSnappingEnabled` will also be introduced.
         *
         * **If you need to use `textPixelSnappingEnabled` in your application, please consider informing the developers of LightningChart JS at `https://lightningchart.com/js-charts/docs/contact`**
         * You do not need to share any extensive details about yourself, your company or your use case.
         * However, it is important for us to get some idea if users start depending on this property.
         * A simple message like "Hi, I just encountered a problem related to text pixel snapping and had to disable it with the textPixelSnappingEnabled flag." will do perfectly fine.
         *
         * @beta
         */
        readonly textPixelSnappingEnabled?: boolean;
        /**
         * Alter default WebGL text rendering by choosing another built-in option.
         * Currently only HTML text rendering is available as an alternative.
         *
         * ```ts
         *  // Example, use built-in HTML text rendering
         *  const chart = lightningChart().ChartXY({
         *      textRenderer: htmlTextRenderer
         *  })
         * ```
         *
         * For more information about HTML text rendering, please refer to online documentation:
         * https://lightningchart.com/js-charts/docs/more-guides/html-text-rendering/
         *
         * While technically type supported, passing implementations of custom text renderers is generally not recommended, or considered an officially supported feature.
         * Feel free to contact us if you are interested in such an use case.
         *
         * @beta    Introduced in v7.1.0. API may be changed according to user feedback, reports and further development.
         */
        readonly textRenderer?: TextRenderer | TextRendererFactory;
    }
    /**
     * Utility type for creating union string literal types from Enums.
     * @public
     */
    export declare type EnumToStringUnion<T extends string | number> = `${T}`;
    /**
     * @public
     */
    export declare class Eventer<EventMap, Info extends {} = any> implements EventInterface<EventMap, Info> {
        /**
         * Set whether element can be target of pointer events or not.
         *
         * Disabling pointer events means that the objects below this component can be interacted _through_ it.
         * @param   state -     Boolean.
         * @public
         */
        setPointerEvents(state: boolean): void;
        /**
         * Get whether element can be target of pointer events or not.
         * @returns     Boolean
         * @public
         */
        getPointerEvents(): boolean;
        addEventListener<K extends keyof EventMap>(type: K, listener: (event: EventMap[K], info: Info) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof EventMap>(type: K, listener: (event: EventMap[K], info: Info) => unknown): void;
        /**
         * Reference to [HTML draggable attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/draggable)
         *
         * Essentially part of convenience functionality which allows you to specify specific LCJS elements as "draggable",
         * this information is automatically passed on to the LCJS charts container DIV when that element is pointed
         * (since LCJS elements are not HTML elements, the DIV is the only actual HTML element).
         * @public
         */
        set draggable(state: boolean);
        get draggable(): boolean;
        /**
         * Clear any previous connections, resetting to a black state
         *
         * Does not clear subscriptions.
         */
        _clear(): void;
    }
    /**
     * @public
     */
    declare interface EventInterface<EventMap, Info = unknown> {
        /**
         * Add callback function to be triggered when specified event is fired.
         *
         * ```ts
         *  // Example syntax
         *  object.addEventListener('click', (event) => {
         *      console.log(event)
         *  })
         * ```
         *
         * Some classes also report extra information about the interacted object with the second parameter:
         *
         * ```ts
         *  // Most series share information about interacted data point
         *  series.addEventListener('click', (event, info) => {
         *      console.log(info)
         *  })
         * ```
         *
         * Optional third parameter allows registering event handlers that will automatically remove themselves after first trigger:
         *
         * ```ts
         *  // Example this listener will only fire once
         *  object.addEventListener('click', (event) => {})
         * ```
         *
         * Each class has its own list of supported events.
         * Some events are from HTML standard (`click`, `pointerdown`, etc.),
         * while others are own events from LightningChart JS (`dispose`, `resize`, etc.)
         *
         * **To find what events are available, you can try following:**
         *
         * - If your development environment has `TypeScript` enabled, just write `addEventListener` and see what possible event types the IDE suggests. These APIs are strongly typed, and even the callback event will be correctly typed.
         * - Otherwise, open the class section in API documentation and check out which interface `K` type parameter extends.
         *
         * @param   key -   Event identifier, e.g. `"click"`
         * @param   listener -  Callback function that is triggered when event is fired.
         * @param   options -   Optional extra configuration options.
         * @public
         */
        addEventListener<K extends keyof EventMap>(type: K, listener: (event: EventMap[K], info?: Info) => unknown, options?: LCJSAddEventListenerOptions): void;
        /**
         * Remove event listener added using {@link addEventListener}.
         * The expected argument should be the exact same callback function that was supplied using `addEventListener`:
         *
         * ```ts
         *  // Basic example syntax
         *  const listener = () => {}
         *  obj.addEventListener('click', listener)
         *  obj.removeEventListener('click', listener)
         * ```
         *
         * ```ts
         *  // Basic boilerplate of custom interaction when user drags on an object
         *  obj.addEventListener('pointerdown', (eventDown) => {
         *      let prevCoord = eventDown
         *      const handlePointerMove: LCJSInteractionEventListener<'pointermove'> = (eventMove) => {
         *          const delta = { x: eventMove.clientX - prevCoord.clientX, y: eventMove.clientY - prevCoord.clientY }
         *          prevCoord = eventMove
         *          console.log(delta, eventMove.clientX, eventMove.clientY)
         *      }
         *      const handlePointerUp: LCJSInteractionEventListener<'pointerup'> = (eventUp) => {
         *          window.removeEventListener('pointermove', handlePointerMove)
         *          window.removeEventListener('pointerup', handlePointerUp)
         *      }
         *      window.addEventListener('pointermove', handlePointerMove)
         *      window.addEventListener('pointerup', handlePointerUp)
         *  })
         * ```
         * @param   listener -  Listener that was added using `addEventListener`.
         * @public
         */
        removeEventListener<K extends keyof EventMap>(type: K, listener: (event: EventMap[K], info?: Info) => unknown): void;
    }
    /**
     * Abstract figure class for series visuals that are formed of multiple primitive shapes.
     * @public
     */
    export declare abstract class Figure<SolveResultType extends SolveResultXY = SolveResultXY> extends UIObject implements Disposable, DisposableEvents {
        /**
         * @public
         */
        readonly scale: ScaleXY;
        /**
         * Return some dominant fill style of the figure
         * @returns FillStyle object
         * @public
         */
        abstract getDominantStyle(): FillStyle;
        /**
         * TODO
         * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
         * @returns Object itself
         * @public
         */
        setHighlight(highlight: boolean | number): this;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @returns Object itself.
         * @public
         * @privateRemarks  Override
         */
        setVisible(state: boolean): this;
        /**
         * Check whether the object is disposed.
         * Disposed objects should not be used!
         *
         * @returns     `true` if object is disposed.
         * @public
         */
        isDisposed(): boolean;
        /**
         * Set mouse interactions enabled or disabled
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setPointerEvents(state: boolean): this;
        /**
         * @returns Mouse interactions state
         * @public
         */
        getPointerEvents(): boolean;
        addEventListener<K extends keyof FigureEventMap>(type: K, listener: (event: FigureEventMap[K], info: SolveResultType) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof FigureEventMap>(type: K, listener: (event: FigureEventMap[K], info: SolveResultType) => unknown): void;
    }
    /**
     * Interface of events trackable by {@link Figure.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface FigureEventMap extends DisposableEventMap, HighlightableEventMap, UIObjectEventMap {
    }
    /**
     * Abstract base class for series based on figures.
     * @public
     */
    export declare abstract class FigureSeries<SolveResultType extends SolveResultXY = SolveResultXY, FigureType extends Figure<SolveResultType> = Figure<SolveResultType>, InputType extends unknown = unknown, ScaleType extends ScaleXY = ScaleXY> extends SeriesXY<ScaleType, SolveResultType> {
        /**
         * Get list of all figures existing under the series
         * @returns     List of figure object references
         * @public
         */
        getFigures(): FigureType[];
        /**
         * Set whether element can be target of pointer events or not.
         *
         * Disabling pointer events means that the objects below this component can be interacted _through_ it.
         *
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setPointerEvents(state: boolean): this;
        /**
         * Clear all previously pushed data points from the *series*.
         *
         * ```ts
         *  // Example usage
         *  LineSeries.clear()
         * ```
         *
         * @returns Object itself for fluent interface.
         * @public
         */
        clear(): this;
        /**
         * Add new figure to the series.
         * @param dimensions - Dimensions that figure must represent
         * @returns Created figure
         * @public
         */
        abstract add(dimensions: InputType): FigureType;
        /**
         * Set style for all figures of series.
         * NOTE: Because the function is applied for each figure added, it is not advised to create any objects inside the function.
         * Instead they should be previously cached and later referred to.
         *
         * Example usage:
         *```javascript
         * // Explicit style
         * // The type of 'figure' is equal to type parameter: FigureType
         * SimpleFigureSeries.setDefaultStyle((figure) => ...)
         * ```
         * @param styler - Styler function that is applied to all existing and newly added segments
         * @returns Object itself
         * @public
         */
        setDefaultStyle(styler: FigureStyler<FigureType>): this;
        setVisible(state: boolean): this;
    }
    /**
     * Type for styler function for Figure
     * @param figure - Figure
     * @public
     */
    export declare type FigureStyler<T extends Figure> = (figure: T) => void;
    /**
     * Base interface for *fill styles*.
     *
     * For implementations with more detailed documentation, see:
     * - {@link SolidFill}
     * - {@link emptyFill}
     * - {@link IndividualPointFill}
     * - {@link PalettedFill}
     * - {@link RadialGradientFill}
     * - {@link LinearGradientFill}
     * - {@link ImageFill}
     * @public
     */
    export declare interface FillStyle {
        /**
         * @public
         */
        readonly type: 'fillstyle';
        /**
         * @public
         */
        readonly fillType: 'solid' | 'empty' | 'image' | 'radial-gradient' | 'linear-gradient' | 'individual' | 'palette';
        /**
         * Get CSS representation of the FillStyle.
         * @public
         */
        toCSS(): string;
    }
    /**
     * Interface specifies that Engine should not think about its own size and simply fit itself into
     * an existing element on the document, which should be created by user.
     * @public
     */
    export declare interface FitEngineToDiv {
        /**
         * The DOM Element or its ID that will contain the chart.
         * If there is no such element found, the chart will not work.
         *
         * If nothing was provided, LCJS will automatically append a new DIV element on the document for the chart.
         *
         * **Resizing chart**:
         *
         * When the chart is inside a container managed by user, manual trigger of chart resize is required:
         *
         * ```js
         *  // Example syntax, trigger chart resize on user event.
         *  myResizeEventCallback(() => {
         *      // Trigger chart resize manually.
         *      chart.engine.layout()
         *  })
         * ```
         *
         * For more information, see {@link PublicEngine}.
         */
        readonly container?: HTMLDivElement | string;
    }
    /**
     * Indicates object whose size can be fitted into an arbitrary Vec2
     * @public
     */
    export declare interface Fittable {
        /**
         * Fit object to bounding box.
         * @param bounds - Bounds in pixels
         * @returns Object itself
         * @public
         */
        fitTo(bounds: Point): this;
    }
    /**
     * Interface of all properties of {@link FontSettings}.
     * @public
     */
    export declare interface FontProperties {
        type: 'font';
        /**
         * [CSS font size](https://www.w3schools.com/CSSref/pr_font_font-size.asp).
         *
         * For example, `16`.
         */
        size: number;
        /**
         * [CSS font family](https://www.w3schools.com/CSSref/pr_font_font-family.asp), or list of font families.
         *
         * For example, `'Arial, Helvetica, sans-serif'`.
         */
        family: string;
        /**
         * [CSS font weight](https://www.w3schools.com/CSSref/pr_font_weight.asp).
         *
         * For example, `'bold'`.
         */
        weight: FontWeight;
        /**
         * [CSS font style](https://www.w3schools.com/CSSref/pr_font_font-style.asp).
         *
         * For example, `'italic'`
         */
        style: FontStyle;
        /**
         * [CSS font variant](https://www.w3schools.com/CSSref/pr_font_font-variant.asp).
         *
         * `true` = 'small-caps', `false` = 'normal'.
         */
        variant: boolean;
    }
    /**
     * Style class for describing a *font*.
     *
     * Instances of FontSettings, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
     * but instead return a completely new modified object.
     *
     * **Properties of FontSettings:**
     * - `size`: [CSS font size](https://www.w3schools.com/CSSref/pr_font_font-size.asp).
     * - `family`: [CSS font family](https://www.w3schools.com/CSSref/pr_font_font-family.asp), or list of font families.
     * - `weight`: [CSS font weight](https://www.w3schools.com/CSSref/pr_font_weight.asp).
     * - `style`: [CSS font style](https://www.w3schools.com/CSSref/pr_font_font-style.asp).
     * - `variant`: [CSS font variant](https://www.w3schools.com/CSSref/pr_font_font-variant.asp). `true` = 'small-caps', `false` = 'normal'.
     *
     * **FontSettings usage:**
     *
     * Use FontSettings with:
     * - `setFont` methods:
     *      * {@link ChartXY.setTitleFont}
     *      * {@link UITextBox.setTextFont}
     *      * {@link ResultTable.setTextFont}
     *
     * ```typescript
     *  // Example 1, set chart title font with explicit font.
     *  ChartXY.setTitleFont(new FontSettings({
     *      size: 20,
     *      family: 'Arial, Helvetica, sans-serif',
     *      weight: 'bold',
     *      style: 'italic'
     *  }))
     *
     *  // Example 2, override chart title font, specifying only a sub-set of properties.
     *  ChartXY.setTitleFont((font) => font
     *      .setSize(20)
     *  )
     * ```
     *
     * @public
     */
    export declare class FontSettings extends FontSettingsRecord {
        /**
         * Construct a FontSettings object, specifying any amount of its properties.
         *
         * ```typescript
         *  // Example,
         *  const font = new FontSettings({
         *      size: 20,
         *      family: 'Arial, Helvetica, sans-serif',
         *      weight: 'bold',
         *      style: 'italic',
         *  })
         * ```
         *
         * @param props - Object containing any amount of SolidFill properties.
         * @public
         */
        constructor(props?: Partial<FontProperties>);
        /**
         * Create new FontSettings object with different `size`.
         *
         * [CSS font size](https://www.w3schools.com/CSSref/pr_font_font-size.asp).
         *
         * For example, `16`.
         * @param size - Font size.
         * @returns New FontSettings object.
         * @public
         */
        setSize(size: number): this;
        /**
         * Create new FontSettings object with different `family`.
         *
         * [CSS font family](https://www.w3schools.com/CSSref/pr_font_font-family.asp), or list of font families.
         *
         * For example, `'Arial, Helvetica, sans-serif'`.
         * @param family - Font family or list of families.
         * @returns New FontSettings object.
         * @public
         */
        setFamily(family: string): this;
        /**
         * Create new FontSettings object with different `weight`.
         *
         * [CSS font weight](https://www.w3schools.com/CSSref/pr_font_weight.asp).
         *
         * For example, `'bold'`.
         * @param weight - Font weight.
         * @returns New FontSettings object.
         * @public
         */
        setWeight(weight: FontWeight): this;
        /**
         * Create new FontSettings object with different `style`.
         *
         * [CSS font style](https://www.w3schools.com/CSSref/pr_font_font-style.asp).
         *
         * For example, `'italic'`
         * @param style - Font style.
         * @returns New FontSettings object.
         * @public
         */
        setStyle(style: FontStyle): this;
        /**
         * Create new FontSettings object with different `variant`.
         *
         * [CSS font variant](https://www.w3schools.com/CSSref/pr_font_font-variant.asp).
         *
         * `true` = 'small-caps', `false` = 'normal'
         * @param Font - variant.
         * @returns New FontSettings object.
         * @public
         */
        setVariant(smallCaps: boolean): this;
        /**
         * Get font `size`.
         *
         * [CSS font size](https://www.w3schools.com/CSSref/pr_font_font-size.asp).
         *
         * For example, `16`.
         * @returns Font size.
         * @public
         */
        getSize(): number;
        /**
         * Get font `family`.
         *
         * [CSS font family](https://www.w3schools.com/CSSref/pr_font_font-family.asp), or list of font families.
         *
         * For example, `'Arial, Helvetica, sans-serif'`.
         * @returns Font family.
         * @public
         */
        getFamily(): string;
        /**
         * Get font `weight`.
         *
         * [CSS font weight](https://www.w3schools.com/CSSref/pr_font_weight.asp).
         *
         * For example, `'bold'`.
         * @returns Font weight.
         * @public
         */
        getWeight(): FontWeight;
        /**
         * Get font `style`.
         *
         * [CSS font style](https://www.w3schools.com/CSSref/pr_font_font-style.asp).
         *
         * For example, `'italic'`
         * @returns Font style.
         * @public
         */
        getStyle(): FontStyle;
        /**
         * Get font `variant`.
         *
         * [CSS font variant](https://www.w3schools.com/CSSref/pr_font_font-variant.asp).
         *
         * `true` = 'small-caps', `false` = 'normal'.
         * @returns Font variant.
         * @public
         */
        getVariant(): boolean;
    }
    /**
     * Constructor for a Record of FontProperties.
     * @public
     */
    declare const FontSettingsRecord: Record_2.Factory<FontProperties>;
    /**
     * Type definition for {@link FontSettings.style} property.
     * @public
     */
    export declare type FontStyle = 'normal' | 'italic' | 'oblique';
    /**
     * Type definition for {@link FontSettings.weight} property.
     * @public
     */
    export declare type FontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900;
    /**
     * Function for formatting a longitude + latitude value into degrees and minutes formatted string.
     * @param longitude - Longitude value.
     * @param latitude - Latitude value.
     * @returns Formatted String.
     * @public
     */
    export declare const formatLongitudeLatitude: (longitude: number, latitude: number) => string;
    /**
     * Format value along the LUT range
     * @param lut - LUT object
     * @param value - number
     * @returns     String
     */
    export declare const formatLUTValue: (lut: LUT, value: number) => string;
    /**
     * Format a number to unicode superscript.
     * For example, `10` -\> ``
     *
     * All values behind decimal point are ignored!
     *
     * Please note that Unicode superscript does not necessarily look proper on all fonts.
     * The visual result is heavily font specific.
     * @public
     */
    export declare const formatNumberAsUnicodeSuperscript: (value: number) => string;
    /**
     * Type definition for a *pure* *formatting function*.
     *
     * The formatter is supplied a numeric value, and it formats it into a *string*, that can be displayed
     * on an *Axis tick*, for example.
     * @param value - Numeric value.
     * @param range - Object that represents the possible range for *value*.
     *                          For example, the start-end range of an *Axis*.
     * @returns Value formated as string
     * @public
     */
    export declare type FormattingFunction = (value: number, range: FormattingRange, locale?: string, shiftInfo?: {
        valueShifted: number;
        shiftOrigin: number;
    }) => string;
    /**
     * Enum-like object for implementations of default Formatting functions.
     * @public
     */
    export declare const FormattingFunctions: {
        /**
         * Formats a number.
         * @param value - Value on range to format
         * @param range - FormattingRange
         * @returns Value formatted as string
         * @public
         */
        Numeric: (value: number, range: FormattingRange) => string;
        /**
         * Formats a number by range-dependant rounding and usage of units.
         * @param value - Value on range to format
         * @param range - FormattingRange
         * @returns Value formate as string with units
         * @public
         */
        NumericUnits: (value: number, range: FormattingRange) => string;
        /**
         * Formats number like `"10"`
         *
         * Alternate, built-in formatting for logarithmic ticks.
         * Better suited especially for applications with zooming.
         *
         * ```ts
         *  // Example, enable extreme ticks with exponent formatting
         *  chart
         *      .getDefaultAxisX()
         *      .setTickStrategy(AxisTickStrategies.Numeric, (ticks) =>
         *          ticks
         *              .setMajorFormattingFunction(FormattingFunctions.LogarithmicExponentsRounded)
         *              .setMinorFormattingFunction(FormattingFunctions.LogarithmicExponents)
         *      )
         * ```
         * @public
         */
        LogarithmicExponentsRounded: (value: number, range: FormattingRange, locale?: string, logBase?: 'e' | number) => string;
        /**
         * Formats number like `"210"`
         *
         * Alternate, built-in formatting for logarithmic ticks.
         * Better suited especially for applications with zooming.
         *
         * ```ts
         *  // Example, enable extreme ticks with exponent formatting
         *  chart
         *      .getDefaultAxisX()
         *      .setTickStrategy(AxisTickStrategies.Numeric, (ticks) =>
         *          ticks
         *              .setMajorFormattingFunction(FormattingFunctions.LogarithmicExponentsRounded)
         *              .setMinorFormattingFunction(FormattingFunctions.LogarithmicExponents)
         *      )
         * ```
         * @public
         */
        LogarithmicExponents: (value: number, range: FormattingRange, locale?: string, logBase?: 'e' | number) => string;
        /**
         * Formats number like `"2.1310"`
         *
         * Recommended to be used together with "extreme ticks" when logarithmic ticks are paired with requirement of zooming far in.
         *
         * ```ts
         *  // Example, enable extreme ticks with special formatting
         *  chart
         *      .getDefaultAxisX()
         *      .setTickStrategy(AxisTickStrategies.Numeric, (ticks) =>
         *          ticks
         *              .setExtremeTickStyle(chart.getTheme().xAxisNumericTicks.majorTickStyle)
         *              .setExtremeFormattingFunction(FormattingFunctions.LogarithmicExtreme),
         *      )
         * ```
         * @public
         * @beta
         */
        LogarithmicExtreme: (value: number, range: FormattingRange, locale?: string, logBase?: 'e' | number) => string;
        /**
         * Default formatting function for logarithmic axis.
         * Formats values like `"0.1"`, `"1"`, `"10"` and so on.
         * @public
         * @beta
         */
        LogarithmicNoExponents: (value: number, range: FormattingRange, locale?: string, logBase?: 'e' | number) => string;
        /**
         * Formats number in scientific notation.
         * For example, `1000` -\> `1.00e+3`
         * ```ts
         *  // Example of formatting to scientific notation
         *  chart
         *      .getDefaultAxisX()
         *      .setTickStrategy(AxisTickStrategies.Numeric, (strategy) =>
         *          strategy
         *              .setFormattingFunction(FormattingFunctions.Scientific),
         *      )
         * ```
         * @param value - Value on range to format
         * @param range - FormattingRange
         * @returns Value formatted as string
         * @public
         * @beta Released as beta feature in v6.0.0. This feature may still change according to user feedback and experiences
         */
        Scientific: (value: number, range: FormattingRange) => string;
    };
    /**
     * Object that represents a range of values.
     * Directly related to using {@link FormattingFunctions}
     *
     * ```ts
     *  // Example
     *  console.log(FormattingFunctions.NumericUnits(1000000, chart.axisY.getInterval()))
     * ```
     * @public
     */
    export declare type FormattingRange = {
        start: number;
        end: number;
    };
    /**
     * Abstract base class for *Funnel Charts*.
     * Visualizes proportions and percentages between categories, by dividing a funnel into proportional segments.
     *
     * Set data using *FunnelChart*.**addSlice( name: string, value: number )**
     *
     * There are multiple implementations of *FunnelChart*, each with their own visual design and *API* for customizing it.
     * List of selectable options can be found in: {@link FunnelChartTypes}
     * @public
     */
    export declare abstract class FunnelChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends Chart implements SlicedCharts<FunnelSlice>, ChartWithCursor<CursorResultTableBackgroundType, CursorPosition2D, Cursor2D<CursorResultTableBackgroundType>, SolveResultFunnelChart> {
        setCursor(mutator: Mutator<Cursor2D<CursorResultTableBackgroundType>>): this;
        getCursor(): Cursor2D<CursorResultTableBackgroundType>;
        setCursorMode(mode: SolveNearestMode | undefined): this;
        getCursorMode(): SolveNearestMode | undefined;
        setCustomCursor(clbk: undefined | ((event: CursorTargetChangedEvent<SolveResultFunnelChart>) => unknown)): this;
        setCursorDynamicBehavior(value: CursorDynamicBehavior): this;
        /**
         * Set cursor formatting, controlling the text displayed in built-in cursor.
         *
         * ```ts
         *  chart.setCursorFormatting((_, hit, hits) => {
         *      return [
         *          ['Cursor pointing at'],
         *          [hit.series], // returning a series will display the series color and its name automatically.
         *          ['X', '', hit.axisX.formatValue(hit.x)], // utilizing axis formatValue is useful for considering active zoom level and type of axis
         *          ['Y', '', hit.y.toFixed(2)], // empty string '' results in gap between cells
         *          [{ text: 'Example', font: { weight: 'bold' }, fillStyle: fillRed }] // any cell can also be styled individually
         *      ]
         *  })
         * ```
         *
         * Before overriding default cursor formatting, it is recommended to check if using {@link GenericAxis.setUnits} or configuring Axis cursor formatting would be enough.
         *
         * In order to use series specific data properties (e.g. Heatmap sample "intensity"),
         * you should use type guards to assert the type of the `SolveResult`:
         *
         * ```ts
         *  // Example of using type guard in cursor formatter
         *  Chart.setCursorFormatting((chart, hit, hits) => {
         *      if (!isHitHeatmap(hit)) return undefined
         *      return [hit.intensity.toFixed(1)]
         *  })
         * ```
         *
         * More details in Developer documentation (Features \> Cursor).
         * @param   formatter -     Callback function for cursor formatting.
         * @returns     Object itself
         * @public
         */
        setCursorFormatting(formatter: CursorFormatterFunnelChart): this;
        /**
         * Get active cursor formatter.
         * @returns     Cursor formatter.
         * @public
         */
        getCursorFormatting(): CursorFormatterFunnelChart;
        /**
         * Add manually controlled Cursor object.
         * These have exactly same functions as built-in cursors but they can be freely controlled by application logic.
         *
         * ```ts
         *  const cursor = chart.addCursor()
         * ```
         *
         * Styling works same as built-in cursors (e.g. {@link setCursor}).
         *
         * Position is set using `setPosition` method and displayed content using `setResultTable(table => table.setContent(...))`
         * For more details, see Developer documentation \> Features \> Cursor \> Manual cursors
         *
         * @param   cursorBuilder -     Builder for cursor. Can be used to tweak a handful of properties which can't be changed during runtime.
         * @returns     Cursor object.
         * @public
         */
        addCursor<ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: CursorBuilder2D<ResultTableBackgroundType>): Cursor2D<ResultTableBackgroundType>;
        /**
         * This method is used for the adding slices in the funnel chart.
         * @param title - Funnel slice title
         * @param value - funnel slice value
         * @public
         */
        addSlice(title: string, value: number): FunnelSlice;
        /**
         * This method is used for the adding multiple slices in the funnel chart.
         * @param slices - Array of slices
         * @public
         */
        addSlices(slices: {
            name: string;
            value: number;
        }[]): Array<FunnelSlice>;
        /**
         * Get all Slices of Funnel Chart.
         * NOTE: Manual modifications to returned Array can have unforeseen side-effects.
         * Removing or adding Slices is intended to be done using other APIs (FunnelChart.addSlice, Slice.dispose, ...)
         * @returns Array of Slices
         * @public
         */
        getSlices(): FunnelSlice[];
        /**
         * Set Funnel Neck Width
         * @param neckWidth - Funnel Neck Width range from 1 to 50
         * @returns Funnel Chart itself
         * @public
         */
        setNeckWidth(neckWidth: number): this;
        /**
         * Get Funnel Neck Width
         * @returns number (1 - 50)
         * @public
         */
        getNeckWidth(): number;
        /**
         * Set gap between Slice / start of label connector, and end of label connector / Label.
         * @param sliceGap - Gap as pixels. Clamped between [0, 20] !
         * @returns Funnel Chart itself
         * @public
         */
        setSliceGap(sliceGap: pixel): this;
        /**
         * Set FunnelSliceMode. Can be used to select between different drawing approaches for Slices.
         *
         * See {@link FunnelSliceModes} for a collection of options.
         * @param sliceMode - FunnelSliceMode
         * @returns Funnel Chart itself
         * @public
         */
        setSliceMode(sliceMode: FunnelSliceModes): this;
        /**
         * Get FunnelSliceMode. Can be used to select between different drawing approaches for Slices.
         *
         * See {@link FunnelSliceModes} for a collection of options.
         * @returns FunnelSliceMode
         * @public
         */
        getFunnelSliceMode(): FunnelSliceModes;
        /**
         * Attach lookup table (LUT) to fill the slices with Colors based on value.
         *
         * The color for the slice would be selected from a specified *LUT*, which contains the information about gradient steps.
         * After setting LUT to undefined all the slices stay colorized, but no further lookup.
         *
         * LUT class stores information about values and its associated colors,
         * * which provides efficient lookup of the color based on provided value
         * * as well as linear and step interpolation between colors.
         *
         * ``` javascript
         * const funnel = lightningChart()
         *  .Funnel( { type: FunnelChartTypes.LabelsOnSides } )
         *  .setLUT( new LUT (steps: [
         *          { value: 10, color: ColorRGBA( 0, 0, 0 ) },
         *          { value: 20, color: ColorRGBA( 30, 255, 0 ) },
         *          { value: 30, color: ColorRGBA( 60, 204, 0 ) },
         *          { value: 40, color: ColorRGBA( 90, 128, 0 ) },
         *          { value: 50, color: ColorRGBA( 255, 0, 0 ) } ) ],
         *      interpolate: true } )
         * ```
         *
         * @param lut - Lookup table
         * @returns Pie itself for fluent interface
         * @public
         */
        setLUT(value: LUT): this;
        /**
         * Set style of Funnel Slices fill.
         * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Funnel will be assigned an incremental index,
         * which will be used to pick its fill style from this Palette.
         *
         * So, for example... We have a Funnel Chart with 5 Slices, and we give it a Palette with only 3 possible values
         * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
         * Note that this means, that the supplied Palette will have to work in a continuous manner!
         *
         * @param sliceFillStylePalette - Palette for FillStyle objects
         * @returns Funnel Chart itself
         * @public
         */
        setSliceFillStyle(sliceFillStylePalette: (index: number, slice: FunnelSlice) => FillStyle): this;
        /**
         * Get style of Funnel Slices fill.
         * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Funnel will be assigned an incremental index,
         * which will be used to pick its fill style from this Palette.
         *
         * So, for example... We have a Funnel Chart with 5 Slices, and we give it a Palette with only 3 possible values
         * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
         * Note that this means, that the supplied Palette will have to work in a continuous manner!
         *
         * @returns Palette<FillStyle>
         * @public
         */
        getSliceFillStyle(): (index: number, slice: FunnelSlice) => FillStyle;
        /**
         * Set style of Funnel Slices Stroke.
         * @param value - LineStyle object or function which creates a new style based on previous
         * @returns Funnel Chart itself
         * @public
         */
        setSliceStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of Funnel Slices Stroke.
         * @returns LineStyle object
         * @public
         */
        getSliceStrokeStyle(): LineStyle;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setSliceEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getSliceEffect(): boolean;
        /**
         * Set sorter of Funnels' Slices as a comparator-function.
         *
         * For some commonly needed default implementations, can refer to SliceSorters-collection.
         * @param sliceSorter - SliceSorter - function which sorts Slices of Funnel with JavaScript API: Array.sort.
         * @returns Funnel Chart itself
         * @public
         */
        setSliceSorter(sliceSorter: SliceSorter<FunnelSlice>): this;
        /**
         * Get sorter of Funnels' Slices as a comparator-function.
         * @returns SliceSorter - function which sorts Slices of Funnel with JavaScript API: Array.sort.
         * @public
         */
        getSliceSorter(): SliceSorter<FunnelSlice>;
        /**
         * Set fill style of Funnel Slices Labels.
         * @param value - FillStyle object or function which creates a new style based on previous
         * @returns Funnel Chart itself
         * @public
         */
        setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of Funnel Slice Labels.
         * @returns FillStyle object
         * @public
         */
        getLabelFillStyle(): FillStyle;
        /**
         * Not to be confused with {@link GlowEffect}
         * @public
         * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
         */
        setLabelShadow(value: Color | undefined): this;
        /**
         * Not to be confused with {@link GlowEffect}
         * @public
         * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
         */
        getLabelShadow(): Color | undefined;
        /**
         * Set font of Slice Labels.
         * @param value - FontSettings or mutator function for existing settings
         * @returns Funnel Chart itself
         * @public
         */
        setLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Get font of Slice Labels.
         * @returns FontSettings
         * @public
         */
        getLabelFont(): FontSettings;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setLabelEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getLabelEffect(): boolean;
        /**
         * Set formatter of Slice Labels.
         *
         * See {@link SliceLabelFormatters} for a collection of default options.
         * @param labelFormatter - SliceLabelFormatter - function which generates text of Labels per Slice.
         * @returns Funnel Chart itself
         * @public
         */
        setLabelFormatter(labelFormatter: SliceLabelFormatter<FunnelSlice>): this;
        /**
         * Get formatter of Slice Labels.
         * @returns SliceLabelFormatter - function which generates text of Labels per Slice.
         * @public
         */
        getLabelFormatter(): SliceLabelFormatter<FunnelSlice>;
        /**
         * Set if slices should be highlighted on mouse hover / touch. Applies to all Slices.
         * @param state - True if Slices should be highlighted on hover, false if not. This applies to all existing Slices and new Slices added.
         * @public
         */
        setSliceHighlightOnHover(state: boolean): this;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns Object itself for fluent interface
         * @public
         */
        dispose(): this;
        addEventListener<K extends keyof FunnelChartEventMap>(type: K, // ?
        listener: (event: FunnelChartEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof FunnelChartEventMap>(type: K, listener: (event: FunnelChartEventMap[K], info: unknown) => unknown): void;
    }
    /**
     * Interface of events trackable by {@link FunnelChart.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface FunnelChartEventMap extends PanelEventMap, ChartWithCursorEventMap<SolveResultFunnelChart> {
    }
    /**
     * Interface for readonly configuration of {@link FunnelChart}.
     *
     * Some properties of `FunnelChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, create chart with specified color theme.
     *  const chart = LightningChart.Funnel({
     *      theme: Themes.light,
     *  })
     * ```
     *
     * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
     *
     * For *standalone* `FunnelChart`, more parameters are documented in {@link LightningChart.Funnel}.
     *
     * For *dashboard* `FunnelChart`, more parameters are documented in {@link Dashboard.createFunnelChart}.
     *
     *
     * **Commonly used properties:**
     *
     * - {@link FunnelChartOptions.type}: Specify visual design of *funnel chart* from a collection of options.
     * - {@link FunnelChartOptions.theme}: Specify chart color *theme*.
     * - {@link FunnelChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, create funnel chart with default configuration.
     *  const chart = LightningChart.Funnel({})
     * ```
     *
     * ```typescript
     *  // Example 2, create funnel chart with labels inside slices.
     *  const chart = LightningChart.Funnel({
     *      type: FunnelChartTypes.LabelsInsideSlices
     *  })
     * ```
     *
     * ```typescript
     *  // Example 3, create funnel chart with specified color theme.
     *  const chart = LightningChart.Funnel({
     *      theme: Themes.light,
     *  })
     * ```
     * @public
     */
    export declare interface FunnelChartOptions<FunnelChartType extends FunnelChartTypes = FunnelChartTypes, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
        /**
         * Interface for specifying desired "type" of Funnel Chart.
         * This can be used to select different rendering approaches, mainly reflecting how Slice Labels are positioned.
         *
         * Options are located in {@link FunnelChartTypes}-collection. If undefined, will default to {@link FunnelChartWithLabelsOnSides}.
         */
        type?: FunnelChartType;
        /**
         * Builder for the charts' *auto cursor*.
         *
         * For most use cases, it is not recommended to use this, but rather {@link FunnelChart.setCursor} for a more convenient API.
         * @public
         */
        readonly cursorBuilder?: CursorBuilder2D<CursorResultTableBackgroundType>;
    }
    /**
     * Collection of {@link FunnelChart} implementations. Each option can have their own visual design, and *API* for customization of it.
     *
     * This must be specified when the *FunnelChart* is created (or default one will be used).
     *
     * Example usage:
     *```javascript
     * // Create a FunnelChart with default type
     * LightningChart.Funnel()
     * // Create a FunnelChart with specified type
     * LightningChart.Funnel({ type: FunnelChartTypes.LabelsInsideSlices })
     * ```
     * @public
     */
    export declare const FunnelChartTypes: {
        /**
         * Funnel Chart type, where Slice Labels are positioned on the either left or right sides of Chart.
         * The side can be set using setLabelSide
         * Labels are connected to their Slices with lines, which can be styled using unique API for this Funnel Chart type.
         */
        LabelsOnSides: typeof FunnelChartWithLabelsOnSides;
        /**
         * Funnel Chart type, where Slice Labels inside the Slices.
         */
        LabelsInsideSlices: typeof FunnelChartWithLabelsInsideSlices;
    };
    /**
     * Available Funnel Chart types
     * @public
     */
    export declare type FunnelChartTypes = (typeof FunnelChartTypes)[keyof typeof FunnelChartTypes];
    /**
     * {@link FunnelChart} implementation that draws Slice Labels inside the Slices.
     * Works well when Label texts are short and there are not a lot of Slices, as the actual Funnel has more space.
     * @public
     */
    export declare class FunnelChartWithLabelsInsideSlices extends FunnelChart {
        /**
         * Get minimum size of Panel.
         * Depending on the type of class this value might be automatically computed to fit different elements.
         * @returns Point
         * @public
         */
        getMinimumSize(): Point | undefined;
    }
    /**
     * {@link FunnelChart} implementation that draws Slice Labels on its left and right sides.
     * Slices and Labels are connected by 'label connector lines'.
     * @public
     */
    export declare class FunnelChartWithLabelsOnSides extends FunnelChart {
        /**
         * Set style of Label connector lines.
         * @param labelConnectorStyle - LineStyle object
         * @returns Funnel Chart itself
         * @public
         */
        setLabelConnectorStyle(labelConnectorStyle: LineStyle): this;
        /**
         * Get style of Label connector lines.
         * @returns LineStyle object
         * @public
         */
        getLabelConnectorStyle(): LineStyle;
        /**
         * @public
         */
        setLabelConnectorGapBeforeLabel(gap: number): this;
        /**
         * @public
         */
        getLabelConnectorGapBeforeLabel(): number;
        /**
         * @public
         */
        setLabelConnectorGapBeforeSlice(gap: number): this;
        /**
         * @public
         */
        getLabelConnectorGapBeforeSlice(): number;
        /**
         * @public
         */
        setLabelConnectorLengthAfterSlice(length: number): this;
        /**
         * @public
         */
        getLabelConnectorLengthAfterSlice(): number;
        /**
         * @public
         */
        setLabelConnectorMinLengthBeforeSlice(length: number): this;
        /**
         * @public
         */
        getLabelConnectorMinLengthBeforeSlice(): number;
        /**
         * Set the side where label should display
         * @param labelSide - Left /Right
         * @returns Funnel Chart itself
         * @public
         */
        setLabelSide(labelSide: FunnelLabelSide): this;
        /**
         * Get the side where label shown
         * @returns The label side
         * @public
         */
        getLabelSide(): FunnelLabelSide;
        /**
         * Get minimum size of Panel.
         * Depending on the type of class this value might be automatically computed to fit different elements.
         * @returns Point minimum size or undefined if unimplemented
         * @public
         */
        getMinimumSize(): Point | undefined;
    }
    /**
     * Options for selecting side of labels in a {@link FunnelChartWithLabelsOnSides}.
     *
     * Use with {@link FunnelChartWithLabelsOnSides.setLabelSide}
     * @public
     */
    export declare enum FunnelLabelSide {
        /**
         * Label Side  - Right
         */
        Right = 0,
        /**
         * Label Side  - Left
         */
        Left = 1
    }
    /**
     * Interface that can be used to define {@link FunnelChart} configurations, when inside a {@link Dashboard}, that can't be changed after creation.
     *
     *  Example usage:
     *```javascript
     * // Funnel Chart with default type
     * undefined
     * // Funnel Chart with specified type
     * { funnelOptions: { type: FunnelChartTypes.LabelsOnSides } }
     * ```
     * @public
     */
    export declare interface FunnelOptions<FunnelChartType extends FunnelChartTypes = FunnelChartTypes> extends DashboardCellOptions, FunnelChartOptions<FunnelChartType> {
    }
    /**
     * Class that represents a single Slice of a Funnel Chart.
     * It is given to users when a Slice is added.
     * @public
     */
    export declare abstract class FunnelSlice extends Slice {
        /**
         * Set value of Slice.
         * @param value - Numeric value
         * @returns Slice itself
         * @public
         */
        abstract setValue(value: number): this;
        /**
         * Get value of Slice.
         * @returns Numeric value
         * @public
         */
        abstract getValue(): number;
    }
    /**
     * Enum for selecting different drawing approaches for {@link FunnelChart}.
     *
     * Use with {@link FunnelChart.setSliceMode}
     * @public
     */
    export declare enum FunnelSliceModes {
        /**
         * Slices **height** represents its relative value inside the Funnel Chart.
         */
        VariableHeight = 0,
        /**
         * Slices **width** represents its relative value inside the Funnel Chart.
         */
        VariableWidth = 1
    }
    /**
     * Chart for visualizing a single value within a interval.
     *
     * ** Creating Gauge Chart **
     *
     * ```ts
     * // Create a Gauge Chart with specific options.
     * const chart = lightningChart().GaugeChart({
     *    // Chart options
     * })
     * ```
     *
     * The gauge interval can be adjusted to suit the granularity of the data being visualized.
     *
     * The gauge bar can be configured to display data over a specific range of angles.
     * This allows for customization of the visual appearance of the gauge,
     * such as whether it covers a full circle or just a segment of it.
     *
     * Gauge chart can display value indicators on top of the main bar,
     * which are additional intervals superimposed on the main gauge bar.
     * These value indicators can be used to delineate certain thresholds or value ranges of interest in the data.
     * @public
     */
    export declare class GaugeChart extends Chart {
        /**
         * Disable/Enable all animations of the Chart.
         * ```ts
         * chart.setAnimationsEnabled(true)
         * ```
         * @param animationsEnabled - Boolean value to enable or disable animations.
         * @returns Chart itself for fluent interface.
         * @public
         */
        setAnimationsEnabled(animationsEnabled: boolean): this;
        /**
         * Sets the gauge value interval.
         * ```ts
         * chart.setInterval(-100, 100)
         * ```
         * @param start - start value
         * @param end - end value
         * @returns Object itself
         * @public
         */
        setInterval(start: number, end: number): this;
        /**
         * Get the interval of the gauge.
         * @returns Object containing the current start and end of the gauge.
         * @public
         */
        getInterval(): {
            start: number;
            end: number;
        };
        /**
         * Set the FillStyle of gauge ticks.
         * ```ts
         * chart.setTickFillStyle(
         *  new SolidFill({
         *      color: ColorRGBA(255, 0, 0),
         *  }),
         * )
         * ```
         * @param fillStyle - FillStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setTickFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get the FillStyle of gauge ticks.
         * @returns FillStyle object
         * @public
         */
        getTickFillStyle(): FillStyle;
        /**
         * Set the FontSettings of gauge ticks.
         * ```ts
         * // Example, set font size
         * chart.setTickFont((font) => font.setSize(16))
         * ```
         * @param fontSettings - FontSettings or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setTickFont(fontSettings: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Get the font of gauge ticks.
         * @returns FontSettings object
         * @public
         */
        getTickFont(): FontSettings;
        /**
         * Set the formatter function of gauge ticks.
         * ```ts
         * chart.setTickFormatter((value) => value.toFixed(1))
         * ```
         * @param formatter - Callback function to format tick values
         * @returns Object itself
         * @public
         */
        setTickFormatter(formatter: (value: number) => string): this;
        /**
         * Get the formatter function for gauge ticks.
         * @returns Formatting function
         * @public
         */
        getTickFormatter(): (value: number) => string;
        /**
         * Set the FillStyle of the value label.
         * ```ts
         * chart.setValueLabelFillStyle(
         new SolidFill({
         color: ColorRGBA(255, 0, 0),
         }),
         )
         * ```
         * @param fillStyle - FillStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setValueLabelFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get the FillStyle of value label.
         * @returns FillStyle object
         * @public
         */
        getValueLabelFillStyle(): FillStyle;
        /**
         * Set the FontSettings of the value label.
         * ```ts
         * // Example, set font size
         * chart.setValueLabelFont((font) => font.setSize(16))
         * ```
         * @param fontSettings - FontSettings or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setValueLabelFont(fontSettings: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Get the font of value label.
         * @returns FontSettings object
         * @public
         */
        getValueLabelFont(): FontSettings;
        /**
         * Set the text or formatting of the value label.
         * ```ts
         * chart.setValueFormatter((value) => value.toFixed(1))
         * ```
         * @param arg - String value or callback function to format the value label
         * @returns Object itself
         * @public
         */
        setValueFormatter(arg: string | ((value: number) => string)): this;
        /**
         * Get the value or the formatter of value label
         * @returns Formatting function
         * @public
         */
        getValueLabel(): string | ((value: number) => string);
        /**
         * Set the FillStyle of the unit label.
         * ```ts
         * chart.setUnitLabelFillStyle(
         *   new SolidFill({
         *      color: ColorRGBA(255, 0, 0),
         *  }),
         * )
         * ```
         * @param fillStyle - FillStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setUnitLabelFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get the FillStyle of unit label.
         * @returns FillStyle object
         * @public
         */
        getUnitLabelFillStyle(): FillStyle;
        /**
         * Set the FontSetting of the unit label.
         * ```ts
         * // Example, set font size
         * chart.setUnitLabelFont((font) => font.setSize(16))
         * ```
         * @param fontSettings - FontSettings or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setUnitLabelFont(fontSettings: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Get the font of unit label.
         * @returns FontSettings object
         * @public
         */
        getUnitLabelFont(): FontSettings;
        /**
         * Set the text of the unit label.
         * ```ts
         * chart.setUnitLabel("C")
         * ```
         * @param label - Unit label text
         * @returns Object itself
         * @public
         */
        setUnitLabel(label: string): this;
        /**
         * Get the text of unit label.
         * @returns String
         * @public
         */
        getUnitLabel(): string;
        /**
         * Set the FillStyle of the gauge needle.
         * ```ts
         * chart.setNeedleFillStyle(
         *   new SolidFill({
         *      color: ColorRGBA(255, 0, 0),
         *  }),
         * )
         * ```
         * @param fillStyle - FillStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setNeedleFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * The the FillStyle of the needle line.
         * @returns FillStyle object
         * @public
         */
        getNeedleFillStyle(): FillStyle;
        /**
         * Set the thickness of the needle.
         * ```ts
         * chart.setNeedleThickness(10)
         * ```
         * @param thickness - Thickness in pixels
         * @returns Object itself
         * @public
         */
        setNeedleThickness(thickness: number): this;
        /**
         * Get the thickness of the needle.
         * @returns Thickness in pixels
         * @public
         */
        getNeedleThickness(): number;
        /**
         * Set the LineStyle of the needle stroke.
         * ```ts
         * chart.setNeedleStrokeStyle(
         *  new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) }),
         *  }),
         * )
         * ```
         * @param lineStyle - LineStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setNeedleStrokeStyle(lineStyle: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get the LineStyle of the needle border.
         * @returns LineStyle object
         * @public
         */
        getNeedleStrokeStyle(): LineStyle;
        /**
         * Set the length of the gauge needle.
         * ```ts
         * chart.setNeedleLength(20)
         * ```
         * @param pixels - Length in pixels
         * @returns Object itself
         * @public
         */
        setNeedleLength(pixels: number): this;
        /**
         * Get the length of the needle.
         * @returns Length of the needle in pixels.
         * @public
         */
        getNeedleLength(): number;
        /**
         * Set the normal bar color, when not affected by value coloring.`
         * ```ts
         * chart.setBarColor(ColorRGBA(255, 0, 0))
         * ```
         * @param color - Color object
         * @returns Object itself
         * @public
         */
        setBarColor(color: Color): this;
        /**
         * Get the current color of the gauge bar.
         * @returns Color object
         * @public
         */
        getBarColor(): Color;
        /**
         * Enable or disable gradient coloring for the gauge bar.
         * If true, the active color of the Gauge Bar is mapped to a RadialGradientFill.
         * If false, bar is always solid color.
         * ```ts
         * chart.setBarGradient(true)
         * ```
         * @param enabled - Boolean flag
         * @returns Object itself
         * @public
         */
        setBarGradient(enabled: boolean): this;
        /**
         * Get the boolean value whether gradient coloring is enabled on the gauge bar.
         * @returns Boolean flag
         * @public
         */
        getBarGradient(): boolean;
        /**
         * Set the StrokeStyle of the gauge bar, i.e., the gauge bar border.
         * ```ts
         * chart.setBarStrokeStyle(
         *  new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) }),
         *  }),
         * )
         * ```
         * @param lineStyle - LineStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setBarStrokeStyle(lineStyle: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get the stroke style of the gauge bar.
         * @returns LineStyle object
         * @public
         */
        getBarStrokeStyle(): LineStyle;
        /**
         * Set the thickness of the gauge bar.
         * ```ts
         * chart.setBarThickness(20)
         * ```
         * @param pixels - Thickness in pixels
         * @returns Object itself
         * @public
         */
        setBarThickness(pixels: number): this;
        /**
         * Get the thickness of the gauge bar.
         * @returns Thickness in pixels
         * @public
         */
        getBarThickness(): number;
        /**
         * Set the angle interval of the gauge.
         * ```ts
         * chart.setAngleInterval(180, 0)
         * ```
         * @param angleStartDeg - Start angle
         * @param angleEndDeg - End angle
         * @returns Object itself
         * @public
         */
        setAngleInterval(angleStartDeg: number, angleEndDeg: number): this;
        /**
         * Get the angle interval of the gauge.
         * @returns Object containing the current start and end angles of the gauge.
         * @public
         */
        getAngleInterval(): {
            start: number;
            end: number;
        };
        /**
         * Set the value of the gauge.
         * ```ts
         * chart.setValue(100)
         * ```
         * @param value - Gauge value
         * @returns Object itself
         * @public
         */
        setValue(value: number): this;
        /**
         * Get the current value of the gauge.
         * @returns Current gauge value
         * @public
         */
        getValue(): number;
        /**
         * Enable or disable value animations.
         * ```ts
         * // Slow down animation
         * chart.setValueAnimation(true, 0.75)
         * // Speed up animation
         * chart.setValueAnimation(true, 1.25)
         * // Disable animation
         * chart.setValueAnimation(false)
         * ```
         * @param enabled - Boolean flag
         * @param speedMultiplier - Optional value for adjusting the speed of the animation
         * @returns Object itself
         * @public
         */
        setValueAnimation(enabled: boolean, speedMultiplier?: number): this;
        /**
         * Enable or disable color animations.
         * ```ts
         * // Slow down animation
         * chart.setColorAnimation(true, 0.75)
         * // Speed up animation
         * chart.setColorAnimation(true, 1.25)
         * // Disable animation
         * chart.setColorAnimation(false)
         * ```
         * @param enabled - Boolean flag
         * @param speedMultiplier - Optional value for adjusting the speed of the animation
         * @returns Object itself
         * @public
         */
        setColorAnimation(enabled: boolean, speedMultiplier?: number): this;
        /**
         * Enable or disable rounded edges for the gauge nad value indicators.
         * ```ts
         * chart.setRoundedEdges(false)
         * ```
         * @param enabled - Boolean flag
         * @returns Object itself
         * @public
         */
        setRoundedEdges(enabled: boolean): this;
        /**
         * Get the boolean value whether rounded edges are enabled for the gauge.
         * @returns Boolean flag
         * @public
         */
        getRoundedEdges(): boolean;
        /**
         * Set the value indicators of the gauge.
         * ```ts
         * chart.setValueIndicators([
         *  { start: 0, end: 25, color: ColorCSS('red') },
         *  { start: 25, end: 50, color: ColorCSS('orange') },
         *  { start: 50, end: 75, color: ColorCSS('yellow') },
         *  { start: 75, end: 100, color: ColorCSS('green') },
         * ])
         * ```
         * @param indicators - Array of value indicators
         * @returns Object itself
         * @public
         */
        setValueIndicators(indicators: Array<{
            start: number;
            end: number;
            color: Color;
            startLabel?: string;
            endLabel?: string;
        }>): this;
        /**
         * Get the current value indicators of the gauge.
         * @returns Array of value indicators
         * @public
         */
        getValueIndicators(): {
            start: number;
            end: number;
            color: Color;
            startLabel?: string | undefined;
            endLabel?: string | undefined;
        }[];
        /**
         * Set the thickness of the value indicators.
         * ```ts
         * chart.setValueIndicatorThickness(10)
         * ```
         * @param pixels - Thickness in pixels
         * @returns Object itself
         * @public
         */
        setValueIndicatorThickness(pixels: number): this;
        /**
         * Get the thickness of the value indicators.
         * @returns Thickness in pixels
         * @public
         */
        getValueIndicatorThickness(): number;
        /**
         * Enable or disable dynamic gauge bar coloring based on value indicators.
         * If true, gauge bar is colored with the current indicator color.
         * If false, gauge bar is always colored according to its "normal" color, `setBarColor`
         * ```ts
         * chart.setAutomaticBarColoring(true)
         * ```
         * @param arg - Boolean flag
         * @returns Object itself
         * @public
         */
        setAutomaticBarColoring(arg: undefined | boolean): this;
        /**
         * Get the boolean value whether dynamic gauge bar coloring is enabled.
         * @returns Boolean flag
         * @public
         */
        getAutomaticBarColoring(): boolean;
        /**
         * Set the background glow color.
         * arg: undefined = No background glow color.
         * arg: Color = Use explicit glow color always.
         * arg: { auto: true } = Automatically color with same color as gauge bar.
         * ```ts
         * // Disable background glow
         * chart.setGlowColor(undefined)
         * // Use explicit glow color
         * chart.setGlowColor(ColorRGBA(255, 0, 0, 64))
         * // Use dynamic coloring, set alpha value
         * chart.setGlowColor({auto: true, alpha: 32})
         * ```
         * @param arg - undefined | Color | { auto: boolean }
         * @param alpha - Alpha value between 0 and 255 for adjusting the amount of glow
         * @returns Object itself
         * @public
         */
        setGlowColor(arg: undefined | Color | {
            auto: boolean;
            alpha?: number;
        }): this;
        /**
         * Get the boolean value whether dynamic background coloring is enabled.
         * @returns Boolean flag
         * @public
         */
        getAutomaticGlowColoring(): boolean;
        /**
         * Align the gauge needle from the gauge bar center.
         * ```ts
         * chart.setNeedleAlignment(-1)
         * ```
         * @param offset - Numerical offset value between -1 and 1
         * @returns Object itself
         * @public
         */
        setNeedleAlignment(offset: number): this;
        /**
         * Get the alignment value of the needle.
         * @returns Alignment value
         * @public
         */
        getNeedleAlignment(): number;
        /**
         * Set the distance between gauge bar and value indicators.
         * ```ts
         * chart.setGapBetweenBarAndValueIndicators(4)
         * ```
         * @param gap - Distance in pixels
         * @returns Object itself
         * @public
         */
        setGapBetweenBarAndValueIndicators(gap: number): this;
        /**
         * Get the distance between gauge bar and value indicators.
         * @returns Distance in pixels
         * @public
         */
        getGapBetweenBarAndValueIndicators(): number;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setBarEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getBarEffect(): boolean;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setLabelEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getLabelEffect(): boolean;
        /**
         * Get minimum size of Chart.
         * Depending on the type of class this value might be automatically computed to fit different elements.
         * @returns Vec2 minimum size or undefined if unimplemented
         */
        getMinimumSize(): Point | undefined;
        addEventListener<K extends keyof PanelEventMap>(type: K, listener: (event: PanelEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof PanelEventMap>(type: K, listener: (event: PanelEventMap[K], info: unknown) => unknown): void;
    }
    /**
     * Abstract super class for 2D/3D Axis implementations.
     * @public
     */
    export declare abstract class GenericAxis<ScaleType extends AxisScale = AxisScale, StrategyType extends AbstractAxisStrategy = AbstractAxisStrategy, TickType extends _AbstractAxisTick = _AbstractAxisTick, UpdateInput extends _GenericAxisInput = _GenericAxisInput, TickPlottingVariables extends _GenericTickPlottingVariables = _GenericTickPlottingVariables, TickInfo extends _GenericTickInfo = _GenericTickInfo, UpdateOutput extends _GenericAxisOutput<TickType, TickInfo> = _GenericAxisOutput<TickType, TickInfo>> implements AxisState, Hideable, HideableEvents {
        /**
         * Set unit that Axis measures. e.g. `"Hz"`, or `"C"`.
         * This is a convenience API that affects following things:
         *
         * - The unit is displayed after the Axis title (if it is defined). e.g. "Axis title (Hz)"
         * - Default cursor formatters place the Unit next to units of the Axis.
         *
         * ```ts
         *  // Example syntax
         *  axis
         *      .setTitle('Frequency')
         *      .setUnits('Hz')
         *
         *  axis.setUnits('Hz', { displayOnAxis: false })
         * ```
         *
         * @param   units -     String or `undefined`.
         * @param   behavior -  Optional extra argument to control which side effects of configuring Units are enabled.
         * @returns             Object itself.
         * @public
         */
        setUnits(units: string | undefined, behavior?: AxisUnitsBehavior): this;
        /**
         * Get unit that Axis measures. e.g. `"Hz"`, or `"C"`.
         *
         * - The unit is displayed after the Axis title (if it is defined). e.g. "Axis title (Hz)"
         * - Default cursor formatters place the Unit next to units of the Axis.
         * @public
         */
        getUnits(): string | undefined;
        /**
         * Set Axis default interval.
         * This does the same as {@link setInterval} method, but is also applied again whenever {@link Axis.fit} is triggered, or the "zoom to fit" user interaction is triggered.
         *
         * Intended to be used in use cases that set an Axis interval nicely at start of application.
         *
         * ```ts
         *  // Example 1, set hardcoded interval at application start
         *  Axis.setDefaultInterval({ start: 0, end: 100 })
         * ```
         *
         * This method also allows interval specification as a callback function,
         * allowing the applied default interval to be based on the range of data or current axis interval:
         *
         * ```ts
         *  // Example 2, scrolling axis - when axis is fitted, restore default time window and continue scrolling
         *  Axis.setDefaultInterval((state) => ({
         *      end: state.dataMax ?? 0,
         *      start: (state.dataMax ?? 0) - 10_000,
         *      stopAxisAfter: false,
         *  }))
         * ```
         *
         * ```ts
         *  // Example 3, add some extra space
         *  Axis.setDefaultInterval((state) => ({
         *      start: (state.dataMin ?? 0) - 10,
         *      end: (state.dataMax ?? 0) + 10,
         *  }))
         * ```
         *
         * Optional extra arguments:
         *
         * ```ts
         *  // Configure default interval (to be applied on restoreDefault user interaction or axis.fit()), but don't apply it immediately
         *  Axis.setDefaultInterval({ start: 0, end: 10 }, { applyImmediately: false })
         * ```
         *
         * By default, default interval ignores any interval restrictions that have been set.
         * If undesirable, this can be changed by specifying `skipIntervalRestrictions` flag.
         *
         * ```ts
         *  // Don't skip interval restrictions
         *  Axis.setDefaultInterval({ start: 0, end: 10 }, { skipIntervalRestrictions: false })
         * ```
         * @public
         */
        setDefaultInterval(arg: AxisIntervalConfiguration | undefined | ((state: {
            curStart: number;
            curEnd: number;
            dataMin: number | undefined;
            dataMax: number | undefined;
        }) => AxisIntervalConfiguration), opts?: {
            /**
             * Potentially misleading naming, even if set to `true`, it doesn't mean that the interval is immediately configured after the `setDefaultInterval` call.
             * Rather, the default interval is applied just before rendering next frame.
             */
            applyImmediately?: boolean;
            skipIntervalRestrictions?: boolean;
        }): this;
        /**
         * Get current configuration of default interval ({@link setDefaultInterval}).
         * Defaults to `undefined`.
         * @public
         */
        getDefaultInterval(): undefined | AxisIntervalConfiguration | ((info: {
            curStart: number;
            curEnd: number;
            dataMin: number | undefined;
            dataMax: number | undefined;
        }) => AxisIntervalConfiguration);
        /**
         * @returns Axis title string
         * @public
         */
        getTitle(): string;
        /**
         * Specifies an Axis title string
         * @param title - Axis title as a string
         * @returns Axis itself for fluent interface
         * @public
         */
        setTitle(title: string): this;
        /**
         * @returns Axis title fillstyle
         * @public
         */
        getTitleFillStyle(): FillStyle;
        /**
         * Set restrictions on Axis interval (start/end).
         * These are not applied immediately, but affect all axis scrolling and user interactions afterwards.
         *
         * ```ts
         *  // Example 1, prevent zooming outside active data set
         *  Axis.setIntervalRestrictions((state) => ({
         *      startMin: state.dataMin,
         *      endMax: state.dataMax,
         *  }))
         * ```
         *
         * ```ts
         *  // Example 2, set max zoom in level (intervalMin)
         *  Axis.setIntervalRestrictions({ intervalMin: 10 })
         * ```
         *
         * ```ts
         *  // Example 3, set max zoom out level (intervalMax)
         *  Axis.setIntervalRestrictions({ intervalMax: 1000 })
         * ```
         *
         * ```ts
         *  // Example 4, no restrictions
         *  Axis.setIntervalRestrictions(undefined)
         * ```
         *
         * @public
         */
        setIntervalRestrictions(arg: undefined | {
            startMin?: number;
            startMax?: number;
            endMin?: number;
            endMax?: number;
            intervalMin?: number;
            intervalMax?: number;
        } | ((state: {
            curStart: number;
            curEnd: number;
            dataMin: number | undefined;
            dataMax: number | undefined;
        }) => {
            startMin?: number;
            startMax?: number;
            endMin?: number;
            endMax?: number;
            intervalMin?: number;
            intervalMax?: number;
        })): this;
        /**
         * Get current value of {@link setIntervalRestrictions}. By default, no restrictions.
         * @public
         */
        getIntervalRestrictions(): undefined | {
            startMin?: number;
            startMax?: number;
            endMin?: number;
            endMax?: number;
            intervalMin?: number;
            intervalMax?: number;
        };
        /**
         * Specifies Axis title FillStyle
         *
         * ```ts
         *  // Example, set title color
         *  Axis.setTitleFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         * ```
         *
         * - To learn more of fill style configurations, see {@link FillStyle}.
         * @param fillStyle - FillStyle of Axis title or mutator to modify existing one
         * @returns Axis itself for fluent interface
         * @public
         */
        setTitleFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get font of axis labels.
         * @returns FontSettings
         * @public
         */
        getTitleFont(): FontSettings;
        /**
         * Set font of Axis title.
         *
         * ```ts
         *  // Example, set font size
         *  Axis.setTitleFont((font) => font.setSize(10))
         * ```
         *
         * - To learn more of font configurations, see {@link FontSettings}.
         *
         * @param value - FontSettings or mutator function for existing settings
         * @returns Object itself
         * @public
         */
        setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Set rotation of Axis title.
         * @param value - Rotation in degrees
         * @returns Object itself
         * @public
         */
        setTitleRotation(value: number): this;
        /**
         * Get rotation of Axis title.
         * @returns Rotation in degrees
         * @public
         */
        getTitleRotation(): number;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setTitleEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getTitleEffect(): boolean;
        /**
         * Set axis interval.
         *
         * Examples:
         *
         * ```ts
         *  // Set interval start and end.
         *  Axis.setInterval({ start: 0, end: 5000 })
         * ```
         *
         * ```ts
         *  // Set interval end only.
         *  Axis.setInterval({ end: 5000 })
         * ```
         *
         * ```ts
         *  // Set interval but don't stop the axis from scrolling
         *  Axis.setInterval({ start: 0, end: 5000, stopAxisAfter: false })
         * ```
         *
         * ```ts
         *  // Set interval with 2000 milliseconds long animation
         *  Axis.setInterval({ start: 0, end: 5000, animate: 2000 })
         * ```
         *
         * @param   opts -  Parameters for axis interval.
         * @returns Object itself for fluent interface
         * @public
         */
        setInterval(opts: AxisIntervalConfiguration): this;
        /**
         * Get the currently applied axis scale interval.
         * @returns Object containing the current start and end of Axis.
         * @public
         */
        getInterval(): AxisInterval;
        /**
         * Set Axis stopped or not.
         *
         * When an Axis is stopped it temporarily prevents the active {@link AxisScrollStrategy | scroll strategy} from changing the Axis interval.
         *
         * Axis can be stopped programmatically using this method, and also by different built in interactions, such as panning/zooming.
         *
         * ```ts
         *  // Example, stop Axis scrolling / fitting.
         *  Axis.setStopped(true)
         * ```
         * @param stopped - Axis stopped
         * @returns         Object itself
         * @public
         */
        setStopped(stopped: boolean): this;
        /**
         * Get Axis stopped or not.
         *
         * When an Axis is stopped it temporarily prevents the active {@link AxisScrollStrategy | scroll strategy} from changing the Axis interval.
         *
         * Axis can be stopped programmatically using this method, and also by different built in interactions, such as panning/zooming.
         *
         * @returns         Axis stopped
         * @public
         */
        getStopped(): boolean;
        /**
         * Fit axis view to attached series.
         * @param animate - Boolean for animation enabled, or number for animation duration in milliseconds
         * @param stopAxisAfter - If true, stops Axis after fitting
         * @public
         */
        fit(animate?: number | boolean, stopAxisAfter?: boolean): this;
        /**
         * Specify *ScrollStrategy* of the *Axis*. This decides where the *Axis* scrolls based on current view and series boundaries.
         *
         * ```ts
         *  // Example syntax
         *  chart.axisY.setScrollStrategy(AxisScrollStrategies.fitting)
         *  chart.axisX.setScrollStrategy(AxisScrollStrategies.scrolling)
         *  chart.axisY.setScrollStrategy(AxisScrollStrategies.fitting({ considerVisibleRangeOnly: false }))
         * ```
         *
         * While technically it is possible to define custom axis scroll strategies by passing an object that satisfies this interface,
         * **this is not recommended**.
         *
         * All known use cases can be realized with built-in scroll strategies.
         * If you believe this is not the case, please contact us https://lightningchart.com/js-charts/docs/contact/
         *
         * @param scrollStrategy - *AxisScrollStrategy* or undefined to disable automatic scrolling.
         *                          See {@link AxisScrollStrategies} for all options.
         * @returns Object itself for fluent interface.
         * @public
         */
        setScrollStrategy(scrollStrategy?: AxisScrollStrategy | (() => AxisScrollStrategy)): this;
        /**
         * @returns Current *AxisScrollStrategy*
         * @public
         */
        getScrollStrategy(): AxisScrollStrategy | undefined;
        /**
         * Specifies scroll animation.
         * @param enabled - Boolean flag for whether scrolling should be animated or not.
         * @public
         */
        setAnimationScroll(enabled: boolean | undefined): this;
        /**
         * Specifies zoom animation to use.
         *
         * Example usage:
         *
         * | Desired result              | Argument                                           | Parameters                                                                                                                            |
         * | :-------------------------  | :------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |
         * | Change animation            | `setAnimationZoom(AnimationEasings.easeOut, 500)`  | First parameter defines the easing to use for the animation. Second parameter is optional, and defines the duration for the animation |
         * | Disable zooming animations  | `axis.setAnimationZoom(undefined)`                 | Passing **undefined** as the parameter will disable the zooming animations for the Axis.                                              |
         *
         * @param easing - Easing of animation. Undefined disables zoom animations. See 'common/animator.Easings' for defaults
         * @param duration - Optional default duration for zooming animations in milliseconds
         * @public
         */
        setAnimationZoom(easing: AnimationEasing | undefined, duration?: number): this;
        /**
         *  Disable/Enable all animations of the Chart.
         * @param animationsEnabled - Boolean value to enable/disable animations.
         * @returns Axis itself for fluent interface.
         * @public
         */
        setAnimationsEnabled(animationsEnabled: boolean): this;
        /**
         * Get animations disable/enable state.
         * @returns Animations default state.
         * @public
         */
        getAnimationsEnabled(): boolean;
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @returns Object itself.
         * @public
         */
        setVisible(state: boolean): this;
        /**
         * Get element visibility.
         *
         * @returns `true` when element is set to be visible and `false` otherwise.
         * @public
         */
        getVisible(): boolean;
        /**
         * Set whether element can be target of pointer events or not.
         *
         * Disabling pointer events means that the objects below this component can be interacted _through_ it.
         *
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        abstract setPointerEvents(state: boolean): this;
        /**
         * Get whether element can be target of pointer events or not.
         *
         * Disabling pointer events means that the objects below this component can be interacted _through_ it.
         *
         * @returns Boolean
         * @public
         */
        abstract getPointerEvents(): boolean;
        /**
         * Used in phase 1: after we know what ticks will be displayed, formulate generic information for chart layout calculations (e.g. XY layout for XY charts).
         */
        protected abstract _getAbstractUpdateResult(input: UpdateInput, ticksInfo: Map<TickType, TickInfo>, updatedTicks: boolean): UpdateOutput;
        /**
         * Format a value along axis to string. Behavior depends on the Axis' TickStrategy.
         * Eq. A DateTime-Axis will interpret 'value' as a Date.
         * @param value - Value along axis
         * @returns Value formated to string
         * @public
         */
        formatValue: (value: number) => string;
        /**
         * Get data extents of series attached to the axis.
         * @returns     `{ min: number, max: number }` or `undefined`.
         * @public
         */
        getSeriesDataRange(): Interval<number> | undefined;
        /**
         * Method that allows configuring extra space allocated around series data boundaries when axis is scrolling.
         * Important, in LCJS context, scrolling refers to any automatic axis behavior adjusting according to attached series.
         *
         * By default, automatic scroll margins are enabled, which means the actual value is based on attached series and their style.
         * For example, in case of point series, the scroll margins are set to half of point size.
         *
         * ```ts
         *  // Example, disable scroll margins entirely
         *  Axis.setScrollMargins(false)
         * ```
         *
         * ```ts
         *  // Example, set specific scroll margins as pixels
         *  Axis.setScrollMargins(5)
         * ```
         *
         * ```ts
         *  // Example, insymmetric scroll margins as pixels
         *  Axis.setScrollMargins({ start: 0, end: 10 })
         * ```
         *
         * If axis interval is explicitly configured using {@link setInterval} or {@link setDefaultInterval} then scroll margins are not applied.
         *
         * @param   arg     - Scroll margin configuration.
         * @returns     Object itself.
         * @public
         * @beta Introduced in v7.1.0. Method may be removed/changed depending on how the related use cases evolve.
         */
        setScrollMargins(arg: number | boolean | undefined | {
            start: number;
            end: number;
        }): this;
        /**
         * Get value of {@link setScrollMargins}
         * @returns     Scroll margins configuration
         */
        getScrollMargins(): {
            start: number;
            end: number;
        } | boolean;
        /**
         * Method that allows disabling Axis allocating automatic pixel based regions around data start and data end.
         * For example, if Axis has attached point series with 10px size, the Axis can automatically add 10px gaps at both start and end.
         *
         * This behavior is enabled normally, but in some cases it can cause problems with several axes being out of sync, in which case they can
         * be disabled with this method.
         *
         * @param   enabled - Auto regions enabled or not.
         * @returns     Object itself.
         * @public
         * @deprecated  Deprecated in v7.1.0. Use {@link setScrollMargins} instead.
         */
        setAutoRegionsEnabled(enabled: boolean): this;
        /**
         * Interface for attaching listeners to user interaction events (`click`, `pointerenter`, etc.) on axis title.
         *
         * ```ts
         *  // Example syntax
         *  axis.title.addEventListener('click', (event) => {
         *      console.log(event)
         *  })
         * ```
         *
         * For syntax examples, refer to {@link EventInterface}.
         * Available event keys are listed under {@link LCJSInteractionEventMap}
         * @public
         */
        readonly title: Eventer<LCJSInteractionEventMap>;
        abstract addEventListener<K extends keyof GenericAxisEventMap>(type: K, listener: (event: GenericAxisEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        abstract removeEventListener<K extends keyof GenericAxisEventMap>(type: K, listener: (event: GenericAxisEventMap[K], info: unknown) => unknown): void;
    }
    /**
     * Interface of events trackable by {@link GenericAxis.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface GenericAxisEventMap extends DisposableEventMap, HideableEventMap {
        /**
         * Event fired when the axis is stopped or released.
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('stoppedchange', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        stoppedchange: AxisStoppedChangedEvent;
        /**
         * Event fired when the axis interval changes.
         *
         * ```ts
         *  // Example usage
         *  chart.addEventListener('intervalchange', (event) => {
         *      console.log(event)
         *  })
         * ```
         */
        intervalchange: AxisIntervalChangedEvent;
    }
    /**
     * @public
     * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
     */
    declare interface _GenericAxisInput {
    }
    /**
     * @public
     * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
     */
    declare interface _GenericAxisOutput<TickType = _AbstractAxisTick, TickInfo = _GenericTickInfo> {
    }
    /**
     * @public
     * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
     */
    declare interface _GenericTickInfo {
    }
    /**
     * @public
     * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
     */
    declare interface _GenericTickPlottingVariables {
    }
    /**
     * @public
     */
    export declare interface GettableText {
        /**
         * Get the text of the entire shape.
         * @returns The entire text string.
         * @public
         */
        getText(): string;
    }
    /**
     * Type definition of an Glow Effect Configuration_.
     *
     * A theme can specify an Effect to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     * @public
     */
    export declare class GlowEffect extends GlowEffectRecord implements StylePropFuncs<ThisType<GlowEffect>, Omit<GlowEffectProperties, 'type'>> {
        /**
         * Constructor for a `GlowEffect` object.
         *
         * All parameters are optional, and when omitted fallback to default values.
         *
         * ```ts
         *  // Example, define an GlowEffect object
         *  const glowEffect = new GlowEffect({
         *      color: ColorRGBA(100, 0, 0, 150),
         *      blur: 5,
         *  })
         * ```
         *
         * For details of the available properties, see {@link GlowEffectProperties}
         *
         * @public
         */
        constructor(props?: Partial<GlowEffectProperties>);
        /**
         * Construct a new GlowEffect object based on this one, but with modified spread distance.
         *
         * ```ts
         *  // Example
         *  const glow2 = glow1.setSpread(10)
         * ```
         * @param spread - Spread distance as pixels. Max value is `10`.
         * @returns New GlowEffect object
         * @public
         */
        setSpread(spread: number | ImmutableMutator<number>): this;
        /**
         * Get Glow spread distance as pixels.
         * @returns     Spread distance as pixels.
         * @public
         */
        getSpread(): number;
        /**
         * Construct a new GlowEffect object based on this one, but with modified blur distance.
         *
         * ```ts
         *  // Example
         *  const glow2 = glow1.setBlur(10)
         * ```
         * @param blur - Blur distance as pixels. Max value is `10`.
         * @returns New GlowEffect object
         * @public
         */
        setBlur(blur: number | ImmutableMutator<number>): this;
        /**
         * Get Glow blur distance as pixels.
         * @returns     Blur distance as pixels.
         * @public
         */
        getBlur(): number;
        /**
         * Construct a new GlowEffect object based on this one, but with modified color.
         *
         * ```ts
         *  // Example
         *  const glow2 = glow1.setColor(ColorRGBA(255, 0, 0, 100))
         * ```
         * @param value - Either a Color object or a function, which will be used to create a new Color based on current value.
         * @returns New GlowEffect object
         * @public
         */
        setColor(color: Color | ImmutableMutator<Color>): this;
        /**
         * Get Glow color.
         * @returns     Color.
         * @public
         */
        getColor(): Color;
        /**
         * Construct a new GlowEffect object based on this one, but with modified offset distance.
         *
         * ```ts
         *  // Example
         *  const glow2 = glow1.setOffset({ x: 10, y: -10 })
         * ```
         * @param offset - Offset distance as pixels.
         * @returns New GlowEffect object
         * @public
         */
        setOffset(offset: Point | ImmutableMutator<Point>): this;
        /**
         * Get Glow offset distance as pixels.
         * @returns     Offset distance as pixels.
         * @public
         */
        getOffset(): Point;
    }
    /**
     * Interface of all properties of [[GlowEffect]].
     * @public
     */
    export declare interface GlowEffectProperties {
        type: 'glow';
        /**
         * Spread distance as pixels.
         *
         * Max value `10`.
         * @public
         */
        spread: number;
        /**
         * Blur distance as pixels.
         *
         * Max value `10`.
         * @public
         */
        blur: number;
        /**
         * Glow color.
         *
         * Assign using {@link ColorRGBA} or any other color factory.
         * Glow intensity can be controlled with color alpha channel.
         *
         * ```ts
         *  // Example, red glow color.
         *  color: ColorRGBA(255, 0, 0, 255)
         * ```
         * @public
         */
        color: Color;
        /**
         * Offset as pixels.
         * @public
         */
        offset: Point;
    }
    /**
     * Constructor for a Record of GlowEffect.
     * @public
     */
    declare const GlowEffectRecord: Record_2.Factory<GlowEffectProperties>;
    /**
     * Common functions for any gradient implementation.
     * @public
     */
    export declare interface Gradient {
        /**
         * Set color stops for the gradient.
         *
         * All style object setter methods return a new object rather than modifying the current one.
         * @param stops - Color Stops
         */
        setColorStops(stops: ColorStop[]): void;
        /**
         * Get current color stops from the gradient.
         */
        getColorStops(): ColorStop[];
    }
    /**
     * Gradient extents
     * @public
     */
    export declare enum GradientExtent {
        closestSide = "closest-side",
        closestCorner = "closest-corner",
        farthestSide = "farthest-side",
        farthestCorner = "farthest-corner"
    }
    /**
     * Gradient Shapes
     * @public
     */
    export declare enum GradientShape {
        circle = "circle",
        ellipse = "ellipse"
    }
    /**
     * Abstract Series class for visualizing a *Heatmap Grid* with static columns and rows count.
     *
     * Implementations:
     * - {@link HeatmapGridSeriesIntensityValues}
     * @public
     */
    export declare abstract class HeatmapGridSeries extends SeriesXY<LinearScaleXY, SolveResultHeatmap> implements ContourLines {
        solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultHeatmap | undefined;
        /**
         * Set start coordinate of Heatmap on its X and Y axis.
         * @param   start - Coordinate on axis where 1st heatmap sample will be positioned.
         * @returns     Object itself.
         * @public
         */
        setStart(start: Point | undefined): this;
        /**
         * Get start coordinate of Heatmap on its X and Y axis.
         * @returns     Coordinate on axis where 1st heatmap sample will be positioned.
         * @public
         */
        getStart(): Point;
        /**
         * Set Step between each consecutive heatmap value on the X and Y Axes.
         *
         * X = columns,
         * Y = rows
         *
         * @param   step - Axis offset between heatmap samples.
         * @returns     Object itself.
         * @public
         */
        setStep(step: Point | undefined): this;
        /**
         * Get Step between each consecutive heatmap value on the X and Y Axes.
         * @returns     Axis offset between heatmap samples.
         * @public
         */
        getStep(): Point;
        /**
         * Set end coordinate of Heatmap on its X and Y axis.
         * @param   end - Coordinate on axis where last heatmap sample will be positioned.
         * @returns     Object itself.
         * @public
         */
        setEnd(end: Point | undefined): this;
        /**
         * Get end coordinate of Heatmap on its X and Y axis.
         * @returns     Coordinate on axis where last heatmap sample will be positioned.
         * @public
         */
        getEnd(): Point;
        /**
         * Set contour lines.
         *
         * ```ts
         *  // Example syntax
         *  heatmap.setContours({
         *      levels: [
         *          { value: 10 },
         *          {
         *              value: 40,
         *              label: 'Hey',
         *              labelFont: { family: 'Courier' },
         *              labelColor: ColorRGBA(255, 0, 0),
         *              strokeStyle: new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(0, 0, 0) }) })
         *          }
         *      ]
         *  })
         * ```
         * @param   config - Contour config
         * @returns Object itself.
         * @public
         */
        setContours(config: ContourConfiguration | undefined): this;
        /**
         * Get contour lines configuration.
         * @returns Contour config
         * @public
         */
        getContours(): ContourConfiguration | undefined;
    }
    /**
     * Series for visualizing a *Intensity Heatmap Grid* with a static column and grid count. Has API for fast modification of cell values.
     *
     * `HeatmapGridSeriesIntensityValues` is optimized for *massive* amounts of data - here are some reference specs on average PC to give an idea:
     *
     * - Heatmap Chart with 1 million data points (`1000x1000`) is cold started in ~0.3 seconds.
     * - Heatmap Chart with 1 million data points (`1000x1000`) is re-populated (change data set) in ~0.050 seconds.
     * - Heatmap Chart with 16 million data points (`4000x4000`) is cold started in ~2.0 seconds.
     * - Heatmap Chart with 16 million data points (`4000x4000`) is re-populated (change data set) in ~0.5 seconds.
     *
     * `HeatmapGridSeriesIntensityValues` max data amount is entirely restricted by the client hardware RAM and more specifically amount of RAM usable by the context running LightningChart JS.
     * If by increasing the amount of `columns` and `rows` you encounter suddenly weak performance, it is likely that there is not enough RAM memory available.
     *
     * Created with {@link ChartXY.addHeatmapGridSeries}.
     *
     * Frequently used API:
     * - Set intensity data {@link invalidateIntensityValues}
     * - Set fill style {@link setFillStyle}
     * - Set wireframe style {@link setWireframeStyle}
     * - Set intensity interpolation {@link setIntensityInterpolation}
     * - Format auto cursor {@link setCursorResultTableFormatter}
     * @public
     */
    export declare class HeatmapGridSeriesIntensityValues extends HeatmapGridSeries {
        /**
         * Invalidate range of heatmap intensity values starting from first column and row, updating coloring if a Color look up table ({@link LUT}) has been attached to the series (see {@link HeatmapGridSeriesIntensityValues.setFillStyle}).
         *
         * ```js
         *  // Example, 3x3 grid full invalidation.
         *  const heatmapGridSeries = ChartXY.addHeatmapGridSeries({
         *      dataOrder: 'columns',
         *      columns: 3,
         *      rows: 3
         *  })
         *
         *  heatmapGridSeries.invalidateIntensityValues([
         *      // Column 1 intensity values.
         *      [0, 0, 0],
         *      // Column 2 intensity values.
         *      [1, 1, 1],
         *      // Column 3 intensity values.
         *      [0, 2, 0],
         *  ])
         * ```
         *
         * Data interpretation basis is defined by {@link HeatmapGridSeriesOptions.dataOrder} property from when the series was created.
         * Can be either list of *columns*, or list of *rows*.
         *
         * `invalidateIntensityValues` can trigger warnings when used controversially.
         * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
         *
         * @param value - Matrix containing intensity values for each data slot of the grid.
         * @returns Object itself for fluent interface.
         * @public
         */
        invalidateIntensityValues(value: number[][] | TypedArray[]): this;
        /**
         * Invalidate a partial range of heatmap intensity values, updating coloring if a Color look up table ({@link LUT}) has been attached to the series (see {@link HeatmapGridSeriesIntensityValues.setFillStyle}).
         *
         * ```js
         *  // Example, 100x10 grid invalidate partial section of grid.
         *
         *  const heatmapGridSeries = ChartXY.addHeatmapGridSeries({
         *      dataOrder: 'columns',
         *      columns: 100,
         *      rows: 10
         *  })
         *
         *  heatmapGridSeries.invalidateIntensityValues({
         *      // Index of first invalidated column.
         *      iColumn: 50,
         *      // Index of first invalidated row.
         *      iRow: 2,
         *      // Intensity values matrix. It's dimensions imply the amount of invalidated columns & rows.
         *      values: [
         *          // 1st invalidated column intensity values.
         *          [1, 1, 1, 1, 1],
         *          // 2nd invalidated column intensity values.
         *          [2, 2, 2, 2, 2],
         *          // 3rd invalidated column intensity values.
         *          [1, 0, 0, 0, 1],
         *          // 4th invalidated column intensity values.
         *          [0, 1, 0, 1, 0],
         *          // 5th invalidated column intensity values.
         *          [0, 0, 1, 0, 0],
         *      ],
         *  })
         * ```
         *
         * `invalidateIntensityValues` can trigger warnings when used controversially.
         * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
         *
         * @param value - Partial invalidation information, where `values` is an intensity value matrix, `iColumn` the first affected column and `iRow` the first affected row.
         * @returns Object itself for fluent interface.
         * @public
         */
        invalidateIntensityValues(value: {
            iColumn: number;
            iRow: number;
            values: number[][] | TypedArray[];
        }): this;
        /**
         * Invalidate a partial range of heatmap intensity values with flat data array input.
         *
         * ```js
         *  // Example, 100x10 grid invalidate partial section of grid.
         *
         *  const heatmapGridSeries = ChartXY.addHeatmapGridSeries({
         *      dataOrder: 'columns',
         *      columns: 100,
         *      rows: 10
         *  })
         *
         *  heatmapGridSeries.invalidateIntensityValues({
         *      // Index of first invalidated column.
         *      iColumn: 50,
         *      // Index of first invalidated row.
         *      iRow: 2,
         *      columns: 2,
         *      rows: 5,
         *      values: new Float32Array([
         *          // 1st column
         *          0, 1, 2, 3, 4,
         *          // 2nd column
         *          5, 6, 7, 8, 9,
         *      ]),
         *  })
         * ```
         *
         * `invalidateIntensityValues` can trigger warnings when used controversially.
         * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
         *
         * @param value - Partial invalidation information, where `values` is an intensity value matrix, `iColumn` the first affected column and `iRow` the first affected row.
         * @returns Object itself for fluent interface.
         * @public
         * @public
         */
        invalidateIntensityValues(value: {
            iColumn: number;
            iRow: number;
            columns: number;
            rows: number;
            values: TypedArray | number[];
        }): this;
        /**
         * Invalidate the entire heatmap intensity values by supplying a single flat number array.
         * Interpretation order depends on `dataOrder` parameter configured when creating the series.
         *
         * `dataOrder === 'columns'`: `[x0_y0, x0_y1, x0_y2, x0_yn, x1_y0, x1_y1, x1_y2, x1_yn, ...]`
         *
         * `dataOrder === 'rows'`: `[x0_y0, x1_y0, x2_y0, xn_y0, x0_y1, x1_y1, x2_y1, xn_y1, ...]`
         *
         * Flat data input can situationally be significantly more efficient than number[][] based input:
         *
         * - Oftentimes, you already have the input data in a flat format. Mapping that to number matrix format can be a very expensive operation, which can be avoided by using this method override.
         * - Processing input as flat array can be ~40% faster than number matrix input. However, this depends on the structure of the heatmap (column and row amounts).
         *
         * If your heatmap is very large in one dimension and considerably smaller in the other dimension AND your input data is flat, then you can enable some case specific optimizations by overriding heatmap tiling safety values.
         * For example:
         *
         * ```ts
         *  const columns = 16500
         *  const rows = 250
         *  const heatmap = chart.addHeatmapGridSeries({
         *      columns, rows,
         *      // This can allow the heatmap to store data internally in a single tile, which significantly increases efficiency when data is supplied as a single flat array.
         *      maxTileSize: Math.max(columns, rows)
         *  })
         * ```
         *
         * While the method definition accepts any `TypedArray` (i.e. `Float64Array`, `Uint16Array` etc.), internally the value is always mapped to a `Float32Array`.
         * For this reason, `Float32Array` is the most performant input type.
         *
         * @param   value -     Flat number array.
         * @returns             Object itself
         * @public
         */
        invalidateIntensityValues(value: TypedArray | number[]): this;
        /**
         * Set fill style of heatmap series.
         *
         * **Supported fill styles:**
         *
         * {@link PalettedFill}:
         *
         * Colors heatmap fill by looking color up from {@link LUT} based on heatmap *intensity values*.
         *
         * ```js
         *  // Example, color look up by intensity values.
         *  heatmapSeries.setFillStyle(
         *      new PalettedFill({
         *          lut: new LUT({
         *              steps: [
         *                  { value: 0, color: ColorCSS('red') },
         *                  { value: 20, color: ColorCSS('blue') },
         *              ],
         *              interpolate: true,
         *          }),
         *      }),
         *  )
         * ```
         *
         * Assign *intensity values* with {@link invalidateIntensityValues}.
         *
         * Note, Heatmap doesn't currently support {@link LUT.color} (fallback color).
         *
         * {@link SolidFill}:
         *
         * Solid color for all heatmap cells. Supported for debugging purposes mainly.
         *
         * {@link emptyFill}:
         *
         * Disables heatmap fill.
         *
         * ```js
         *  // Example, hide heatmap fill and show wireframe.
         *  heatmapSeries
         *      .setFillStyle(emptyFill)
         *      .setWireframeStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         * ```
         *
         * @param value - FillStyle object or function which modifies current value.
         * @returns Object itself for fluent interface.
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of series.
         * @returns FillStyle.
         * @public
         */
        getFillStyle(): FillStyle;
        /**
         * Set heatmap intensity interpolation mode.
         *
         * `'disabled'` or `undefined`: Interpolation disabled; draw data exactly as it is.
         *
         * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
         *
         * @param interpolationMode - Heatmap intensity interpolation mode selection.
         * @returns Object itself for fluent interface.
         * @public
         */
        setIntensityInterpolation(interpolationMode: IntensityInterpolationMode | undefined): this;
        /**
         * Get heatmap intensity interpolation mode.
         * @returns Heatmap intensity interpolation mode selection.
         * @public
         */
        getIntensityInterpolation(): IntensityInterpolationMode;
        /**
         * Set heatmap aggregation behavior.
         * By default, heatmaps display the closest heatmap cell value to each pixel that is rendered on the screen.
         * With dense, high resolution heatmaps, this can mean that there is no guarantee which data value is displayed in a pixel.
         *
         * Heatmap aggregation can be enabled to specify this behavior (which value to show when multiple cell values are contained by single pixel)
         * at the expense of a performance hit.
         *
         * ```ts
         *  // Example usage
         *  heatmap
         *      // Ensure bilinear interpolation is disabled
         *      .setIntensityInterpolation('disabled')
         *      .setAggregation('max')
         * ```
         *
         * Doesn't work together with bilinear interpolation.
         * @param   aggregationMode -   Heatmap aggregation mode
         * @returns     Object itself
         * @public
         */
        setAggregation(aggregationMode: IntensityAggregationMode): this;
        /**
         * Get heatmap aggregation config.
         * @returns     Aggregation mode
         * @public
         */
        getAggregation(): IntensityAggregationMode;
        /**
         * Clear all previous data pushed to the series.
         * @returns Object itself for fluent interface.
         * @public
         */
        clear(): this;
        /**
         * Set style of wireframe.
         *
         * ```js
         *  // Example, disable wireframe.
         *  heatmapSeries.setWireframeStyle(emptyLine)
         * ```
         *
         * ```js
         *  // Example, set wireframe style.
         *  heatmapSeries.setWireframeStyle(new SolidLine({
         *      thickness: 1,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0, 255) })
         *  }))
         * ```
         *
         * **Note that wireframe is not supported on high precision axis!**
         *
         * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
         * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
         * @returns Series itself for fluent interface.
         * @public
         */
        setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of wireframe.
         *
         * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
         * @returns LineStyle.
         * @public
         */
        getWireframeStyle(): LineStyle;
        addEventListener<K extends keyof HeatmapGridSeriesIntensityValuesEventMap>(type: K, listener: (event: HeatmapGridSeriesIntensityValuesEventMap[K], info: SolveResultHeatmap) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof HeatmapGridSeriesIntensityValuesEventMap>(type: K, listener: (event: HeatmapGridSeriesIntensityValuesEventMap[K], info: SolveResultHeatmap) => unknown): void;
    }
    /**
     * Interface of events trackable by {@link HeatmapGridSeriesIntensityValues.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface HeatmapGridSeriesIntensityValuesEventMap extends ChartComponentEventMap {
    }
    /**
     * Interface describing readonly configurations of a {@link HeatmapGridSeries}.
     *
     * **Required properties:**
     * - {@link columns}
     * - {@link rows}
     *
     * **Optional properties:**
     * - {@link start}
     * - {@link step}
     * - {@link dataOrder}
     * - {@link heatmapDataType}
     * @public
     */
    export declare interface HeatmapGridSeriesOptions<DataType extends 'intensity' = 'intensity'> extends SeriesOptionsXY {
        /**
         * Specify how to interpret grid matrix values supplied by user.
         *
         * `'columns'` -\> Supply lists of "columns"
         *
         * ```typescript
         *  const intensityValues = [
         *      [
         *          0, // Intensity value column = 0, row = 0
         *          0, // Intensity value column = 0, row = 1
         *          0, // Intensity value column = 0, row = n
         *      ],
         *      [
         *          0, // Intensity value column = 1, row = 0
         *          0, // Intensity value column = 1, row = 1
         *          0, // Intensity value column = 1, row = n
         *      ],
         *  ]
         * ```
         *
         * `'rows'` -\> Supply lists of "rows"
         *
         * ```typescript
         *  const intensityValues = [
         *      [
         *          0, // Intensity value row = 0, column = 0
         *          0, // Intensity value row = 0, column = 1
         *          0, // Intensity value row = 0, column = n
         *      ],
         *      [
         *          0, // Intensity value row = 1, column = 0
         *          0, // Intensity value row = 1, column = 1
         *          0, // Intensity value row = 1, column = n
         *      ],
         *  ]
         * ```
         *
         * Defaults to `'columns'`.
         */
        dataOrder?: 'columns' | 'rows';
        /**
         * Selection of format in which heatmap values are supplied.
         *
         * `'intensity'` | numeric value that can be colored with an associated color look up table.
         *
         * Defaults to `'intensity'.`
         */
        heatmapDataType?: DataType;
        /**
         * Amount of *columns* (values on X Axis).
         */
        columns: number;
        /**
         * Amount of *rows* (values on Y Axis).
         */
        rows: number;
        /**
         * Defaults to 2048.
         * Can be overridden for case specific optimizations, where your heatmap is larger than 2048 in one dimension and you are providing all the heatmap data as single TypedArray.
         */
        maxTileSize?: number;
    }
    /**
     * Abstract Series class for visualizing a *Heatmap Grid*, with API for pushing data in a scrolling manner (append new data on top of existing data).
     *
     * Implementations:
     * - {@link HeatmapScrollingGridSeriesIntensityValues}
     * @public
     */
    export declare abstract class HeatmapScrollingGridSeries extends SeriesXY<LinearScaleXY, SolveResultHeatmap> implements SeriesWithDataCleaning {
        solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultHeatmap | undefined;
        /**
         * Set start coordinate of Heatmap on its X and Y axis.
         * @param   start - Coordinate on axis where 1st heatmap sample will be positioned.
         * @returns     Object itself.
         * @public
         */
        setStart(start: Point | undefined): this;
        /**
         * Get start coordinate of Heatmap on its X and Y axis.
         * @returns     Coordinate on axis where 1st heatmap sample will be positioned.
         * @public
         */
        getStart(): Point;
        /**
         * Set Step between each consecutive heatmap value on the X and Y Axes.
         *
         * X = columns,
         * Y = rows
         *
         * @param   step - Axis offset between heatmap samples.
         * @returns     Object itself.
         * @public
         */
        setStep(step: Point | undefined): this;
        /**
         * Get Step between each consecutive heatmap value on the X and Y Axes.
         * @returns     Axis offset between heatmap samples.
         * @public
         */
        getStep(): Point;
        /**
         * Clear all previous data pushed to the series.
         * @returns Object itself for fluent interface.
         * @public
         */
        clear(): this;
        /**
         * Set heatmap aggregation behavior.
         * By default, heatmaps display the closest heatmap cell value to each pixel that is rendered on the screen.
         * With dense, high resolution heatmaps, this can mean that there is no guarantee which data value is displayed in a pixel.
         *
         * Heatmap aggregation can be enabled to specify this behavior (which value to show when multiple cell values are contained by single pixel)
         * at the expense of a performance hit.
         *
         * ```ts
         *  // Example usage
         *  heatmap
         *      // Ensure bilinear interpolation is disabled
         *      .setIntensityInterpolation('disabled')
         *      .setAggregation('max')
         * ```
         *
         * Doesn't work together with bilinear interpolation.
         * @param   aggregationMode -   Heatmap aggregation mode
         * @returns     Object itself
         * @public
         */
        setAggregation(aggregationMode: IntensityAggregationMode): this;
        /**
         * Get heatmap aggregation config.
         * @returns     Aggregation mode
         * @public
         */
        getAggregation(): IntensityAggregationMode;
        /**
         * Set style of wireframe.
         *
         * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
         *
         * ```js
         *  // Example, disable wireframe.
         *  heatmapSeries.setWireframeStyle(emptyLine)
         * ```
         *
         * ```js
         *  // Example, set wireframe style.
         *  heatmapSeries.setWireframeStyle(new SolidLine({
         *      thickness: 1,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0, 255) })
         *  }))
         * ```
         *
         * **Note that wireframe is not supported on high precision axis!**
         *
         * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
         * @returns Series itself for fluent interface.
         * @public
         */
        setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of wireframe.
         *
         * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
         * @returns LineStyle.
         * @public
         */
        getWireframeStyle(): LineStyle;
        /**
         * Set heatmap intensity interpolation mode.
         *
         * `'disabled'` or `undefined`: Interpolation disabled; all pixels within a grid cell share the same color.
         *
         * `'bilinear'`: Each pixel is colored individually by *bilinear interpolation*.
         * @param interpolationMode - Heatmap fill pixel interpolation mode selection.
         * @returns Object itself for fluent interface.
         * @public
         */
        setIntensityInterpolation(interpolationMode: IntensityInterpolationMode | undefined): this;
        /**
         * Get heatmap intensity interpolation mode.
         * @returns Heatmap fill pixel interpolation mode selection.
         * @public
         */
        getIntensityInterpolation(): IntensityInterpolationMode;
        /**
         * Set heatmap fill pixel interpolation mode.
         *
         * `'disabled'` or `undefined`: Interpolation disabled; all pixels within a grid cell share the same color.
         *
         * `'bilinear'`: Each pixel is colored individually by *bilinear interpolation*.
         * @param interpolationMode - Heatmap fill pixel interpolation mode selection.
         * @returns Object itself for fluent interface.
         * @public
         * @deprecated  Deprecated in favour of `setIntensityInterpolation`
         */
        setPixelInterpolationMode(interpolationMode: IntensityInterpolationMode | undefined): this;
        /**
         * Get heatmap fill pixel interpolation mode.
         * @returns Heatmap fill pixel interpolation mode selection.
         * @public
         * @deprecated  Deprecated in favour of `getIntensityInterpolation`
         */
        getPixelInterpolationMode(): IntensityInterpolationMode;
        /**
         * Disable automatic data cleaning.
         *
         * ```js
         *  // Example syntax, disable data cleaning.
         *  series.setDataCleaning(undefined)
         * ```
         *
         * @param arg - Data cleaning configuration.
         * @returns Object itself for fluent interface.
         * @public
         */
        setDataCleaning(arg: undefined): this;
        /**
         * Enable automatic data cleaning by `minDataPointCount` configuration.
         *
         * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
         *
         * ```js
         *  // Example syntax for specifying minDataPointCount
         *  series.setDataCleaning({ minDataPointCount: 10000 })
         * ```
         *
         * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
         * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
         *
         * ```js
         *  // Example, enable lazy data cleaning of out of view data.
         *  series.setDataCleaning({ minDataPointCount: 1 })
         * ```
         *
         * @param arg - Data cleaning configuration.
         * @returns Object itself for fluent interface.
         * @public
         */
        setDataCleaning(arg: {
            minDataPointCount: number | undefined;
        }): this;
        /**
         * Enable automatic data cleaning by `maxDataPointCount` configuration.
         *
         *Specifying `maxDataPointCount` results in data cleaning always happening **exactly** when total data amount exceeds the supplied threshold.
         *
         * ```js
         *  // Example syntax for specifying maxDataPointCount
         *  series.setDataCleaning({ maxDataPointCount: 10000 })
         * ```
         *
         * `maxDataPointCount` is usually used in memory limited applications to prevent running out of memory.
         *
         * **`maxDataPointCount` is currently only supported by only select series:**
         * - {@link HeatmapScrollingGridSeries}.
         * - {@link OHLCSeries}.
         *
         * If the feature receives good support and usage from the user base, it might be expanded to all series types in a future release.
         *
         * @param arg - Data cleaning configuration.
         * @returns Object itself for fluent interface.
         * @public
         */
        setDataCleaning(arg: {
            maxDataPointCount: number | undefined;
        }): this;
        _getLegendStyle(): {
            fill: FillStyle;
        };
    }
    /**
     * Series class for visualizing a *Heatmap Grid*, with API for pushing data in a scrolling manner (append new data on top of existing data).
     *
     * `HeatmapScrollingGridSeriesIntensityValues` is optimized for *massive* amounts of data - here are some reference specs on average PC to give an idea:
     *
     * - Scrolling Heatmap Chart with 2 million incoming data points **per second** (`rows: 2048`, 1000 columns/s) runs consistently and smoothly with 60 FPS and no stuttering. CPU usage stays easily below 40%.
     * - Scrolling Heatmap Chart with 8 million incoming data points **per second** (`rows: 4096`, 2000 columns/s) runs consistently and smoothly with 60 FPS and minor stuttering.
     *
     * `HeatmapScrollingGridSeriesIntensityValues` max data amount is entirely restricted by the client hardware RAM and more specifically amount of RAM usable by the context running LightningChart JS.
     * If performance suddenly plummets at some approximate data threshold, then it is likely that there is not enough RAM available.
     * Use data cleaning configuration and suitable Axis intervals to adjust to your hardware limitations.
     *
     * Each cell of the heatmap grid is associated with a *numeric intensity value*, which can be used in conjuction with a Color look up table ({@link LUT}).
     *
     * Created with {@link ChartXY.addHeatmapScrollingGridSeries}.
     *
     * Frequently used API:
     * - Add intensity data {@link addIntensityValues}
     * - Set fill style {@link setFillStyle}
     * - Set wireframe style {@link setWireframeStyle}
     * - Format auto cursor {@link setCursorResultTableFormatter}
     * - Configure automatic data cleaning {@link setDataCleaning}
     * @public
     */
    export declare class HeatmapScrollingGridSeriesIntensityValues extends HeatmapScrollingGridSeries {
        /**
         * Push a Matrix of *intensity values* into the Heatmap grid.
         * Each value describes one cell in the grid.
         *
         * Order of data is selected when creating the series;
         *
         * `scrollDimension: 'columns'` -\>
         *
         * ```typescript
         *  [
         *      [
         *          0, // Intensity value column = 0, row = 0
         *          0, // Intensity value column = 0, row = 1
         *          0, // Intensity value column = 0, row = n
         *      ],
         *      [
         *          0, // Intensity value column = 1, row = 0
         *          0, // Intensity value column = 1, row = 1
         *          0, // Intensity value column = 1, row = n
         *      ],
         *  ]
         * ```
         *
         * `scrollDimension: 'rows'` -\>
         *
         * ```typescript
         *  [
         *      [
         *          0, // Intensity value row = 0, column = 0
         *          0, // Intensity value row = 0, column = 1
         *          0, // Intensity value row = 0, column = n
         *      ],
         *      [
         *          0, // Intensity value row = 1, column = 0
         *          0, // Intensity value row = 1, column = 1
         *          0, // Intensity value row = 1, column = n
         *      ],
         *  ]
         * ```
         *
         * Example usage:
         *
         * ```typescript
         *  // Create x-scrolling intensity heatmap.
         *  const series = ChartXY.addHeatmapScrollingGridSeries({
         *      heatmapDataType: 'intensity',
         *      scrollDimension: 'columns',
         *      resolution: 5,
         *  })
         *
         *  // Push a column into heatmap.
         *  series.addIntensityValues([
         *      [0, 10, 0, 20, 0]
         *  ])
         * ```
         *
         * `invalidateIntensityValues` can trigger warnings when used controversially.
         * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
         *
         * @param intensityValues - Matrix of *intensity values* - Each array represents a column or row, and each number represents a cell in the grid.
         * @returns Object itself for fluent interface.
         * @public
         */
        addIntensityValues(intensityValues: number[][] | TypedArray[]): this;
        /**
         * Invalidate existing and/or add new intensity values in the Heatmap grid.
         * The location along scrolling dimension is identified by a **sample index**.
         *
         * Sample index `0` would reference the first sample in the heatmap, whereas `1` the second sample.
         * This allows, for example, the modification of previously pushed heatmap samples.
         *
         * This method is also capable of adding new samples into the heatmap, which happens if the sample index exceeds the currently existing sample count
         * (this can be received with {@link getSampleCount} method).
         *
         * If this method is used to push new samples into the heatmap in a manner where **gaps** form between the new samples and previous ones,
         * the gaps are automatically filled by duplicating the previous last heatmap sample!
         *
         * ```ts
         *  // Example, modify last sample pushed to heatmap
         *  heatmapSeries.invalidateIntensityValues({
         *      iSample: heatmapSeries.getSampleCount() - 1,
         *      values: [[0, 0, 0, 0, 0]]
         *  })
         * ```
         *
         * ```ts
         *  // Example, update 5 samples starting at sample index 2
         *  heatmapSeries.invalidateIntensityValues({
         *      iSample: 2,
         *      values: [
         *          [0, 0, 0],
         *          [0, 0, 0],
         *          [0, 0, 0],
         *          [0, 0, 0],
         *          [0, 0, 0],
         *      ]
         *  })
         * ```
         * @param   arg - Object with sample index and intensity values parameters.
         * @returns     Object itself.
         * @public
         */
        invalidateIntensityValues(arg: {
            iSample: number;
            values: number[][] | TypedArray[];
        }): this;
        /**
         * Get number of samples that have been pushed into the scrolling heatmap series.
         * For empty heatmap this will be `0`.
         * @returns     Number of samples in the heatmap.
         * @public
         */
        getSampleCount(): number;
        /**
         * Set fill style of heatmap series.
         *
         * **Supported fill styles:**
         *
         * `PalettedFill`:
         *
         * Colors heatmap fill by looking color up from {@link LUT} based on heatmap *intensity values*.
         *
         * ```js
         *  // Example, color look up by intensity values.
         *  heatmapSeries.setFillStyle(
         *      new PalettedFill({
         *          lut: new LUT({
         *              steps: [
         *                  { value: 0, color: ColorCSS('red') },
         *                  { value: 20, color: ColorCSS('blue') },
         *              ],
         *              interpolate: true,
         *          }),
         *      }),
         *  )
         * ```
         *
         * Intensity values are defined when data is pushed in with {@link addIntensityValues} method.
         *
         * Note, Heatmap doesn't currently support {@link LUT.color} (fallback color).
         *
         * - `SolidFill`:
         *
         * Solid color for all heatmap cells. Supported for debugging purposes mainly.
         *
         * `emptyFill`:
         *
         * Disables heatmap fill.
         *
         * ```js
         *  // Example, hide heatmap fill and show wireframe.
         *  heatmapSeries
         *      .setFillStyle(emptyFill)
         *      .setWireframeStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         * ```
         *
         * @param value - FillStyle object or function which modifies current value.
         * @returns Object itself for fluent interface.
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of series.
         * @returns FillStyle.
         * @public
         */
        getFillStyle(): FillStyle;
        addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultHeatmap) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultHeatmap) => unknown): void;
    }
    /**
     * Interface describing readonly configurations of a {@link HeatmapScrollingGridSeries}.
     *
     * **Required properties:**
     * - {@link resolution}
     *
     * **Optional properies:**
     * - {@link start}
     * - {@link step}
     * - {@link scrollDimension}
     * - {@link heatmapDataType}
     * @public
     */
    export declare interface HeatmapScrollingGridSeriesOptions<DataType extends 'intensity' = 'intensity'> extends SeriesOptionsXY {
        /**
         * Select scrolling dimension, as well as how to interpret grid matrix values supplied by user.
         *
         * If `columns` is selected, then there will be no limit on how many *columns* can be pushed to the series, but *rows* amount will be static.
         *
         * If `rows` is selected, then there will be no limit on how many *rows* can be pushed to the series, but *columns* amount will be static.
         *
         * Data order:
         *
         * `'columns'` -\> Supply lists of "columns"
         *
         * ```typescript
         *  const intensityValues = [
         *      [
         *          0, // Intensity value column = 0, row = 0
         *          0, // Intensity value column = 0, row = 1
         *          0, // Intensity value column = 0, row = n
         *      ],
         *      [
         *          0, // Intensity value column = 1, row = 0
         *          0, // Intensity value column = 1, row = 1
         *          0, // Intensity value column = 1, row = n
         *      ],
         *  ]
         * ```
         *
         * `'rows'` -\> Supply lists of "rows"
         *
         * ```typescript
         *  const intensityValues = [
         *      [
         *          0, // Intensity value row = 0, column = 0
         *          0, // Intensity value row = 0, column = 1
         *          0, // Intensity value row = 0, column = n
         *      ],
         *      [
         *          0, // Intensity value row = 1, column = 0
         *          0, // Intensity value row = 1, column = 1
         *          0, // Intensity value row = 1, column = n
         *      ],
         *  ]
         * ```
         *
         * Defaults to `'columns'`.
         */
        scrollDimension?: 'columns' | 'rows';
        /**
         * Static amount of *columns* (cells on X Axis) OR *rows* (cells on Y Axis).
         *
         * This depends on value of `scrollDimension`:
         *
         * `scrollDimension: 'columns'` -\> amount of rows.
         *
         * `scrollDimension: 'rows'` -\> amount of columns.
         */
        resolution: number;
        /**
         * Selection of format in which heatmap values are supplied.
         *
         * `'intensity'` | numeric value that can be colored with an associated color look up table.
         *
         * Defaults to `'intensity'.`
         */
        heatmapDataType?: DataType;
    }
    /**
     * Component which visibility can be controlled.
     *
     * Resources for hidden elements are not released.
     * Use `dispose` if complete removal of element is preferred over simply hiding it from view
     * @public
     */
    export declare interface Hideable {
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @public
         */
        setVisible: (state: boolean) => this;
        /**
         * Get element visibility.
         *
         * @returns `true` when element is set to be visible and `false` otherwise.
         * @public
         */
        getVisible: () => boolean;
    }
    /**
     * @public
     */
    export declare interface HideableEventMap {
        visiblechange: VisibleChangedEvent;
    }
    /**
     * Component which has events for visibility state changes
     * @public
     */
    export declare interface HideableEvents extends EventInterface<HideableEventMap> {
    }
    /**
     * Interface for an object that can be highlighted.
     * @public
     */
    export declare interface Highlightable extends EventInterface<HighlightableEventMap> {
        /**
         * Set state of component highlighting.
         *
         * ```ts
         *  // Example usage
         *
         *  component.setHighlight(true)
         * ```
         *
         * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
         * @returns Object itself
         * @public
         */
        setHighlight(highlight: boolean | number): this;
        /**
         * Get state of component highlighting.
         *
         * @returns Number between 0 and 1, where 1 is fully highlighted.
         * @public
         */
        getHighlight(): number;
    }
    /**
     * Interface of events trackable by {@link Highlightable.addEventListener} and the respective Event types.
     * @public
     */
    export declare interface HighlightableEventMap {
        highlightchange: HighlightChangeEvent;
    }
    /**
     * @public
     */
    export declare interface HighlightChangeEvent {
        highlight: number;
    }
    /**
     * Abstract base class for Axis Highlighters.
     *
     * These components are placed along a single Axis to highlight some area of data.
     * @public
     */
    export declare abstract class Highlighter extends ChartComponent implements ClippableXY {
        /**
         * @public
         */
        readonly axis: Axis;
        /**
         * Configure whether series rendering should be clipped to the area enclosed by its owning axes or not.
         * All series rendering is ALWAYS clipped so that it doesn't leak outside the owning charts series area.
         * However, it is optional whether the series rendering should be able to leak outside the series owning axes viewport, which might be smaller than the charts viewport (for example, when using stacked axes).
         *
         * By default, clipping is enabled (`true`).
         *
         * ```ts
         *  // Example, disable clipping, allowing the series rendering to leak outside its own axes.
         *  SeriesXY.setClipping(false)
         * ```
         *
         * @param clipping - Clipping enabled or disabled.
         * @returns     Object itself
         * @public
         */
        setClipping(clipping: boolean): this;
        /**
         * Read whether series rendering should be clipped to the area enclosed by its owning axes or not.
         * All series rendering is ALWAYS clipped so that it doesn't leak outside the owning charts series area.
         * However, it is optional whether the series rendering should be able to leak outside the series owning axes viewport, which might be smaller than the charts viewport (for example, when using stacked axes).
         *
         * By default, clipping is enabled (`true`).
         * @returns     True or false.
         * @public
         */
        getClipping(): boolean;
    }
    /**
     * Selections describing behavior of user-interaction-triggered highlighting.
     *
     * Generally simpler syntax like `component.setHighlightOnHover(false)` or `true` is preferred.
     * Mainly needed for explicitly enabling `onHoverIndividual` mode for figure series.
     * @public
     */
    export declare enum HighlightModes {
        /**
         * Highlighting is not affected by user-interactions.
         */
        noHighlighting = 0,
        /**
         * When any part of a *Series* is interacted with, the whole *Series* is highlighted.
         */
        onHover = 1,
        /**
         * Used for figure series, only specific interacted figure is highlighted.
         */
        onHoverIndividual = 2
    }
    /**
     * Built-in alternative to WebGL text rendering.
     * Renders each LCJS text element by creating DOM elements and letting browser render them.
     *
     * For more information, see {@link EngineOptions.textRenderer}
     * @public
     * @beta    Introduced in v7.1.0. API may be changed according to user feedback and reports.
     */
    export declare const htmlTextRenderer: {
        init: (initInfo: Parameters<TextRendererFactory['init']>[0]) => TextRenderer;
    };
    /**
     * Class that describes an _Icon_, a relatively small graphic that can be used with different LightningChart JS components.
     *
     * Icons can be created by supplying a graphic source and optionally a desired size for the Icon.
     *
     * To learn more, see {@link PublicEngine.addCustomIcon}.
     *
     * @public
     */
    export declare class Icon extends IconRecord implements Disposable {
        /**
         * Inform the engine owning the Icon that it is no longer used.
         *
         * Afterwards, there is no guarantee that the Icon will work.
         *
         * It is recommended to dispose all user defined Icons that are no longer needed.
         * In the short term, there is no large significance in retaining Icons that may be temporarily unused.
         * Disposing Icons is recommended more for the long term effects, such as avoiding permanent memory leaks that may show only over long runtimes.
         *
         * ```ts
         *  // Example, inform engine that an Icon is no longer needed.
         *  icon.dispose()
         * ```
         *
         * @returns  The object itself.
         * @public
         */
        dispose(): this;
        /**
         * Construct a new Icon that is otherwise identical to this one, except with modified {@link Icon.width} value.
         *
         * To confirm, **this does not modify the Icon object at all, and returns a reference to a brand new Icon.**
         *
         * @param   width  - Icon width as pixels.
         * @returns          A new Icon object.
         * @public
         */
        setWidth(width: number | undefined): Icon;
        /**
         * Get value of {@link Icon.width} property.
         *
         * This is not equal to the actual visible width of the Icon!
         * There is currently no method for accessing that value.
         *
         * @returns          Icon width value.
         * @public
         */
        getWidth(): number | undefined;
        /**
         * Construct a new Icon that is otherwise identical to this one, except with modified {@link Icon.height} value.
         *
         * To confirm, **this does not modify the Icon object at all, and returns a reference to a brand new Icon.**
         *
         * @param   height - Icon height as pixels.
         * @returns          A new Icon object.
         * @public
         */
        setHeight(height: number | undefined): Icon;
        /**
         * Get value of {@link Icon.height} property.
         *
         * This is not equal to the actual visible height of the Icon!
         * There is currently no method for accessing that value.
         * @returns          Icon height value.
         * @public
         */
        getHeight(): number | undefined;
        /**
         * Construct a new Icon that is otherwise identical to this one, except with modified size.
         *
         * To confirm, **this does not modify the Icon object at all, and returns a reference to a brand new Icon.**
         *
         * @param   width  - Icon width as pixels.
         * @param   height - Icon height as pixels.
         * @returns          A new Icon object.
         * @public
         */
        setSize(width: number, height: number): Icon;
    }
    /**
     * Interface for all properties of an Icon.
     * @public
     */
    export declare interface IconProperties {
        type: 'icon';
        /**
         * Explicit width as pixels, or `undefined` to use source size.
         *
         * If only `width` is specified, then icon height is automatically scaled to maintain source aspect ratio.
         * @public
         */
        width: undefined | number;
        /**
         * Explicit height as pixels, or `undefined` to use source size.
         *
         * If only `height` is specified, then icon width is automatically scaled to maintain source aspect ratio.
         * @public
         */
        height: undefined | number;
    }
    /**
     * Record contractor for IconProperties.
     * @public
     */
    declare const IconRecord: Record_2.Factory<IconProperties & {
    }>;
    /**
     * Style class for describing a *image fill style*.
     *
     * Instances of ImageFill, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
     * but instead return a completely new modified object.
     *
     * **Properties of ImageFill:**
     * - `surroundingColor`: Fill color for the area surrounding the image. Construct a *LCJS color* using one of the many available *factories*:
     *      * {@link ColorRGBA}
     *      * {@link ColorHEX}
     *      * {@link ColorCSS}
     *      * {@link ColorHSV}
     *
     * - `sourceMissingColor`: Fill color used in place of the image when image is loading or image loading has failed. Construct a *LCJS color* using one of the many available *factories*:
     *      * {@link ColorRGBA}
     *      * {@link ColorHEX}
     *      * {@link ColorCSS}
     *      * {@link ColorHSV}
     *
     * - `fitMode`: {@link ImageFitMode} that specifies how the image is placed inside of the element using the ImageFill.
     * - `source`: Image source object. Can be any of `ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement`.
     *
     * **ImageFill Usage:**
     *
     * Use ImageFill with:
     * - `setFillStyle` methods:
     *      * {@link PointLineAreaSeries.setMarkerFillStyle}
     *      * {@link PolarPointSeries.setPointFillStyle}
     *      * {@link RectangleFigure.setFillStyle}
     *      * {@link ChartXY.setSeriesBackgroundFillStyle}
     *      * {@link ChartXY.setBackgroundFillStyle}
     *      * {@link ChartXY.setZoomingRectangleFillStyle}
     *      * {@link ChartXY.setFittingRectangleFillStyle}
     *      * {@link Chart3D.setBackgroundFillStyle}
     *      * {@link Axis.setOverlayStyle}
     *      * {@link UIBackground.setFillStyle}
     *
     * Example 1:
     * Styling a rectangle figure with an image.
     * ```typescript
     * const myImage = new Image()
     * myImage.src = 'https://example.com/myImage.png'
     * rectangleFigure.setFillStyle(new ImageFill({
     *     source: myImage,
     *     fitMode: ImageFitModes.Stretch
     * }))
     * ```
     *
     * Example 2:
     * Creating a new ImageFill object with a video as the source.
     * ```javascript
     * const myVideo = document.createElement('video')
     * myVideo.autoplay = true
     * myVideo.muted = true
     * myVideo.loop = true
     * myVideo.src = 'https://example.com/myVideo.mp4'
     * myVideo.play()
     * const imageFill = new ImageFill({
     *      source: myVideo,
     *      fitMode: ImageFitModes.Fit
     * })
     * ```
     *
     * **Related information:**
     *
     * For more *fill styles*, see:
     * - {@link emptyFill}
     * - {@link IndividualPointFill}
     * - {@link PalettedFill}
     * - {@link RadialGradientFill}
     * - {@link LinearGradientFill}
     * - {@link SolidFill}
     * @public
     */
    export declare class ImageFill extends ImageFillStyleRecord implements FillStyle {
        /**
         * Construct a new ImageFill object, specifying any amount of its properties.
         *
         * Example 1:
         * Creating a new ImageFill object with an image as the source.
         * ```javascript
         * const myImage = new Image()
         * myImage.src = 'https://example.com/myImage.png'
         * const imageFill = new ImageFill({
         *      source: myImage,
         *      fitMode: ImageFitModes.Stretch
         * })
         * ```
         *
         * Example 2:
         * Creating a new ImageFill object with a video as the source.
         * ```javascript
         * const myVideo = document.createElement('video')
         * myVideo.autoplay = true
         * myVideo.muted = true
         * myVideo.loop = true
         * myVideo.src = 'https://example.com/myVideo.mp4'
         * myVideo.play()
         * const imageFill = new ImageFill({
         *      source: myVideo,
         *      fitMode: ImageFitModes.Fit
         * })
         * ```
         *
         * When a HTMLVideoElement is specified as the source the chart will be constantly rendered while the video is playing.
         *
         * @param props - Object containing any amount of ImageFill properties.
         */
        constructor(props?: Partial<ImageFillStyleProperties>);
        /**
         * Construct a new ImageFill object based on this one, but with different image source.
         *
         * Example:
         * ```javascript
         * const myImg = new Image()
         * myImg.src = 'https://example.com/myImage.png'
         * imageFill.setSource(myImg)
         * ```
         *
         * @param value - TextureSource object
         * @returns New ImageFill object
         * @public
         */
        setSource(value: ImageFillSource): this;
        /**
         * Get image of ImageFill.
         * @returns ImageTexture object
         * @public
         */
        getSource(): ImageFillSource;
        /**
         * Construct a new ImageFill object based on this one, but with modified surrounding color.
         *
         * Surrounding color is used to fill the remaining element when the image doesn't fill the element completely.
         *
         * Example:
         * ```javascript
         * // specify new color
         * imageFill.setSurroundingColor( ColorHEX('#F00') )
         *
         * // change individual color properties
         * imageFill.setSurroundingColor( color => color.setA(80) )
         * ```
         * @param value - Either a Color object or a function, which will be used to create a new Color based on current value.
         * @returns New ImageFill object
         * @public
         */
        setSurroundingColor(value: Color | ImmutableMutator<Color>): this;
        /**
         * Get color of ImageFill.
         * @returns Color object
         * @public
         */
        getSurroundingColor(): Color;
        /**
         * Construct a new ImageFill object based on this one, but with modified source missing color.
         *
         * Source missing color is used in place of an image when the image has not been loaded yet or loading of the image has failed.
         *
         * Example:
         * ```javascript
         * // specify new color
         * imageFill.setSourceMissingColor( ColorHEX('#F00') )
         *
         * // change individual color properties
         * imageFill.setSourceMissingColor( color => color.setA(80) )
         * ```
         * @param value - Either a Color object or a function, which will be used to create a new Color based on current value.
         * @returns New ImageFill object
         * @public
         */
        setSourceMissingColor(value: Color | ImmutableMutator<Color>): this;
        /**
         * Get source missing color of ImageFill.
         * @returns Color object
         * @public
         */
        getSourceMissingColor(): Color;
        /**
         * Set new image fit mode.
         * @param value - Image fit mode
         * @public
         */
        setFitMode(value: ImageFitMode): this;
        /**
         * Get fit mode of ImageFill.
         * @returns Fit mode
         * @public
         */
        getFitMode(): ImageFitMode;
        /**
         * Get CSS representation of the FillStyle.
         * @public
         */
        toCSS(): string;
    }
    /**
     * Types that are accepted as the image source for {@link ImageFill}.
     *
     * Can be any of `ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement`
     *
     * @see ImageFill
     * @public
     */
    export declare type ImageFillSource = TexImageSource | undefined;
    /**
     * Interface for all options of a {@link ImageFill}.
     *
     * See {@link ImageFill}.
     * @see ImageFill
     * @public
     */
    export declare interface ImageFillStyleProperties {
        type: 'fillstyle';
        fillType: 'image';
        /**
         * The image source element to use.
         *
         * Can be any of {@link ImageFillSource}.
         *
         * Most commonly a `HTMLImageElement`.
         *
         * Example:
         * ```javascript
         * const myImage = new Image()
         * myImage.src = 'https://example.com/myImage.png'
         * const imageFill = new ImageFill({
         *      source: myImage
         * })
         * ```
         */
        source: ImageFillSource;
        /**
         * The color filling the area of element not filled by the image.
         */
        surroundingColor: Color;
        /**
         * The color filling element when image is loading or image loading failed.
         */
        sourceMissingColor: Color;
        /**
         * Image fitting mode.
         *
         * Example:
         *
         * ```javascript
         * const imageFill = new ImageFill({
         *      fitMode: ImageFitMode.Stretch
         * })
         * ```
         */
        fitMode: ImageFitMode;
    }
    /**
     * Record contractor for ImageFillFillStyleProperties.
     * @public
     */
    declare const ImageFillStyleRecord: Record_2.Factory<ImageFillStyleProperties>;
    /**
     * Different ways the image might be placed on the element.
     *
     * See {@link ImageFill}.
     * @see ImageFill
     * @public
     */
    export declare enum ImageFitMode {
        /**
         * Ensures that the image fills the full area of the element it's inside of.
         * Will keep image aspect ratio as is.
         * Image might be clipped on the smaller size axis.
         */
        Fill = 0,
        /**
         * Ensures that the image fits in the full area of the element it's inside of.
         * Will keep image aspect ratio as is.
         * Image might be not fill the element fully on the larger size axis.
         */
        Fit = 1,
        /**
         * Ensures that the image fills the full area of the element it's inside of.
         * Image aspect ratio will be distorted if the element aspect ratio is not same as the image aspect ratio.
         */
        Stretch = 2,
        /**
         * Places the image to the center of the full area of the element it's inside of.
         * Image aspect ratio will be kept as is.
         * Image might be clipped or not fill the element on either top/bottom and/or left/right, if the element is not same size as the image.
         */
        Center = 3,
        /**
         * Draws image starting from top left corner of the element it's inside of with exact source size.
         * If the element is larger than the image, then the image will be repeated indefinitely.
         * Can be used for drawing Tileable backgrounds.
         */
        Tile = 4
    }
    /**
     * Type of a mutator function for abstract, immutable object.
     * Function provides functionality for creating a new object based on an existing one.
     * @param object - Reference object
     * @returns New object
     * @public
     */
    export declare type ImmutableMutator<T, B = T> = (object: T) => B;
    /**
     * Style class for describing a *individually configured fill color*, enabling users to specify data-point
     * specific colors.
     *
     * Instances of IndividualPointFill, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
     * but instead return a completely new modified object.
     *
     * **Properties of IndividualPointFill:**
     * - `color`: fallback color to be used with data points that were not associated with a color.
     * Construct a *LCJS color* using one of the many available *factories*:
     *      * {@link ColorRGBA}
     *      * {@link ColorHEX}
     *      * {@link ColorCSS}
     *      * {@link ColorHSV}
     *
     * **IndividualPointFill Usage:**
     *
     * IndividualPointFill can be used with a select group of series:
     *
     * - {@link PointSeries.setPointFillStyle | PointSeries}
     * - {@link HeatmapGridSeriesIntensityValues.setFillStyle | HeatmapGridSeriesIntensityValues}
     * - {@link PointSeries3D.setPointStyle | PointSeries3D}
     *
     * ```typescript
     *  // Example, individual points fill color.
     *  PointSeries.setPointFillStyle(new IndividualPointFill())
     * ```
     *
     * **Related information:**
     *
     * For more *fill styles*, see:
     * - {@link SolidFill}
     * - {@link emptyFill}
     * - {@link PalettedFill}
     * - {@link RadialGradientFill}
     * - {@link LinearGradientFill}
     * - {@link ImageFill}
     * @public
     */
    export declare class IndividualPointFill extends VisibleFill {
        /**
         * Construct a IndividualPointFill object, specifying any amount of its properties.
         *
         * ```typescript
         *  // Example, for most cases no arguments are necessary (fallback color will be black).
         *  const individualPointFill = new IndividualPointFill()
         * ```
         *
         * ```typescript
         *  // Example, specify fallback color for data points without associated color.
         *  const individualPointFill = new IndividualPointFill({
         *      color: ColorRGBA( 0, 255, 0 )
         *  })
         * ```
         * @param props - Object containing any amount of IndividualPointFill properties.
         * @public
         */
        constructor(props?: Partial<VisibleFillStyleProperties>);
        /**
         * Get CSS representation of the FillStyle.
         * @public
         */
        toCSS(): string;
        /**
         * Construct a new IndividualPointFill object based on this one, but with modified fallback color.
         *
         * Example:
         * ```javascript
         * // specify new color
         * individualfill.setColor( ColorHEX('#F00') )
         *
         * // change individual color properties
         * individualfill.setColor( color => color.setA(80) )
         * ```
         * @param value - Either a Color object or a function, which will be used to create a new Color based on current value.
         * @returns New IndividualPointFill object
         * @public
         */
        setFallbackColor(value: Color | ImmutableMutator<Color>): this;
        /**
         * Get Fallback Color of IndividualPointFill.
         * @returns Color object
         * @public
         */
        getFallbackColor(): Color;
    }
    /**
     * Heatmap aggregation mode.
     *
     * By default, heatmaps display the closest heatmap cell value to each pixel that is rendered on the screen.
     * With dense, high resolution heatmaps, this can mean that there is no guarantee which data value is displayed in a pixel.
     *
     * Heatmap aggregation can be enabled to specify this behavior (which value to show when multiple cell values are contained by single pixel)
     * at the expense of a performance hit.
     * @public
     */
    export declare type IntensityAggregationMode = undefined | 'max' | 'min';
    /**
     * Description of intensity interpolation mode for Intensity Heatmap and Surface series.
     *
     * Use with `setIntensityInterpolation` methods.
     *
     * `'disabled'`: Interpolation disabled; draw data exactly as it is.
     *
     * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
     * @public
     */
    export declare type IntensityInterpolationMode = 'disabled' | 'bilinear';
    /**
     * Interface for object that allows tracking of basic HTML interaction events (pointerenter, pointermove, pointerdown, click, etc.)
     * @public
     */
    declare interface Interactable<Info = unknown> extends EventInterface<LCJSInteractionEventMap, Info> {
        /**
         * Set mouse interactions enabled or disabled
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setPointerEvents(state: boolean): this;
        /**
         * @returns Mouse interactions state
         * @public
         */
        getPointerEvents(): boolean;
        /**
         * Reference to [HTML draggable attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/draggable)
         *
         * Essentially part of convenience functionality which allows you to specify specific LCJS elements as "draggable",
         * this information is automatically passed on to the LCJS charts container DIV when that element is pointed
         * (since LCJS elements are not HTML elements, the DIV is the only actual HTML element).
         * @public
         */
        draggable: boolean;
    }
    /**
     * @public
     */
    export declare type InteractionConfigWithOverrides<Options, Sources extends string, Overrides extends string = 'ctrl' | 'shift' | 'alt' | 'lmb' | 'rmb' | 'mmb'> = Options & {
        [Source in Sources]?: false | Options;
    } & {
        [Override in Overrides]?: false | (Options & {
            [Source in Sources]?: false | Options;
        });
    } & {
        /**
         * Callback function which is fired when the interaction is applied.
         *
         * In case of interactions that can be applied several times during one gesture (such as panning), this callback is triggered for each step, so several times for 1 gesture.
         *
         * In case of interactions that are applied only once per gesture (such as rectangle zooming), this callback is triggered AFTER the interaction is completed.
         */
        on?: (args: {
            event: Event | undefined;
        }) => unknown;
    };
    /**
     * Internal interface of Background.
     * Type of UiElement that can be used as a Background of another element.
     * The main requirement for a background is to be fitted to a rectangle of any size.
     * @public
     */
    declare interface InternalBackground extends InternalUIElement, UIBackground, Highlightable {
        addEventListener(type: 'highlightchange', listener: (event: HighlightChangeEvent, info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        addEventListener(type: 'dispose', listener: (event: DisposeEvent, info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener(type: 'highlightchange', listener: (event: HighlightChangeEvent, info: unknown) => unknown): void;
        removeEventListener(type: 'dispose', listener: (event: DisposeEvent, info: unknown) => unknown): void;
    }
    /**
     * Internal type used to limit access to PointMarker
     * @public
     */
    declare type InternalPointMarker = UIElement & PointMarker;
    /**
     * Internal ResultTable class.
     * @public
     */
    declare class InternalResultTable<BackgroundClass extends UIBackground = UIBackground> extends UIRowGrid<BackgroundClass> implements ResultTable<BackgroundClass> {
        /**
         * Set displayed data of ResultTable
         * @param content - TableContent
         * @returns Object itself for fluent interface
         * @public
         */
        setContent(content: ResultTableContent): this;
        /**
         * Set text fill style
         * @param value - Fill style object or mutator to modify existing one
         * @returns Object itself for fluent interface
         * @public
         */
        setTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * @returns Current fill style object
         * @public
         */
        getTextFillStyle(): FillStyle;
        /**
         * Set font of Label.
         * @param value - FontSettings or mutator function for existing settings
         * @returns Object itself
         * @public
         */
        setTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Get font of Label.
         * @returns FontSettings
         * @public
         */
        getTextFont(): FontSettings;
        /**
         * Set rotation of Label.
         * @param value - Rotation in degrees
         * @returns Object itself
         * @public
         */
        setTextRotation(value: number): this;
        /**
         * Get rotation of Label.
         * @returns Rotation in degrees
         * @public
         */
        getTextRotation(): number;
    }
    /**
     * @public
     * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
     */
    declare interface _InternalSeries<SolveResultType extends SolveResult = SolveResult> extends ChartComponent<SolveResultType>, Interactable<SolveResultType> {
        addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultType) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultType) => unknown): void;
    }
    /**
     * @public
     * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
     */
    declare interface _InternalSeriesWithCursor<SolveResultType extends SolveResult = SolveResult> extends _InternalSeries<SolveResultType> {
        /**
         * Configure whether *cursors* should pick on this particular *series* or not.
         *
         * ```typescript
         *  // Example, prevent chart auto cursor from snapping to a series.
         *  LineSeries.setCursorEnabled(false)
         * ```
         *
         * **Related API:**
         *
         * - {@link ChartWithCursor.setCursorMode} | configure behavior when auto cursor is visible.
         * @public
         */
        setCursorEnabled(state: boolean): this;
    }
    /**
     * Internal interface for CustomTicks TickMarkers.
     * @public
     */
    declare interface InternalTickMarker extends TickMarker, CustomizableText {
    }
    /**
     * Base class for UI elements.
     * @public
     */
    declare abstract class InternalUIElement extends UIObject implements UIElement, Disposable, DisposableEvents {
        addEventListener<K extends keyof UIElementEventMap>(key: K, listener: (event: UIElementEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof UIElementEventMap>(key: K, listener: (event: UIElementEventMap[K], info: unknown) => unknown): void;
        /**
         * Pixel location of UiElements origin. To get position use getPosition(relativePosition).
         *
         * Coordinate system = position scale (UIElement.scale)
         * @public
         */
        _position: Point;
        /**
         * @public
         */
        protected origin: Point;
        /**
         * @public
         */
        protected size: Point;
        /**
         * @public
         */
        protected readonly renderingScale: LinearScaleXY;
        /**
         * @public
         */
        readonly scale: ScaleXY;
        /**
         * Set mouse interactions enabled.
         * Implementations should update the mouse-interactions of any Shapes they may contain here.
         * @param state -
         * @public
         */
        setPointerEvents(state: boolean): this;
        /**
         * @returns Mouse interactions state
         * @public
         */
        getPointerEvents(): boolean;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getEffect(): boolean;
        /**
         * Set auto dispose behavior for this UI element.
         *
         * Can be used to set a condition, where the UI element is automatically *disposed*, removing it from view.
         *
         * ```ts
         *  // Example, remove UI element when it is larger than 20% of viewport.
         *  UIElement.setAutoDispose({
         *      type: 'max-width',
         *      maxWidth: 0.20,
         *  })
         * ```
         * @param autoDisposeMode - Auto dispose mode.
         * @returns Object itself for fluent interface.
         * @public
         */
        setAutoDispose(autoDisposeMode: AutoDisposeMode): this;
        /**
         * Get auto dispose behavior for this UI element.
         * @returns Auto dispose mode.
         * @public
         */
        getAutoDispose(): AutoDisposeMode;
        /**
         * Returns the size of the UiElements in pixels including any Margins or Paddings
         * @param spaceOfInterest - Parameter to disregard parts of object when calculating the position. Defaults to Margin,
         *                              which includes everything. Should only ever be necessary for sub-classes
         * @returns Object size in pixels
         * @public
         */
        getSize(spaceOfInterest?: UISpace): Point;
        /**
         * Member function that updates the size of the UI elements contents.
         * UiElements should apply this inside 'update'
         * @param sizeInPixels - Size of element in pixels
         * @public
         */
        protected setContentSize(sizeInPixels: Point): void;
        private _margin;
        /**
         * Set margin around object in pixels.
         * @param margin - Number with pixel margins for all sides or datastructure with individual pixel margins
         *                      for each side. Any side can be omitted, only passed values will be overridden.
         * @returns Object itself
         * @public
         */
        setMargin(margin: Partial<MMargin> | number): this;
        /**
         * Get margin around object in pixels.
         * @returns Margin datastructure
         * @public
         */
        getMargin(): Margin;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @returns Object itself.
         */
        setVisible(state: boolean): this;
        /**
         * Check whether the object is disposed.
         * Disposed objects should not be used!
         *
         * @returns     `true` if object is disposed.
         * @public
         */
        isDisposed(): boolean;
        /**
         * Sets the position of this UiElement relative to its origin.
         *
         * NOTE: UIElements scale can't be changed apart from when it is created.
         * @param position - Location on the UIElements scale, where its origin should be positioned
         * @returns Object itself
         * @public
         */
        setPosition(position: Point): this;
        /**
         * Returns the position of this UiElement at given location relative to elements size.
         * @param relativePosition - Relative position vector (-1 to 1 which specifies position of origin, 0 is center of the object)
         * @param spaceOfInterest - Parameter to disregard parts of object when calculating the asked position. Defaults to Margin,
         *                              which includes everything. Should only ever be necessary for other UiElements
         * @returns Object itself for fluent itself
         * @public
         */
        getPosition(relativePosition?: Point, spaceOfInterest?: UISpace): Point;
        /**
         * Sets the position origin of this UiElement. Affects how the "position" of UIElement is interpreted.
         *
         * See {@link UIOrigins} for a collection of common arguments in an easy-to-read format.
         * @param Vec2 - with each plane in range [-1, 1], where 0 is middle
         * @returns Object itself
         * @public
         */
        setOrigin(origin: Point): this;
        /**
         * Get the position origin of this UiElement. Affects how the "position" of UIElement is interpreted.
         *
         * @returns Vec2 with each plane in range [-1, 1], where 0 is middle
         * @public
         */
        getOrigin(): Point;
        /**
         * Set dragging mode of object. Defines how the object can be dragged by mouse.
         *
         * See {@link UIDraggingModes}collection for options.
         * @param draggingMode - DraggingMode or undefined to disable dragging
         * @returns Object itself
         * @public
         */
        setDraggingMode(draggingMode?: UIDraggingModes): this;
        /**
         * Get dragging mode of object.
         * Defines how the object can be dragged by mouse.
         * @returns Object itself
         * @public
         */
        getDraggingMode(): UIDraggingModes;
        /**
         * Set mouse style when hovering over UI object.
         * @param mouseStyle - Interface for defining how mouse should look when hovering over UI object
         * @returns Object itself
         * @public
         */
        setMouseStyle(mouseStyle: UIMouseStyle): this;
        /**
         * Get mouse style.
         * @returns Interface for defining how mouse should look when hovering over UI object
         * @public
         */
        getMouseStyle(): UIMouseStyle;
    }
    /**
     * Utility for interpolating between colors.
     * @param color1 -  Color A
     * @param color2 -  Color B
     * @param position - Position between A, B [0,1] where 0 = A.
     * @param alpha - Alpha value override [0,255]
     * @returns     Interpolated color object.
     * @public
     */
    export declare const interpolateColor: (color1: Color, color2: Color, position: number, alpha?: number) => Color;
    /**
     * Generic Interval
     * @param min - Start of interval
     * @param max - End of interval
     */
    declare interface Interval<T> {
        readonly min: T;
        readonly max: T;
    }
    /**
     * @public
     */
    export declare interface InViewChangedEvent {
        isInView: boolean;
    }
    /**
     * Safety mechanism to allow user applications to identify between real DOM events and artificial events fired by LCJS under some specific circumstances.
     *
     * Most notably, `"pointermove"` events are repeated when a pointer is resting on a chart and the chart is re-rendering.
     * In some use cases it can be critical to know for sure that an event actually means user is moving their pointer.
     *
     * ```ts
     *  // Example syntax
     *  chart.seriesBackground.addEventListener('pointermove', event => {
     *      // Ignore artificial events
     *      if (isArtificialLCJSEvent(event)) return
     *      // ...
     *  })
     * ```
     *
     * @param event - Event object from an event listener.
     * @public
     */
    export declare const isArtificialLCJSEvent: (event: Event) => boolean;
    /**
     * Color type guard.
     *
     * Use to verify that an unknown object is an instance of {@link Color}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a Color
     * @public
     */
    export declare const isColor: (value: unknown) => value is Color;
    /**
     * Type guard for checking if an object has type of {@link Coordinate3D}.
     * @public
     */
    export declare const isCoordinate3D: (value: unknown) => value is Coordinate3D;
    /**
     * Type guard for checking if an object has type of {@link CoordinateBarChart}.
     * @public
     */
    export declare const isCoordinateBarChart: (value: unknown) => value is CoordinateBarChart;
    /**
     * Type guard for checking if an object has type of {@link CoordinateClient}.
     * @public
     */
    export declare const isCoordinateClient: (value: unknown) => value is CoordinateClient;
    /**
     * Type guard for checking if an object has type of {@link CoordinatePolar}.
     * @public
     */
    export declare const isCoordinatePolar: (value: unknown) => value is PolarPoint;
    /**
     * Type guard for checking if an object has type of {@link CoordinateXY}.
     * @public
     */
    export declare const isCoordinateXY: (value: unknown) => value is CoordinateXY;
    /**
     * DashedLine type guard.
     *
     * Use to verify that an LineStyle is a DashedLine.
     *
     * Example:
     * ```ts
     * line.setStrokeStyle((stroke) => isDashedLine(stroke) ? stroke.setPattern(StipplePatterns.Dashed) : stroke )
     * ```
     *
     * @param value - LineStyle to check
     * @returns Boolean indicating if value is a DashedLine
     * @public
     */
    export declare const isDashedLine: (value: unknown) => value is DashedLine;
    /**
     * EmptyFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link EmptyFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a EmptyFill
     * @public
     */
    export declare const isEmptyFill: (value: unknown) => value is EmptyFill;
    /**
     * Convenience function for checking if all properties of a tick style are empty.
     *
     * @param value - Object to check
     * @returns Boolean indicating if all styles are empty (label, gridstroke, tickline).
     * @public
     */
    export declare const isEmptyTick: (value: TickStyle) => boolean;
    /**
     * FontSettings type guard.
     *
     * Use to verify that an unknown object is an instance of {@link FontSettings}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a FontSettings
     * @public
     */
    export declare const isFontSettings: (value: unknown) => value is FontSettings;
    /**
     * GlowEffect type guard.
     *
     * Use to verify that an unknown object is an instance of {@link GlowEffect}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a GlowEffect
     * @public
     */
    export declare const isGlowEffect: (value: unknown) => value is GlowEffect;
    /**
     * Type guard for checking if solve result has properties of a 2D Box Series.
     * @public
     */
    export declare const isHitBox: <T>(hit: T) => hit is T & SolveResultXY & Point & {
        figure: BoxFigure;
    } & BoxFigureDimensions;
    /**
     * Type guard for checking if solve result has properties of a 3D Box Series.
     * @public
     */
    export declare const isHitBox3D: <T>(hit: T) => hit is T & SolveResultBoxSeries3D;
    /**
     * Type guard for checking if solve result has properties of a 2D Ellipse Series.
     * @public
     */
    export declare const isHitEllipse: <T>(hit: T) => hit is T & SolveResultXY & Point & {
        figure: EllipseFigure;
    } & EllipseDimensions;
    /**
     * Type guard for checking if solve result has properties of a Heatmap.
     *
     * Can be used as if condition or to satisfy types before accessing Heatmap-like properties:
     *  - `hit.column`
     *  - `hit.row`
     *  - `hit.intensity`
     * @public
     */
    export declare const isHitHeatmap: <T>(hit: T) => hit is T & SolveResultHeatmap;
    /**
     * Type guard for checking if solve result has properties of a 3D Mesh Model.
     * @public
     */
    export declare const isHitMeshModel: <T>(hit: T) => hit is T & SolveResultMeshModel3D;
    /**
     * Type guard for checking if solve result has properties of a OHLC series.
     *
     * Can be used as if condition or to satisfy types before accessing OHLC sample properties:
     * @public
     */
    export declare const isHitOHLC: <T>(hit: T) => hit is T & SolveResultXY & OHLCSegment;
    /**
     * Type guard for checking if solve result has properties of a Polar Heatmap.
     *
     * Can be used as if condition or to satisfy types before accessing properties:
     *  - `hit.sector`
     *  - `hit.annulus`
     *  - `hit.intensity`
     * @public
     */
    export declare const isHitPolarHeatmap: <T>(hit: T) => hit is T & SolveResultPolarHeatmap;
    /**
     * Type guard for checking if solve result has properties of a 2D Polygon Series.
     * @public
     */
    export declare const isHitPolygon: <T>(hit: T) => hit is T & SolveResultXY & Point & {
        figure: PolygonFigure;
        coordinates: Point[];
    };
    /**
     * Type guard for checking if solve result has properties of a Rectangle Series.
     * @public
     */
    export declare const isHitRectangle: <T>(hit: T) => hit is T & SolveResultXY & RectangleTwoPoints & {
        figure: RectangleFigure;
        positionAndSize: RectanglePositionAndSize;
    };
    /**
     * Type guard for checking if solve result has properties of a {@link SampleXY}.
     *
     * Can be used as if condition or to satisfy types before accessing properties:
     *  - `hit.rotation`
     *  - `hit.color`
     *  - `hit.id`
     *  - `hit.size`
     *  - `hit.lookupValue`
     * @public
     */
    export declare const isHitSampleXY: <T>(hit: T) => hit is T & SolveResultSampleXY;
    /**
     * Type guard for checking if solve result has properties of a 2D Segment Series.
     * @public
     */
    export declare const isHitSegment: <T>(hit: T) => hit is T & SolveResultXY & Point & {
        figure: SegmentFigure;
    } & SegmentDimensions;
    /**
     * Type guard for checking if solve result has properties of a Surface series.
     *
     * Can be used as if condition or to satisfy types before accessing Surface-like properties:
     *  - `hit.column`
     *  - `hit.row`
     *  - `hit.intensity`
     * @public
     */
    export declare const isHitSurface: <T>(hit: T) => hit is T & SolveResultSurface3D;
    /**
     * Icon type guard.
     *
     * Use to verify that an unknown object is an instance of {@link Icon}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a Icon
     * @public
     */
    export declare const isIcon: (value: unknown) => value is Icon;
    /**
     * ImageFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link ImageFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a ImageFill
     * @public
     */
    export declare const isImageFill: (value: unknown) => value is ImageFill;
    /**
     * IndividualPointFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link IndividualPointFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a IndividualPointFill
     * @public
     */
    export declare const isIndividualPointFill: (value: unknown) => value is IndividualPointFill;
    /**
     * LinearGradientFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link LinearGradientFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a LinearGradientFill
     * @public
     */
    export declare const isLinearGradientFill: (value: unknown) => value is LinearGradientFill;
    /**
     * LUT type guard.
     *
     * Use to verify that an unknown object is an instance of {@link LUT}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a LUT
     * @public
     */
    export declare const isLUT: (value: unknown) => value is LUT;
    /**
     * PalettedFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link PalettedFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a PalettedFill
     * @public
     */
    export declare const isPalettedFill: (value: unknown) => value is PalettedFill<LookUpProperty>;
    /**
     * PhongShadingStyle type guard.
     *
     * Use to verify that an unknown object is an instance of {@link PhongShadingStyle}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a PhongShadingStyle
     * @public
     */
    export declare const isPhongShadingStyle: (value: unknown) => value is PhongShadingStyle;
    /**
     * PixelatedPoints3D type guard.
     *
     * Use to verify that an unknown object is an instance of {@link PixelatedPoints3D}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a PixelatedPoints3D
     * @public
     */
    export declare const isPixelatedPoints3D: (value: unknown) => value is PixelatedPoints3D;
    /**
     * RadialGradientFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link RadialGradientFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a RadialGradientFill
     * @public
     */
    export declare const isRadialGradientFill: (value: unknown) => value is RadialGradientFill;
    /**
     * Check if a SeriesXY is of SupportedSeries type.
     * @public
     */
    export declare const isSeriesSupportedByZoomBandChart: (series: SeriesXY<any, any>) => series is ZoomBandChartSupportedSeries;
    /**
     * SimpleShadingStyle type guard.
     *
     * Use to verify that an unknown object is an instance of {@link SimpleShadingStyle}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a SimpleShadingStyle
     * @public
     */
    export declare const isSimpleShadingStyle: (value: unknown) => value is SimpleShadingStyle;
    /**
     * SolidFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link SolidFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a SolidFill
     * @public
     */
    export declare const isSolidFill: (value: unknown) => value is SolidFill;
    /**
     * SolidLine type guard.
     *
     * Use to verify that an LineStyle is a SolidLine.
     *
     * Example:
     * ```ts
     * line.setStrokeStyle((stroke) => isSolidLine(stroke) ? stroke.setThickness(10) : new SolidLine() )
     * ```
     *
     * @param value - LineStyle to check
     * @returns Boolean indicating if value is a SolidLine
     * @public
     */
    export declare const isSolidLine: (value: unknown) => value is SolidLine;
    /**
     * TickStyle type guard.
     *
     * Use to verify that an unknown object is an instance of {@link TickStyle}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a TickStyle
     * @public
     */
    export declare const isTickStyle: (value: unknown) => value is TickStyle;
    /**
     * TriangulatedPoints3D type guard.
     *
     * Use to verify that an unknown object is an instance of {@link TriangulatedPoints3D}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a TriangulatedPoints3D
     * @public
     */
    export declare const isTriangulatedPoints3D: (value: unknown) => value is TriangulatedPoints3D;
    /**
     * Subset of standard `AddEventListenerOptions`.
     * @public
     */
    export declare interface LCJSAddEventListenerOptions {
        /**
         * Defaults to `false`.
         * If `true`, the event listener is automatically removed after the first time its fired.
         *
         * ```ts
         *  // Example syntax
         *  object.addEventListener('click', (event) => {
         *      console.log(event)
         *  }, { once: true })
         * ```
         */
        once?: boolean;
    }
    /**
     * @public
     */
    export declare type LCJSInteractionEventListener<EventType extends keyof LCJSInteractionEventMap, Info extends {} = {}> = (event: LCJSInteractionEventMap[EventType], info: Info) => unknown;
    /**
     * Subset of `HTMLElementEventMap`, JavaScript events that are monitored by LightningChart JS.
     * @public
     */
    export declare type LCJSInteractionEventMap = {
        [Key in keyof Pick<HTMLElementEventMap, 'click' | 'contextmenu' | 'dblclick' | 'drag' | 'dragend' | 'dragenter' | 'dragleave' | 'dragover' | 'dragstart' | 'drop' | 'gotpointercapture' | 'lostpointercapture' | 'pointercancel' | 'pointerdown' | 'pointerenter' | 'pointerleave' | 'pointermove' | 'pointerout' | 'pointerover' | 'pointerup' | 'touchcancel' | 'touchend' | 'touchmove' | 'touchstart' | 'wheel'>]: HTMLElementEventMap[Key];
    };
    /**
     * Class for all legend implementations.
     * @public
     */
    export declare class Legend implements Disposable {
        /**
         * Add a new entry to the legend.
         * @param component - Attachable, Chart, or LUT.
         * @param options - LegendEntryOptions
         * @returns Object itself.
         * @public
         */
        add(component?: Attachable | Chart | LUT, options?: LegendEntryOptions): this;
        /**
         * Remove existing entry from the legend.
         * @param component - Component of the entry.
         * @returns Object itself.
         * @public
         */
        remove(component: Attachable): this;
        /**
         * Remove all existing entries from the legend.
         * @returns Object itself.
         * @public
         */
        clear(): this;
        /**
         * Permanently destroy the component.
         * @returns Object itself.
         * @public
         */
        dispose(): this;
        /**
         * Set the options of the legend.
         * @param options - LegendOptions
         * @returns Object itself.
         * @public
         */
        setOptions(options: LegendOptions): this;
        /**
         * Get the current options for the legend.
         * @returns LegendOptions
         * @public
         */
        getOptions(): LegendOptions;
        /**
         * Override LegendEntryOptions of an specific entry.
         * @param component - Component of the entry to be modified.
         * @param options - New LegendEntryOptions
         * @returns Object itself.
         * @public
         */
        setEntryOptions(component: Attachable | LUT, options: Partial<LegendEntryOptions>): this;
        /**
         * Get the current options of specific entry.
         * @param component - Attachable component of the entry.
         * @returns LegendEntryOptions
         */
        getEntryOptions(component: Attachable | LUT): LegendEntryOptions | undefined;
        /**
         * Get the current entries of the legend.
         * @returns LegendEntry array.
         * @public
         */
        getEntries(): LegendEntry[];
        /**
         * Interface for attaching listeners to user interaction events (`click`, `pointerenter`, etc.) on legend title.
         *
         * ```ts
         *  // Example syntax
         *  chart.legend.title.addEventListener('click', (event) => {
         *      console.log(event)
         *  })
         * ```
         *
         * For syntax examples, refer to {@link EventInterface}.
         * Available event keys are listed under {@link LCJSInteractionEventMap}
         * @public
         */
        readonly title: Eventer<LCJSInteractionEventMap, any>;
        /**
         * Interface for attaching listeners to user interaction events (`click`, `pointerenter`, etc.) on legend background.
         *
         * ```ts
         *  // Example syntax
         *  chart.legend.background.addEventListener('click', (event) => {
         *      console.log(event)
         *  })
         * ```
         *
         * For syntax examples, refer to {@link EventInterface}.
         * Available event keys are listed under {@link LCJSInteractionEventMap}
         * @public
         */
        readonly background: Eventer<LCJSInteractionEventMap, any>;
    }
    /**
     * Legend entry object.
     * @public
     */
    export declare interface LegendEntry {
        /**
         * Component that is attached to the legend entry.
         */
        component?: Attachable;
        /**
         * Options for the entry.
         */
        options: LegendEntryOptions;
    }
    /**
     * Collection of callbacks for legend entry click events.
     * @public
     */
    export declare const LegendEntryClickBehaviors: {
        /**
         * Toggle visibility of the clicked entry (default).
         *
         * ```ts
         *  // Example syntax
         *  const chart = lc.ChartXY({
         *      legend: {
         *          entries: {
         *              events: {
         *                  click: LegendEntryClickBehaviors.toggleIndividualVisibility
         *              }
         *          }
         *      }
         *  })
         * ```
         */
        toggleIndividualVisibility: (event: Event, info: {
            entry: LegendEntry;
            allEntries: LegendEntry[];
        }) => void;
        /**
         * Make the clicked entry the only visible one.
         *
         * ```ts
         *  // Example syntax
         *  const chart = lc.ChartXY({
         *      legend: {
         *          entries: {
         *              events: {
         *                  click: LegendEntryClickBehaviors.focusClicked
         *              }
         *          }
         *      }
         *  })
         * ```
         */
        focusClicked: (event: Event, info: {
            entry: LegendEntry;
            allEntries: LegendEntry[];
        }) => void;
        /**
         * Do nothing on click.
         *
         * ```ts
         *  // Example syntax
         *  const chart = lc.ChartXY({
         *      legend: {
         *          entries: {
         *              events: {
         *                  click: LegendEntryClickBehaviors.doNothing
         *              }
         *          }
         *      }
         *  })
         * ```
         */
        doNothing: () => void;
    };
    /**
     * Options for individual legend entry.
     * @public
     */
    export declare interface LegendEntryOptions {
        /**
         * Whether to show the entry on the legend.
         */
        show?: boolean;
        /**
         * Text to be displayed on the legend entry.
         */
        text?: string;
        /**
         * Highlighting on hover enabled?
         */
        highlight?: boolean;
        /**
         * FontSettings for the entry text.
         */
        textFont?: Partial<FontSettings>;
        /**
         * FillStyle for the entry text.
         */
        textFillStyle?: FillStyle;
        /**
         * Entry button size.
         */
        buttonSize?: number;
        /**
         * Entry button shape.
         */
        buttonShape?: PointShape | Icon;
        /**
         * Rotation of the entry button in degrees.
         */
        buttonRotation?: number;
        /**
         * FillStyle for the entry button.
         */
        buttonFillStyle?: FillStyle;
        /**
         * LineStyle for the entry button.
         */
        buttonStrokeStyle?: LineStyle;
        /**
         * Whether buttonFillStyle should be matched exactly with the style of the represented component.
         *
         * Defaults to `false`, which results in button fill style being displayed as a linear gradient calculated around the represented component color.
         */
        matchStyleExactly?: boolean;
        /**
         * Event callbacks for the entry. Can be used to add entry specific event handlers:
         *
         * ```ts
         *  // Example syntax, click handler for all legend entries
         *  const chart = lc.ChartXY({
         *      legend: {
         *          entries: {
         *              events: {
         *                  click: (event, info) => {}
         *              }
         *          }
         *      }
         *  })
         * ```
         *
         * ```ts
         *  // Example syntax, click handler for a specific entry
         *  chart.legend.setEntryOptions(series, {
         *      events: {
         *          click: (event, info) => {}
         *      }
         *  })
         * ```
         *
         * Most frequently used event keys:
         *  - `'click'`
         *  - `'contextmenu'`
         *  - `'pointerenter'`
         *  - `'pointermove'`
         *  - `'pointerleave'`
         */
        events?: {
            [key in keyof LCJSInteractionEventMap]?: (event: LCJSInteractionEventMap[key], info: {
                entry: LegendEntry;
                allEntries: LegendEntry[];
            }) => void;
        };
        /**
         * LUT element to be displayed on the legend.
         * By default, LUT is automatically displayed if the associated entry is styled using a LUT.
         * This behavior can be prevented by setting `lut` to null.
         *
         * ```ts
         *  // Example syntax, prevent LUT from being displayed in legend
         *  const chart = lc.ChartXY({
         *      legend: {
         *          entries: {
         *              lut: null
         *          }
         *      }
         *  })
         * ```
         */
        lut?: LUT | null;
        /**
         * Length of the LUT element as pixels.
         */
        lutLength?: number;
        /**
         * Thickness of the LUT element as pixels.
         */
        lutThickness?: number;
        /**
         * Whether distances between LUT step values are displayed, or if the displayed LUT steps should be split equal distances apart.
         */
        lutDisplayProportionalSteps?: boolean;
        /**
         * Callback function for LUT element value formatting.
         */
        lutStepValueFormatter?: (step: LUTStep, lut: LUT) => string;
    }
    /**
     * Handle for communication between the chart and the legend.
     * @public
     */
    export declare interface LegendHandle {
        /**
         * Method for updating the internal properties and elements of the legend before rendering.
         * @param info - LegendRenderInfo
         * @returns Space allocated for the legend as Margin.
         */
        update(info?: LegendRenderInfo): Margin | undefined;
        /**
         * Method for rendering the legend.
         * @param info - LegendRenderInfo
         */
        plot(info?: LegendRenderInfo): void;
        /**
         * Method for disposing of the legend and its elements.
         */
        dispose?(): void;
    }
    /**
     * Initialization configuration for the legend.
     * @public
     */
    export declare interface LegendInitConfig {
        panel: Panel;
    }
    /**
     * Function to define LegendHandle with custom logic.
     * @public
     */
    export declare type LegendLogic = (legendOptions?: LegendInitConfig) => LegendHandle;
    /**
     * Options for the Legend.
     * @public
     */
    export declare interface LegendOptions {
        /**
         * Whether legend entries should be automatically added and displayed.
         *
         * Defaults to `true` for default legend and `false` for manually added legends (`chart.addLegend`).
         */
        addEntriesAutomatically?: boolean;
        /**
         * Position of the legend.
         *
         * ```ts
         *  // Example syntax, choose from preset options
         *  const chart = lc.ChartXY({
         *      legend: {
         *          position: LegendPosition.RightCenter
         *      }
         *  })
         * ```
         *
         * Alternatively, arbitrary location as pixels relative to container bottom left corner can be specified:
         *
         * ```ts
         *  // Example syntax, arbitrary location
         *  chart.legend.setOptions({
         *      position: {
         *          x: 0,
         *          y: 0,
         *          origin: UIOrigins.UIOrigins.LeftBottom
         *      }
         *  })
         * ```
         *
         * These coordinates are defined in {@link ChartXY.coordsRelative} coordinate system.
         */
        position?: LegendPosition | {
            x: number;
            y: number;
            origin?: Point;
        };
        /**
         * Legend orientation.
         * By default, this is automatically dictated by configured {@link position}
         * But it can be forced to a specific value, which can be useful when positioning legends at arbitrary locations.
         *
         * ```ts
         *  // Example syntax, arbitrary location
         *  chart.legend.setOptions({
         *      position: {
         *          x: 0,
         *          y: 0,
         *          origin: UIOrigins.UIOrigins.LeftBottom
         *      },
         *      orientation: LegendOrientation.Horizontal
         *  })
         * ```
         */
        orientation?: LegendOrientation;
        /**
         * Legend content padding.
         */
        padding?: number | Partial<Margin>;
        /**
         * Margin between legend entries.
         */
        entryMargin?: number;
        /**
         * Margin from the main chart element to the legend.
         */
        marginInner?: number;
        /**
         * Margin from the legend to the edge of the chart area.
         */
        marginOuter?: number | Partial<Margin>;
        /**
         * Whether the legend should be rendered on top of the chart.
         */
        renderOnTop?: boolean;
        /**
         * Title of the legend.
         */
        title?: string;
        /**
         * FontSettings of the legend title.
         */
        titleFont?: Partial<FontSettings>;
        /**
         * FillStyle of the legend title.
         */
        titleFillStyle?: FillStyle;
        /**
         * Whether the legend should be visible.
         */
        visible?: boolean;
        /**
         * Whether the legend background should be visible.
         */
        backgroundVisible?: boolean;
        /**
         * Background FillStyle of the legend.
         */
        backgroundFillStyle?: FillStyle;
        /**
         *  Background LineStyle of the legend.
         */
        backgroundStrokeStyle?: LineStyle;
        /**
         * Default LegendEntryOptions for the entries.
         */
        entries?: LegendEntryOptions;
        /**
         * The maximum allowed proportion of the viewport that the legend can occupy before it is automatically hidden.
         * For example, a value of 0.75 means the legend will be hidden if it covers more than 75% of the viewport.
         */
        autoHideThreshold?: number;
    }
    /**
     * Orientation enumeration for default legend.
     * @public
     */
    export declare enum LegendOrientation {
        Horizontal = 0,
        Vertical = 1
    }
    /**
     * Position enumeration for default legend.
     * @public
     */
    export declare enum LegendPosition {
        RightTop = 0,
        RightCenter = 1,
        RightBottom = 2,
        LeftTop = 3,
        LeftCenter = 4,
        LeftBottom = 5,
        TopLeft = 6,
        TopCenter = 7,
        TopRight = 8,
        BottomLeft = 9,
        BottomCenter = 10,
        BottomRight = 11
    }
    /**
     * Information used for rendering the legend.
     * @public
     */
    export declare interface LegendRenderInfo extends Omit<LegendOptions, 'entries'> {
        /**
         * Space allocated for the chart title, used for adjusting the legend position.
         */
        chartTitleSpace: Margin;
        /**
         * Margin from the legend to the edge of the chart area.
         */
        marginOuter: Margin;
        /**
         * Chart padding, used for adjusting the legend position.
         */
        chartPadding: Margin;
        /**
         * Position of the legend.
         * If x and y are provided, they will be interpreted as relative coordinates of the chart bottom left (`chart.coordsRelative`).
         * If origin is provided, it will be interpreted as the origin of the legend position.
         */
        position: LegendPosition | {
            x: number;
            y: number;
            origin?: Point;
        };
        /**
         * Legend content padding.
         */
        padding?: Margin;
        /**
         * Array of legend entries.
         */
        entries: LegendEntry[];
        /**
         * Events for the legend title.
         */
        titleEvents: Eventer<LCJSInteractionEventMap>;
        /**
         * Events for the legend background.
         */
        backgroundEvents: Eventer<LCJSInteractionEventMap>;
    }
    /**
     * Main interface of LCJS, which is used to create all top level components - *charts* and *dashboards*.
     * Reference to `LightningChart` is received with the {@link lightningChart} export, which is also used to supply possible license information, and other top-level configuration:
     *
     * ```typescript
     *  const lcjs = lightningChart({
     *      // Either supply license number, or omit for automatic community license.
     *      // license: 'my-license-number'
     *  })
     *
     *  // Create charts...
     *  const chart = lcjs.ChartXY()
     * ```
     *
     * To get started, browse through the available properties, for example:
     *
     * - {@link LightningChart.ChartXY}.
     * - {@link LightningChart.Chart3D}.
     * - {@link LightningChart.Dashboard}.
     * @public
     */
    export declare interface LightningChart {
        /**
         * Factory for `Dashboard`.
         * Dashboard allows placement of multiple *charts* inside a *grid layout*. Usage of *dashboard* is recommended when applicable,
         * due to increased performance (shared rendering context for all *charts*).
         *
         * To learn more about *dashboard* features, refer to {@link Dashboard}.
         *
         * **Dashboard configuration:**
         *
         * When a *dashboard* is created, the user must specify an amount of *columns* and *rows* for the grid layout.
         * These dimensions can't be changed afterwards, whereas the distribution of width/height between the *columns* and *rows*, can be adjusted at any time.
         *
         * ```typescript
         *  // Example, Create a 3x3 dashboard.
         *  const dashboard = LightningChart.Dashboard({
         *      // Number of cells along horizontal plane.
         *      numberOfColumns: 3,
         *      // Number of cells along vertical plane.
         *      numberOfRows: 3,
         *  })
         * ```
         *
         * To learn about the effects of *columns* / *rows* configuration, please read more here {@link Dashboard}.
         *
         * **Optional extra configuration:**
         *
         * Some extra, optional properties of `Dashboard` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in the same object parameter that is used for supplying `numberOfColumns`, and `numberOfRows`.
         *
         * ```typescript
         *  // Example, create 3x3 dashboard inside DOM element managed by user. The element must be added to the document, before creating the dashboard.
         *  const chart = LightningChart.Dashboard({
         *      // Number of cells along horizontal plane.
         *      numberOfColumns: 3,
         *      // Number of cells along vertical plane.
         *      numberOfRows: 3,
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *dashboard* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `Dashboard` specific properties, refer to {@link DashboardOptions}.
         *
         * **Dashboard examples:**
         *
         * You can find an interactive gallery of different `Dashboard` use cases on our web site [`lightningchart.com`](https://lightningchart.com/lightningchart-js-interactive-examples/search.html?t=dashboard)
         *
         * @param options - Optional object with readonly configuration arguments for `Dashboard`.
         * @returns Created dashboard.
         * @public
         */
        Dashboard: (options: EngineOptions & DashboardOptions) => Dashboard;
        /**
         * Factory for `ChartXY`. This chart visualizes data between two dimensions *X* and *Y*.
         * It has built-in *Axis* functionality, and supports a large set of *series* types.
         *
         * To learn more about its features, refer to {@link ChartXY}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `ChartXY` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.ChartXY({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `ChartXY` specific properties, refer to {@link ChartXYOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `ChartXY`.
         * @returns Created chart.
         * @public
         */
        ChartXY: <CursorResultTableBackgroundType extends UIBackground>(options?: EngineOptions & ChartXYOptions<CursorResultTableBackgroundType>) => ChartXY<CursorResultTableBackgroundType>;
        /**
         * Factory for `SpiderChart`. This chart visualizes data distributed over several *axes*.
         * *Spider Axes* are layed out in a circle, without any set limit on the amount of axes.
         * It supports a collection of different *series* types.
         *
         * To learn more about its features, refer to {@link SpiderChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `SpiderChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.SpiderChart({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `SpiderChart` specific properties, refer to {@link SpiderChartOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `SpiderChart`.
         * @returns Created chart.
         * @public
         */
        Spider: <CursorResultTableBackgroundType extends UIBackground>(options?: EngineOptions & SpiderChartOptions<CursorResultTableBackgroundType>) => SpiderChart<CursorResultTableBackgroundType>;
        /**
         * Factory for `PolarChart`. This chart visualizes data in a *Polar coordinate system* ( **angle** + **amplitude** ).
         * It has built-in *Axis* functionality, and supports a collection of different *series* types.
         *
         * To learn more about its features, refer to {@link PolarChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `PolarChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.Polar({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `PolarChart` specific properties, refer to {@link PolarChartOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `PolarChart`.
         * @returns Created chart.
         * @public
         */
        Polar: <CursorResultTableBackgroundType extends UIBackground>(options?: EngineOptions & PolarChartOptions<CursorResultTableBackgroundType>) => PolarChart<CursorResultTableBackgroundType>;
        /**
         * Factory for `PieChart`. This chart visualizes proportions and percentages between categories,
         * by dividing a circle into proportional segments.
         *
         * To learn more about its features, refer to {@link PieChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `PieChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.Pie({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `PieChart` specific properties, refer to {@link PieChartOptions}.
         *
         * **Return type:**
         *
         * `PieChart` return type depends on supplied readonly configuration! Specifically, {@link PieChartOptions.type}.
         *
         * | Configuration `type` | Return chart type |
         * | :------------------- | :---------------- |
         * | `undefined` or omitted | {@link PieChartWithLabelsOnSides} |
         * | `PieChartTypes.LabelsOnSides` | {@link PieChartWithLabelsOnSides} |
         * | `PieChartTypes.LabelsInsideSlices` | {@link PieChartWithLabelsInsideSlices} |
         *
         * @param options - Optional object with readonly configuration arguments for `PieChart`.
         * @returns Created chart.
         * @public
         */
        Pie: <PieChartType extends PieChartTypes = typeof PieChartWithLabelsOnSides>(options?: EngineOptions & PieChartOptions<PieChartType>) => InstanceType<PieChartType>;
        /**
         * Factory for `GaugeChart`. Gauge charts indicate where your data point(s) falls over a particular range.
         * This chart type is often used in executive dashboard reports to show key business indicators.
         *
         * To learn more about its features, refer to {@link SolidGauge}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `GaugeChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.Gauge({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `GaugeChart`.
         * @returns Created chart.
         * @public
         */
        Gauge: (options?: EngineOptions & CommonChartOptions) => GaugeChart;
        /**
         * Factory for `FunnelChart`. This chart visualizes proportions and percentages between categories.
         *
         * To learn more about its features, refer to {@link FunnelChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `FunnelChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.Funnel({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `FunnelChart` specific properties, refer to {@link FunnelChartOptions}.
         *
         * **Return type:**
         *
         * `FunnelChart` return type depends on supplied readonly configuration! Specifically, {@link FunnelChartOptions.type}.
         *
         * | Configuration `type` | Return chart type |
         * | :------------------- | :---------------- |
         * | `undefined` or omitted | {@link FunnelChartWithLabelsOnSides} |
         * | `FunnelChartTypes.LabelsOnSides` | {@link FunnelChartWithLabelsOnSides} |
         * | `FunnelChartTypes.LabelsInsideSlices` | {@link FunnelChartWithLabelsInsideSlices} |
         *
         * @param options - Optional object with readonly configuration arguments for `FunnelChart`.
         * @returns Created chart.
         * @public
         */
        Funnel: <FunnelChartType extends FunnelChartTypes = typeof FunnelChartWithLabelsOnSides>(options?: EngineOptions & FunnelChartOptions<FunnelChartType>) => InstanceType<FunnelChartType>;
        /**
         * Factory for `PyramidChart`. This chart visualizes proportions and percentages between categories.
         *
         * To learn more about its features, refer to {@link PyramidChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `PyramidChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.Pyramid({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `PyramidChart` specific properties, refer to {@link PyramidChartOptions}.
         *
         * **Return type:**
         *
         * `PyramidChart` return type depends on supplied readonly configuration! Specifically, {@link PyramidChartOptions.type}.
         *
         * | Configuration `type` | Return chart type |
         * | :------------------- | :---------------- |
         * | `undefined` or omitted | {@link PyramidChartWithLabelsOnSides} |
         * | `PyramidChartTypes.LabelsOnSides` | {@link PyramidChartWithLabelsOnSides} |
         * | `PyramidChartTypes.LabelsInsideSlices` | {@link PyramidChartWithLabelsInsideSlices} |
         *
         * @param options - Optional object with readonly configuration arguments for `PyramidChart`.
         * @returns Created chart.
         * @public
         */
        Pyramid: <PyramidChartType extends PyramidChartTypes = typeof PyramidChartWithLabelsOnSides>(options?: EngineOptions & PyramidChartOptions<PyramidChartType>) => InstanceType<PyramidChartType>;
        /**
         * Factory for `UIPanel`. This component can only be used to anchor *UI elements* outside of any particular *chart*.
         *
         * To learn more about its features, refer to {@link UIPanel}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `UIPanel` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create panel inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const panel = LightningChart.UIPanel({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-panel-div'
         *  })
         * ```
         *
         * For full list of available properties, refer to {@link EngineOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `UIPanel`.
         * @returns Created UI panel.
         * @public
         */
        UIPanel: (options?: EngineOptions & {
            legend?: LegendOptions;
        }) => UIPanel;
        /**
         * Factory for `MapChart`. This chart visualizes a Map of the selected part of the world. Defaults to the entire world.
         * It has built-in *cursor* functionality and supports dynamic region coloring.
         *
         * To learn more about its features, refer to {@link MapChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `MapChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, specify map type.
         *  const chart = LightningChart.Map({
         *      type: MapTypes.Europe
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `MapChart` specific properties, refer to {@link MapChartOptions}.
         *
         * **Required resources:**
         *
         * `MapChart` requires external file resources in order to work.
         * These resources are distributed along with the LightningChart JS package (`node_modules/@lightningchart/lcjs/dist/resources`).
         *
         * In order to use `MapChart` the map resources need to be hosted on a file server.
         * When `MapChart` is created, a GET request will be issued to URL: `<resourcesBaseUrl>/maps/<mapDataFile>`.
         *
         * The file server location can be specified by supplying a `resourcesBaseUrl`
         * (see {@link LightningChartOptions.resourcesBaseUrl}).
         *
         * The following table documents which resource files are required based on used *Map type*:
         *
         * | Map type                   | Map data file                             |
         * | :------------------------- | :---------------------------------------- |
         * | `MapTypes.World`           | `'countries_world.json'`                  |
         * | `MapTypes.Europe`          | `'countries_europe.json'`                 |
         * | `MapTypes.NorthAmerica`    | `'countries_northAmerica.json'`           |
         * | `MapTypes.SouthAmerica`    | `'countries_southAmerica.json'`           |
         * | `MapTypes.Africa`          | `'countries_africa.json'`                 |
         * | `MapTypes.Asia`            | `'countries_asia.json'`                   |
         * | `MapTypes.USA`             | `'states_usa.json'`                       |
         * | `MapTypes.Canada`          | `'territoriesProvinces_canada.json'`      |
         * | `MapTypes.Australia`       | `'territories_australia.json'`            |
         *
         * @param options - Optional object with readonly configuration arguments for `MapChart`.
         * @returns Created chart.
         * @public
         */
        Map: <SelectedMapType extends MapType, CursorResultTableBackgroundType extends UIBackground>(options?: EngineOptions & MapChartOptions<SelectedMapType, CursorResultTableBackgroundType>) => MapChart<SelectedMapType, CursorResultTableBackgroundType>;
        /**
         * Factory for `Chart3D`. This chart visualizes data in three dimensions.
         * It has built-in *Axis* and *camera* functionality, and supports a collection of different *series* types.
         *
         * To learn more about its features, refer to {@link Chart3D}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `Chart3D` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.Chart3D({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `Chart3D` specific properties, refer to {@link ChartOptions3D}.
         *
         * @param options - Optional object with readonly configuration arguments for `Chart3D`.
         * @returns Created chart.
         * @public
         */
        Chart3D: (options?: EngineOptions & ChartOptions3D) => Chart3D;
        /**
         * Create a {@link DataGrid} component.
         * This component visualizes data inside a grid structure using a variety of methods, such as text, numbers, spark charts and colored backgrounds.
         *
         * To learn more about its features, refer to {@link DataGrid}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `DataGrid` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create data grid inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const dataGrid = LightningChart.DataGrid({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For the full list of readonly configuration properties, refer to {@link EngineOptions}.
         *
         * @param options - Options object for creating a DataGrid.
         * @returns             DataGrid.
         * @public
         */
        DataGrid: (options?: EngineOptions) => DataGrid;
        /**
         * Create a {@link BarChart} component.
         * Chart type for visualizing categorical data as Bars.
         * Supports Positive and Negative data sets (baseline 0), and Bipolar data sets. These are automatically detected.
         *
         * To learn more about its features, refer to {@link BarChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `BarChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create bar chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.BarChart({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `BarChart` specific properties, refer to {@link BarChartOptions}.
         *
         * @param options - Options object for creating a BarChart.
         * @returns             BarChart.
         * @public
         */
        BarChart: (options?: EngineOptions & BarChartOptions) => BarChart;
        /**
         * Create a {@link ZoomBandChart} component.
         * Chart that is used to display a fully zoomed out view of 1 or more charts or series.
         * It also provides convenient built-in user interactions for interacting with the attached chart(s) that show the zoomed in view.
         *
         * By nature, ZoomBandChart does not host any original data. Rather, it is a duplicate of other data sets in order to simultaneously show both zoomed in view and fully zoomed out view.
         *
         * To learn more about its features, refer to {@link ZoomBandChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `ZoomBandChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.ZoomBandChart({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `ZoomBandChart` specific properties, refer to {@link ZoomBandChartOptions}.
         *
         * @param options - Options object for creating a ZoomBandChart.
         * @returns ZoomBandChart.
         * @public
         */
        ZoomBandChart: (options?: EngineOptions & ZoomBandChartOptions) => ZoomBandChart;
        /**
         * Factory for `TreeMapChart`. This chart visualizes hierarchical data in a tree-like structure.
         *
         * To learn more about its features, refer to {@link TreeMapChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `TreeMapChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         * // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         * const chart = LightningChart.TreeMapChart({
         *     // Argument can be either *element id* or actual reference to the HTML element.
         *     container: 'my-chart-div'
         * })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `TreeMapChart`.
         * @returns Created chart.
         * @public
         */
        TreeMapChart: (options?: EngineOptions & CommonChartOptions) => TreeMapChart;
        /**
         * Factory for `ParallelCoordinateChart`. This chart visualizes hierarchical data in a tree-like structure.
         *
         * To learn more about its features, refer to {@link ParallelCoordinateChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `ParallelCoordinateChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         * // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         * const chart = LightningChart.ParallelCoordinateChart({
         *     // Argument can be either *element id* or actual reference to the HTML element.
         *     container: 'my-chart-div'
         * })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `ParallelCoordinateChart`.
         * @returns Created chart.
         * @public
         */
        ParallelCoordinateChart: (options?: EngineOptions & CommonChartOptions) => ParallelCoordinateChart;
        /**
         * Calculate the layout of all charts within this context again.
         * Equivalent to {@link PublicEngine.layout} but applies to several charts.
         *
         * This is used to inform charts that their position may have changed as a result of an Event that the charts are not aware of.
         * For example, if the chart is positioned within a scrollable DIV.
         *
         * ```js
         *  // Example syntax, trigger chart layout when it is scrolled.
         *  div.onscroll = () => lc.layout()
         * ```
         * @public
         */
        layout(): void;
        /**
         * Dispose the shared context rendering engine and all of the charts created with it.
         * @public
         */
        dispose(): void;
    }
    /**
     * Function for initializing the LightningChart library.
     *
     * Returns the main interface of LCJS, which is used to create all top level components - *charts* and *dashboards*.
     *
     * ```typescript
     *  const lcjs = lightningChart({
     *      // Either supply license number, or omit for automatic community license.
     *      // license: 'my-license-number'
     *  })
     *
     *  // Create charts...
     *  const chart = lcjs.ChartXY()
     * ```
     *
     * - More information of available chart types and options: {@link LightningChart}
     * - More information of top level *LCJS* configuration (licensing, etc.): {@link LightningChartOptions}
     *
     *
     * @param arg1 - Object containing any properties supported by {@link LightningChartOptions} interface. Most importantly used for supplying *license* information.
     *                  *string* license can be supplied to support old syntax, but **this will be deprecated eventually**, consider using `{ license: 'my-license' }` syntax instead.
     * @param arg2 - Additional information for license verification. Only required by Application Deployment license.
     *                  Consider using `{ licenseInformation: ... }` arg1 syntax instead.
     * @returns A *LightningChart* object for creating *Charts* and components.
     * @public
     */
    export declare const lightningChart: (arg1?: LightningChartOptions | string, arg2?: AppDeploymentLicenseInformation) => LightningChart;
    /**
     * Interface for configuring LightningChart JS initialization, before any charts or series are created.
     *
     * Supplied when {@link lightningChart |`lightningChart`} function is called:
     *
     * ```typescript
     *  const lcjs = lightningChart({
     *      // Either supply license number, or omit for automatic community license.
     *      // license: 'my-license-number'
     *  })
     *
     *  // Create charts...
     *  const chart = lcjs.ChartXY()
     * ```
     * @public
     */
    export declare interface LightningChartOptions {
        /**
         * Optional development or deployment license. If omitted, a community license will be used.
         */
        license?: string;
        /**
         * Additional information for license verification. Only required by Application Deployment license.
         */
        licenseInformation?: AppDeploymentLicenseInformation;
        /**
         * Specify URL path to file server that hosts LightningChart JS resources.
         *
         * LightningChart JS is distributed along with some resource files, which are required for select features only:
         * - {@link MapChart} (`resources/maps/`)
         * - {@link OnScreenMenu} (`resources/osm/`)
         * - Themes with background pictures (`resources/themes`)
         *
         * When any of these features are used, the user has to ensure that the necessary resources are hosted on a file server where LightningChart JS can fetch them.
         * In official LightningChart JS example frameworks, templates and projects, this setup is usually done beforehand.
         *
         * _Example local file server with `http-server` from `node_modules`:_
         *
         * ```
         *  npm i --global http-server
         *  cd node_modules/@lightningchart/lcjs/dist/resources
         *  http-server --cors
         * ```
         *
         * ```js
         *  const lcjs = lightningChart({
         *      resourcesBaseUrl: 'http://127.0.0.1:8081', // <--- or whichever port http-server assigned.
         *  })
         * ```
         *
         * **Node Js:**
         *
         * When using LightningChart JS in Node JS environment with [lcjs-headless](https://github.com/Lightning-Chart/lcjs-headless) you will need to provide a path to the resource files.
         * This path needs to be provided with syntax `fs:<path>`. For example:
         *
         * ```js
         *  const lcjs = lightningChart({
         *      resourcesBaseUrl: `fs:${path.resolve(__dirname, 'node_modules', '@lightningchart', 'lcjs', 'dist', 'resources')}`
         *  })
         * ```
         *
         * **Troubleshooting:**
         *
         * If LightningChart JS can't fetch any required resource, it will result in an error.
         * Here is a list of common resource issues:
         *
         * **1. Resources are not hosted.**
         *
         * In LightningChart JS template projects, the hosting of resources is built-in.
         * However, in users own projects, it is the users responsibility to setup a file server for LightningChart JS resources if they are required.
         *
         * **2. Resources server URL is wrong.**
         *
         * Please make sure that the configured `resourcesBaseUrl` points to URL landing inside `resources` folder.
         *
         * `resourcesBaseUrl` should not end with a `'/'`.
         * For example, `'http://127.0.0.1:8081'` is a valid value. `'http://127.0.0.1:8081/'` might result in an error.
         *
         * **3. Request is CORS blocked.**
         *
         * A common issue especially when first starting development / testing.
         * For example, when hosting `resources` folder with `http-server` *npm module*, the extra `cors` flag must be supplied.
         *
         * ```bash
         *  cd node_modules/@lightningchart/lcjs/dist/resources
         *  http-server --cors
         * ```
         */
        resourcesBaseUrl?: string;
        /**
         * Optional configuration for instructing desired reaction to warnings that can have small side-effects, like decreasing performance or which might indicate issues in application code.
         *
         * By default these warnings are enabled, which might result in some output to browser console, stdout or such channels.
         *
         * By setting `warnings` to `false`, this kind of warnings can be disabled.
         *
         * ```js
         *  // Example syntax, disable low-level warnings.
         *  const chart = lightningChart({
         *      warnings: false
         *  }).ChartXY()
         * ```
         */
        warnings?: boolean;
        /**
         * Pass instructions regarding WebGL (rendering engine framework).
         */
        webgl?: {
            /**
             * Force specific WebGL version to be used.
             *
             * LightningChart JS supports WebGL versions 2 and 1.
             * WebGL 2 is used when available (better performance).
             *
             * If a specific version is selected, then it is always used, or if it is not available then the chart will crash.
             * This can be useful for debugging a specific WebGL version.
             */
            version?: 'webgl1' | 'webgl2';
        };
        /**
         * Options for shared context rendering.
         */
        sharedContextOptions?: {
            /**
             * Provide specific canvas element to use for rendering.
             *
             * Allows for more complex layout scenarios. Needed when HTML content is both under and above the charts.
             */
            canvas?: HTMLCanvasElement | string;
            /**
             * Prevent LCJS from adding it's default CSS styles to the canvas element.
             *
             * Can be useful in more complex layout scenarios.
             */
            noCanvasStyles?: boolean;
            /**
             * Disable LCJS automatically moving the canvas with scrolling to keep it in static position relative to browser viewport.
             *
             * Can be useful in more complex layout scenarios.
             */
            noCanvasTransform?: boolean;
            /**
             * Set preference for anti-aliasing.
             *
             * If set to true or undefined and browser supports anti-aliasing then the chart will be anti-aliased. If set to false or browser
             * doesn't support anti-aliasing then the chart will not be anti-aliased.
             */
            antialias?: boolean;
            /**
             * Device pixel ratio to use for composing the charts to final canvas.
             * Can be different from the pixel ratio used to render the charts.
             */
            devicePixelRatio?: boolean | number;
            /**
             * Disable automatic stacking order updates.
             *
             * Only used when not using individual canvas rendering method.
             *
             * This can improve performance on large dom trees when stacking of charts on top of each other is not required.
             *
             * Set to `false` to disable.
             * Enabled by default.
             */
            useStackingOrder?: boolean;
            /**
             * Enable the usage of individual canvas rendering.
             *
             * This rendering method provides better support for more complex web site layouts. The tradeoff is that on some browsers it adds significant overhead slowing down rendering.
             *
             * When enabled, each chart will have it's own canvas placed inside of the given container. This allows normal CSS and HTML layout usage to create complex overlapping layouts.
             *
             * The default rendering method uses a single canvas to render all charts. This provides a lot more consistent performance but comes with the drawback of making overlapping layouts harder to do and sometimes impossible.
             */
            useIndividualCanvas?: boolean;
        };
    }
    /**
     * Super class for LineSeries3D and PointLineSeries3D.
     *
     * Sub-classes only differ on joint styling logic.
     * @public
     */
    export declare abstract class LineAndPointSeries3D extends Series3D implements XYZDataInput {
        /**
         * Set stroke style of Series.
         *
         * Supported line styles:
         * - {@link SolidLine}
         *
         * ```ts
         *  // Example syntax, specify LineStyle
         *  LineSeries3D.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
         *  }))
         * ```
         *
         * ```ts
         *  // Example syntax, change active LineStyle
         *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(5))
         * ```
         *
         * Use `-1` thickness to enable primitive line rendering.
         * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
         * ```typescript
         *  LineSeries3D.setStrokeStyle((solidLine) => solidLine.setThickness(-1))
         * ```
         *
         * - **Supported fill styles:**
         *
         * {@link SolidFill}:
         *
         * Solid color for entire line series.
         *
         * ```ts
         *  // Example, solid colored line.
         *  LineSeries3D.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
         *  }))
         * ```
         *
         * To learn more about available *Color* factories, see {@link ColorRGBA}
         *
         * {@link PalettedFill}:
         *
         * Color line stroke dynamically based on `x`, `y` or `z` coordinate.
         *
         * ```ts
         *  // Example, dynamic color by Y coordinates
         *  LineSeries3D.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new PalettedFill({
         *          lookUpProperty: 'y',
         *          lut: new LUT({
         *              interpolate: true,
         *              steps: [
         *                  { value: 0, color: ColorRGBA(255, 0, 0) },
         *                  { value: 100, color: ColorRGBA(0, 255, 0) },
         *              ]
         *          })
         *      })
         *  }))
         * ```
         *
         * To learn more about Color lookup tables, see {@link LUT}.
         *
         * - **Primitive 3D line rendering**
         *
         * `LineSeries3D` has a special feature for drawing *primitive* line sets.
         *
         * When enabled, this will draw all line segments as exactly 1 pixel thick on the monitor (regardless of distance from camera).
         *
         * As a benefit, this is considerably lighter on the GPU, which is especially good with mobile and laptop devices with weak GPUs.
         *
         * *Primitive* drawing is enabled by setting stroke thickness to `-1`:
         *
         * ```ts
         *  // Enable primitive 3D line drawing.
         *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(-1))
         * ```
         *
         * - **Other information**
         *
         * In 3D, line thickness is not configured exactly as pixels (since the size of pixel is not affected by distance from camera).
         *
         * However, for usage convenience, you can consider line thickness in 3D as pixels just the same as 2D,
         * even if the resulting visualization will have some differences.
         *
         * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
         * @returns Object itself for fluent interface.
         * @public
         */
        setStrokeStyle(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D>): this;
        /**
         * Get normal line style (not highlighted).
         * @returns LineSeriesStyle3D
         * @public
         */
        getStrokeStyle(): LineSeriesStyle3D;
        /**
         * Add point or array of points to the series.
         * @param data - Point3D or array of points
         * @returns Object itself for fluent interface
         * @public
         */
        add(data: Point3D | Point3D[]): this;
        /**
         * Clear all previously pushed data points from the *series*.
         *
         * ```ts
         *  // Example usage
         *  LineSeries.clear()
         * ```
         *
         * @returns Object itself for fluent interface.
         * @public
         */
        clear(): this;
        /**
         * Get amount of points that series currently has.
         * @returns Number of points
         * @public
         */
        getPointAmount(): number;
        addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResult3D) => unknown, options?: LCJSAddEventListenerOptions): void;
        removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResult3D) => unknown): void;
    }
    /**
     * Linear Gradient fill style.
     *
     * Instances of LinearGradientFill are *immutable*, meaning that its setters don't modify the object,
     * but instead return a completely new modified object.
     * @public
     */
    export declare class LinearGradientFill extends LinearGradientFillStyleRecord implements Gradient, FillStyle {
        /** @public */
        constructor(props?: Partial<LinearGradientFillStyleProperties>);
        /**
         * Get CSS representation of the FillStyle.
         * @public
         */
        toCSS(): string;
        /**
         * Set color stops for the gradient.
         *
         * All style object setter methods return a new object rather than modifying the current one.
         * @param stops - Color Stops
         * @public
         */
        setColorStops(stops: ColorStop[]): this;
        /**
         * Get current color stops from the gradient.
         * @public
         */
        getColorStops(): ColorStop[];
        /**
         * Set the angle of the gradient line in degrees or radians.
         *
         * All style object setter methods return a new object rather than modifying the current one.
         * @param angle - Angle in degrees or radians. 0 degrees/radians is up. Clockwise rotation.
         * @param isRadians - Pass `true` if the angle provided is in radians.
         * @public
         */
        setAngle(angle: number, isRadians?: boolean): this;
        /**
         * Get the angle of the gradient line in degrees or radians.
         * @param isRadians - Pass `true` if radians is wanted.
         * @public
         */
        getAngle(isRadians?: boolean): number;
    }
    /**
     * Factory for creating a LinearGradientFill palette.
     * @param colorPalettes - Collection of default colors from PaletteFactory
     * @param amount - Amount of colors in the palette
     * @param angle - Angle for the Linear Gradient. Set to 90 degrees by default.
     * @returns A new LinearGradientFill palette
     * @public
     */
    export declare const LinearGradientFillPalette: (colorPalettes: PaletteFactory<Color>, amount: number, angle?: number, color?: Color) => Palette<FillStyle>;
    /**
     * Interface for all properties of a LinearGradient.
     * @public
     */
    export declare interface LinearGradientFillStyleProperties {
        type: 'fillstyle';
        fillType: 'linear-gradient';
        /**
         * Gradient Color stops
         */
        stops: ColorStop[];
        /**
         * Gradient angle in degrees
         */
        angle: number;
    }
    /**
     * Record contractor for LinearGradientFillStyleProperties.
     * @public
     */
    declare const LinearGradientFillStyleRecord: Record_2.Factory<LinearGradientFillStyleProperties>;
    /**
     * Implementation of Linear rendering Scale.
     * @public
     */
    declare class LinearScale1D extends ViewportScale1D {
        /**
         * Translate a pixel position on the viewport into corresponding coordinate on the Scale.
         * ( Viewport -\> Axis ).
         * @param viewportPosition - Position on viewport as pixels.
         * @returns Respective coordinate on Scale.
         */
        _getValueFromPixels(viewportPosition: pixel): number;
        /**
         * @returns Scale pixel size
         * @public
         */
        getPixelSize(): number;
        /**
         * Method that computes what pixel size the Scale would have, given its inner interval was equal to a supplied value.
         * @param innerInterval - Supposed inner interval.
         * @returns Pixel size.
         */
        _computePixelSize(innerInterval: number): number;
    }
    /**
     * Implementation of ScaleXY for a combination of two Linear Scales.
     *
     * Should be used in XY scales with only Linear scales (e.g. UI scales and Axis scales when no logarithmic scales are specified).
     */
    declare class LinearScaleXY extends ScaleXY<LinearScale1D> {
    }
    /**
     * Series type for visualizing a collection of `{ x, y, z }` coordinates by a continuous line stroke.
     *
     * `LineSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * **Creating LineSeries3D:**
     *
     * `LineSeries3D` are created with {@link Chart3D.addLineSeries} method.
     *
     * ```typescript
     *  // Example syntax, create line series 3D
     *  const lineSeries3D = Chart3D.addLineSeries()
     * ```
     *
     * **Frequently used methods:**
     *
     * - Append data points to series | {@link add}
     * - Remove all data points from series | {@link clear}
     * - Configure style of line stroke | {@link setStrokeStyle}
     * - Destory series permanently | {@link dispose}
     *
     * **Color shading style**.
     *
     * By default, `LineSeries3D` uses _Phong_ shading style.
     *
     * This can be changed with `LineSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())`
     *
     * **Related information:**
     *
     * To combine line stroke with markers over each data coordinate, {@link PointLineSeries3D} can be used.
     * @public
     */
    export declare class LineSeries3D extends LineAndPointSeries3D {
        /**
         * Set stroke style of Series.
         *
         * ```ts
         *  // Example syntax, specify LineStyle
         *  LineSeries3D.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
         *  }))
         * ```
         *
         * ```ts
         *  // Example syntax, change active LineStyle
         *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(5))
         * ```
         *
         * Use `-1` thickness to enable primitive line rendering.
         * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
         * ```typescript
         *  LineSeries3D.setStrokeStyle((solidLine) => solidLine.setThickness(-1))
         * ```
         *
         * - **Supported fill styles:**
         *
         * {@link SolidFill}:
         *
         * Solid color for entire line series.
         *
         * ```ts
         *  // Example, solid colored line.
         *  LineSeries3D.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
         *  }))
         * ```
         *
         * To learn more about available *Color* factories, see {@link ColorRGBA}
         *
         * {@link PalettedFill}:
         *
         * Color line stroke dynamically based on `x`, `y` or `z` coordinate.
         *
         * ```ts
         *  // Example, dynamic color by Y coordinates
         *  LineSeries3D.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new PalettedFill({
         *          lookUpProperty: 'y',
         *          lut: new LUT({
         *              interpolate: true,
         *              steps: [
         *                  { value: 0, color: ColorRGBA(255, 0, 0) },
         *                  { value: 100, color: ColorRGBA(0, 255, 0) },
         *              ]
         *          })
         *      })
         *  }))
         * ```
         *
         * To learn more about Color lookup tables, see {@link LUT}.
         *
         * - **Primitive 3D line rendering**
         *
         * `LineSeries3D` has a special feature for drawing *primitive* line sets.
         *
         * When enabled, this will draw all line segments as exactly 1 pixel thick on the monitor (regardless of distance from camera).
         *
         * As a benefit, this is considerably lighter on the GPU, which is especially good with mobile and laptop devices with weak GPUs.
         *
         * *Primitive* drawing is enabled by setting stroke thickness to `-1`:
         *
         * ```ts
         *  // Enable primitive 3D line drawing.
         *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(-1))
         * ```
         *
         * - **Other information**
         *
         * In 3D, line thickness is not configured exactly as pixels (since the size of pixel is not affected by distance from camera).
         *
         * However, for usage convenience, you can consider line thickness in 3D as pixels just the same as 2D,
         * even if the resulting visualization will have some differences.
         *
         * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
         * @returns Object itself for fluent interface.
         * @public
         */
        setStrokeStyle(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D>): this;
    }
    /**
     * Interface that can be used to specify readonly parameters when creating a {@link LineSeries3D}.
     *
     * `LineSeries3D` is created with {@link Chart3D.addLineSeries} method.
     * @public
     */
    export declare interface LineSeriesOptions3D extends SeriesOptions {
        /**
         * Flag that can be used to enable data points `value` property on top of `x`, `y` and `z`.
         * By default this is disabled.
         *
         * This feature can be used to color data points individually by dynamic color look up.
         *
         * If required, this must be enabled **when the series is created**.
         *
         * ```js
         *  // Example, enable PointSeries3D data `value` property.
         *  const pointSeries3D = chart3D.addPointSeries({
         *      individualLookupValuesEnabled: true
         *  })
         *
         *  // 'value' property can now be included in data points.
         *  pointSeries3D.add([
         *      { x: 0, y: 0, z: 0, value: 5 }
         *  ])
         * ```
         *
         * `individualLookupValuesEnabled` must be enabled in order to style `PointSeries3D` with {@link PalettedFill} of `lookUpProperty: 'value'`.
         * See {@link PointSeries3D.setPointStyle} for more detailed information.
         *
         * **Performance side-effects from enabling**:
         * - With detailed point geometry (like 'sphere'), the geometry precision will be maximized, resulting in considerable increase in GPU processing time.
         */
        individualLookupValuesEnabled?: boolean;
    }
    /**
     * Type union of LineStyle types supported by LineSeries3D.
     *
     * Supports only `PalettedFill` and `SolidFill` fill styles!
     * @public
     */
    export declare type LineSeriesStyle3D = SolidLine;
    /**
     * Base interface for *line styles*.
     *
     * For implementations with more detailed documentation, see:
     * - {@link SolidLine}
     * - {@link DashedLine}
     * - {@link emptyLine}
     * @public
     */
    export declare interface LineStyle {
        /**
         * @public
         */
        readonly type: 'linestyle';
        /**
         * @public
         */
        readonly lineType: 'solid' | 'empty' | 'dashed';
        /**
         * Construct a new LineStyle object based on this one, but with modified thickness.
         *
         * -1 can be used to signify smallest available thickness.
         * With most features, this will result in slightly better GPU performance, but less detailed line.
         *
         * @param thickness - Thickness as pixels.
         * @public
         */
        setThickness(thickness: number): this;
        /**
         * Get thickness of the LineStyle
         * @returns Thickness as pixels
         * @public
         */
        getThickness(): number;
        /**
         * Construct a new LineStyle object based on this one, but with modified fill style.
         *
         * Example (SolidFill):
         * ```javascript
         * // specify new fillstyle
         * solidLineStyle.setFillStyle( new SolidFill({
         *  color: ColorHex('#F00')
         * }) )
         * // change fillstyle properties
         * solidLineStyle.setFillStyle(
         *  solidfill => solidfill.setA( 80 )
         * )
         * ```
         * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
         * @returns New LineStyle object
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): LineStyle;
        /**
         * Get fill style of the LineStyle.
         * @returns FillStyle object
         * @public
         */
        getFillStyle(): FillStyle;
    }
    /**
     * Implementation of Logarithmic rendering Scale.
     * @public
     */
    declare class LogarithmicScale1D extends ViewportScale1D {
    }
    /**
     * Type union of possible values for 'lookUpProperty' configuration of a {@link PalettedFill}.
     *
     * Points to a property to be used when picking colours from a Look Up Table.
     *
     * - **"value"**: LUT value is taken from a separate value that can be set by user by some Series-specific logic.
     * - **"x"**: LUT value is taken directly from data points X coordinate.
     * - **"y"**: LUT value is taken directly from data points Y coordinate.
     * - **"z"**: LUT value is taken directly from data points Z coordinate.
     *
     * Use alongside {@link PalettedFill} and {@link LUT}.
     * @public
     */
    export declare type LookUpProperty = 'value' | 'x' | 'y' | 'z';
    /**
     * Style class for describing a *table of colors* with associated lookup values (numbers).
     *
     * Instances of LUT, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
     * but instead return a completely new modified object.
     *
     * **Properties of LUT:**
     * - `steps`: List of color steps (color + number value pair).
     * - `interpolate`: `true` enables automatic linear interpolation between color steps.
     *
     * **LUT Behavior:**
     *
     * Example 1, LUT with *interpolation disabled*.
     *
     * ```typescript
     *  const lut = new LUT({
     *      steps: [
     *          { value: 0, color: ColorRGBA( 0, 0, 0 ) },
     *          { value: 10, color: ColorRGBA( 255, 0, 0 ) },
     *          { value: 100, color: ColorRGBA( 0, 255, 0 ) }
     *      ],
     *      interpolate: false
     *  })
     * ```
     *
     * | Lookup Value | Color |
     * |--------------|-------|
     * | value \< 10         | black |
     * | 10 \<= value \< 100  | red   |
     * | 100 \<= value       | green |
     *
     *
     * Example 2, LUT with *interpolation enabled*.
     *
     * ```typescript
     *  const lut = new LUT({
     *      steps: [
     *          { value: 0, color: ColorRGBA( 0, 0, 0 ) },
     *          { value: 10, color: ColorRGBA( 255, 0, 0 ) },
     *          { value: 100, color: ColorRGBA( 0, 255, 0 ) }
     *      ],
     *      interpolate: true
     *  })
     * ```
     *
     * | Lookup Value | Color |
     * |--------------|-------|
     * | value \<= 0         | black |
     * | 0 \< value \< 10     | interpolated between black and red |
     * | 10 \< value \< 100   | interpolated between red and green |
     *
     *
     * **LUT Usage:**
     *
     * Use *LUT* with:
     * - {@link PalettedFill} for styling *series* based on different lookup values (user supplied data, x/y/z coordinates, ...)
     * - Sliced charts for styling slices dynamically based on their value
     *      * {@link PieChart.setLUT}
     *      * {@link GaugeChart.setLUT}
     *      * {@link PyramidChart.setLUT}
     *      * {@link FunnelChart.setLUT}
     *
     * @public
     */
    export declare class LUT extends LUTRecord {
        /**
         * Construct a LUT object, specifying any amount of its properties.
         *
         * Example 1, LUT with *interpolation disabled*.
         *
         * ```typescript
         *  const lut = new LUT({
         *      steps: [
         *          { value: 0, color: ColorRGBA( 0, 0, 0 ) },
         *          { value: 10, color: ColorRGBA( 255, 0, 0 ) },
         *          { value: 100, color: ColorRGBA( 0, 255, 0 ) }
         *      ],
         *      interpolate: false
         *  })
         * ```
         *
         * Example 2, LUT with *interpolation enabled*.
         *
         * ```typescript
         *  const lut = new LUT({
         *      steps: [
         *          { value: 0, color: ColorRGBA( 0, 0, 0 ) },
         *          { value: 10, color: ColorRGBA( 255, 0, 0 ) },
         *          { value: 100, color: ColorRGBA( 0, 255, 0 ) }
         *      ],
         *      interpolate: true
         *  })
         * ```
         *
         * @param props - Object containing any amount of LUT properties.
         * @public
         */
        constructor(options: LUTOptions);
        /**
         * Set new collection of LUT steps.
         *
         * All style object setter methods return a new object rather than modifying the current one.
         * @param steps - Collection of color-value pairs.
         * @public
         */
        setSteps(steps: LUTStep[]): this;
        /**
         * Get collection of LUT steps.
         * @returns Collection of steps.
         * @public
         */
        getSteps(): LUTStep[];
        /**
         * Set title of the LUT, which describes the data.
         *
         * All style object setter methods return a new object rather than modifying the current one.
         * @param title - Title of the LUT.
         * @public
         */
        setTitle(title: string): this;
        /**
         * Get title of the LUT.
         * @returns Title of the LUT as string.
         * @public
         */
        getTitle(): string;
        /**
         * Set units of the data-values in the LUT, which describes the data domain.
         *
         * All style object setter methods return a new object rather than modifying the current one.
         * @param units - Units of the LUT.
         * @public
         */
        setUnits(units: string): this;
        /**
         * Get units of the LUT.
         * @returns Units of the LUT as string.
         * @public
         */
        getUnits(): string;
        /**
         * Set interpolation behavior of the LUT, which describes the distribution of color for the data:
         * - True: creates a ***gradient*** LUT using linear-interpolation (LERP) between colors,
         * which were defined in the collection of steps.
         * - False: creates a ***uniform*** LUT using step-function for each color
         * to describe the range of values where this color is used.
         *
         * All style object setter methods return a new object rather than modifying the current one.
         * @param interpolate - Interpolation behavior: True - gradient, False - uniform.
         * @public
         */
        setInterpolation(interpolate: boolean): this;
        /**
         * Get interpolation behavior of the LUT.
         * @returns Intepolation behaviour state. True - gradient, False - uniform.
         * @public
         */
        getInterpolation(): boolean;
        /**
         * Set fallback color.
         * The following color would be used as a backup.
         * Meaning, the LUT might be configured incorrectly or the data is incorrect.
         *
         * All style object setter methods return a new object rather than modifying the current one.
         * @param color - Color object.
         * @public
         */
        setFallbackColor(color: Color): this;
        /**
         * Get fallback color of value the LUT.
         * @returns Color object.
         * @public
         */
        getFallbackColor(): Color;
        /**
         * Set whether values represent percentages or explicit values.
         *
         * See {@link ValuePaletteOptions.percentageValues} for more information.
         *
         * All style object setter methods return a new object rather than modifying the current one.
         * @param   percentageValues - Boolean.
         * @public
         */
        setPercentageValues(percentageValues: boolean): this;
        /**
         * Get whether values represent percentages or explicit values.
         *
         * See {@link ValuePaletteOptions.percentageValues} for more information.
         * @returns     Boolean.
         * @public
         */
        getPercentageValues(): boolean;
        /**
         * Set LUT formatter.
         *
         * See {@link ValuePaletteOptions.formatter} for more information.
         *
         * All style object setter methods return a new object rather than modifying the current one.
         * @param   formatter - Formatter function.
         * @public
         */
        setFormatter(formatter: (value: number, info: {
            min: number;
            max: number;
        }) => string): this;
        /**
         * Get LUT formatter.
         *
         * See {@link ValuePaletteOptions.formatter} for more information.
         * @returns     Formatter function.
         * @public
         */
        getFormatter(): (value: number, info: {
            min: number;
            max: number;
        }) => string;
        /**
         * Get the color associated with the given value.
         *
         * Example:
         * ```javascript
         * const color = lut.getColors( 5 )
         * ```
         * @param values - Single value.
         * @returns Associated color if the LUT is valid, otherwise fallback color.
         * @public
         */
        getColors(values: number, valueRange: {
            min: number;
            max: number;
        } | undefined): Color;
        /**
         * Get the colors associated with the given collection of values.
         *
         * Example:
         * ```javascript
         * const colors = lut.getColors( [ 5, 10, 15 ] )
         * ```
         * @param values - 1D collection of value.
         * @returns Collection of associated colors if the LUT is valid, otherwise fallback colors.
         * @public
         */
        getColors(values: number[], valueRange: {
            min: number;
            max: number;
        } | undefined): Color[];
        /**
         * Get the colors associated with the given collection Matrix2D of values.
         *
         * Example:
         * ```javascript
         * const colors = lut.getColors(
         *  [
         *    [ 3, 7, 9 ],
         *    [ 5, 10, 15 ]
         *  ]
         * )
         * ```
         * @param values - 2D collection of values.
         * @returns Collection of associated colors if the LUT is valid, otherwise fallback colors.
         * @public
         */
        getColors(values: number[][], valueRange: {
            min: number;
            max: number;
        } | undefined): Color[][];
    }
    /**
     * Interface defines a *LUT* lookup table configurations.
     * @public
     */
    export declare type LUTOptions = LUTStepsOptions & Partial<ValuePaletteOptions>;
    /**
     * Record constructor for PaletteProperties.
     * @public
     */
    declare const LUTRecord: Record_2.Factory<LUTRecordType>;
    /**
     * Record property object.
     * @public
     */
    export declare type LUTRecordType = LUTStepsOptions & ValuePaletteOptions & LUTStateOptions & {
        type: 'lut';
    };
    /**
     * Interface to define a LUT options which were recomputed after each LUT update.
     * @public
     */
    export declare interface LUTStateOptions {
        /**
         * Amount of LUT steps.
         */
        length: number;
        /**
         * Minimal value of the entire LUT.
         */
        min: number;
        /**
         * Maximal value of the entire LUT.
         */
        max: number;
        /**
         * Collection of subranges.
         */
        subranges: SubRange[];
        /**
         * Validation flag which describes that the LUT is configured correctly.
         */
        isValid: boolean;
    }
    /**
     * Interface to specify the color and its value.
     * Each represented as a pair object \{value: number, color: Color\}.
     * @public
     */
    export declare interface LUTStep {
        /**
         * Value/percentage associated with a color.
         */
        value: number;
        /**
         * Color at given step.
         */
        color: Color;
        /**
         * Optional label to show on given step.
         *
         * Can be specified to alter default labels when the component that uses the `LUT` is attached to a `Legend`.
         *
         * ```typescript
         *  // Example, map Uint8 data range to Decibels range [0, 140].
         *  const lut = new LUT({
         *      steps: [
         *          { value: 0, label: '0', color: ColorHSV(0) },
         *          { value: 127.5, label: '70', color: ColorHSV(120) },
         *          { value: 255.0, label: '140', color: ColorHSV(240) },
         *      ],
         *      units: 'dB',
         *      interpolate: true,
         *  })
         * ```
         */
        label?: string;
    }
    /**
     * Interface to store the collection of LUTSteps.
     * @public
     */
    export declare interface LUTStepsOptions {
        /**
         * The collection of LUTSteps, which specifies the colors and their corresponding values
         * to describe the location and color of a transition point in a gradient.
         * Each represented as a pair object \{value: number, color: Color\}.
         *
         * Default value: [].
         */
        steps: LUTStep[];
    }
    /**
     * Chart class for visualizing a Map of a selected part of the world. Defaults to the entire world.
     *
     * `MapChart` can be created in two different ways - to learn more about creation time configuration of `MapChart`, please refer to:
     * - {@link LightningChart.Map} (stand-alone chart).
     * - {@link Dashboard.createMapChart} (chart inside *dashboard*).
     *
     * **MapChart features**
     *
     * 1. Map Types
     *
     * `MapChart` supports 9 different *map types*, each of which depicts a different part of the world.
     * *Map types* can also be split based on different types of *regions*, like *countries, states, territories, provinces*, etc.
     *
     * Supported {@link MapTypes | map types}:
     *
     * - `MapTypes.World`         | Map of the whole world, regions as countries.
     * - `MapTypes.Europe`        | Map of Europe, regions as countries.
     * - `MapTypes.Africa`        | Map of Africa, regions as countries.
     * - `MapTypes.Asia`          | Map of Asia, regions as countries.
     * - `MapTypes.NorthAmerica`  | Map of North America, regions as countries.
     * - `MapTypes.SouthAmerica`  | Map of South America, regions as countries.
     * - `MapTypes.Australia`     | Map of Australia, regions as Australian territories.
     * - `MapTypes.USA`           | Map of the United States of America, regions as states.
     * - `MapTypes.Canada`        | Map of Canada, regions as Canadian territories and provinces.
     *
     * Map type is selected when the `MapChart` is created, with the `type` argument:
     *
     * ```typescript
     *  // Example, specify map type.
     *  const mapChart = lightningChart().Map({
     *      type: MapTypes.Europe,
     *  })
     * ```
     *
     * 2. Style and dynamic region coloring
     *
     * `MapChart` has two style properties: region *fill* style and *stroke* style.
     * The style is shared for all regions.
     *
     * Style is configured with
     * - {@link MapChart.setFillStyle}.
     * - {@link MapChart.setStrokeStyle}.
     *
     * Dynamic region coloring is possibly by configuring *fill* style with {@link PalettedFill}.
     *
     * ```typescript
     *  // Example, enable dynamic region coloring based on a color look-up table.
     *  MapChart.setFillStyle(new PalettedFill({
     *      lut: new LUT({
     *          interpolate: true,
     *          steps: [
     *              { value: 0, color: ColorRGBA(255, 0, 0) },
     *              { value: 100, color: ColorRGBA(0, 255, 0) }
     *          ]
     *      })
     *  }))
     * ```
     *
     * Region values used for color look-up are configured with {@link MapChart.invalidateRegionValues}.
     * This method is very flexible and can be used in a variety of ways - refer to the method documentation for more examples.
     *
     * ```typescript
     *  // Example, set value of "Finland" region to `0`.
     *  MapChart.invalidateRegionValues([
     *      { value: 0, ISO_A3: 'FIN' }
     *  ])
     * ```
     *
     * 3. Cursor
     *
     * `MapChart` has built-in *Cursor* functionality, which is activated when
     * user pointer is above any region.
     *
     * *Auto cursor* can be configured in a variety of ways:
     * - {@link MapChart.setCursorResultTableFormatter} | configure formatting of *result table* contents.
     * - {@link MapChart.setCursor} | style auto cursor.
     * - {@link MapChart.setCursorMode} | disable / enable *auto cursor*.
     *
     *
     * **Required resources:**
     *
     * `MapChart` requires external file resources in order to work.
     * These resources are distributed along with the LightningChart JS package (`node_modules/@lightningchart/lcjs/dist/resources`).
     *
     * In order to use `MapChart` the map resources need to be hosted on a file server.
     * When `MapChart` is created, a GET request will be issued to URL: `<resourcesBaseUrl>/maps/<mapDataFile>`.
     *
     * The file server location can be specified by supplying a `resourcesBaseUrl`, please see {@link LightningChartOptions.resourcesBaseUrl} for general information and troubleshooting on LCJS resources.
     *
     * The following table documents which resource files are required based on used *Map type*:
     *
     * | Map type                   | Map data file                             |
     * | :------------------------- | :---------------------------------------- |
     * | `MapTypes.World`           | `'countries_world.json'`                  |
     * | `MapTypes.Europe`          | `'countries_europe.json'`                 |
     * | `MapTypes.NorthAmerica`    | `'countries_northAmerica.json'`           |
     * | `MapTypes.SouthAmerica`    | `'countries_southAmerica.json'`           |
     * | `MapTypes.Africa`          | `'countries_africa.json'`                 |
     * | `MapTypes.Asia`            | `'countries_asia.json'`                   |
     * | `MapTypes.USA`             | `'states_usa.json'`                       |
     * | `MapTypes.Canada`          | `'territoriesProvinces_canada.json'`      |
     * | `MapTypes.Australia`       | `'territories_australia.json'`            |
     * @public
     */
    export declare class MapChart<SelectedMapType extends MapType = MapType, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends Chart implements Highlightable, ChartWithCursor<CursorResultTableBackgroundType, CursorPosition2D, Cursor2D<CursorResultTableBackgroundType>, SolveResultMap<SelectedMapType>> {
        /**
         * Interface for attaching listeners to user interaction events (`click`, `pointerenter`, etc.) on MapChart regions.
         *
         * ```ts
         *  // Example syntax
         *  chart.regions.addEventListener('click', (event, region) => {
         *      console.log(event, region)
         *  })
         * ```
         *
         * For more syntax examples, refer to {@link EventInterface}.
         * Available event keys are listed under {@link LCJSInteractionEventMap}
         * @public
         */
        readonly regions: Eventer<LCJSInteractionEventMap, MapTypeRegionProperties[SelectedMapType]>;
        /**
         * Set Fill Style of Map regions.
         *
         * **Example usage:**
         *
         * {@link SolidFill}:
         *
         * All Map regions are filled with a single color.
         *
         * ```typescript
         *  // Example, solid color MapChart.
         *  MapChart.setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         * ```
         *
         * {@link PalettedFill}:
         *
         * Each Map region is colored with an individual color.
         * Coloring basis is further based on `lookUpProperty` of the `PalettedFill`:
         *
         * `lookUpProperty: 'value'`:
         *
         * Each region is colored with a solid color that is looked up from the attached {@link LUT}
         * by the active value of that region, as configured with {@link invalidateRegionValues} method.
         *
         * ```typescript
         *  // Example, MapChart color look-up based on region values.
         *  const mapChart = lightningChart().Map({
         *      type: MapTypes.Europe
         *  })
         *  mapChart.setFillStyle(new PalettedFill({
         *      lookUpProperty: 'value',
         *      lut: new LUT({
         *          interpolate: true,
         *          steps: [
         *              { value: 0, color: ColorRGBA(0, 0, 0) },
         *              { value: 100, color: ColorRGBA(0, 255, 0) }
         *          ]
         *      })
         *  }))
         *  // Assign value for "Finland" region.
         *  mapChart.invalidateRegionValues([{ value: 100, ISO_A3: 'FIN' }])
         * ```
         *
         * `lookUpProperty: 'x' | 'y'`:
         *
         * Each pixel color of the map is looked up from the attached {@link LUT} by the respective
         * *longitude* (`'x'`), or *latitude* (`'y'`) coordinate.
         *
         * ```typescript
         *  // Example, MapChart color look-up based on longitude.
         *  const mapChart = lightningChart().Map({
         *      type: MapTypes.Europe
         *  })
         *  mapChart.setFillStyle(new PalettedFill({
         *      lookUpProperty: 'x',
         *      lut: new LUT({
         *          interpolate: false,
         *          steps: [
         *              { value: -180, color: ColorRGBA(0, 0, 0) },
         *              { value: 20, color: ColorRGBA(0, 255, 0) },
         *              { value: 32, color: ColorRGBA(0, 0, 0) },
         *          ]
         *      })
         *  }))
         * ```
         *
         * {@link LinearGradientFill}:
         *
         * Each pixel color of the map is colored according to a *linear gradient*.
         *
         * ```typescript
         *  // Example, color MapChart with linear gradient.
         *  MapChart.setFillStyle(new LinearGradientFill({
         *      angle: 45,
         *      stops: [
         *          { offset: 0.0, color: ColorRGBA(255, 0, 0) },
         *          { offset: 1.0, color: ColorRGBA(0, 255, 0) }
         *      ]
         *  }))
         * ```
         *
         * {@link RadialGradientFill}:
         *
         * Each pixel color of the map is colored according to a *radial gradient*.
         *
         * ```typescript
         *  // Example, color MapChart with radial gradient.
         *  MapChart.setFillStyle(new RadialGradientFill({
         *      position: { x: 0.8, y: 0.7 },
         *      stops: [
         *          { offset: 0.0, color: ColorRGBA(255, 0, 0) },
         *          { offset: 1.0, color: ColorRGBA(0, 0, 255) }
         *      ]
         *  }))
         * ```
         *
         * {@link emptyFill}:
         *
         * Map regions are not filled.
         *
         * @param value - Either a {@link FillStyle} object or a function,
         *                      which will be used to create a new FillStyle based on current Fill Style.
         * @returns MapChart itself.
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get Fill Style of Map regions.
         * @returns FillStyle.
         * @public
         */
        getFillStyle(): FillStyle;
        /**
         * Set Stroke style of Map regions.
         *
         * **Example usage:**
         *
         * {@link SolidLine}:
         *
         * All Map regions edges are drawn with a stroke.
         *
         * ```typescript
         *  // Example, solid region stroke
         *  MapChart.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
         *  }))
         * ```
         *
         * {@link emptyLine}:
         *
         * Regions edges are not drawn with a stroke.
         *
         * @param value - `LineStyle` or function which mutates the active `LineStyle`.
         * @returns Object itself
         * @public
         */
        setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get Stroke Style of Map regions.
         * @returns {@link LineStyle}.
             * @public
             */
         getStrokeStyle(): LineStyle;
         /**
          * Set theme effect enabled on component or disabled.
          *
          * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
          * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
          *
          * ```ts
          *  // Example, disable theme effect from a particular component.
          *  Component.setEffect(false)
          * ```
          *
          * For the most part, theme effects are **enabled** by default on most components.
          *
          * Theme effect is configured with {@link Theme.effect} property.
          *
          * @param enabled - Theme effect enabled
          * @returns          Object itself.
          * @public
          */
         setEffect(enabled: boolean): this;
         /**
          * Get theme effect enabled on component or disabled.
          *
          * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
          * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
          *
          * ```ts
          *  // Example, disable theme effect from a particular component.
          *  Component.setEffect(false)
          * ```
          *
          * For the most part, theme effects are **enabled** by default on most components.
          *
          * Theme effect is configured with {@link Theme.effect} property.
          *
          * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
          * @public
          */
         getEffect(): boolean;
         /**
          * Set {@link FillStyle} of *outlier regions* (parts of map that are visible, but not interactable with active map type).
          *
          * ```typescript
          *  // Example usage,
          *  MapChart.setOutlierRegionFillStyle(new SolidFill({ color: ColorRGBA( 80, 0, 0 ) }))
          * ```
          * @param value - `FillStyle` or function which mutates the active `FillStyle`.
          * @returns Object itself
          * @public
          */
         setOutlierRegionFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
         /**
          * Get {@link FillStyle} of *outlier regions* (parts of map that are visible, but not interactable with active map type).
          *
          * @returns FillStyle
          * @public
          */
         getOutlierRegionFillStyle(): FillStyle;
         /**
          * Set {@link LineStyle} of *outlier regions* (parts of map that are visible, but not interactable with active map type).
          *
          * ```typescript
          *  // Example usage,
          *  MapChart.setOutlierRegionStrokeStyle(new SolidLine({
          *      thickness: 2,
          *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
          *  }))
          * ```
          * @param value - `LineStyle` or function which mutates the active `LineStyle`.
          * @returns Object itself
          * @public
          */
         setOutlierRegionStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
         /**
          * Get {@link LineStyle} of *outlier regions* (parts of map that are visible, but not interactable with active map type).
          *
          * @returns LineStyle
          * @public
          */
         getOutlierRegionStrokeStyle(): LineStyle;
         /**
          * Set {@link FillStyle} of *separate regions*, which are visual components surrounding areas such as *Alaska* and *Hawaii*.
          *
          * Separate regions are present in following {@link MapTypes | Map types}:
          * - `MapTypes.USA`
          *
          * ```typescript
          *  // Example usage,
          *  MapChart.setSeparateRegionFillStyle(new SolidFill({ color: ColorRGBA( 80, 0, 0 ) }))
          * ```
          * @param value - `FillStyle` or function which mutates the active `FillStyle`.
          * @returns Object itself
          * @public
          */
         setSeparateRegionFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
         /**
          * Get {@link FillStyle} of *Separate regions*, which are visual components surrounding areas such as *Alaska* and *Hawaii*.
          *
          * Separate regions are present in following {@link MapTypes | Map types}:
          * - `MapTypes.USA`
          *
          * @returns FillStyle
          * @public
          */
         getSeparateRegionFillStyle(): FillStyle;
         /**
          * Set {@link LineStyle} of *Separate regions*, which are visual components surrounding areas such as *Alaska* and *Hawaii*.
          *
          * Separate regions are present in following {@link MapTypes | Map types}:
          * - `MapTypes.USA`
          *
          * ```typescript
          *  // Example usage,
          *  MapChart.setSeparateRegionStrokeStyle(new SolidLine({
          *      thickness: 2,
          *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
          *  }))
          * ```
          * @param value - `LineStyle` or function which mutates the active `LineStyle`.
          * @returns Object itself
          * @public
          */
         setSeparateRegionStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
         /**
          * Get {@link LineStyle} of *Separate regions*, which are visual components surrounding areas such as *Alaska* and *Hawaii*.
          *
          * Separate regions are present in following {@link MapTypes | Map types}:
          * - `MapTypes.USA`
          *
          * @returns LineStyle
          * @public
          */
         getSeparateRegionStrokeStyle(): LineStyle;
         /**
          * Invalidate numeric values associated with each *region* of the Map using a callback function that is called for every region.
          *
          * Region values can be used in conjuction with:
          *
          * - DataCursor:
          *
          * The values can be displayed when user puts the mouse above a *region*. Modify DataCursor parsing with
          * {@link MapChart.setCursorResultTableFormatter}
          *
          * - FillStyle:
          *
          * Each *region* can be styled based on its assigned value, by setting the MapCharts' fill style to a
          * {@link PalettedFill}.
          *
          * **Example usage:**
          *
          * ``` ts
          *  // Example, Set a random value [0, 100] for each region.
          *  MapChart.invalidateRegionValues( ( region, prev ) => Math.random() * 100 )
          * ```
          *
          * In a more realistic application, you would look up a value from an external data set based on the `region`.
          * The properties available from `region` are based on the used {@link MapType}, see {@link MapTypeRegionProperties} for a list of supported properties.
          *
          * ```typescript
          *  // Example, invalidate region values by external data set.
          *  fetch(...)
          *      .then((data) => {
          *          MapChart.invalidateRegionValues((region) => {
          *              // Look up value for `region`.
          *              const value = data[region.name]
          *              return value || 0
          *          })
          *      })
          * ```
          *
          * @param callback - Function that is called for each region.
          *                      First parameter is a region data structure, that can be used to identify each region.
          *                      Second parameter is the previous value if any.
          * @returns MapChart itself.
          * @public
          */
         invalidateRegionValues(callback: (region: MapTypeRegionProperties[SelectedMapType], prev?: number) => number | undefined): this;
         /**
          * Invalidate numeric values associated with each *region* of the Map using an Array of identifier-value objects.
          *
          * Region values can be used in conjuction with:
          *
          * - DataCursor:
          *
          * The values can be displayed when user puts the mouse above a *region*. Modify DataCursor parsing with
          * {@link MapChart.setCursorResultTableFormatter}
          *
          * - FillStyle:
          *
          * Each *region* can be styled based on its assigned value, by setting the MapCharts' fill style to a
          * {@link PalettedFill}
          *
          * **Example usage**:
          *
          * - Select region by name or other property supported by the used {@link MapTypes}.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { value: 0, name: 'Finland' }
          *  ])
          * ```
          *
          * In place of 'name', any property supported by the used {@link MapType} can be supplied.
          * Look up {@link MapTypeRegionProperties} for a map of supported properties per *MapType*.
          *
          * ``` ts
          *  // MapTypes that plot *Countries* (for example, 'World', 'Europe') also support 'ISO_A3' country codes.
          *  MapChart.invalidateRegionValues([
          *      { value: 0, ISO_A3: 'FIN' }
          *  ])
          * ```
          *
          * - For quick access, you can also refer to the *region* list of the used *MapType* that is accessed through {@link MapRegions}.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { value: 0, ...MapRegions[ MapTypes.World ].Finland }
          *  ])
          * ```
          *
          * @param values - Array of identifier-value objects.
          * @returns MapChart itself.
          * @public
          */
         invalidateRegionValues(values: Array<(Partial<MapTypeRegionProperties[SelectedMapType]> & {
             value: number;
         }) | undefined>): this;
         /**
          * Set mouse interactions enabled or disabled.
          *
          * Disabling mouse interactions can have a positive impact on performance.
          *
          * @param state - Specifies state of mouse interactions
          * @returns Object itself for fluent interface
          * @public
          */
         setPointerEvents(state: boolean): this;
         /**
          * Get mouse interactions enabled or disabled.
          * @returns Mouse interactions state
          * @public
          */
         getPointerEvents(): boolean;
         /**
          * Set state of component highlighting.
          *
          * ```ts
          *  // Example usage
          *
          *  component.setHighlight(true)
          *
          *  component.setHighlight(0.5)
          * ```
          *
          * If highlight animations are enabled (which is true by default), the transition will be animated.
          * As long as the component is highlighted, the active highlight intensity will be animated continuously between 0 and the configured value.
          * Highlight animations can be disabled with {@link setAnimationHighlight}
          *
          * **In case of MapChart, this method only considers the complete highlighting of MapChart, not highlighting individual regions**
          *
          * This method does not work before map data is loaded. See {@link onMapDataReady}
          *
          * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
          * @returns Object itself
          * @public
          */
         setHighlight(highlight: boolean | number): this;
         /**
          * Get state of component highlighting.
          *
          * In case highlight animations are enabled, this method returns the **unanimated highlight value**.
          *
          * **In case of MapChart, this method only considers the complete highlighting of MapChart, not highlighting individual regions**
          *
          * @returns Number between 0 and 1, where 1 is fully highlighted.
          * @public
          */
         getHighlight(): number;
         /**
          * Set component highlight animations enabled or not.
          * For most components this is enabled by default.
          *
          * ```ts
          *  // Example usage, disable highlight animations.
          *  component.setAnimationHighlight(false)
          * ```
          *
          * This method does not work before map data is loaded. See {@link onMapDataReady}
          *
          * @param   enabled    - Animation enabled?
          * @returns            Object itself
          */
         setAnimationHighlight(enabled: boolean): this;
         /**
          * Get component highlight animations enabled or not.
          *
          * @returns      Animation enabled?
          */
         getAnimationHighlight(): boolean;
         /**
          * Set highlight on mouse hover enabled or disabled.
          *
          * Mouse interactions have to be enabled on the component for this to function as expected.
          * See {@link setMouseInteractions} for more information.
          *
          * @param state - True if highlighting on mouse hover, false if no highlight on mouse hover
          * @returns Object itself for fluent interface.
          * @public
          */
         setHighlightOnHover(state: boolean): this;
         /**
          * Get boolean flag for whether object should highlight on mouse hover
          * @returns Boolean for if object should highlight on mouse hover or not.
          * @public
          */
         getHighlightOnHover(): boolean;
         setCursor(mutator: Mutator<Cursor2D<CursorResultTableBackgroundType>>): this;
         getCursor(): Cursor2D<CursorResultTableBackgroundType>;
         setCursorMode(mode: SolveNearestMode | undefined): this;
         getCursorMode(): SolveNearestMode | undefined;
         setCustomCursor(clbk: undefined | ((event: CursorTargetChangedEvent<SolveResultMap<SelectedMapType>>) => unknown)): this;
         setCursorDynamicBehavior(value: CursorDynamicBehavior): this;
         /**
          * Set cursor formatting, controlling the text displayed in built-in cursor.
          *
          * ```ts
          *  chart.setCursorFormatting((_, hit, hits) => {
          *      return [
          *          ['Cursor pointing at'],
          *          [hit.series], // returning a series will display the series color and its name automatically.
          *          ['X', '', hit.axisX.formatValue(hit.x)], // utilizing axis formatValue is useful for considering active zoom level and type of axis
          *          ['Y', '', hit.y.toFixed(2)], // empty string '' results in gap between cells
          *          [{ text: 'Example', font: { weight: 'bold' }, fillStyle: fillRed }] // any cell can also be styled individually
          *      ]
          *  })
          * ```
          *
          * Before overriding default cursor formatting, it is recommended to check if using {@link GenericAxis.setUnits} or configuring Axis cursor formatting would be enough.
          *
          * In order to use series specific data properties (e.g. Heatmap sample "intensity"),
          * you should use type guards to assert the type of the `SolveResult`:
          *
          * ```ts
          *  // Example of using type guard in cursor formatter
          *  Chart.setCursorFormatting((chart, hit, hits) => {
          *      if (!isHitHeatmap(hit)) return undefined
          *      return [hit.intensity.toFixed(1)]
          *  })
          * ```
          *
          * More details in Developer documentation (Features \> Cursor).
          * @param   formatter -     Callback function for cursor formatting.
          * @returns     Object itself
          * @public
          */
         setCursorFormatting(formatter: CursorFormatterMapChart<SelectedMapType>): this;
         /**
          * Get active cursor formatter.
          * @returns     Cursor formatter.
          * @public
          */
         getCursorFormatting(): CursorFormatterMapChart<SelectedMapType>;
         /**
          * Add manually controlled Cursor object.
          * These have exactly same functions as built-in cursors but they can be freely controlled by application logic.
          *
          * ```ts
          *  const cursor = chart.addCursor()
          * ```
          *
          * Styling works same as built-in cursors (e.g. {@link setCursor}).
          *
          * Position is set using `setPosition` method and displayed content using `setResultTable(table => table.setContent(...))`
          * For more details, see Developer documentation \> Features \> Cursor \> Manual cursors
          *
          * @param   cursorBuilder -     Builder for cursor. Can be used to tweak a handful of properties which can't be changed during runtime.
          * @returns     Cursor object.
          * @public
          */
         addCursor<ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: CursorBuilder2D<ResultTableBackgroundType>): Cursor2D<ResultTableBackgroundType>;
         /**
          * Disable/Enable all animations of the Chart.
          * @param animationsEnabled - Boolean value to enable or disable animations.
          * @returns Chart itself for fluent interface.
          * @public
          */
         setAnimationsEnabled(animationsEnabled: boolean | undefined): this;
         /**
          * Get animations disable/enable state.
          * @returns Animations default state.
          * @public
          */
         getAnimationsEnabled(): boolean;
         /**
          * Get minimum size of Panel.
          * Depending on the type of class this value might be automatically computed to fit different elements.
          * @returns Vec2 minimum size or undefined if unimplemented
          * @public
          */
         getMinimumSize(): Point | undefined;
         /**
          * **Permanently** destroy the component.
          *
          * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
          * **to the component and its children** in application code.
          * ```javascript
          * let chart = ...ChartXY()
          * let axisX = chart.getDefaultAxisX()
          * // Dispose Chart, and remove all references so that they can be garbage-collected.
          * chart.dispose()
          * chart = undefined
          * axisX = undefined
          * ```
          * @returns Object itself for fluent interface
          * @public
          */
         dispose(): this;
         addEventListener<K extends keyof MapChartEventMap>(type: K, listener: (event: MapChartEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
         removeEventListener<K extends keyof MapChartEventMap>(type: K, listener: (event: MapChartEventMap[K], info: unknown) => unknown): void;
        }
        /**
         * Interface that can be used to define {@link MapChart} configurations, when inside a {@link Dashboard},
         * that can't be changed after creation.
         *
         * **Example usage:**
         *
         * - Specify minimum amount of required configurations ({@link DashboardCellOptions}).
         *
         * ``` ts
         *  const mapChart = lightningChart().Dashboard({
         *      rowIndex: 0,
         *      columnIndex: 0,
         *      rowSpan: 1,
         *      columnSpan: 1
         *  })
         * ```
         *
         * - Specify *MapType*.
         *
         * ``` ts
         *  const mapChart = lightningChart().Dashboard({
         *      rowIndex: 0,
         *      columnIndex: 0,
         *      rowSpan: 1,
         *      columnSpan: 1,
         *      type: MapTypes.USA
         *  })
         * ```
         * @public
         */
        export declare interface MapChartDashboardOptions<SelectedMapType extends MapType, CursorResultTableBackgroundType extends UIBackground> extends DashboardCellOptions, MapChartOptions<SelectedMapType, CursorResultTableBackgroundType> {
        }
        /**
         * Interface of events trackable by {@link MapChart.addEventListener} and the respective Event types.
         * @public
         */
        export declare interface MapChartEventMap extends PanelEventMap, HighlightableEventMap, ChartWithCursorEventMap<SolveResultMap> {
            /**
             * Event fired when the MapChart data is loaded.
             *
             * ```ts
             *  // Example usage
             *  chart.addEventListener('ready', (event) => {
             *      console.log(event)
             *  })
             * ```
             */
            ready: MapChartReadyEvent;
            /**
             * Event fired when the Map chart view changes (lot,lan,width,height)
             *
             * ```ts
             *  // Example usage
             *  chart.addEventListener('viewchange', (event) => {
             *      console.log(event)
             *  })
             * ```
             */
            viewchange: MapChartViewChangeEvent;
        }
        /**
         * Interface that can be used to define *Map Chart* configurations that can't be changed after creation.
         *
         * **Example usage:**
         *
         * - Specify *MapType*.
         *
         * ``` ts
         *  const mapChart = lightningChart().Map({
         *      type: MapTypes.USA
         *  })
         * ```
         * @public
         */
        export declare interface MapChartOptions<SelectedMapType extends MapType, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
            /**
             * Preset selection that defines the displayed Map region as well as the type of
             * associated region data (eq. USA -\> states, World -\> countries).
             *
             * Valid options can be referenced via {@link MapTypes}:
             *
             * ``` ts
             *  const mapChart = lightningChart().Map({
             *      type: MapTypes.USA
             *  })
             * ```
             * @public
             */
            type?: SelectedMapType;
            /**
             * Builder for the Charts Cursor. If omitted, a default one will be used.
             * CursorBuilders.Map can be used to build a custom one from scratch.
             * @public
             */
            cursorBuilder?: CursorBuilder2D<CursorResultTableBackgroundType>;
        }
        /**
         * @public
         */
        export declare interface MapChartReadyEvent {
        }
        /**
         * @public
         */
        export declare interface MapChartViewChangeEvent {
            /**
             * Displayed longitude range (east-west position).
             */
            longitudeRange: {
                start: number;
                end: number;
            };
            /**
             * Displayed latitude range (north-south position).
             */
            latitudeRange: {
                start: number;
                end: number;
            };
            /**
             * Margins around Map chart edges as pixels.
             */
            margin: {
                left: number;
                top: number;
                right: number;
                bottom: number;
            };
        }
        /**
         * {@link MapTypes} pairing with a list of MapRegions the MapType includes.
         *
         * For example, when using **MapType.Europe**, the list of available *countries* can be referenced with:
         *
         * ```ts
         * const countries = MapRegions[ MapTypes.Europe ]
         * ```
         *
         * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
         *
         * **Example usage**:
         *
         * - Invalidate selected region value.
         *
         * ``` ts
         *  MapChart.invalidateRegionValues([
         *      { ...MapRegions[ MapTypes.Europe ].Finland, value: 0 }
         *  ])
         * ```
         *
         * - List all region names (can be useful when developing a js application without intellisense).
         *
         * ``` ts
         *  Object.keys( MapRegions[ MapTypes.Europe ] ).forEach( key => console.log( key ) )
         * ```
         * @public
         */
        export declare const MapRegions: {
            /**
             * {@link MapRegionsWorld}
             */
            World: {
                Aruba: Country;
                Afghanistan: Country;
                Angola: Country;
                Anguilla: Country;
                Albania: Country;
                Aland: Country;
                Andorra: Country;
                'United Arab Emirates': Country;
                Argentina: Country;
                /**
                 * {@link MapRegionsWorld}
                 */
                Armenia: Country;
                'American Samoa': Country;
                Antarctica: Country;
                'French Southern and Antarctic Lands': Country;
                'Antigua and Barbuda': Country;
                Australia: Country;
                Austria: Country;
                Azerbaijan: Country;
                Burundi: Country;
                Belgium: Country;
                Benin: Country;
                'Burkina Faso': Country;
                Bangladesh: Country;
                Bulgaria: Country;
                Bahrain: Country;
                'The Bahamas': Country;
                'Bosnia and Herzegovina': Country;
                Belarus: Country;
                Belize: Country;
                Bermuda: Country;
                Bolivia: Country;
                Brazil: Country;
                Barbados: Country;
                Brunei: Country;
                Bhutan: Country;
                Botswana: Country;
                'Central African Republic': Country;
                Canada: Country;
                Switzerland: Country;
                Chile: Country;
                China: Country;
                'Ivory Coast': Country;
                Cameroon: Country;
                'Cyprus No Mans Area': Country;
                'Democratic Republic of the Congo': Country;
                'Republic of Congo': Country;
                'Cook Islands': Country;
                Colombia: Country;
                Comoros: Country;
                'Cape Verde': Country;
                'Costa Rica': Country;
                Cuba: Country;
                Curaao: Country;
                'Cayman Islands': Country;
                'Northern Cyprus': Country;
                Cyprus: Country;
                'Czech Republic': Country;
                Germany: Country;
                Djibouti: Country;
                Dominica: Country;
                Denmark: Country;
                'Dominican Republic': Country;
                Algeria: Country;
                Ecuador: Country;
                Egypt: Country;
                Eritrea: Country;
                'Dhekelia Sovereign Base Area': Country;
                Spain: Country;
                Estonia: Country;
                Ethiopia: Country;
                Finland: Country;
                Fiji: Country;
                'Falkland Islands': Country;
                France: Country;
                'Faroe Islands': Country;
                'Federated States of Micronesia': Country;
                Gabon: Country;
                'United Kingdom': Country;
                Georgia: Country;
                Guernsey: Country;
                Ghana: Country;
                Guinea: Country;
                Gambia: Country;
                'Guinea Bissau': Country;
                'Equatorial Guinea': Country;
                Greece: Country;
                Grenada: Country;
                Greenland: Country;
                Guatemala: Country;
                Guam: Country;
                Guyana: Country;
                'Hong Kong S.A.R.': Country;
                'Heard Island and McDonald Islands': Country;
                Honduras: Country;
                Croatia: Country;
                Haiti: Country;
                Hungary: Country;
                Indonesia: Country;
                'Isle of Man': Country;
                India: Country;
                'Indian Ocean Territories': Country;
                'British Indian Ocean Territory': Country;
                Ireland: Country;
                Iran: Country;
                Iraq: Country;
                Iceland: Country;
                Israel: Country;
                Italy: Country;
                Jamaica: Country;
                Jersey: Country;
                Jordan: Country;
                Japan: Country;
                'Baykonur Cosmodrome': Country;
                'Siachen Glacier': Country;
                Kazakhstan: Country;
                Kenya: Country;
                Kyrgyzstan: Country;
                Cambodia: Country;
                Kiribati: Country;
                'Saint Kitts and Nevis': Country;
                'South Korea': Country;
                Kosovo: Country;
                Kuwait: Country;
                Laos: Country;
                Lebanon: Country;
                Liberia: Country;
                Libya: Country;
                'Saint Lucia': Country;
                Liechtenstein: Country;
                'Sri Lanka': Country;
                Lesotho: Country;
                Lithuania: Country;
                Luxembourg: Country;
                Latvia: Country;
                'Macao S.A.R': Country;
                'Saint Martin': Country;
                Morocco: Country;
                Moldova: Country;
                Madagascar: Country;
                Maldives: Country;
                Mexico: Country;
                'Marshall Islands': Country;
                Macedonia: Country;
                Mali: Country;
                Malta: Country;
                Myanmar: Country;
                Montenegro: Country;
                Mongolia: Country;
                'Northern Mariana Islands': Country;
                Mozambique: Country;
                Mauritania: Country;
                Montserrat: Country;
                Mauritius: Country;
                Malawi: Country;
                Malaysia: Country;
                Namibia: Country;
                'New Caledonia': Country;
                Niger: Country;
                Nigeria: Country;
                Nicaragua: Country;
                Niue: Country;
                Netherlands: Country;
                Norway: Country;
                Nepal: Country;
                'New Zealand': Country;
                Oman: Country;
                Pakistan: Country;
                Panama: Country;
                'Pitcairn Islands': Country;
                Peru: Country;
                'Spratly Islands': Country;
                Philippines: Country;
                Palau: Country;
                'Papua New Guinea': Country;
                Poland: Country;
                'Puerto Rico': Country;
                'North Korea': Country;
                Portugal: Country;
                Paraguay: Country;
                Palestine: Country;
                'French Polynesia': Country;
                Qatar: Country;
                Romania: Country;
                Russia: Country;
                Rwanda: Country;
                'Western Sahara': Country;
                'Saudi Arabia': Country;
                Sudan: Country;
                'South Sudan': Country;
                Senegal: Country;
                Singapore: Country;
                'South Georgia and South Sandwich Islands': Country;
                'Saint Helena': Country;
                'Solomon Islands': Country;
                'Sierra Leone': Country;
                'El Salvador': Country;
                Somalia: Country;
                'Saint Pierre and Miquelon': Country;
                'Republic of Serbia': Country;
                'Sao Tome and Principe': Country;
                Suriname: Country;
                Slovakia: Country;
                Slovenia: Country;
                Sweden: Country;
                Swaziland: Country;
                Seychelles: Country;
                Syria: Country;
                'Turks and Caicos Islands': Country;
                Chad: Country;
                Togo: Country;
                Thailand: Country;
                Tajikistan: Country;
                Turkmenistan: Country;
                'East Timor': Country;
                Tonga: Country;
                'Trinidad and Tobago': Country;
                Tunisia: Country;
                Turkey: Country;
                Tuvalu: Country;
                Taiwan: Country;
                'United Republic of Tanzania': Country;
                Uganda: Country;
                Ukraine: Country;
                'United States Minor Outlying Islands': Country;
                Uruguay: Country;
                'United States of America': Country;
                'US Naval Base Guantanamo Bay': Country;
                Uzbekistan: Country;
                'Saint Vincent and the Grenadines': Country;
                Venezuela: Country;
                'British Virgin Islands': Country;
                'United States Virgin Islands': Country;
                Vietnam: Country;
                Vanuatu: Country;
                'Wallis and Futuna': Country;
                'Akrotiri Sovereign Base Area': Country;
                Samoa: Country;
                Yemen: Country;
                'South Africa': Country;
                Zambia: Country;
                Zimbabwe: Country;
                'French Guyana': Country;
            };
            /**
             * {@link MapRegionsUSA}
             */
            USA: {
                Alabama: State;
                Alaska: State;
                Arizona: State;
                Arkansas: State;
                California: State;
                Colorado: State;
                Connecticut: State;
                Delaware: State;
                'District of Columbia': State;
                Florida: State;
                Georgia: State;
                Hawaii: State;
                Idaho: State;
                Illinois: State;
                Indiana: State;
                Iowa: State;
                Kansas: State;
                Kentucky: State;
                Louisiana: State;
                Maine: State;
                Maryland: State;
                Massachusetts: State;
                Michigan: State;
                Minnesota: State;
                Mississippi: State;
                Missouri: State;
                Montana: State;
                Nebraska: State;
                Nevada: State;
                'New Hampshire': State;
                'New Jersey': State;
                'New Mexico': State;
                'New York': State;
                'North Carolina': State;
                'North Dakota': State;
                Ohio: State;
                Oklahoma: State;
                Oregon: State;
                Pennsylvania: State;
                'Rhode Island': State;
                'South Carolina': State;
                'South Dakota': State;
                Tennessee: State;
                Texas: State;
                Utah: State;
                Vermont: State;
                Virginia: State;
                Washington: State;
                'West Virginia': State;
                Wisconsin: State;
                Wyoming: State;
            };
            /**
             * {@link MapRegionsNorthAmerica}
             */
            NorthAmerica: {
                Anguilla: Country;
                'Antigua and Barbuda': Country;
                'The Bahamas': Country;
                Bermuda: Country;
                Barbados: Country;
                Canada: Country;
                Cuba: Country;
                'Cayman Islands': Country;
                Dominica: Country;
                'Dominican Republic': Country;
                Grenada: Country;
                Greenland: Country;
                Haiti: Country;
                Jamaica: Country;
                'Saint Kitts and Nevis': Country;
                'Saint Lucia': Country;
                'Saint Martin': Country;
                Mexico: Country;
                Montserrat: Country;
                'Puerto Rico': Country;
                'Saint Pierre and Miquelon': Country;
                'Turks and Caicos Islands': Country;
                'Trinidad and Tobago': Country;
                'United States of America': Country;
                'Saint Vincent and the Grenadines': Country;
                'British Virgin Islands': Country;
                'United States Virgin Islands': Country;
            };
            /**
             * {@link MapRegionsSouthAmerica}
             */
            SouthAmerica: {
                Argentina: Country;
                Bolivia: Country;
                Brazil: Country;
                Chile: Country;
                Colombia: Country;
                'Costa Rica': Country;
                Ecuador: Country;
                'Falkland Islands': Country;
                Guyana: Country;
                Nicaragua: Country;
                Panama: Country;
                Peru: Country;
                Paraguay: Country;
                Suriname: Country;
                Uruguay: Country;
                Venezuela: Country;
                'French Guyana': Country;
                Guatemala: Country;
                'El Salvador': Country;
                Honduras: Country;
            };
            /**
             * {@link MapRegionsCanada}
             */
            Canada: {
                'British Columbia': CanadaProvinceOrTerritory;
                Quebec: CanadaProvinceOrTerritory;
                Nunavut: CanadaProvinceOrTerritory;
                'Prince Edward Island': CanadaProvinceOrTerritory;
                Saskatchewan: CanadaProvinceOrTerritory;
                Yukon: CanadaProvinceOrTerritory;
                Manitoba: CanadaProvinceOrTerritory;
                Ontario: CanadaProvinceOrTerritory;
                'New Brunswick': CanadaProvinceOrTerritory;
                'Northwest Territories': CanadaProvinceOrTerritory;
                Alberta: CanadaProvinceOrTerritory;
                'Newfoundland and Labrador': CanadaProvinceOrTerritory;
                'Nova Scotia': CanadaProvinceOrTerritory;
            };
            /**
             * {@link MapRegionsEurope}
             */
            Europe: {
                Albania: Country;
                Austria: Country;
                Belarus: Country;
                Belgium: Country;
                Bulgaria: Country;
                'Bosnia and Herzegovina': Country;
                Switzerland: Country;
                Cyprus: Country;
                'Czech Republic': Country;
                Germany: Country;
                Denmark: Country;
                Spain: Country;
                Estonia: Country;
                Finland: Country;
                France: Country;
                'United Kingdom': Country;
                Greece: Country;
                Croatia: Country;
                Hungary: Country;
                Ireland: Country;
                Iceland: Country;
                Italy: Country;
                Kosovo: Country;
                Lithuania: Country;
                Luxembourg: Country;
                Latvia: Country;
                Macedonia: Country;
                Malta: Country;
                Montenegro: Country;
                Netherlands: Country;
                Norway: Country;
                Poland: Country;
                Portugal: Country;
                Romania: Country;
                'Republic of Serbia': Country;
                Slovakia: Country;
                Slovenia: Country;
                Sweden: Country;
                Ukraine: Country;
                Moldova: Country;
                Russia: Country;
                Turkey: Country;
            };
            /**
             * {@link MapRegionsAsia}
             */
            Asia: {
                Afghanistan: Country;
                'United Arab Emirates': Country;
                Armenia: Country;
                Australia: Country;
                Azerbaijan: Country;
                Bangladesh: Country;
                Bahrain: Country;
                Brunei: Country; /**
                * {@link MapRegionsUSA}
                */
                Bhutan: Country;
                China: Country;
                Georgia: Country;
                Indonesia: Country;
                India: Country;
                Iran: Country; /**
                * {@link MapRegionsEurope}
                */
                Iraq: Country;
                Israel: Country;
                Jordan: Country;
                Japan: Country;
                Kazakhstan: Country;
                Kyrgyzstan: Country;
                Cambodia: Country;
                'South Korea': Country;
                Kuwait: Country;
                Laos: Country;
                Lebanon: Country;
                'Sri Lanka': Country;
                Maldives: Country;
                Myanmar: Country;
                Mongolia: Country;
                Malaysia: Country;
                Nepal: Country;
                Oman: Country;
                Pakistan: Country;
                Philippines: Country;
                'Papua New Guinea': Country;
                'North Korea': Country;
                Palestine: Country;
                Qatar: Country;
                Russia: Country;
                'Saudi Arabia': Country;
                Singapore: Country;
                Syria: Country;
                Thailand: Country;
                Tajikistan: Country;
                Turkmenistan: Country;
                Turkey: Country;
                Taiwan: Country;
                Uzbekistan: Country;
                Vietnam: Country;
                Yemen: Country;
            };
            /**
             * {@link MapRegionsAfrica}
             */
            Africa: {
                Angola: Country;
                Burundi: Country;
                Benin: Country;
                'Burkina Faso': Country;
                Botswana: Country;
                'Central African Republic': Country;
                'Ivory Coast': Country;
                Cameroon: Country;
                'Democratic Republic of the Congo': Country;
                'Republic of Congo': Country;
                Comoros: Country;
                'Cape Verde': Country;
                Djibouti: Country;
                Algeria: Country;
                Egypt: Country;
                Eritrea: Country;
                Ethiopia: Country;
                Gabon: Country;
                Ghana: Country;
                Guinea: Country;
                Gambia: Country;
                'Guinea Bissau': Country;
                'Equatorial Guinea': Country;
                Israel: Country;
                Jordan: Country;
                Kenya: Country;
                Lebanon: Country;
                Liberia: Country;
                Libya: Country;
                Lesotho: Country;
                Morocco: Country;
                Madagascar: Country;
                Mali: Country;
                Malta: Country;
                Mozambique: Country;
                Mauritania: Country;
                Mauritius: Country;
                Malawi: Country;
                Namibia: Country;
                Niger: Country;
                Nigeria: Country;
                Oman: Country;
                Rwanda: Country;
                'Western Sahara': Country;
                'Saudi Arabia': Country;
                Sudan: Country;
                'South Sudan': Country;
                Senegal: Country;
                'Saint Helena': Country;
                'Sierra Leone': Country;
                Somalia: Country;
                Swaziland: Country;
                Seychelles: Country;
                Syria: Country;
                Chad: Country;
                Togo: Country;
                Tunisia: Country;
                'United Republic of Tanzania': Country;
                Uganda: Country;
                Yemen: Country;
                'South Africa': Country;
                Zambia: Country;
                Zimbabwe: Country;
            };
            /**
             * {@link MapRegionsAustralia}
             */
            Australia: {
                'New South Wales': AustraliaTerritory;
                Victoria: AustraliaTerritory;
                Queensland: AustraliaTerritory;
                'South Australia': AustraliaTerritory;
                'Western Australia': AustraliaTerritory;
                Tasmania: AustraliaTerritory;
                'Northern Territory': AustraliaTerritory;
                'Australian Capital Territory': AustraliaTerritory;
                'Other Territories': AustraliaTerritory;
            };
        };
        /**
         * List of MapRegions included in {@link MapTypes | MapTypes.Africa}.
         *
         * Can be referenced like so:
         *
         * ```ts
         * const countries = MapRegions[ MapTypes.Africa ]
         * ```
         *
         * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
         *
         * **Example usage**:
         *
         * - Invalidate selected region value.
         *
         * ``` ts
         *  MapChart.invalidateRegionValues([
         *      { ...MapRegions[ MapTypes.Africa ].Egypt, value: 0 }
         *  ])
         * ```
         *
         * - List all region names (can be useful when developing a js application without intellisense).
         *
         * ``` ts
         *  Object.keys( MapRegions[ MapTypes.Africa ] ).forEach( key => console.log( key ) )
         * ```
         *
         * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of Africa.
         * @public
         */
        export declare const MapRegionsAfrica: {
            Angola: Country;
            Burundi: Country;
            Benin: Country;
            'Burkina Faso': Country;
            Botswana: Country;
            'Central African Republic': Country;
            'Ivory Coast': Country;
            Cameroon: Country;
            'Democratic Republic of the Congo': Country;
            'Republic of Congo': Country;
            Comoros: Country;
            'Cape Verde': Country;
            Djibouti: Country;
            Algeria: Country;
            Egypt: Country;
            Eritrea: Country;
            Ethiopia: Country;
            Gabon: Country;
            Ghana: Country;
            Guinea: Country;
            Gambia: Country;
            'Guinea Bissau': Country;
            'Equatorial Guinea': Country;
            Israel: Country;
            Jordan: Country;
            Kenya: Country;
            Lebanon: Country;
            Liberia: Country;
            Libya: Country;
            Lesotho: Country;
            Morocco: Country;
            Madagascar: Country;
            Mali: Country;
            Malta: Country;
            Mozambique: Country;
            Mauritania: Country;
            Mauritius: Country;
            Malawi: Country;
            Namibia: Country;
            Niger: Country;
            Nigeria: Country;
            Oman: Country;
            Rwanda: Country;
            'Western Sahara': Country;
            'Saudi Arabia': Country;
            Sudan: Country;
            'South Sudan': Country;
            Senegal: Country;
            'Saint Helena': Country;
            'Sierra Leone': Country;
            Somalia: Country;
            Swaziland: Country;
            Seychelles: Country;
            Syria: Country;
            Chad: Country;
            Togo: Country;
            Tunisia: Country;
            'United Republic of Tanzania': Country;
            Uganda: Country;
            Yemen: Country;
            'South Africa': Country;
            Zambia: Country;
            Zimbabwe: Country;
        };
        /**
         * List of MapRegions included in {@link MapTypes | MapTypes.Asia}.
         *
         * Can be referenced like so:
         *
         * ```ts
         * const countries = MapRegions[ MapTypes.Asia ]
         * ```
         *
         * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
         *
         * **Example usage**:
         *
         * - Invalidate selected region value.
         *
         * ``` ts
         *  MapChart.invalidateRegionValues([
         *      { ...MapRegions[ MapTypes.Asia ].China, value: 0 }
         *  ])
         * ```
         *
         * - List all region names (can be useful when developing a js application without intellisense).
         *
         * ``` ts
         *  Object.keys( MapRegions[ MapTypes.Asia ] ).forEach( key => console.log( key ) )
         * ```
         *
         * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of Asia.
         * @public
         */
        export declare const MapRegionsAsia: {
            Afghanistan: Country;
            'United Arab Emirates': Country;
            Armenia: Country;
            Australia: Country;
            Azerbaijan: Country;
            Bangladesh: Country;
            Bahrain: Country;
            Brunei: Country;
            Bhutan: Country;
            China: Country;
            Georgia: Country;
            Indonesia: Country;
            India: Country;
            Iran: Country;
            Iraq: Country;
            Israel: Country;
            Jordan: Country;
            Japan: Country;
            Kazakhstan: Country;
            Kyrgyzstan: Country;
            Cambodia: Country;
            'South Korea': Country;
            Kuwait: Country;
            Laos: Country;
            Lebanon: Country;
            'Sri Lanka': Country;
            Maldives: Country;
            Myanmar: Country;
            Mongolia: Country;
            Malaysia: Country;
            Nepal: Country;
            Oman: Country;
            Pakistan: Country;
            Philippines: Country;
            'Papua New Guinea': Country;
            'North Korea': Country;
            Palestine: Country;
            Qatar: Country;
            Russia: Country;
            'Saudi Arabia': Country;
            Singapore: Country;
            Syria: Country;
            Thailand: Country;
            Tajikistan: Country;
            Turkmenistan: Country;
            Turkey: Country;
            Taiwan: Country;
            Uzbekistan: Country;
            Vietnam: Country;
            Yemen: Country;
        };
        /**
         * List of MapRegions included in {@link MapTypes | MapTypes.Australia}.
         *
         * Can be referenced like so:
         *
         * ```ts
         * const territories = MapRegions[ MapTypes.Australia ]
         * ```
         *
         * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
         *
         * **Example usage**:
         *
         * - Invalidate selected region value.
         *
         * ``` ts
         *  MapChart.invalidateRegionValues([
         *      { ...MapRegions[ MapTypes.Australia ].Queensland, value: 0 }
         *  ])
         * ```
         *
         * - List all region names (can be useful when developing a js application without intellisense).
         *
         * ``` ts
         *  Object.keys( MapRegions[ MapTypes.Australia ] ).forEach( key => console.log( key ) )
         * ```
         * @public
         */
        export declare const MapRegionsAustralia: {
            'New South Wales': AustraliaTerritory;
            Victoria: AustraliaTerritory;
            Queensland: AustraliaTerritory;
            'South Australia': AustraliaTerritory;
            'Western Australia': AustraliaTerritory;
            Tasmania: AustraliaTerritory;
            'Northern Territory': AustraliaTerritory;
            'Australian Capital Territory': AustraliaTerritory;
            'Other Territories': AustraliaTerritory;
        };
        /**
         * List of MapRegions included in {@link MapTypes | MapTypes.Canada}.
         *
         * Can be referenced like so:
         *
         * ```ts
         * const territories = MapRegions[ MapTypes.Canada ]
         * ```
         *
         * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
         *
         * **Example usage**:
         *
         * - Invalidate selected region value.
         *
         * ``` ts
         *  MapChart.invalidateRegionValues([
         *      { ...MapRegions[ MapTypes.Canada ].Ontario, value: 0 }
         *  ])
         * ```
         *
         * - List all region names (can be useful when developing a js application without intellisense).
         *
         * ``` ts
         *  Object.keys( MapRegions[ MapTypes.Canada ] ).forEach( key => console.log( key ) )
         * ```
         * @public
         */
        export declare const MapRegionsCanada: {
            'British Columbia': CanadaProvinceOrTerritory;
            Quebec: CanadaProvinceOrTerritory;
            Nunavut: CanadaProvinceOrTerritory;
            'Prince Edward Island': CanadaProvinceOrTerritory;
            Saskatchewan: CanadaProvinceOrTerritory;
            Yukon: CanadaProvinceOrTerritory;
            Manitoba: CanadaProvinceOrTerritory;
            Ontario: CanadaProvinceOrTerritory;
            'New Brunswick': CanadaProvinceOrTerritory;
            'Northwest Territories': CanadaProvinceOrTerritory;
            Alberta: CanadaProvinceOrTerritory;
            'Newfoundland and Labrador': CanadaProvinceOrTerritory;
            'Nova Scotia': CanadaProvinceOrTerritory;
        };
        /**
         * List of MapRegions included in {@link MapTypes | MapTypes.Europe}.
         *
         * Can be referenced like so:
         *
         * ```ts
         * const countries = MapRegions[ MapTypes.Europe ]
         * ```
         *
         * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
         *
         * **Example usage**:
         *
         * - Invalidate selected region value.
         *
         * ``` ts
         *  MapChart.invalidateRegionValues([
         *      { ...MapRegions[ MapTypes.Europe ].Finland, value: 0 }
         *  ])
         * ```
         *
         * - List all region names (can be useful when developing a js application without intellisense).
         *
         * ``` ts
         *  Object.keys( MapRegions[ MapTypes.Europe ] ).forEach( key => console.log( key ) )
         * ```
         *
         * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of Europe.
         * @public
         */
        export declare const MapRegionsEurope: {
            Albania: Country;
            Austria: Country;
            Belarus: Country;
            Belgium: Country;
            Bulgaria: Country;
            'Bosnia and Herzegovina': Country;
            Switzerland: Country;
            Cyprus: Country;
            'Czech Republic': Country;
            Germany: Country;
            Denmark: Country;
            Spain: Country;
            Estonia: Country;
            Finland: Country;
            France: Country;
            'United Kingdom': Country;
            Greece: Country;
            Croatia: Country;
            Hungary: Country;
            Ireland: Country;
            Iceland: Country;
            Italy: Country;
            Kosovo: Country;
            Lithuania: Country;
            Luxembourg: Country;
            Latvia: Country;
            Macedonia: Country;
            Malta: Country;
            Montenegro: Country;
            Netherlands: Country;
            Norway: Country;
            Poland: Country;
            Portugal: Country;
            Romania: Country;
            'Republic of Serbia': Country;
            Slovakia: Country;
            Slovenia: Country;
            Sweden: Country;
            Ukraine: Country;
            Moldova: Country;
            Russia: Country;
            Turkey: Country;
        };
        /**
         * List of MapRegions included in {@link MapTypes | MapTypes.NorthAmerica}.
         *
         * Can be referenced like so:
         *
         * ```ts
         * const countries = MapRegions[ MapTypes.NorthAmerica ]
         * ```
         *
         * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
         *
         * **Example usage**:
         *
         * - Invalidate selected region value.
         *
         * ``` ts
         *  MapChart.invalidateRegionValues([
         *      { ...MapRegions[ MapTypes.NorthAmerica ].Panama, value: 0 }
         *  ])
         * ```
         *
         * - List all region names (can be useful when developing a js application without intellisense).
         *
         * ``` ts
         *  Object.keys( MapRegions[ MapTypes.NorthAmerica ] ).forEach( key => console.log( key ) )
         * ```
         *
         * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of North America.
         * @public
         */
        export declare const MapRegionsNorthAmerica: {
            Anguilla: Country;
            'Antigua and Barbuda': Country;
            'The Bahamas': Country;
            Bermuda: Country;
            Barbados: Country;
            Canada: Country;
            Cuba: Country;
            'Cayman Islands': Country;
            Dominica: Country;
            'Dominican Republic': Country;
            Grenada: Country;
            Greenland: Country;
            Haiti: Country;
            Jamaica: Country;
            'Saint Kitts and Nevis': Country;
            'Saint Lucia': Country;
            'Saint Martin': Country;
            Mexico: Country;
            Montserrat: Country;
            'Puerto Rico': Country;
            'Saint Pierre and Miquelon': Country;
            'Turks and Caicos Islands': Country;
            'Trinidad and Tobago': Country;
            'United States of America': Country;
            'Saint Vincent and the Grenadines': Country;
            'British Virgin Islands': Country;
            'United States Virgin Islands': Country;
        };
        /**
         * List of MapRegions included in {@link MapTypes | MapTypes.SouthAmerica}.
         *
         * Can be referenced like so:
         *
         * ```ts
         * const countries = MapRegions[ MapTypes.SouthAmerica ]
         * ```
         *
         * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
         *
         * **Example usage**:
         *
         * - Invalidate selected region value.
         *
         * ``` ts
         *  MapChart.invalidateRegionValues([
         *      { ...MapRegions[ MapTypes.SouthAmerica ].Colombia, value: 0 }
         *  ])
         * ```
         *
         * - List all region names (can be useful when developing a js application without intellisense).
         *
         * ``` ts
         *  Object.keys( MapRegions[ MapTypes.SouthAmerica ] ).forEach( key => console.log( key ) )
         * ```
         *
         * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of South America.
         * @public
         */
        export declare const MapRegionsSouthAmerica: {
            Argentina: Country;
            Bolivia: Country;
            Brazil: Country;
            Chile: Country;
            Colombia: Country;
            'Costa Rica': Country;
            Ecuador: Country;
            'Falkland Islands': Country;
            Guyana: Country;
            Nicaragua: Country;
            Panama: Country;
            Peru: Country;
            Paraguay: Country;
            Suriname: Country;
            Uruguay: Country;
            Venezuela: Country;
            'French Guyana': Country;
            Guatemala: Country;
            'El Salvador': Country;
            Honduras: Country;
        };
        /**
         * List of MapRegions included in {@link MapTypes | MapTypes.USA}.
         *
         * Can be referenced like so:
         *
         * ```ts
         * const states = MapRegions[ MapTypes.USA ]
         * ```
         *
         * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
         *
         * **Example usage**:
         *
         * - Invalidate selected region value.
         *
         * ``` ts
         *  MapChart.invalidateRegionValues([
         *      { ...MapRegions[ MapTypes.USA ].Alabama, value: 0 }
         *  ])
         * ```
         *
         * - List all region names (can be useful when developing a js application without intellisense).
         *
         * ``` ts
         *  Object.keys( MapRegions[ MapTypes.USA ] ).forEach( key => console.log( key ) )
         * ```
         * @public
         */
        export declare const MapRegionsUSA: {
            Alabama: State;
            Alaska: State;
            Arizona: State;
            Arkansas: State;
            California: State;
            Colorado: State;
            Connecticut: State;
            Delaware: State;
            'District of Columbia': State;
            Florida: State;
            Georgia: State;
            Hawaii: State;
            Idaho: State;
            Illinois: State;
            Indiana: State;
            Iowa: State;
            Kansas: State;
            Kentucky: State;
            Louisiana: State;
            Maine: State;
            Maryland: State;
            Massachusetts: State;
            Michigan: State;
            Minnesota: State;
            Mississippi: State;
            Missouri: State;
            Montana: State;
            Nebraska: State;
            Nevada: State;
            'New Hampshire': State;
            'New Jersey': State;
            'New Mexico': State;
            'New York': State;
            'North Carolina': State;
            'North Dakota': State;
            Ohio: State;
            Oklahoma: State;
            Oregon: State;
            Pennsylvania: State;
            'Rhode Island': State;
            'South Carolina': State;
            'South Dakota': State;
            Tennessee: State;
            Texas: State;
            Utah: State;
            Vermont: State;
            Virginia: State;
            Washington: State;
            'West Virginia': State;
            Wisconsin: State;
            Wyoming: State;
        };
        /**
         * List of MapRegions included in {@link MapTypes | MapTypes.World}.
         *
         * Can be referenced like so:
         *
         * ```ts
         * const countries = MapRegions[ MapTypes.World ]
         * ```
         *
         * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
         *
         * **Example usage**:
         *
         * - Invalidate selected region value.
         *
         * ``` ts
         *  MapChart.invalidateRegionValues([
         *      { ...MapRegions[ MapTypes.World ].Finland, value: 0 }
         *  ])
         * ```
         *
         * - List all region names (can be useful when developing a js application without intellisense).
         *
         * ``` ts
         *  Object.keys( MapRegions[ MapTypes.World ] ).forEach( key => console.log( key ) )
         * ```
         * @public
         */
        export declare const MapRegionsWorld: {
            Aruba: Country;
            Afghanistan: Country;
            Angola: Country;
            Anguilla: Country;
            Albania: Country;
            Aland: Country;
            Andorra: Country;
            'United Arab Emirates': Country;
            Argentina: Country;
            Armenia: Country;
            'American Samoa': Country;
            Antarctica: Country;
            'French Southern and Antarctic Lands': Country;
            'Antigua and Barbuda': Country;
            Australia: Country;
            Austria: Country;
            Azerbaijan: Country;
            Burundi: Country;
            Belgium: Country;
            Benin: Country;
            'Burkina Faso': Country;
            Bangladesh: Country;
            Bulgaria: Country;
            Bahrain: Country;
            'The Bahamas': Country;
            'Bosnia and Herzegovina': Country;
            Belarus: Country;
            Belize: Country;
            Bermuda: Country;
            Bolivia: Country;
            Brazil: Country;
            Barbados: Country;
            Brunei: Country;
            Bhutan: Country;
            Botswana: Country;
            'Central African Republic': Country;
            Canada: Country;
            Switzerland: Country;
            Chile: Country;
            China: Country;
            'Ivory Coast': Country;
            Cameroon: Country;
            'Cyprus No Mans Area': Country;
            'Democratic Republic of the Congo': Country;
            'Republic of Congo': Country;
            'Cook Islands': Country;
            Colombia: Country;
            Comoros: Country;
            'Cape Verde': Country;
            'Costa Rica': Country;
            Cuba: Country;
            Curaao: Country;
            'Cayman Islands': Country;
            'Northern Cyprus': Country;
            Cyprus: Country;
            'Czech Republic': Country;
            Germany: Country;
            Djibouti: Country;
            Dominica: Country;
            Denmark: Country;
            'Dominican Republic': Country;
            Algeria: Country;
            Ecuador: Country;
            Egypt: Country;
            Eritrea: Country;
            'Dhekelia Sovereign Base Area': Country;
            Spain: Country;
            Estonia: Country;
            Ethiopia: Country;
            Finland: Country;
            Fiji: Country;
            'Falkland Islands': Country;
            France: Country;
            'Faroe Islands': Country;
            'Federated States of Micronesia': Country;
            Gabon: Country;
            'United Kingdom': Country;
            Georgia: Country;
            Guernsey: Country;
            Ghana: Country;
            Guinea: Country;
            Gambia: Country;
            'Guinea Bissau': Country;
            'Equatorial Guinea': Country;
            Greece: Country;
            Grenada: Country;
            Greenland: Country;
            Guatemala: Country;
            Guam: Country;
            Guyana: Country;
            'Hong Kong S.A.R.': Country;
            'Heard Island and McDonald Islands': Country;
            Honduras: Country;
            Croatia: Country;
            Haiti: Country;
            Hungary: Country;
            Indonesia: Country;
            'Isle of Man': Country;
            India: Country;
            'Indian Ocean Territories': Country;
            'British Indian Ocean Territory': Country;
            Ireland: Country;
            Iran: Country;
            Iraq: Country;
            Iceland: Country;
            Israel: Country;
            Italy: Country;
            Jamaica: Country;
            Jersey: Country;
            Jordan: Country;
            Japan: Country;
            'Baykonur Cosmodrome': Country;
            'Siachen Glacier': Country;
            Kazakhstan: Country;
            Kenya: Country;
            Kyrgyzstan: Country;
            Cambodia: Country;
            Kiribati: Country;
            'Saint Kitts and Nevis': Country;
            'South Korea': Country;
            Kosovo: Country;
            Kuwait: Country;
            Laos: Country;
            Lebanon: Country;
            Liberia: Country;
            Libya: Country;
            'Saint Lucia': Country;
            Liechtenstein: Country;
            'Sri Lanka': Country;
            Lesotho: Country;
            Lithuania: Country;
            Luxembourg: Country;
            Latvia: Country;
            'Macao S.A.R': Country;
            'Saint Martin': Country;
            Morocco: Country;
            Moldova: Country;
            Madagascar: Country;
            Maldives: Country;
            Mexico: Country;
            'Marshall Islands': Country;
            Macedonia: Country;
            Mali: Country;
            Malta: Country;
            Myanmar: Country;
            Montenegro: Country;
            Mongolia: Country;
            'Northern Mariana Islands': Country;
            Mozambique: Country;
            Mauritania: Country;
            Montserrat: Country;
            Mauritius: Country;
            Malawi: Country;
            Malaysia: Country;
            Namibia: Country;
            'New Caledonia': Country;
            Niger: Country;
            Nigeria: Country;
            Nicaragua: Country;
            Niue: Country;
            Netherlands: Country;
            Norway: Country;
            Nepal: Country;
            'New Zealand': Country;
            Oman: Country;
            Pakistan: Country;
            Panama: Country;
            'Pitcairn Islands': Country;
            Peru: Country;
            'Spratly Islands': Country;
            Philippines: Country;
            Palau: Country;
            'Papua New Guinea': Country;
            Poland: Country;
            'Puerto Rico': Country;
            'North Korea': Country;
            Portugal: Country;
            Paraguay: Country;
            Palestine: Country;
            'French Polynesia': Country;
            Qatar: Country;
            Romania: Country;
            Russia: Country;
            Rwanda: Country;
            'Western Sahara': Country;
            'Saudi Arabia': Country;
            Sudan: Country;
            'South Sudan': Country;
            Senegal: Country;
            Singapore: Country;
            'South Georgia and South Sandwich Islands': Country;
            'Saint Helena': Country;
            'Solomon Islands': Country;
            'Sierra Leone': Country;
            'El Salvador': Country;
            Somalia: Country;
            'Saint Pierre and Miquelon': Country;
            'Republic of Serbia': Country;
            'Sao Tome and Principe': Country;
            Suriname: Country;
            Slovakia: Country;
            Slovenia: Country;
            Sweden: Country;
            Swaziland: Country;
            Seychelles: Country;
            Syria: Country;
            'Turks and Caicos Islands': Country;
            Chad: Country;
            Togo: Country;
            Thailand: Country;
            Tajikistan: Country;
            Turkmenistan: Country;
            'East Timor': Country;
            Tonga: Country;
            'Trinidad and Tobago': Country;
            Tunisia: Country;
            Turkey: Country;
            Tuvalu: Country;
            Taiwan: Country;
            'United Republic of Tanzania': Country;
            Uganda: Country;
            Ukraine: Country;
            'United States Minor Outlying Islands': Country;
            Uruguay: Country;
            'United States of America': Country;
            'US Naval Base Guantanamo Bay': Country;
            Uzbekistan: Country;
            'Saint Vincent and the Grenadines': Country;
            Venezuela: Country;
            'British Virgin Islands': Country;
            'United States Virgin Islands': Country;
            Vietnam: Country;
            Vanuatu: Country;
            'Wallis and Futuna': Country;
            'Akrotiri Sovereign Base Area': Country;
            Samoa: Country;
            Yemen: Country;
            'South Africa': Country;
            Zambia: Country;
            Zimbabwe: Country;
            'French Guyana': Country;
        };
        /**
         * Collection object for all possible {@link MapChart} types.
         *
         * Selected type defines the displayed Map region as well as the type of associated region data (eq. USA -\> states, World -\> countries).
         *
         * *MapType* can be specified when the *MapChart* is created:
         *
         * ``` ts
         *  const mapChart = lightningChart().Map({
         *      type: MapTypes.USA
         *  })
         * ```
         * @public
         */
        export declare type MapType = (typeof MapTypes)[keyof typeof MapTypes];
        /**
         * Type map that indicates what data is available for each *Map Region*, based on the selected *Map Type*.
         *
         * For example, {@link MapTypes | MapTypes.World} works with {@link Country} data structures, whereas {@link MapTypes | MapTypes.USA} works with {@link State} data structures.
         *
         * This affects the usage of
         * - {@link MapChart.setCursorResultTableFormatter}
         * - {@link MapChart.invalidateRegionValues}
         * @public
         */
        export declare interface MapTypeRegionProperties {
            World: Country;
            USA: State;
            NorthAmerica: Country;
            SouthAmerica: Country;
            Canada: CanadaProvinceOrTerritory;
            Europe: Country;
            Asia: Country;
            Africa: Country;
            Australia: AustraliaTerritory;
        }
        /**
         * Collection of {@link MapChart} types for selecting a section of the world to show.
         *
         * Map type is selected when the `MapChart` is created, with the `type` argument:
         *
         * ```typescript
         *  // Example, specify map type.
         *  const mapChart = lightningChart().Map({
         *      type: MapTypes.Europe,
         *  })
         * ```
         * @public
         */
        export declare const MapTypes: {
            /**
             * Map of whole world, with regions as countries.
             */
            World: "World";
            /**
             * Map of the United States of America with regions as states.
             */
            USA: "USA";
            /**
             * Map of North America, with regions as countries.
             */
            NorthAmerica: "NorthAmerica";
            /**
             * Map of South America, with regions as countries.
             */
            SouthAmerica: "SouthAmerica";
            /**
             * Map of Canada, with regions as Canadian provinces and territories.
             */
            Canada: "Canada";
            /**
             * Map of Europe, with regions as countries.
             */
            Europe: "Europe";
            /**
             * Map of Asia, with regions as countries.
             */
            Asia: "Asia";
            /**
             * Map of Africa, with regions as countries.
             */
            Africa: "Africa";
            /**
             * Map of Australia, with regions as Australian territories.
             */
            Australia: "Australia";
        };
        /**
         * Interface for a data-structure which represents a measurement of four sides.
         * Has number properties for:
         * - left
         * - top
         * - right
         * - bottom
         *
         * This data-structure is mainly used for specifying Chart paddings and UIElement paddings/margins.
         *
         * Duplicate of Padding.
         * @public
         */
        export declare interface Margin {
            /**
             * Left value.
             */
            readonly left: number;
            /**
             * Top value.
             */
            readonly top: number;
            /**
             * Right value.
             */
            readonly right: number;
            /**
             * Bottom value.
             */
            readonly bottom: number;
        }
        /**
         * Indicates object which can have margin.
         * Margin is empty space around element content (including background if any)
         * @public
         */
        export declare interface Marginable {
            /**
             * Set margin around object in pixels.
             * @param margin - Number with pixel margins for all sides or datastructure with individual pixel margins
             *                      for each side. Any side can be omitted, only passed values will be overridden.
             * @returns Object itself
             * @public
             */
            setMargin(margin: Partial<MMargin> | number): this;
            /**
             * Get margin around object in pixels.
             * @returns Margin datastructure
             * @public
             */
            getMargin(): Margin;
        }
        /**
         * Interface for a mutable data-structure which represents a 2-dimensional location and an associated Color.
         *
         * This can be used for Point-based series for coloring each point individually, when combined with usage of IndividualPointFill-style.
         * @public
         */
        export declare interface MColorPoint extends MPoint, MColorValue {
        }
        /**
         * Interface for mutable data-structure which contains a color.
         * @public
         */
        export declare interface MColorValue {
            /**
             * Color for the fill.
             */
            color: Color;
        }
        /**
         * 3D Series for rendering a 3D object model within a {@link Chart3D}.
         *
         * **Creating MeshModel3D:**
         *
         * `MeshModel3D` are created with {@link Chart3D.addMeshModel} method.
         *
         * ```typescript
         *  // Example syntax, create mesh model series
         *  const modelSeries = Chart3D.addMeshModel()
         * ```
         *
         * **Frequently used methods:**
         *
         * - Load model geometry | {@link setModelFromObj} or {@link setModelGeometry}
         * - Set model scale | {@link setScale}
         * - Set model location | {@link setModelLocation}
         * - Set model alignment | {@link setModelAlignment}
         * - Set model rotation | {@link setModelRotation}
         * - Set model fill style | {@link setFillStyle}
         * - Set color shading style (shadows, no shadows) | {@link setColorShadingStyle}
         * - Assign number values to model geometry for dynamic, data based coloring | {@link setVertexValues}
         * - Temporary hide series | {@link setVisible}
         * - Destroy series permanently | {@link dispose}
         *
         * @public
         */
        export declare class MeshModel3D extends Series3D<SolveResultMeshModel3D> {
            /**
             * Rotation of the model **in radians**.
             */
            protected _modelRotationEuler: Coord3D;
            /**
             * Rotation of the model **in quaternion**.
             */
            protected _modelRotationQuaternion: Quaternion;
            /**
             * Method for loading already triangulated 3D model geometry data.
             *
             * **To supply OBJ file content directly use {@link setModelFromObj} instead.**
             *
             * As an example, you can use the open-source NPM library `webgl-obj-loader` to process .OBJ formatted files (supported by almost every 3D Modeling software out there):
             *
             * ```ts
             *  // npm i webgl-obj-loader
             *  import { Mesh } from 'webgl-obj-loader'
             *  // Import .obj file as text
             *  const modelOBJ = require('brain.obj').default
             *
             *  const modelParsed = new Mesh(modelOBJ)
             *  const chart3D = lightningChart().Chart3D()
             *  const modelSeries = chart3D.addMeshModel()
             *      .setModelGeometry({
             *          vertices: modelParsed.vertices,
             *          indices: modelParsed.indices,
             *          normals: modelParsed.vertexNormals,
             *      })
             * ```
             *
             * @param   geometryData - Object containing triangulated 3D model geometry.
             * @returns Object itself.
             * @public
             */
            setModelGeometry(geometryData: ModelGeometry3D): this;
            /**
             * Parse material string for surface rendering information. Support just colors, not textures or other material properties.
             * @param materialSource - Material source.
             * @returns Object itself for fluent interface.
             */
            _parseMaterial(materialSource?: string): this;
            /**
             * Set model material. This will override style set with {@link setFillStyle}, if it was called before.
             * @param material - Obj material file content as text.
             * @returns Object itself for fluent interface.
             * @public
             */
            setModelMaterial(material: string): this;
            /**
             * Set model geometry from object file content.
             * i.e. `data` parameter should be contents of a OBJ formatted text file.
             *
             * @param data - Obj file content.
             * @returns Object itself for fluent interface.
             * @public
             */
            setModelFromObj(data: string): this;
            /**
             * Assign number values to each vertex of the model.
             * This can be used for dynamic coloring of the model, when paired with {@link PalettedFill}.
             *
             * ```ts
             *  // Example, dynamic per-vertex coloring (from random data, probably doesn't look too good)
             *  MeshModel3D
             *      .setFillStyle(
             *          new PalettedFill({
             *              lut: new LUT({
             *                  interpolate: true,
             *                  steps: [
             *                      { value: 0, color: ColorRGBA(0, 0, 0) },
             *                      { value: 1, color: ColorRGBA(255, 0, 0) },
             *                  ],
             *              }),
             *          })
             *      )
             *      .setVertexValues((vertexLocations) => vertexLocations.map((location) => Math.random()))
             * ```
             *
             * See more practical examples of per-vertex coloring in our {@link https://lightningchart.com/js-charts/interactive-examples/search.html?q=model | interactive examples gallery}.
             *
             * The user supplies a function which is called back with an array of the active Models vertex locations **transformed to 3D World coordinates** (which can be further translated to axes).
             * This callback function is then used to return a number array which should have a number for every vertex in the model.
             *
             * The transformation between Model coordinates and World coordinates is invalidated by many effects, like model scale, location, alignment or rotation changing.
             * After these events it may be necessary to reapply coloring by calling `setVertexValues` again.
             * Again, please refer to our {@link https://lightningchart.com/js-charts/interactive-examples/search.html?q=model | online examples} for more practical information.
             *
             * @param callback - Callback function that supplies the user with array of vertex locations in World coordinate system and expects a number array with same length to be returned.
             * @returns Object itself.
             * @public
             */
            setVertexValues(callback: (vertexLocations: Coord3D[]) => number[] | TypedArray): this;
            /**
             * Set scale of the model.
             *
             * ```javascript
             *  series.setScale(0.1)
             *  series.setScale({ x: 0.1, y: 3, z: 1 })
             * ```
             * @param scale - number for symmetric scale multiplier or object with separate scale multipliers for x, y, z..
             * @returns Object itself.
             * @public
             */
            setScale(scale: number | Partial<Coord3D>): this;
            /**
             * Get scale of the model.
             * @returns Scale of the model in format {x, y, z}
             * @public
             */
            getScale(): Coord3D;
            /**
             * Set location of the model.
             * ``` javascript
             * // Example of setting location of the model
             *   series.setModelLocation({ x: 0, y: 10, z: 0 })
             * ```
             * @param location - Location in axis coordinates
             * @returns Object itself.
             * @public
             */
            setModelLocation(location: Coord3D): this;
            /**
             * Get location of the model.
             * @returns Location of the model in format {x, y, z}.
             * @public
             */
            getModelLocation(): Coord3D;
            /**
             * Set alignment of the model.
             * Describes which "corner" of the model is positioned at model location ({@link setModelLocation}).
             *
             * @param alignment - Alignment of the model. Units in range [-1, 1].
             * @returns Object itself.
             * @public
             */
            setModelAlignment(alignment: Coord3D): this;
            /**
             * Get alignment of the model.
             * @returns Alignment of the model in format {x, y, z}.
             * @public
             */
            getModelAlignment(): Coord3D;
            /**
             * Set rotation of the model.
             * @param rotation - Rotation of the model in degrees
             * @returns Object itself.
             *
             * ``` javascript
             * // Example of setting rotation of the model
             *    series.setModelRotation({ x: 0, y: 0, z: 90 })
             * ```
             * @public
             * @deprecated Deprecated in v6.1.0, splitted into setModelRotationEuler and setModelRotationQuaternion
             *
             */
            setModelRotation(rotation: Coord3D): this;
            /**
             * Get rotation of the model.
             * @returns Rotation of the model in format {x, y, z}.
             * @public
             * @deprecated Deprecated in v6.1.0, splitted into getModelRotationEuler and getModelRotationQuaternion
             * */
            getModelRotation(): Coord3D | Quaternion;
            /**
             * Set rotation of the model.
             * @param rotation - Rotation of the model in degrees
             * @returns Object itself.
             *
             * ``` javascript
             * // Example of setting rotation of the model
             *    series.setModelRotationEuler({ x: 0, y: 0, z: 90 })
             * ```
             * @public
             *
             */
            setModelRotationEuler(rotation: Coord3D): this;
            /**
             * Get rotation of the model.
             *
             * **This returns value exactly as set using {@link setModelRotationEuler}. If rotation was configured with {@link setModelRotationQuaternion} this does NOT return correct values!**
             *
             * @returns Rotation of the model in format \{ x, y, z \} in radians.
             * @public
             * */
            getModelRotationEuler(): Coord3D;
            /**
             * Set rotation of the model.
             *
             * ``` javascript
             * // Example of setting rotation of the model
             *    series.setModelRotationQuaternion({ w:1 ,x: 0, y: 0, z: 0 })
             * ```
             * @param rotation - Rotation of the model in quaternion
             * @returns Object itself.
             * @public
             * */
            setModelRotationQuaternion(rotation: Quaternion): this;
            /**
             * Get rotation of the model.
             *
             * **This returns value exactly as set using {@link setModelRotationQuaternion}. If rotation was configured with {@link setModelRotationEuler} this does NOT return correct values!**
             *
             * @returns Rotation of the model in format { w, x, y, z }.
             * @public
             * */
            getModelRotationQuaternion(): Quaternion;
            /**
             * Set *BackfaceCullingMode* of {@link MeshModel3D}.
             * @param mode - BackfaceCullingMode
             *  - **disabled**: No culling.
             *  - **cull-back**: Cull back faces.
             *  - **cull-front**: Cull front faces.
             * @returns Object itself.
             *
             * ``` javascript
             * // Example of setting BackfaceCullingMode
             *   series.setBackfaceCullingMode('disabled')
             * ```
             * @public
             */
            setBackfaceCullingMode(mode: CullMode3D): this;
            /**
             * Get *BackfaceCullingMode* of {@link MeshModel3D}.
             * @returns BackfaceCullingMode
             */
            getBackfaceCullingMode(): CullMode3D;
            /**
             * Set model fill style. This will override material set with {@link setModelMaterial}, if it was called before.
             *
             * Can be either {@link SolidFill} for solid coloring, or {@link PalettedFill} for coloring per-vertex based on values assigned using {@link setVertexValues}.
             *
             * ```ts
             *  // Example, solid coloring
             *  MeshModel3D.setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
             * ```
             *
             * ```ts
             *  // Example, dynamic per-vertex coloring (from random data, probably doesn't look too good)
             *  MeshModel3D
             *      .setFillStyle(
             *          new PalettedFill({
             *              lut: new LUT({
             *                  interpolate: true,
             *                  steps: [
             *                      { value: 0, color: ColorRGBA(0, 0, 0) },
             *                      { value: 1, color: ColorRGBA(255, 0, 0) },
             *                  ],
             *              }),
             *          })
             *      )
             *      .setVertexValues((vertexLocations) => vertexLocations.map((location) => Math.random()))
             * ```
             *
             * See more practical examples of per-vertex coloring in our {@link https://lightningchart.com/js-charts/interactive-examples/search.html?q=model | interactive examples gallery}.
             *
             * @param value - FillStyle or function which creates a FillStyle based on previous value.
             * @returns Object itself.
             * @public
             */
            setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
            /**
             * Get *FillStyle* of {@link MeshModel3D}.
             *
             * Supports following FillStyles:
             * - **{@link SolidFill}**:
             *  Single solid color for the **Model**.
             * - **{@link PalettedFill}**:
             **Model** is colored according to its **"value"** property and the *PalettedFill* objects'
             *  *look up table*.
             * @returns FillStyle object.
             * @public
             */
            getFillStyle(): FillStyle;
            setColorShadingStyle(shadingStyle: ColorShadingStyle): this;
            addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultMeshModel3D) => unknown, options?: LCJSAddEventListenerOptions): void;
            removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultMeshModel3D) => unknown): void;
        }
        /**
         * Interface describing options for MeshModel series that can be specified during creation time.
         *
         * Used with {@link MeshModel3D.addMeshModel} method.
         *
         * @returns          Object itself.
         * @public
         */
        export declare interface MeshModel3DOptions extends SeriesOptions {
        }
        /**
         * Implementation of ScaleXY for a mixable combination of Linear and Logarithmic Scales.
         */
        declare class MixedScaleXY extends ScaleXY<LinearScale1D | LogarithmicScale1D> {
        }
        /**
         * Interface for a mutable margin-datastructure.
         */
        declare interface MMargin {
            left: number;
            top: number;
            right: number;
            bottom: number;
        }
        /**
         * Interface for a data structure of **triangulated** 3D Model geometry.
         *
         * See {@link MeshModel3D.setModelGeometry} for more information and examples.
         * @public
         */
        export declare type ModelGeometry3D = {
            /**
             * An array of vertex coordinates as flat x, y, z, x, y, z number array.
             */
            vertices: number[] | TypedArray;
            /**
             * An array of indices representing the order of vertices in triangle faces.
             */
            indices: number[] | TypedArray;
            /**
             * Optional model vertex normals as flat nx, ny, nz number array.
             */
            normals?: number[] | TypedArray;
        };
        /**
         * Collection of some useful cursor styles.
         *
         * Uses HTML DOM Style cursor property, so supported values are specified by browser.
         *
         * https://www.w3schools.com/jsref/prop_style_cursor.asp
         *
         * Use with {@link UIElement.setMouseStyle}
         * @public
         */
        export declare enum MouseStyles {
            Move = "move",
            ResizeColumn = "col-resize",
            ResizeRow = "row-resize",
            Horizontal = "ew-resize",
            Vertical = "ns-resize",
            NorthWest = "nw-resize",
            NorthEast = "ne-resize",
            Copy = "copy",
            CrossHair = "crosshair",
            Default = "default",
            Help = "help",
            Restricted = "not-allowed",
            None = "none",
            Point = "pointer",
            Text = "text",
            Wait = "wait",
            ZoomIn = "zoom-in",
            ZoomOut = "zoom-out",
            Grab = "grab",
            Grabbing = "grabbing"
        }
        /**
         * Interface for a mutable data-structure which represents a 2-dimensional location.
         * @public
         */
        export declare interface MPoint {
            /**
             * Location in X-dimension.
             */
            x: number;
            /**
             * Location in Y-dimension.
             */
            y: number;
        }
        /**
         * Interface for a strategy which defines dimension
         * @public
         */
        export declare interface MultidimensionalStrategy {
            /**
             * @param size - Two dimensional value width of which has to be extracted
             * @returns Width of Vec2
             * @public
             */
            readonly getWidth: <T>(sizes: Vec2<T>) => T;
            /**
             * @param size - Two dimensional value height of which has to be extracted
             * @returns Height of Vec2
             * @public
             */
            readonly getHeight: <T>(size: Vec2<T>) => T;
            /**
             * Combine argument with the tick value to create relevant Vec2
             * @param height - Value on height Scale units
             * @returns Vec2 which represents relevant for custom tick position
             * @public
             */
            readonly toVec2: <T>(value: T, height: T) => Vec2<T>;
            /**
             * Combine argument with the tick value to create relevant Point
             * @param height - Value on height Scale units
             * @returns Point
             * @public
             */
            readonly toPoint: (value: number, height: number) => Point;
        }
        /**
         * Internal interface for default implementations of Axis TickStrategies.
         *
         * Default implementations are immutable settings objects that users can modify with convenient setters.
         * This interface defines a method that is internally used to convert the settings object into an actual TickStrategy.
         * @public
         */
        declare interface MutableAxisTickStrategy {
        }
        /**
         * Type of a mutator function for abstract object.
         * Function provides functionality for modifying an object.
         * @param object - Object to mutate
         * @public
         */
        export declare type Mutator<T> = (object: T) => void;
        /**
         * Mutable version of Vec2. Internal use only.
         */
        declare interface MVec2<T> {
            x: T;
            y: T;
        }
        /**
         * *Axis Tick Strategy* that is designed for depicting numeric values of all magnitudes.
         *
         * **`NumericTickStrategy` is the default selection for all Axes**.
         *
         * Axis interval ranges supported by `NumericTickStrategy`:
         * - Minimum: `10e-9`
         * - Maximum: Unlimited.
         *
         * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to {@link Axis} documentation for more information.
         *
         * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
         *
         * ```js
         *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks)
         * ```
         *
         * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
         * see example below for the idea:
         *
         * ```js
         *  // Specify TickStrategy and use callback to style automatic ticks.
         *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks
         *      // All methods of `NumericTickStrategy` can be used here for styling ticks.
         *      .setMajorTickStyle((majorTicks) => majorTicks
         *          .setLabelFont((font) => font
         *              .setWeight('bold')
         *          )
         *      )
         *  )
         * ```
         *
         * All available strategies for automatic Axis ticks creation can be referenced via {@link AxisTickStrategies}.
         * @public
         */
        export declare class NumericTickStrategy extends NumericTickStrategyRecord implements MutableAxisTickStrategy {
            /**
             * Set cursor formatter for this `TickStrategy` object.
             *
             * This will override the date time formatting used by:
             * - Default cursor result table formatters.
             * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
             * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
             *
             * ```ts
             *  // Example syntax, custom cursor formatting.
             *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
             *      .setCursorFormatter((value, range, locale) =>
             *          value.toFixed(3)
             *      )
             *  )
             * ```
             * @param formatter - `FormattingFunction` or `undefined` to use default numeric cursor formatting.
             * @returns New *NumericTickStrategy* object.
             * @public
             */
            setCursorFormatter(formatter: FormattingFunction | undefined): this;
            /**
             * Get cursor formatter of this `NumericTickStrategy` object.
             *
             * @returns `FormattingFunction` as set by user, or `undefined` to indicate that the default numeric cursor formatting is configured.
             * @public
             */
            getCursorFormatter(): FormattingFunction | undefined;
            /**
             * Construct a new *NumericTickStrategy* object based on this one, but with modified extreme tick style.
             *
             * Example usage:
             *
             * **Disable extreme ticks**:
             * ```javascript
             * Axis.setTickStrategy(
             *     AxisTickStrategies.Numeric,
             *     ( tickStrategy: NumericTickStrategy ) => tickStrategy
             *         .setExtremeTickStyle( emptyTick )
             * )
             * ```
             *
             * **Set font of extreme ticks**:
             * ```javascript
             * Axis.setTickStrategy(
             *     AxisTickStrategies.Numeric,
             *     ( tickStrategy: NumericTickStrategy ) => tickStrategy
             *         .setExtremeTickStyle(( tickStyle: TickStyle ) => tickStyle
             *             .setLabelFont(( font ) => font
             *                 .setWeight( 'bold' )
             *             )
             *         )
             * )
             * ```
             * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
             *                              Passing a function only works if the existing style is **not** *emptyTick*.
             * @returns New *NumericTickStrategy* object.
             * @public
             */
            setExtremeTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
            /**
             * Get extreme tick style of this *NumericTickStrategy* object.
             * @returns Extreme tick style.
             * @public
             */
            getExtremeTickStyle(): TickStyle;
            /**
             * Construct a new *NumericTickStrategy* object based on this one, but with modified formatting offset.
             *
             * `formattingOffset` is an optional coordinate to offset from tick coordinates when formatting tick labels and default cursor labels.
             *
             * If supplied, the value of `formattingOffset` will be added to every coordinate before formatting.
             * This can be useful for offsetting displayed data ranges in cases where actual data can't be practically rendered due to extremely large numbers for example.
             *
             * ```
             *  // Example, specify formatting offset.
             *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
             *      // Will result in `0` being formatted as `1000000`
             *      .setFormattingOffset(1000000)
             *  )
             * ```
             *
             * @public
             */
            setFormattingOffset(formattingOffset: number | undefined): this;
            /**
             * Get `formattingOffset` of Tick strategy.
             *
             * `formattingOffset` is an optional coordinate to offset from tick coordinates when formatting tick labels and default cursor labels.
             *
             * If supplied, the value of `formattingOffset` will be added to every coordinate before formatting.
             * This can be useful for offsetting displayed data ranges in cases where actual data can't be practically rendered due to extremely large numbers for example.
             *
             * ```
             *  // Example, specify formatting offset.
             *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
             *      // Will result in `0` being formatted as `1000000`
             *      .setFormattingOffset(1000000)
             *  )
             * ```
             * @public
             */
            getFormattingOffset(): number | undefined;
            /**
             * This is a convenience function which simultaneously applies to both {@link setMajorTickStyle} and {@link setMinorTickStyle}, as well as the {@link setExtremeTickStyle} if they are not hidden (`emptyTick`).
             *
             * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
             * @returns New *NumericTickStrategy* object.
             * @public
             */
            setTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
            /**
             * Construct a new *NumericTickStrategy* object based on this one, but with modified major tick style.
             *
             * Example usage:
             *
             * **Set font of major ticks**:
             * ```javascript
             * Axis.setTickStrategy(
             *     AxisTickStrategies.Numeric,
             *     ( tickStrategy: NumericTickStrategy ) => tickStrategy
             *         .setMajorTickStyle(( tickStyle ) => tickStyle
             *             .setLabelFont(( font ) => font
             *                 .setWeight( 'bold' )
             *             )
             *         )
             * )
             * ```
             * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
             * @returns New *NumericTickStrategy* object.
             * @public
             */
            setMajorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
            /**
             * Get major tick style of this *NumericTickStrategy* object.
             * @returns Major tick style.
             * @public
             */
            getMajorTickStyle(): TickStyle;
            /**
             * Construct a new *NumericTickStrategy* object based on this one, but with modified minor tick style.
             *
             * Example usage:
             *
             * **Disable minor ticks**:
             * ```javascript
             * Axis.setTickStrategy(
             *     AxisTickStrategies.Numeric,
             *     ( tickStrategy: NumericTickStrategy ) => tickStrategy
             *         .setMinorTickStyle( emptyTick )
             * )
             * ```
             *
             * **Set font of minor ticks**:
             * ```javascript
             * Axis.setTickStrategy(
             *     AxisTickStrategies.Numeric,
             *     ( tickStrategy: NumericTickStrategy ) => tickStrategy
             *         .setMinorTickStyle(( tickStyle: TickStyle ) => tickStyle
             *             .setLabelFont(( font ) => font
             *                 .setWeight( 'bold' )
             *             )
             *         )
             * )
             * ```
             * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
             *                              Passing a function only works if the existing style is **not** *emptyTick*.
             * @returns New *NumericTickStrategy* object.
             * @public
             */
            setMinorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
            /**
             * Get minor tick style of this *NumericTickStrategy* object.
             * @returns Minor tick style.
             * @public
             */
            getMinorTickStyle(): TickStyle;
            /**
             * Utility method for setting *formatting function* of all numeric tick levels (extreme, major, minor) as well as cursor.
             *
             * Each formatting target can be individually overridden with following methods:
             * - {@link setExtremeFormattingFunction} | extreme ticks
             * - {@link setMajorFormattingFunction} | major ticks
             * - {@link setMinorFormattingFunction} | minor ticks
             * - {@link setCursorFormatter} | cursor result table and ticks
             * @param formattingFunction - Function that formats a tick value to text.
             * @returns New *NumericTickStrategy* object.
             * @public
             */
            setFormattingFunction(formattingFunction: FormattingFunction): this;
            /**
             * Get extreme ticks formatting function of this *NumericTickStrategy* object.
             * @returns Formatting Function.
             * @public
             */
            getExtremeFormattingFunction(): FormattingFunction | undefined;
            /**
             * Set extreme ticks formatting function of this *NumericTickStrategy* object.
             * @param formattingFunction - Formatting function to use with this *NumericTickStrategy* object.
             * @returns New *NumericTickStrategy* object.
             * @public
             */
            setExtremeFormattingFunction(formattingFunction: FormattingFunction): this;
            /**
             * Get major ticks formatting function of this *NumericTickStrategy* object.
             * @returns Formatting Function.
             * @public
             */
            getMajorFormattingFunction(): FormattingFunction | undefined;
            /**
             * Set major ticks formatting function of this *NumericTickStrategy* object.
             * @param formattingFunction - Formatting function to use with this *NumericTickStrategy* object.
             * @returns New *NumericTickStrategy* object.
             * @public
             */
            setMajorFormattingFunction(formattingFunction: FormattingFunction): this;
            /**
             * Get minor ticks formatting function of this *NumericTickStrategy* object.
             * @returns Formatting Function.
             * @public
             */
            getMinorFormattingFunction(): FormattingFunction | undefined;
            /**
             * Set minor ticks formatting function of this *NumericTickStrategy* object.
             * @param formattingFunction - Formatting function to use with this *NumericTickStrategy* object.
             * @returns New *NumericTickStrategy* object.
             * @public
             */
            setMinorFormattingFunction(formattingFunction: FormattingFunction): this;
            /**
             * See {@link NumericTickStrategyProperties.fallBackToExtremeTicksAutomatically} for details.
             * @returns Boolean
             * @public
             * @beta    Introduced in v7.0.0. May be changed according to user feedback.
             */
            getFallBackToExtremeTicksAutomatically(): boolean;
            /**
             * See {@link NumericTickStrategyProperties.fallBackToExtremeTicksAutomatically} for details.
             * @returns Boolean
             * @public
             * @beta    Introduced in v7.0.0. May be changed according to user feedback.
             */
            setFallBackToExtremeTicksAutomatically(value: boolean): this;
        }
        /**
         * Modifiable properties of a Numeric *TickStrategy*.
         *
         * @public
         */
        export declare interface NumericTickStrategyProperties {
            /**
             * Style of Extreme ticks (start & end of Axis).
             *
             * To disable extreme ticks, set to **emptyTick**.
             */
            readonly extremeTickStyle: TickStyle;
            /**
             * Style of Major ticks.
             */
            readonly majorTickStyle: TickStyle;
            /**
             * Style of Minor ticks.
             *
             * To disable minor ticks, set to **emptyTick**.
             */
            readonly minorTickStyle: TickStyle;
            /**
             * Optional coordinate to offset from tick coordinates when formatting tick labels and default cursor labels.
             *
             * If supplied, the value of `formattingOffset` will be added to every coordinate before formatting.
             * This can be useful for offsetting displayed data ranges in cases where actual data can't be practically rendered due to extremely large numbers for example.
             *
             * ```
             *  // Example, specify formatting offset.
             *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
             *      // Will result in `0` being formatted as `1000000`
             *      .setFormattingOffset(1000000)
             *  )
             * ```
             */
            readonly formattingOffset: number | undefined;
            /**
             * Cursor formatter.
             *
             * This controls the formatting used by:
             * - Default cursor result table formatters.
             * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
             * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
             *
             * `undefined` means to use default Numeric cursor formatting.
             *
             * ```ts
             *  // Example value, custom cursor formatter
             *  cursorFormatter: (value, range, locale) => value.toFixed(3)
             * ```
             */
            readonly cursorFormatter: FormattingFunction | undefined;
            /**
             * Formatting function used for extreme ticks.
             *
             * Use FormattingFunctions to select available ones or define custom function.
             *
             * **undefined** will result in default selection.
             */
            readonly extremeFormattingFunction?: FormattingFunction;
            /**
             * Formatting function used for major ticks.
             *
             * Use FormattingFunctions to select available ones or define custom function.
             *
             * **undefined** will result in default selection.
             */
            readonly majorFormattingFunction?: FormattingFunction;
            /**
             * Formatting function used for minor ticks.
             *
             * Use FormattingFunctions to select available ones or define custom function.
             *
             * **undefined** will result in default selection.
             */
            readonly minorFormattingFunction?: FormattingFunction;
            /**
             * If `true` (default) if at any time the axis would display only 1 or 0 tick labels, then automatically fallback to "extreme ticks" behavior
             * (display axis start + end).
             *
             * Aim is to avoid very unfortunate cases where only 1 tick label fits into the chart.
             * This kind of axis is practically unreadable, as the value range can not be perceived.
             *
             * @beta    Introduced in v7.0.0. May be changed according to user feedback.
             */
            readonly fallBackToExtremeTicksAutomatically: boolean;
        }
        /**
         * Default Numeric TickStrategy settings.
         * @public
         */
        declare const NumericTickStrategyRecord: Record_2.Factory<NumericTickStrategyProperties>;
        /**
         * Container class for a value that can be observed.
         * (event which is triggered when value is set)
         * Internal class
         * @public
         */
        declare class ObservableValue<T> {
        }
        /**
         * Interface for SeriesXY types whose data can be observed in detail.
         *
         * The intent is that all SeriesXY types implement this, apart from Figure series. It is used for ZoomBandChart functionality.
         * @typeParam T -   Type of data-point in Series (eq. Point, AreaPoint, XOHLC, ...).
         *
         * @privateRemarks
         * This should be private but as it's implemented by BasicSeries it has to be considered public
         *
         * @public
         */
        export declare interface ObservableXYData<T> extends EventInterface<{
        }> {
        }
        /**
         * Interface for an official LightningChart JS theme.
         *
         * On top of Theme properties, also requires "optional" theme properties utilized in Interactive Examples and other official LCJS applications.
         * @public
         */
        export declare interface OfficialTheme extends Theme {
            examples: ThemeExampleProperties;
        }
        /**
         * Interface for data values of an OHLC segment.
         * @public
         */
        export declare interface OHLCSegment {
            position: number;
            open: number;
            high: number;
            low: number;
            close: number;
            isPacked: boolean;
        }
        /**
         * Series type for visualizing trading figures in large quantities and/or with real-time data input.
         *
         * **OHLC Series is only usable with a Trading license for LightningChart JS**
         *
         * **Creating OHLCSeries:**
         *
         * `OHLCSeries` are created with {@link ChartXY.addOHLCSeries} method.
         *
         * Some properties of `OHLCSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const lineSeries = ChartXY.addOHLCSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link OHLCSeriesOptions}.
         *
         * **Frequently used methods:**
         *
         * - Append data points to series | {@link add}
         * - Remove all data points from series | {@link clear}
         * - Configure cursor enabled | {@link setCursorEnabled}
         * - Destroy series permanently | {@link dispose}
         * - Solve nearest data point from specified location | {@link solveNearest}
         * - Set figure width | {@link setFigureWidth}
         * - Enable/disable automatic figure packing | {@link setPackData}
         * - Configure auto cursor result table formatting | {@link setCursorResultTableFormatter}
         *
         * There are 2 types of OHLC series, each with their own styling API:
         * - {@link OHLCSeriesCandlesticks}
         * - {@link OHLCSeriesBars}
         *
         * By default, candlesticks are created, bars can be selected using {@link OHLCSeriesOptions.type} property.
         * @public
         */
        export declare abstract class OHLCSeries extends SeriesXY<LinearScaleXY | MixedScaleXY, SolveResultOHLC> implements ObservableXYData<XOHLC> {
            solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultOHLC | undefined;
            /**
             * Add OHLC segments to series.
             * NOTE: Added segments must always have progressive X values!
             * @param data - Array of X+OHLC values.
             * @returns Object itself for fluent interface.
             * @public
             */
            add(xohlc: XOHLC[] | XOHLC): this;
            /**
             * Enable/disable automatic data packing.
             * @param pack - Packing disabled or enabled.
             * @returns Object itself for fluent interface.
             * @public
             */
            setPackData(pack: boolean): this;
            /**
             * @returns Packing status. True = packing enabled, false = disabled. Default is true.
             * @public
             */
            getPackData(): boolean;
            /**
             * Get active state of automatic packing.
             * If packing is active, this tells how long time is represented by 1 figure (candle, bar, etc.).
             *
             * This information is not necessarily up to date when the method is called. If you are using methods like `add`, `setFigureWidth` etc.
             * before calling the method you may need to wait 1 frame (`requestAnimationFrame`) before calling this method to get the proper result.
             * @returns     Information about active packing state
             * @public
             */
            getPackDataState(): undefined | {
                figureAxisInterval: number;
            };
            /**
             * Set drawn figure width in pixels.
             * @param widthPixels - width in pixels
             * @returns Object itself for fluent interface.
             * @public
             */
            setFigureWidth(widthPixels: pixel): this;
            /**
             * Get drawn figure width in pixels.
             * @returns width in pixels
             */
            getFigureWidth(): pixel;
            /**
             * Set minimum gap between sticks in pixels when packing is enabled.
             * @param gap - minimum Gap in pixels.
             * @returns Object itself for fluent interface.
             * @public
             */
            setFigureMinimumGap(gap: pixel): this;
            /**
             * Get minimum gap between sticks in pixels when packing is enabled.
             * @returns minimum Gap in pixels.
             */
            getFigureMinimumGap(): pixel;
            /**
             * Clear all previously pushed data points from the *series*.
             *
             * ```ts
             *  // Example usage
             *  series.clear()
             * ```
             *
             * @returns Object itself for fluent interface.
             * @public
             */
            clear(): this;
            addEventListener<K extends keyof OHLCSeriesEventMap>(type: K, listener: (event: OHLCSeriesEventMap[K], info: SolveResultOHLC) => unknown, options?: LCJSAddEventListenerOptions): void;
            removeEventListener<K extends keyof OHLCSeriesEventMap>(type: K, listener: (event: OHLCSeriesEventMap[K], info: SolveResultOHLC) => unknown): void;
        }
        /**
         * Implementation of {@link OHLCSeries} displayed as bars.
         *
         * See documentation of generic super class for more instructions on how to create one, and common configuration {@link OHLCSeries}.
         *
         * **Frequently used methods:**
         *
         * - Set stroke style for negative segments | {@link setStrokeStyleNegative}
         * - Set stroke style for positive segments | {@link setStrokeStylePositive}
         *
         * @public
         */
        export declare class OHLCSeriesBars extends OHLCSeries {
            /**
             * Set positive change stroke style.
             * @returns Object itself for fluent interface.
             * @public
             */
            setStrokeStylePositive(value: LineStyle | ImmutableMutator<LineStyle>): this;
            /**
             * Get positive change stroke style.
             * @returns stroke style.
             * @public
             */
            getStrokeStylePositive(): LineStyle;
            /**
             * Set negative change stroke style.
             * @returns Object itself for fluent interface.
             * @public
             */
            setStrokeStyleNegative(value: LineStyle | ImmutableMutator<LineStyle>): this;
            /**
             * Get negative change stroke style.
             * @returns stroke style.
             * @public
             */
            getStrokeStyleNegative(): LineStyle;
            /**
             * Set drawn figure width in pixels.
             * @param widthPixels - width in pixels
             * @returns Object itself for fluent interface.
             * @public
             * @privateRemarks  Override
             */
            setFigureWidth(widthPixels: number): this;
        }
        /**
         * Implementation of {@link OHLCSeries} displayed as candlesticks.
         *
         * See documentation of generic super class for more instructions on how to create one, and common configuration {@link OHLCSeries}.
         *
         * **Frequently used methods:**
         *
         * - Set body thickness | {@link setBodyThickness}
         * - Set body fill style for negative segments | {@link setBodyFillStyleNegative}
         * - Set body fill style for positive segments | {@link setBodyFillStylePositive}
         * - Set tail stroke style for negative segments | {@link setTailStrokeStyleNegative}
         * - Set tail stroke style for positive segments | {@link setTailStrokeStylePositive}
         *
         * @public
         */
        export declare class OHLCSeriesCandlesticks extends OHLCSeries {
            /**
             * Set body thickness in pixels.
             * @param thickness - New body thickness in pixels.
             * @returns Object itself for fluent interface.
             * @public
             */
            setBodyThickness(thickness: pixel): this;
            /**
             * @returns Get body thickness in pixels.
             * @public
             */
            getBodyThickness(): pixel;
            /**
             * Set positive change fill style. Note! Supported fill style: SolidFill.
             * @returns Object itself for fluent interface.
             * @public
             */
            setBodyFillStylePositive(value: FillStyle | ImmutableMutator<FillStyle>): this;
            /**
             * Get positive change fill style. Note! Supported fill style: SolidFill.
             */
            getBodyFillStylePositive(): FillStyle;
            /**
             * Set negative change fill style. Note! Supported fill style: SolidFill.
             * @returns Object itself for fluent interface.
             * @public
             */
            setBodyFillStyleNegative(value: FillStyle | ImmutableMutator<FillStyle>): this;
            /**
             * Get negative change fill style. Note! Supported fill style: SolidFill.
             */
            getBodyFillStyleNegative(): FillStyle;
            /**
             * Set positive change tail line stroke style.
             * @returns Object itself for fluent interface.
             * @public
             */
            setTailStrokeStylePositive(value: LineStyle | ImmutableMutator<LineStyle>): this;
            /**
             * Get positive change tail line stroke style.
             * @returns Tail line stroke style.
             * @public
             */
            getTailStrokeStylePositive(): LineStyle;
            /**
             * Set negative change tail line stroke style.
             * @returns Object itself for fluent interface.
             * @public
             */
            setTailStrokeStyleNegative(value: LineStyle | ImmutableMutator<LineStyle>): this;
            /**
             * Get negative change tail line stroke style.
             * @returns Tail line stroke style.
             * @public
             */
            getTailStrokeStyleNegative(): LineStyle;
        }
        /**
         * Interface of events trackable by {@link OHLCSeries.addEventListener} and the respective Event types.
         * @public
         */
        export declare interface OHLCSeriesEventMap extends ChartComponentEventMap {
        }
        /**
         * Interface for readonly configuration of {@link OHLCSeries}.
         *
         * **Commonly used properties:**
         * - {@link OHLCSeriesOptions.xAxis}: Attach series on non-default X Axis.
         * - {@link OHLCSeriesOptions.yAxis}: Attach series on non-default Y Axis.
         * - {@link OHLCSeriesOptions.type}: Select how trading data is displayed (candlesticks, bars, etc.).
         *
         * **Example usage:**
         *
         * ```typescript
         *  // Example 1, create series with default configuration.
         *  const series = ChartXY.addOHLCSeries({})
         * ```
         *
         * ```typescript
         *  // Example 2, display data as bars
         *  const series = ChartXY.addOHLCSeries({
         *      type: OHLCSeriesTypes.Bars
         *  })
         * ```
         *
         * See also {@link ChartXY.addOHLCSeries}.
         * @public
         */
        export declare interface OHLCSeriesOptions<Type extends OHLCSeriesTypes> extends SeriesOptionsXY {
            /**
             * Specify how trading data is displayed (candlesticks, bars, etc.).
             *
             * Available options are listed and accessed via {@link OHLCSeriesTypes}.
             *
             * ```ts
             *  // Example
             *  const candlestickSeries = ChartXY.addOHLCSeries({ type: OHLCSeriesTypes.Candlesticks })
             * ```
             */
            type?: Type;
        }
        /**
         * Collection of different types of {@link OHLCSeries}.
         * Used when creating one using {@link ChartXY.addOHLCSeries} method.
         *
         * ```ts
         *  // Example
         *  const candlestickSeries = ChartXY.addOHLCSeries({ type: OHLCSeriesTypes.Candlesticks })
         * ```
         * @public
         */
        export declare const OHLCSeriesTypes: {
            /**
             * Display trading figures as Candlesticks.
             * See available styling API from {@link OHLCSeriesCandlesticks}
             *
             * ```ts
             *  // Example
             *  const candlestickSeries = ChartXY.addOHLCSeries({ type: OHLCSeriesTypes.Candlesticks })
             * ```
             * @public
             */
            Candlesticks: typeof OHLCSeriesCandlesticks;
            /**
             * Display trading figures as Bars.
             * See available styling API from {@link OHLCSeriesBars}
             *
             * ```ts
             *  // Example
             *  const ohlcSeries = ChartXY.addOHLCSeries({ type: OHLCSeriesTypes.Bars })
             * ```
             * @public
             */
            Bars: typeof OHLCSeriesBars;
        };
        /**
         * Type union for possible types of {@link OHLCSeries}.
         * @public
         */
        export declare type OHLCSeriesTypes = (typeof OHLCSeriesTypes)[keyof typeof OHLCSeriesTypes];
        /**
         * Main implementation for OnScreenMenu.
         * This class handles the DOM creation, initialization and event wiring of the core OSM container.
         *
         * @beta This feature is considered experimental and might be changed in minor release.
         */
        export declare class OnScreenMenu {
            /**
             * @public
             */
            protected chart: ChartXY;
            /**
             * Remove the position properties for the div containing osm menu button.
             * @public
             */
            removePositionProperty(): void;
            /**
             * Set the position property for the div containing the OSM menu.
             * @param position - The {@link OSMPosition} where one wants to place the OnScreenMenu on the screen.
             * @public
             */
            setPositionProperty(position: OSMPosition): void;
            /**
             * **Permanently** destroy the component.
             *
             * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
             * **to the component and its children** in application code.
             * ```javascript
             * let chart = ...ChartXY()
             * let axisX = chart.getDefaultAxisX()
             * // Dispose Chart, and remove all references so that they can be garbage-collected.
             * chart.dispose()
             * chart = undefined
             * axisX = undefined
             * ```
             * @returns Object itself for fluent interface
             * @public
             */
            dispose(): void;
            addEventListener<K extends keyof OnScreenMenuEventMap>(type: K, listener: (event: OnScreenMenuEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
            removeEventListener<K extends keyof OnScreenMenuEventMap>(type: K, listener: (event: OnScreenMenuEventMap[K], info: unknown) => unknown): void;
        }
        /**
         * On-Screen Menu button shapes.
         * @public
         */
        export declare enum OnScreenMenuButtonShape {
            Circle = 0,
            Rectangle = 1,
            RoundedRectangle = 2
        }
        /**
         * Lists the various types of pre-defined buttons that can be added to the On-Screen Menu.
         * @public
         */
        export declare enum OnScreenMenuButtonType {
            ZoomIn = 0,
            ZoomInX = 1,
            ZoomInY = 2,
            ZoomOut = 3,
            ZoomOutX = 4,
            ZoomOutY = 5,
            ZoomToFit = 6,
            ToggleAnimations = 7
        }
        /**
         * Base unit height for all controls. This value is multiplied by the
         * rows specified in the {@link OnScreenMenuDimensions} interface to get the final
         * control dimensions.
         * @public
         */
        export declare const onScreenMenuControlBaseHeight: number;
        /**
         * Base unit width for all controls. This value is multiplied by the
         * columns specified in the {@link OnScreenMenuDimensions} interface to get the final
         * control dimensions.
         * @public
         */
        export declare const onScreenMenuControlBaseWidth: number;
        /**
         * Default opacity value for all On-Screen Menu controls.
         * @public
         */
        export declare const onScreenMenuControlOpacity: string;
        /**
         * Interface to describe parameters that are used to construct a custom button for the On-Screen Menu.
         * @public
         */
        export declare interface OnScreenMenuCustomButtonParams {
            /**
             * Path to an icon that this button will display.
             */
            icon?: string;
            /**
             * Optional label to be displayed on the button.
             */
            label?: string;
            dimensions?: OnScreenMenuDimensions;
            /**
             * Optional opacity for the button. Accepts a value between 0 and 1, were 0 is transparent and 1 is opaque.
             */
            opacity?: string;
            /**
             * Optional color value for this button. If no value is specified, the color will be chosen from the theme.
             */
            color?: string;
            /**
             * Optional value for the shape of the button.
             */
            shape?: OnScreenMenuButtonShape;
            /**
             * Function that represents the action to be performed on the click of the button.
             */
            action: (chart: ChartXY) => void;
        }
        /**
         * Default button Shape for all On-Screen menu buttons.
         * @public
         */
        export declare const onScreenMenuDefaultButtonShape: OnScreenMenuButtonShape;
        /**
         * Interface that describes an abstract dimensions for {@link OnScreenMenu} controls.
         * We use this to determine sizing based on a grid layout in HTML.
         * @public
         */
        export declare interface OnScreenMenuDimensions {
            /**
             * The number of rows in the grid the control will take up.
             */
            rows: number;
            /**
             * The number of columns in the grid the control will take up.
             */
            columns: number;
        }
        /**
         * Interface of events trackable by {@link OnScreenMenu.addEventListener} and the respective Event types.
         * @public
         */
        export declare interface OnScreenMenuEventMap extends DisposableEventMap {
        }
        /** @public */
        export declare interface OnScreenMenuIconSet {
            ZoomIn: string | SpriteImagePosition;
            ZoomInX: string | SpriteImagePosition;
            ZoomInY: string | SpriteImagePosition;
            ZoomOut: string | SpriteImagePosition;
            ZoomOutX: string | SpriteImagePosition;
            ZoomOutY: string | SpriteImagePosition;
            ZoomToFit: string | SpriteImagePosition;
            EnableAnimation: string | SpriteImagePosition;
            DisableAnimation: string | SpriteImagePosition;
            CollapseMenu: string | SpriteImagePosition;
            ShowMenu: string | SpriteImagePosition;
        }
        /**
         * url for sprite image
         * @public
         */
        export declare const onScreenMenuSpriteURL: string;
        /**
         * Enum for various types of pre-defined positions that On-Screen Menu button can take.
         * @public
         */
        export declare enum OSMPosition {
            TopRight = 0,
            TopLeft = 1,
            BottomLeft = 2,
            BottomRight = 3
        }
        /**
         * Interface for a data-structure which represents a measurement of four sides.
         * Has number properties for:
         * - left
         * - top
         * - right
         * - bottom
         *
         * This data-structure is mainly used for specifying Chart paddings and UIElement paddings/margins.
         *
         * Duplicate of Margin.
         * @public
         */
        export declare type Padding = Margin;
        /**
         * Type of an abstract Palette function.
         * NOTE: It is common for applications dealing with Palettes to assume that they are continuous,
         * meaning that when supplied an overflowing index, it will return loop back to start.
         * @param index - Index of item to pick from Palette
         * @returns Generated item
         * @public
         */
        export declare type Palette<T> = (index: number) => T;
        /**
         * Style class for describing a *dynamically looked up fill color*. Using a PalettedFill, each data point (or even pixel) can be colored individually.
         * The basis of coloring can be configured extensively, with a variety of different option combinations (read below for details).
         *
         * Instances of PalettedFill, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
         * but instead return a completely new modified object.
         *
         * **Properties of PalettedFill:**
         * - `lut`: color lookup table. Essentially a list of *colors* paired with numeric values. See {@link LUT} for more details.
         * - `lookUpProperty`: selects basis of color lookup. See {@link LookUpProperty} for possible options.
         *
         * **PalettedFill Usage:**
         *
         * PalettedFill can be used with a select group of features:
         *
         * - {@link PointSeries.setPointFillStyle}
         * - {@link SurfaceGridSeries3D.setFillStyle}
         * - {@link SurfaceScrollingGridSeries3D.setFillStyle}
         * - {@link PointSeries3D.setPointStyle}
         * - {@link BoxSeries3D.setFillStyle}
         * - {@link MapChart.setFillStyle}
         *
         * ```typescript
         *  // Example 1, paletted points fill by 'y' coordinates.
         *  PointSeries.setPointFillStyle(new PalettedFill({
         *      lookUpProperty: 'y',
         *      lut: new LUT({
         *          interpolate: true,
         *          steps: [
         *              { value: 0, color: ColorRGBA( 0, 0, 0 ) },
         *              { value: 10, color: ColorRGBA( 255, 0, 0 ) },
         *              { value: 20, color: ColorRGBA( 0, 255, 0 ) },
         *              { value: 30, color: ColorRGBA( 0, 0,255 ) },
         *          ]
         *      })
         *  }))
         * ```
         *
         * ```typescript
         *  // Example 2, paletted points fill by user supplied data point values.
         *  PointSeries
         *      .setPointFillStyle(new PalettedFill({
         *           lookUpProperty: 'value',
         *           lut: new LUT({
         *               interpolate: true,
         *               steps: [
         *                   { value: 0, color: ColorRGBA( 0, 0, 0 ) },
         *                   { value: 100, color: ColorRGBA( 255, 0, 0 ) },
         *               ]
         *           })
         *      }))
         *      .add([
         *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
         *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
         *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
         *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
         *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
         *      ])
         * ```
         *
         * **Related information:**
         *
         * For more *fill styles*, see:
         * - {@link SolidFill}
         * - {@link emptyFill}
         * - {@link IndividualPointFill}
         * - {@link RadialGradientFill}
         * - {@link LinearGradientFill}
         *
         * @public
         */
        export declare class PalettedFill<T extends LookUpProperty = LookUpProperty> extends PalettedFillStyleRecord implements FillStyle {
            /**
             * Construct a PalettedFill object, specifying any amount of its properties.
             *
             * ```typescript
             *  // Example 1, palette by 'y' coordinate.
             *  const paletteY = new PalettedFill({
             *      lookUpProperty: 'y',
             *      lut: new LUT({
             *          interpolate: true,
             *          steps: [
             *              { value: 0, color: ColorRGBA( 0, 0, 0 ) },
             *              { value: 10, color: ColorRGBA( 255, 0, 0 ) },
             *              { value: 20, color: ColorRGBA( 0, 255, 0 ) },
             *              { value: 30, color: ColorRGBA( 0, 0,255 ) },
             *          ]
             *      })
             *  })
             * ```
             *
             * ```typescript
             *  // Example 2, palette by user supplied data point values.
             *  const paletteValue = new PalettedFill({
             *      lookUpProperty: 'value',
             *      lut: new LUT({
             *          interpolate: true,
             *          steps: [
             *              { value: 0, color: ColorRGBA( 0, 0, 0 ) },
             *              { value: 100, color: ColorRGBA( 255, 0, 0 ) },
             *          ]
             *      })
             *  })
             * ```
             *
             * For more details, see {@link LUT}, and {@link LookUpProperty}.
             *
             * @param props - Object containing any amount of PalettedFill properties.
             * @public
             */
            constructor(props?: Partial<PalettedFillProperties<T>>);
            /**
             * Get CSS representation of the FillStyle.
             * @public
             */
            toCSS(): string;
            /**
             * Get LUT lookup table.
             * @returns LUT object.
             * @public
             */
            getPalette(): LUT;
            /**
             * Construct a new PalettedFill object based on this one, but with modified 'lookUpProperty'.
             *
             * Example:
             * ```ts
             * palettedFill.setLookUpProperty( 'y' )
             * ```
             * @param value - {@link LookUpProperty}.
             * @returns New PalettedFill object.
             * @public
             */
            setLookUpProperty<PT extends LookUpProperty>(value: PT | ImmutableMutator<LookUpProperty, PT>): PalettedFill<PT>;
            /**
             * Get look up property of PalettedFill.
             * @returns {@link LookUpProperty}.
                 * @public
                 */
             getLookUpProperty(): LookUpProperty;
            }
            /**
             * Interface for all properties of a PalettedFillStyle.
             * @public
             */
            export declare interface PalettedFillProperties<T extends LookUpProperty = LookUpProperty> {
                type: 'fillstyle';
                fillType: 'palette';
                /**
                 * Color lookup table, which describes the relation of `lookUpProperty` values to colors.
                 */
                lut: LUT;
                /**
                 * Identifier that points to a property to be used when picking colours from attached Look Up Table.
                 *
                 * Possible values are:
                 * - **"value"**
                 * - **"x"**
                 * - **"y"**
                 * - **"z"**
                 *
                 * Features that support assigning a {@link PalettedFill} contain additional per-feature information, which
                 * properties are supported, and how they behave.
                 */
                lookUpProperty: T;
            }
            /**
             * Record contractor for PalettedFillStyleProperties.
             * @public
             */
            declare const PalettedFillStyleRecord: Record_2.Factory<PalettedFillProperties<LookUpProperty>>;
            /**
             * Type of an abstract Palette factory.
             * @param length - Length of Palette
             * @returns Palette of specified length
             * @public
             */
            export declare type PaletteFactory<T> = (length: number, color?: Color) => Palette<T>;
            /**
             * Abstract base class for charts and UI panels
             * @public
             */
            export declare abstract class Panel implements Control, DashboardPanel {
                /**
                 * Selector for "relative" _Coordinate System_.
                 *
                 * This coordinate system is relative to the bottom left corner of the Control (chart/dashboard/etc.), and is measured as pixels.
                 * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from bottom.
                 *
                 * This selector can be used for two purposes:
                 *
                 * **Positioning LCJS UI elements in pixels:**
                 *
                 * ```ts
                 *  // Position UI element in pixels by supplying `Control.coordsRelative` as its positioning system.
                 *  const textBox = Control.addUIElement(UIElementBuilders.TextBox, Control.coordsRelative)
                 *      .setOrigin(UIOrigins.LeftBottom)
                 *      .setPosition({ x: 100, y: 20 })
                 * ```
                 *
                 * **Translations between coordinate systems:**
                 *
                 * Use with {@link translateCoordinate} method to translate coordinates from "relative" to another coordinate system.
                 *
                 * @public
                 */
                readonly coordsRelative: CoordinateSystemRelative;
                /**
                 * Selector for "client" _Coordinate System_.
                 *
                 * This references the coordinate system used in HTML.
                 * It starts at top left of the web page and is measured in pixels.
                 * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
                 *
                 * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
                 *
                 * This selector can be used for translating client coordinates to other coordinate systems and vice versa.
                 * For example, in order to:
                 * - Position LCJS UI elements in client coordinates
                 * - Find client coordinate that matches a location along LCJS Axis or Chart.
                 * - etc.
                 *
                 * See {@link translateCoordinate} for more detailed use case information and example usage.
                 *
                 * @public
                 */
                readonly coordsClient: CoordinateSystemClient;
                /**
                 * The default Legend reference of the panel.
                 * @public
                 */
                readonly legend: Legend;
                /**
                 * Interface for end user API of the LCJS engine.
                 * It provides some useful capabilities over the area enclosed by a single LCJS context (which can be just a single chart, or a Dashboard with several charts).
                 * @public
                 */
                readonly engine: PublicEngine;
                /**
                 * Scale for panel area in percentages (0-100).
                 *
                 * While it is not functionally equal to this, using [[coordsRelative]] coordinate system is preferred (more confidence for long term support).
                 * @public
                 */
                uiScale: LinearScaleXY;
                /**
                 * @public
                 */
                protected removePanel: (panel: Panel) => void;
                /**
                 * Get minimum size of Panel.
                 * Depending on the type of class this value might be automatically computed to fit different elements.
                 * @returns Point minimum size or undefined if unimplemented
                 * @public
                 */
                abstract getMinimumSize(): Point | undefined;
                /**
                 * Returns the Theme currently being used.
                 * @returns An object containing the Theme.
                 * @public
                 */
                getTheme(): Theme;
                /**
                 * Get size of control as pixels.
                 *
                 * For stand-alone component, the size will be equal to the size of its containing HTML \<div\> (`Control.engine.container`)
                 *
                 * For component inside Dashboard, the size will only include the component itself, so size can be less than the size of containing HTML \<div\>.
                 *
                 * @returns     Object with x and y properties `{ x: number, y: number }`, where both are pixel values.
                 * @public
                 */
                getSizePixels(): Point;
                /**
                 * Set {@link FillStyle} of chart background.
                 *
                 * ```typescript
                 *  // Example usage,
                 *  ChartXY.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 80, 0, 0 ) }))
                 * ```
                 *
                 * **Related API:**
                 * - Use {@link SolidFill} to describe a solid fill color.
                 * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
                 *
                 * **Transparent chart backgrounds:**
                 *
                 * LightningChart JS charts can be configured to be fully or partially transparent.
                 *
                 * ```ts
                 *  // Example, partially transparent chart
                 *
                 *  // Engine background exists under all LCJS components. In case of Dashboard, there is only 1 shared engine background.
                 *  chart.engine.setBackgroundFillStyle(emptyFill)
                 *  // Chart background covers every 1 chart. In case of Dashboard, every chart has its own chart background.
                 *  chart.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
                 *  // Some charts also have a separate series background.
                 *  chart.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
                 * ```
                 *
                 * @param value - `FillStyle` or function which mutates the active `FillStyle`.
                 * @returns Object itself
                 * @public
                 */
                setBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                /**
                 * Get fillstyle of chart background.
                 * @returns FillStyle
                 * @public
                 */
                getBackgroundFillStyle(): FillStyle;
                /**
                 * Set {@link LineStyle} of chart background border stroke.
                 *
                 * ```typescript
                 *  // Example usage,
                 *  ChartXY.setBackgroundStrokeStyle(new SolidLine({
                 *      thickness: 2,
                 *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
                 *  }))
                 * ```
                 *
                 * **Related API:**
                 * - Use {@link SolidLine} to describe a solid line style.
                 * - Use {@link SolidFill} to describe a solid fill color.
                 * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
                 *
                 * @param value - `LineStyle` or function which mutates the active `LineStyle`.
                 * @returns Object itself
                 * @public
                 */
                setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                /**
                 * Get stroke style of chart background.
                 * @returns LineStyle
                 * @public
                 */
                getBackgroundStrokeStyle(): LineStyle;
                /**
                 * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
                 *
                 * ```ts
                 *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
                 *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
                 *  // locationRelative is in pixels relative to bottom left corner of the chart
                 * ```
                 *
                 * Relative coordinates can be used for positioning LightningChart JS UI components:
                 *
                 * ```ts
                 *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
                 *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
                 *      .setOrigin(UIOrigins.LeftBottom)
                 *      .setPosition({ x: 20, y: 20 })
                 * ```
                 *
                 * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                 * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                 *
                 * ```ts
                 *  LineSeries.add(myData)
                 *  requestAnimationFrame(() => {
                 *      // translateCoordinate should now consider data added just now.
                 *  })
                 * ```
                 *
                 * @public
                 */
                translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
                /**
                 * Translate a coordinate from relative control coordinates to HTML client coordinate system.
                 *
                 * ```ts
                 *  // 10 pixels left and 20 pixels up from controls bottom left corner
                 *  const locationRelative = { x: 10, y: 20 }
                 *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
                 * ```
                 *
                 * Client coordinates can be used to absolute position HTML elements using CSS, for example.
                 *
                 * ```ts
                 *  myHTMLElement.style.position = 'absolute'
                 *  myHTMLElement.style.left = locationClient.clientX
                 *  myHTMLElement.style.top = locationClient.clientY
                 * ```
                 *
                 * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                 * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                 *
                 * ```ts
                 *  LineSeries.add(myData)
                 *  requestAnimationFrame(() => {
                 *      // translateCoordinate should now consider data added just now.
                 *  })
                 * ```
                 *
                 * @public
                 */
                translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
                /**
                 * Add a stand-alone *UIElement* using a *builder*.
                 *
                 * **Example usage:**
                 *
                 * 1) TextBox with default positioning coordinate system.
                 *
                 * ```typescript
                 *  addUIElement( UIElementBuilders.TextBox )
                 *      // Position = [0, 100] as percentages.
                 *      .setPosition({ x: 50, y: 50 })
                 * ```
                 *
                 * 2) Position in pixel coordinate system.
                 *
                 * ```typescript
                 *  addUIElement( UIElementBuilders.TextBox, chart.coordsRelative )
                 *      // Position = pixels.
                 *      .setPosition({ x: 300, y: 100 })
                 * ```
                 *
                 * 3) Position on Axes.
                 *
                 * ```typescript
                 *  addUIElement( UIElementBuilders.TextBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
                 *      // Position = Axis values.
                 *      .setPosition({ x: 5, y: 5 })
                 * ```
                 *
                 * @typeParam UIElementType - Type of *UIElement* that is specified by 'builder'-*parameter*.
                 *
                 * @param builder - *UIElementBuilder*. If omitted, *TextBoxBuilder* will be selected. Use {@link UIElementBuilders} for selection.
                 * @param scale - Optional parameter for altering the coordinate system used for positioning the UIElement. Defaults to whole Chart in percentages [0, 100].
                 * @returns Object that fulfills *interfaces*:  *UIElementType* (typeparam) and *UIElement*
                 * @public
                 */
                addUIElement<UIElementType extends UIPart = UITextBox>(builder?: UIElementBuilder<UIElementType>, scale?: UserScaleDefinition): UIElementType & UIElement;
                /**
                 * **Permanently** destroy the component.
                 *
                 * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                 * **to the component and its children** in application code.
                 * ```javascript
                 * let chart = ...ChartXY()
                 * let axisX = chart.getDefaultAxisX()
                 * // Dispose Chart, and remove all references so that they can be garbage-collected.
                 * chart.dispose()
                 * chart = undefined
                 * axisX = undefined
                 * ```
                 * @returns Object itself for fluent interface
                 * @public
                 */
                dispose(): this;
                /**
                 * Check whether the object is disposed.
                 * Disposed objects should not be used!
                 *
                 * @returns     `true` if object is disposed.
                 * @public
                 */
                isDisposed(): boolean;
                /**
                 * Capture rendered state in an image file. Prompts the browser to download the created file.
                 *
                 * **NOTE: The download might be blocked by browser/plugins as harmful.**
                 * To prevent this, only call the method in events tied to user-interactions.
                 * From mouse-event handlers, for example.
                 *
                 * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
                 * For supported image formats, compression quality, Etc. refer to:
                 *
                 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
                 *
                 * Example usage:
                 *```javascript
                 * // Download 'screenshot.png'
                 * Panel.saveToFile('screenshot')
                 * // Attempt download 'maybeNotSupported.bmp'
                 * Panel.saveToFile('maybeNotSupported', 'image/bmp')
                 * // Attempt download jpeg.file with specified compression quality
                 * Panel.saveToFile('fileName', 'image/jpeg', 0.50)
                 * ```
                 * @remarks              **If 'type' is not supported by browser, an Error will be thrown.**
                 *
                 * @param fileName - Name of prompted download file as string. **File extension shouldn't be included**
                 *                          as it is automatically detected from 'type'-argument.
                 * @param type - A DOMString indicating the image format. The default format type is image/png.
                 * @param encoderOptions - A Number between 0 and 1 indicating the image quality to use for image formats
                 *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
                 *                          the default value for image quality is used. The default value is 0.92.
                 * @param scale - Convenience output scaling factor. This doesn't actually stretch the result, but instead draws an altered scaled version and captures that.
                 * @public
                 */
                saveToFile(fileName: string, type?: string, encoderOptions?: number, scale?: number): this;
                /**
                 * Flag that is set whenever Panel or any scale is resized.
                 *
                 * Will be handled before plot to update scale and trigger resize event just once per frame.
                 */
                protected _isPanelResized: boolean;
                /**
                 * Find if chart is currently considered to be in the browser viewport.
                 * @returns `true` when panel is in view
                 */
                getIsInView(): boolean;
                /**
                 * Interface for attaching listeners to user interaction events (`click`, `pointerenter`, etc.) on chart background.
                 *
                 * ```ts
                 *  // Example syntax
                 *  chart.background.addEventListener('click', (event) => {
                 *      console.log(event)
                 *  })
                 * ```
                 *
                 * For syntax examples, refer to {@link EventInterface}.
                 * Available event keys are listed under {@link LCJSInteractionEventMap}
                 *
                 * **Please note that many chart types have a separate "series background" (area enclosed by axes), which has its own separate events**.
                 * This is accessed via {@link seriesBackground} property.
                 * @public
                 */
                readonly background: Eventer<LCJSInteractionEventMap, any>;
                abstract addEventListener<K extends keyof PanelEventMap>(type: K, listener: (event: PanelEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                abstract removeEventListener<K extends keyof PanelEventMap>(type: K, listener: (event: PanelEventMap[K], info: unknown) => unknown): void;
            }
            /**
             * Interface of events trackable by {@link Panel.addEventListener} and the respective Event types.
             * @public
             */
            export declare interface PanelEventMap extends DisposableEventMap, ResizableEventMap {
                /**
                 * Event fired when the components visibility on web page changes.
                 *
                 * ```ts
                 *  // Example usage
                 *  chart.addEventListener('inviewchange', (event) => {
                 *      console.log(event)
                 *  })
                 * ```
                 */
                inviewchanged: InViewChangedEvent;
            }
            /**
             * Class that represents one Axis in a {@link ParallelCoordinateChart}.
             * Axes are first created using {@link ParallelCoordinateChart.setAxes}, and later can be accessed using {@link ParallelCoordinateChart.getAxis} or {@link ParallelCoordinateChart.axes}.
             * @public
             */
            export declare class ParallelCoordinateAxis extends GenericAxis<LinearScale1D, AbstractAxisStrategy, _AbstractAxisTick, _ParallelCoordinateAxisInput, _ParallelCoordinateAxisPlottingVariables, _ParallelCoordinateAxisTickInfo, _ParallelCoordinateAxisOutput> implements DisposableEvents {
                /**
                 * @public
                 */
                readonly chart: ParallelCoordinateChart;
                /**
                 * Key of the Axis. Generally this is the `string` property name of data samples.
                 * e.g. `"Height"` or `"Weight"`, etc.
                 * @public
                 */
                readonly key: string;
                /**
                 * Additional user supplied identification apart from the Axis {@link key}.
                 * Generally this is a number index (nth axis), or when using Enum-like approach to defining Axes, the value of the Enum-like entry:
                 *
                 * ```ts
                 *  // Enum-like approach syntax
                 *  const Axes = {
                 *      Weight: 0,
                 *      Height: 1,
                 *      'Eye color': 2,
                 *  }
                 *  chart.setAxes(Axes)
                 *  chart.getAxis(Axes.Height).userID // `1`
                 * ```
                 * @public
                 */
                readonly userID: unknown;
                /**
                 * Set fill style of background behind the Axis.
                 * By default this is a linear gradient that helps with readability of the tick labels.
                 *
                 * @param arg -     FillStyle or function that mutates current FillStyle.
                 * @returns     Object itself.
                 * @public
                 */
                setBackgroundFillStyle(arg: FillStyle | ImmutableMutator<FillStyle>): this;
                /**
                 * Get fill style of background behind the Axis.
                 * By default this is a linear gradient that helps with readability of the tick labels.
                 * @returns     FillStyle object.
                 * @public
                 */
                getBackgroundFillStyle(): FillStyle;
                /**
                 * Set stroke style of axis line, that goes from start of axis to end of axis.
                 * To highlight LUT of the Axis, you can give a `SolidLine` object with `fillStyle: PalettedFill` to also show the LUT on the Axis stroke.
                 *
                 * @param value -   LineStyle or function which mutates current LineStyle.
                 * @returns     Object itself.
                 * @public
                 */
                setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                /**
                 * Get stroke style of axis line, that goes from start of axis to end of axis.
                 * @returns     LineStyle object.
                 * @public
                 */
                getStrokeStyle(): LineStyle;
                /**
                 * Set *TickStrategy* of *Axis*.
                 *
                 * The *TickStrategy* defines the positioning and formatting logic of *Axis* ticks
                 * as well as the style of created ticks.
                 *
                 * **Example usage**:
                 *
                 * **DateTime Axis**:
                 * ```javascript
                 *  Axis.setTickStrategy( AxisTickStrategies.DateTime )
                 * ```
                 *
                 * **Disable automatic ticks completely**:
                 * ```javascript
                 *  Axis.setTickStrategy( AxisTickStrategies.Empty )
                 * ```
                 *
                 * **Customized TickStrategy**:
                 * ```javascript
                 *  Axis.setTickStrategy( AxisTickStrategies.Numeric, ( tickStrategy: NumericTickStrategy ) => tickStrategy
                 *      .setNumericUnits( true )
                 *      .setMajorTickStyle( ( tickStyle ) => tickStyle
                 *          .setLabelFont( ( font ) => font
                 *              .setWeight( 'bold' )
                 *          )
                 *      )
                 *  )
                 * ```
                 *
                 * **Type table for optional second parameter ('styler')**:
                 *
                 * | tickStrategy   | styler                                                        |
                 * | :------------- | :------------------------------------------------------------ |
                 * | 'Numeric'      | `( tickStrategy: **NumericTickStrategy** ) => tickStrategy`   |
                 * | 'Time'         | `( tickStrategy: **TimeTickStrategy** ) => tickStrategy`      |
                 * | 'DateTime'     | `( tickStrategy: **DateTimeTickStrategy** ) => tickStrategy`  |
                 * | 'Empty'        | `undefined`                                                   |
                 *
                 *
                 * @param tickStrategy - Selected TickStrategy.
                 *                          See {@link AxisTickStrategies} for a collection of options.
                 * @param styler - Optional callback that can be used to customize the *TickStrategy*.
                 *                          The type of supplied *TickStrategy* object depends on what was supplied to 'tickStrategy' parameter;
                 *                          See the above method documentation for a value table.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setTickStrategy<TickStrategy extends TickStrategyType>(tickStrategy: TickStrategy, styler?: TickStrategyStyler<TickStrategyParameters, TickStrategy>): this;
                /**
                 * Get the currently used tick strategy
                 * @public
                 */
                getTickStrategy(): TickStrategyType;
                /**
                 * Programmatically add a Range Selector to the Axis.
                 * These are used to highlight filtered series in the chart in use cases where you can have even thousands of series at same time.
                 * A Range selector defines a value range (start-end) along 1 specific Axis, and as a result all series whose value on that Axis is within the range are highlighted.
                 *
                 * ```ts
                 *  // Example syntax
                 *  const rangeSelector = chart.getAxis('Key').addRangeSelector().setInterval(0, 1)
                 * ```
                 *
                 * Range selectors can also be created using built-in interaction of double clicking an Axis.
                 * @returns     ParallelCoordinateAxisRangeSelector object.
                 * @public
                 */
                addRangeSelector(): ParallelCoordinateAxisRangeSelector;
                /**
                 * Add an end user managed tick to the axis.
                 *
                 * Custom ticks are just like default ticks, except they can be completely controlled by the end user.
                 *
                 * ```ts
                 *  // Example
                 *  const customTick = Axis.addCustomTick()
                 *      // Tick position on Axis.
                 *      .setValue(100)
                 *      .setTextFormatter((value) => `Custom tick at ${value.toFixed(1)}`)
                 * ```
                 *
                 * For full set of configuration API, see {@link ParallelCoordinateAxisCustomTick}.
                 *
                 * @returns     ParallelAxisCustomTick.
                 * @public
                 */
                addCustomTick(): ParallelCoordinateAxisCustomTick;
                /**
                 * Get all custom ticks added to the axis.
                 * @returns Array of ParallelCoordinateAxisCustomTick instances.
                 * @public
                 */
                getCustomTicks(): ParallelCoordinateAxisCustomTick[];
                /**
                 * Check whether the object is disposed.
                 * Disposed objects should not be used!
                 *
                 * @returns     `true` if object is disposed.
                 * @public
                 */
                isDisposed(): boolean;
                /**
                 * Used in phase 1: after we know what ticks will be displayed, formulate generic information for chart layout calculations (e.g. XY layout for XY charts).
                 */
                protected _getAbstractUpdateResult(input: _ParallelCoordinateAxisInput, ticksInfo: Map<_AbstractAxisTick, _ParallelCoordinateAxisTickInfo>, updatedTicks: boolean): _ParallelCoordinateAxisOutput;
                addEventListener<K extends keyof GenericAxisEventMap>(type: K, listener: (event: GenericAxisEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                removeEventListener<K extends keyof GenericAxisEventMap>(type: K, listener: (event: GenericAxisEventMap[K], info: unknown) => unknown): void;
                setPointerEvents(state: boolean): this;
                getPointerEvents(): boolean;
            }
            /**
             * End user managed Axis Tick in a ParallelCoordinateChart. Custom ticks are just like default ticks, except they can be completely controlled by the end user.
             *
             * For example, their position, text, text fill style, gridline style, etc. everything can be customized.
             * They can be created whenever and destroyed whenever.
             *
             * They are created with {@link ParallelCoordinateAxis.addCustomTick} method, and destroyed with {@link dispose} method.
             *
             * ```ts
             *  // Example
             *  const customTick = ParallelCoordinateChart.getAxis(0).addCustomTick()
             *      // Tick position on Axis.
             *      .setValue(100)
             *      .setTextFormatter((value) => `Custom tick at ${value.toFixed(1)}`)
             * ```
             *
             * Default Axis ticks can be hidden by selecting empty tick strategy.
             *
             * ```ts
             *  // Remove default ticks.
             *  ParallelCoordinateChart.getAxis(0).setTickStrategy(AxisTickStrategies.Empty)
             * ```
             *
             * @public
             * @privateRemarks  End user interface for Parallel Coordinate Axis custom tick.
             */
            export declare interface ParallelCoordinateAxisCustomTick extends AbstractCustomTick {
                /**
                 * Set alignment of Label respective to tick line.
                 *
                 * **after**: -1
                 *
                 * **center**: 0
                 *
                 * **before**: +1
                 * @param alignment - Label alignment [-1, 1].
                 * @returns     Object itself
                 * @public
                 */
                setLabelAlignment(alignment: number): this;
                /**
                 * Get alignment of Label respective to tick line.
                 * @returns alignment [-1, 1].
                 * @public
                 */
                getLabelAlignment(): number;
            }
            /**
             * @public
             * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
             */
            declare interface _ParallelCoordinateAxisInput extends _GenericAxisInput {
            }
            /**
             * @public
             * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
             */
            declare interface _ParallelCoordinateAxisOutput extends _GenericAxisOutput<_AbstractAxisTick, _ParallelCoordinateAxisTickInfo> {
            }
            /**
             * @public
             * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
             */
            declare interface _ParallelCoordinateAxisPlottingVariables extends _GenericTickPlottingVariables {
            }
            /**
             * Interface that represents a Range Selector on a Parallel coordinate axis.
             * Created using {@link ParallelCoordinateAxis.addRangeSelector}.
             * @public
             */
            export declare interface ParallelCoordinateAxisRangeSelector {
                /**
                 * Set range of the selector.
                 *
                 * ```ts
                 *  // Example syntax
                 *  rangeSelector.setInterval(0, 10)
                 * ```
                 * @param   a -     Interval A coordinate
                 * @param   b -     Interval B coordinate
                 * @returns     Object itself.
                 * @public
                 */
                setInterval(a: number, b: number): this;
                /**
                 * Set mouse interactions enabled or not.
                 * @param state -   Boolean
                 * @returns     Object itself.
                 * @public
                 */
                setPointerEvents(state: boolean): this;
                /**
                 * Remove the selector permanently
                 * @returns     Object itself.
                 * @public
                 */
                dispose(): this;
            }
            /**
             * @public
             * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
             */
            declare interface _ParallelCoordinateAxisTickInfo extends _GenericTickInfo {
            }
            /**
             * Chart for visualizing a number of series with any number of observed numeric data properties.
             * The parallel coordinate chart consists of any number of axes, and any number of series along those axes.
             *
             * ```ts
             *  // Basic syntax
             *  const chart = lightningChart().ParallelCoordinateChart()
             *  const Axes = {
             *      'Variable A': 0,
             *      'Variable B': 1,
             *      'Variable C': 2,
             *  }
             *  chart.setAxes(Axes)
             *  chart.getAxis(Axes['Variable A']).setInterval({ start: 20, end: 60 })
             *  chart.getAxis(Axes['Variable B']).setInterval({ start: 80, end: 120 })
             *  chart.getAxis(Axes['Variable C']).setInterval({ start: 0.0, end: 2.5 })
             *
             *  const series1 = chart.addSeries().setName('Sample 1').setData({
             *    'Variable A': 50,
             *    'Variable B': 100,
             *    'Variable C': 2.0,
             *  })
             * ```
             *
             * @public
             */
            export declare class ParallelCoordinateChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithSeries<ParallelCoordinateSeries> implements ChartWithAxis<ParallelCoordinateAxis>, ChartWithCursor<CursorResultTableBackgroundType, CursorPosition2D, Cursor2D<CursorResultTableBackgroundType>, SolveResultParallelCoordinate> {
                /**
                 * Reference to the axes of the parallel coordinate chart.
                 * **Do not modify directly!**
                 */
                axes: ParallelCoordinateAxis[];
                setCursor(mutator: Mutator<Cursor2D<CursorResultTableBackgroundType>>): this;
                getCursor(): Cursor2D<CursorResultTableBackgroundType>;
                setCursorMode(mode: SolveNearestMode | undefined): this;
                getCursorMode(): SolveNearestMode | undefined;
                setCustomCursor(clbk: undefined | ((event: CursorTargetChangedEvent<SolveResultParallelCoordinate>) => unknown)): this;
                setCursorDynamicBehavior(value: CursorDynamicBehavior): this;
                /**
                 * Set cursor formatting, controlling the text displayed in built-in cursor.
                 *
                 * ```ts
                 *  chart.setCursorFormatting((_, hit, hits) => {
                 *      return [
                 *          ['Cursor pointing at'],
                 *          [hit.series], // returning a series will display the series color and its name automatically.
                 *          ['X', '', hit.axisX.formatValue(hit.x)], // utilizing axis formatValue is useful for considering active zoom level and type of axis
                 *          ['Y', '', hit.y.toFixed(2)], // empty string '' results in gap between cells
                 *          [{ text: 'Example', font: { weight: 'bold' }, fillStyle: fillRed }] // any cell can also be styled individually
                 *      ]
                 *  })
                 * ```
                 *
                 * Before overriding default cursor formatting, it is recommended to check if using {@link GenericAxis.setUnits} or configuring Axis cursor formatting would be enough.
                 *
                 * In order to use series specific data properties (e.g. Heatmap sample "intensity"),
                 * you should use type guards to assert the type of the `SolveResult`:
                 *
                 * ```ts
                 *  // Example of using type guard in cursor formatter
                 *  Chart.setCursorFormatting((chart, hit, hits) => {
                 *      if (!isHitHeatmap(hit)) return undefined
                 *      return [hit.intensity.toFixed(1)]
                 *  })
                 * ```
                 *
                 * More details in Developer documentation (Features \> Cursor).
                 * @param   formatter -     Callback function for cursor formatting.
                 * @returns     Object itself
                 * @public
                 */
                setCursorFormatting(formatter: CursorFormatterParallelCoordinateChart): this;
                /**
                 * Get active cursor formatter.
                 * @returns     Cursor formatter.
                 * @public
                 */
                getCursorFormatting(): CursorFormatterParallelCoordinateChart;
                /**
                 * Add manually controlled Cursor object.
                 * These have exactly same functions as built-in cursors but they can be freely controlled by application logic.
                 *
                 * ```ts
                 *  const cursor = chart.addCursor()
                 * ```
                 *
                 * Styling works same as built-in cursors (e.g. {@link setCursor}).
                 *
                 * Position is set using `setPosition` method and displayed content using `setResultTable(table => table.setContent(...))`
                 * For more details, see Developer documentation \> Features \> Cursor \> Manual cursors
                 *
                 * @param   cursorBuilder -     Builder for cursor. Can be used to tweak a handful of properties which can't be changed during runtime.
                 * @returns     Cursor object.
                 * @public
                 */
                addCursor<ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: CursorBuilder2D<ResultTableBackgroundType>): Cursor2D<ResultTableBackgroundType>;
                /**
                 * Set color of series that are _unselected_, meaning they are outside the range of an existing Range Selector.
                 *
                 * ```ts
                 *  // Example syntax
                 *  chart.setUnselectedSeriesColor(ColorRGBA(255, 255, 255, 30))
                 * ```
                 *
                 * @param   value -     Color or function which mutates current color.
                 * @returns     Object itself.
                 * @public
                 */
                setUnselectedSeriesColor(value: Color | ImmutableMutator<Color>): this;
                /**
                 * Get color of series that are _unselected_, meaning they are outside the range of an existing Range Selector.
                 * @public
                 */
                getUnselectedSeriesColor(): Color;
                /**
                 * Set stroke style of series that is pointed by cursor.
                 *
                 * ```ts
                 *  // Example syntax
                 *  chart.setPointedSeriesStrokeStyle(new SolidLine({
                 *      thickness: 2,
                 *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                 *  }))
                 * ```
                 * @param   value -     LineStyle or function which mutates current LineStyle.
                 * @returns     Object itself.
                 * @public
                 */
                setPointedSeriesStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                /**
                 * Get stroke style of series that is pointed by cursor.
                 * @public
                 */
                getPointedSeriesStrokeStyle(): LineStyle;
                /**
                 * Set whether built-in spline interpolation is enabled or disabled.
                 * This is enabled by default.
                 *
                 * ```ts
                 *  // Example, disable spline
                 *  chart.setSpline(false)
                 * ```
                 *
                 * ```ts
                 *  // Example, enable spline and specify resolution to use
                 *  chart.setSpline(true, { resolution: 16 }) // 32 is default
                 * ```
                 *
                 * Spline interpolation is somewhat heavy and can be disabled for better performance.
                 *
                 * @param   enabled -   Boolean.
                 * @param   opts -      Optional extra configurations.
                 * @returns     Object itself.
                 * @public
                 */
                setSpline(enabled: boolean, opts?: {
                    resolution: number;
                }): this;
                /**
                 * Set axes of the parallel coordinate chart as a list of `strings`.
                 *
                 * ```ts
                 *  // Example syntax
                 *  chart.setAxes(['A', 'B', 'C'])
                 * ```
                 *
                 * These values end up being used as the {@link ParallelCoordinateAxis.key} property of the created Axes, and should match the keys of your data set.
                 *
                 * ```ts
                 *  // Matching data
                 * chart.addSeries().setData({
                 *     A: 1,
                 *     B: 2,
                 *     C: 3,
                 * })
                 * ```
                 * @param axes -    List of strings.
                 * @returns     Object itself.
                 * @public
                 */
                setAxes(axes: string[]): this;
                /**
                 * Set axes of the parallel coordinate chart as an JavaScript object.
                 * The keys of the object are read as the list of Axes that the chart should contain.
                 *
                 * ```ts
                 *  // Example syntax
                 *  const Axes = {
                 *      Weight: 0,
                 *      Height: 1,
                 *      'Eye color': 2,
                 *  }
                 *  chart.setAxes(Axes)
                 * ```
                 *
                 * @param axes -    JS Object
                 * @returns     Object itself.
                 * @public
                 */
                setAxes(axes: {
                    [Key: string]: unknown;
                }): this;
                /**
                 * Get reference to a {@link ParallelCoordinateAxis} object based on an ID` (`string | number`).
                 *
                 * This ID should be same value used when the Axes of the chart are defined in {@link setAxes}.
                 * **This method throws an Error if the requested Axis is not found!**
                 *
                 * ```ts
                 *  // Example syntax
                 *  const Axes = {
                 *      Weight: 0,
                 *      Height: 1,
                 *      'Eye color': 2,
                 *  }
                 *  chart.setAxes(Axes)
                 *  const axisHeight = chart.getAxis(Axes.Height)
                 * ```
                 *
                 * {@link hasAxis} can be used to check if Axis exists without throwing errors.
                 *
                 * @param   id -   String or Number.
                 * @returns     Axis object.
                 * @public
                 */
                getAxis(id: string | number): ParallelCoordinateAxis;
                /**
                 * Check if specific Axis exists  based on an ID` (`string | number`).
                 * This ID should be same value used when the Axes of the chart are defined in {@link setAxes}.
                 *
                 * ```ts
                 *  // Example syntax
                 *  const Axes = {
                 *      Weight: 0,
                 *      Height: 1,
                 *      'Eye color': 2,
                 *  }
                 *  chart.setAxes(Axes)
                 *  chart.hasAxis(Axes.Height) // true
                 * ```
                 *
                 * @param   id -   String or Number.
                 * @returns     Boolean.
                 * @public
                 */
                hasAxis(id: string | number): boolean;
                /**
                 * Add a series to the chart.
                 *
                 * ```ts
                 *  // Example syntax
                 *  chart.addSeries()
                 *      .setName('Sample 1')
                 *      .setData({
                 *          A: 10,
                 *          B: 21,
                 *          C: 0.023
                 *      })
                 * ```
                 *
                 * Data should match currently existing axes in the chart {@link setAxes}.
                 *
                 * @param options -     Optional readonly options that can only be specified when series is created.
                 * @returns     Series object.
                 * @public
                 */
                addSeries(options?: SeriesOptions): ParallelCoordinateSeries;
                /**
                 * Set thickness of normal series lines as pixels.
                 *
                 * ```ts
                 *  // Example syntax, 2 pixel stroke
                 *  chart.setSeriesStrokeThickness(2)
                 * ```
                 *
                 * @param thickness -   Thickness as pixels
                 * @returns     Object itself.
                 * @public
                 */
                setSeriesStrokeThickness(thickness: number): this;
                /**
                 * Get thickness of normal series lines as pixels.
                 * @returns     Number.
                 * @public
                 */
                getSeriesStrokeThickness(): number;
                /**
                 * Configure series coloring by a Value-Color Table.
                 * In a Parallel coordinate chart, you can optionally specify one Axis which dictates coloring of all series based on their value along that particular Axis.
                 *
                 * ```ts
                 *  // Example syntax
                 *  chart.setLUT({
                 *      axis: chart.getAxis('Height'),
                 *      lut: new LUT({
                 *          interpolate: true,
                 *          steps: [
                 *              { value: 150: ColorRGBA(255, 0, 0) },
                 *              { value: 200: ColorRGBA(0, 0, 255) },
                 *          ]
                 *      })
                 *  })
                 * ```
                 * @param value -   Either object with `lut` and `axis` properties or `undefined` to disable LUT.
                 * @returns     Object itself.
                 * @public
                 */
                setLUT(value: {
                    lut: LUT;
                    axis: ParallelCoordinateAxis;
                } | undefined): this;
                private _applySeriesColoring;
                _handleAxisIntervalChanged(axis: ParallelCoordinateAxis, start: number, end: number): void;
                private _handleResize;
                /**
                 * Get series of a chart
                 * @returns Array of series
                 * @public
                 */
                getSeries(): ParallelCoordinateSeries[];
                /**
                 * Get minimum size of Chart.
                 * Depending on the type of class this value might be automatically computed to fit different elements.
                 * @returns Vec2 minimum size or undefined if unimplemented
                 */
                getMinimumSize(): Point | undefined;
                /**
                 * Iterate over each Axis of Chart.
                 * @param clbk - Callback function for each Axis.
                 * @returns Object itself.
                 * @public
                 */
                forEachAxis(clbk: (axis: ParallelCoordinateAxis) => void): this;
                /**
                 * **Permanently** destroy the component.
                 *
                 * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                 * **to the component and its children** in application code.
                 * ```javascript
                 * let chart = ...ChartXY()
                 * let axisX = chart.getDefaultAxisX()
                 * // Dispose Chart, and remove all references so that they can be garbage-collected.
                 * chart.dispose()
                 * chart = undefined
                 * axisX = undefined
                 * ```
                 * @returns Object itself for fluent interface
                 * @public
                 */
                dispose(): this;
                /**
                 * Configure user interactions from a set of preset options.
                 *
                 * Without any explicit configuration, the charts select the default user interaction scheme based on available information,
                 * such as axis types, attached series and data supplied to series.
                 *
                 * The `setUserInteraction` methods allow explicitly configuring the used interaction scheme.
                 *
                 * ```ts
                 *  // Example, disable all user interactions
                 *  chart.setUserInteractions(undefined)
                 * ```
                 *
                 * ```ts
                 *  // Example, remove select range selector interactions
                 *  chart.setUserInteractions({
                 *      rangeSelectors: {
                 *          create: {
                 *              doubleClickAxis: false,
                 *          },
                 *          dispose: {
                 *              doubleClick: false,
                 *          },
                 *      },
                 *  })
                 * ```
                 *
                 * @param   config -    Option with any set of properties of {@link ParallelCoordinateChartInteractions} or `undefined` to disable all interactions.
                 * @returns     Object itself.
                 * @public
                 * @beta    Introduced in v7.0.0. API may change according to user feedback.
                 */
                setUserInteractions(config: Partial<ParallelCoordinateChartInteractions> | undefined): this;
                /**
                 * Get currently active user interaction scheme.
                 * This does NOT return the last value supplied to {@link setUserInteractions}.
                 * Rather, it considers the current structure of the chart, all built-in defaults as well as overrides supplied by the user
                 * and returns the currently used interaction scheme.
                 *
                 * @returns     ParallelCoordinateChartInteractions
                 * @public
                 * @beta    Introduced in v7.0.0. API may change according to user feedback.
                 */
                getUserInteractions(): ParallelCoordinateChartInteractions;
                addEventListener<K extends keyof ParallelCoordinateChartEventMap>(type: K, listener: (event: ParallelCoordinateChartEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                removeEventListener<K extends keyof ParallelCoordinateChartEventMap>(type: K, listener: (event: ParallelCoordinateChartEventMap[K], info: unknown) => unknown): void;
            }
            /**
             * Interface that can be used to define {@link ParallelCoordinateChart} configurations, when inside a {@link Dashboard},
             * that can't be changed after creation.
             * @public
             */
            export declare interface ParallelCoordinateChartDashboardOptions extends DashboardCellOptions, ParallelCoordinateChartOptions {
            }
            /**
             * Interface of events trackable by {@link ChartXY.addEventListener} and the respective Event types.
             * @public
             */
            declare interface ParallelCoordinateChartEventMap extends ChartWithSeriesEventMap<ParallelCoordinateSeries>, ChartWithCursorEventMap<SolveResultParallelCoordinate> {
                seriesselect: {
                    selectedSeries: ParallelCoordinateSeries[];
                };
            }
            /**
             * @public
             * @beta    Introduced in v7.0.0. API may change according to user feedback.
             */
            export declare interface ParallelCoordinateChartInteractions {
                rangeSelectors?: {
                    create?: {
                        doubleClickAxis?: boolean;
                    };
                    move?: {
                        drag?: boolean;
                    };
                    dispose?: {
                        doubleClick?: boolean;
                    };
                };
            }
            /**
             * @public
             */
            export declare interface ParallelCoordinateChartOptions<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
                /**
                 * Builder for the charts' *auto cursor*.
                 *
                 * For most use cases, it is not recommended to use this, but rather {@link ParallelCoordinateChart.setCursor} for a more convenient API.
                 * @public
                 */
                readonly cursorBuilder?: CursorBuilder2D<CursorResultTableBackgroundType>;
            }
            /**
             * Class that represents one series within a {@link ParallelCoordinateChart}.
             * Series are added with {@link ParallelCoordinateChart.addSeries} method.
             * @public
             */
            export declare class ParallelCoordinateSeries extends Series2D<SolveResultParallelCoordinate> implements _InternalSeriesWithCursor<SolveResultParallelCoordinate> {
                readonly chart: ParallelCoordinateChart;
                /**
                 * Set data points of the series.
                 * This signature of the method accepts one JS object, where key = Axis key and value = Number (value on that Axis).
                 *
                 * ```ts
                 *  // Example syntax
                 *  series.setData({
                 *      A: 10,
                 *      B: 0,
                 *      C: 50
                 *  })
                 * ```
                 * @param data -    JS Object.
                 * @returns     Object itself.
                 * @public
                 */
                setData(data: {
                    [Key: string]: number;
                }): this;
                /**
                 * Set data points of the series.
                 * This signature of the method accepts an Array of Objects with `key` and `value` properties.
                 *
                 * ```ts
                 *  // Example syntax
                 *  series.setData([
                 *      { key: 'A', value: 10 },
                 *      { key: 'B', value: 0 },
                 *      { key: 'C', value: 50 },
                 *  ])
                 * ```
                 * @param data -    Array of Objects with `key` and `value` properties.
                 * @returns     Object itself.
                 * @public
                 */
                setData(data: {
                    key: string;
                    value: number;
                }[]): this;
                /**
                 * Set data points of the series.
                 * This signature of the method accepts an Array of Numbers, where each Number is value on 1 Axis.
                 * To ensure each data point is matched with correct Axis it is recommended to use other signatures of this method instead.
                 *
                 * ```ts
                 *  // Example syntax
                 *  series.setData([10, 0, 50])
                 * ```
                 *
                 * @param   data -  List of Numbers.
                 * @returns     Object itself.
                 * @public
                 */
                setData(data: number[]): this;
                /**
                 * Get data of the series.
                 * @returns     Object with values for each axis or `undefined`.
                 * @public
                 */
                getData(): {
                    [Key: string]: number;
                } | undefined;
                /**
                 * Set color of the series.
                 *
                 * ```ts
                 *  // Example syntax
                 *  series.setColor(ColorRGBA(255, 0, 0))
                 * ```
                 * @param   value -     Color object or function which mutates current Color.
                 * @returns     Object itself.
                 * @public
                 */
                setColor(value: Color | ImmutableMutator<Color>): this;
                /**
                 * Get color of the series.
                 * @returns     Color.
                 * @public
                 */
                getColor(): Color;
                addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultParallelCoordinate) => unknown, options?: LCJSAddEventListenerOptions): void;
                removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultParallelCoordinate) => unknown): void;
            }
            /**
             * _Phong_ color shading style.
             *
             * Phong shading supports ambient and specular lighting, greatly increasing depth perception
             * capabilities.
             *
             * With Phong shading enabled, the color of each pixel is affected by angle to camera, as well as the various available
             * Phong shading properties, like light colors and reflection values.
             *
             * ```js
             *  // Example syntax, use default Phong shading.
             *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong())
             * ```
             *
             * ```js
             *  // Example syntax, use Phong shading with specific configuration.
             *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong({
             *      // Add specular reflection for "highlight" effect.
             *      specularReflection: 0.5,
             *      specularColor: ColorRGBA(255, 255, 255),
             *  }))
             * ```
             *
             * Color shading style is specified with {@link Series3D.setColorShadingStyle} method.
             * @public
             */
            export declare class PhongShadingStyle implements PhongShadingStyleOptions {
                readonly type = "phong";
                /**
                 * Controls how much ambient light affects the color.
                 *
                 * Value ranges from 0 to 1, where higher values correspond to reflecting more.
                 *
                 * The impact of ambient color on a surface is also affected by {@link ambientColor} property.
                 *
                 * The default value is `1.0`.
                 */
                readonly ambientReflection: number;
                /**
                 * Controls specular reflection strength.
                 *
                 * Describes how much the material reflects specular light.
                 *
                 * The impact of specular color on a surface is also affected by {@link shininess} and {@link specularColor} properties.
                 *
                 * Value ranges from 0 to 1, where higher values correspond to reflecting more.
                 *
                 * The default value is `0.1`.
                 */
                readonly specularReflection: number;
                /**
                 * Controls how strongly the diffuse color is. Diffuse color is the color defined by user.
                 *
                 * Value ranges from 0 to 1, where higher values correspond to reflecting more.
                 *
                 * The default value is `1.0`.
                 */
                readonly diffuseReflection: number;
                /**
                 * Ambient light color.
                 *
                 * Describes light that is present at all points of the surface, kind of like a _background light_.
                 *
                 * The impact of ambient color on a surface is also affected by {@link ambientReflection} property.
                 *
                 * The default setting is black.
                 *
                 * ```js
                 *  // Example, white ambient light.
                 *  ambientColor: ColorRGBA(255, 255, 255)
                 * ```
                 */
                readonly ambientColor: Color;
                /**
                 * Specular highlight color.
                 *
                 * Describes light that is reflected from a shiny surface.
                 * Can be used to get a "shine" effect on surfaces.
                 *
                 * The impact of specular color on a surface is also affected by {@link specularReflection} and {@link shininess} properties.
                 *
                 * The default setting is white.
                 *
                 * ```js
                 *  // Example, red specular light.
                 *  specularColor: ColorRGBA(255, 0, 0)
                 * ```
                 */
                readonly specularColor: Color;
                /**
                 * Specular highlight shininess.
                 *
                 * Describes how _shiny_ the material surface is.
                 *
                 * The impact of specular color on a surface is also affected by {@link specularReflection} and {@link specularColor} properties.
                 *
                 * Value ranges from 1 to 64, where higher values correspond to being _exponentially_ **less** shiny.
                 *
                 * The default value is `32`.
                 */
                readonly shininess: number;
                /** @public */
                constructor(options?: Partial<PhongShadingStyleOptions>);
            }
            /**
             * Interface for configuration properties of {@link PhongShadingStyle}.
             *
             * ```js
             *  // Example syntax, use Phong shading with specific configuration.
             *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong({
             *      // Add specular reflection for "highlight" effect.
             *      specularReflection: 0.5,
             *      specularColor: ColorRGBA(255, 255, 255),
             *  }))
             * ```
             * @public
             */
            export declare interface PhongShadingStyleOptions {
                /**
                 * Controls how much ambient light affects the color.
                 *
                 * Value ranges from 0 to 1, where higher values correspond to reflecting more.
                 *
                 * The impact of ambient color on a surface is also affected by {@link ambientColor} property.
                 *
                 * The default value is `1.0`.
                 */
                ambientReflection: number;
                /**
                 * Controls specular reflection strength.
                 *
                 * Describes how much the material reflects specular light.
                 *
                 * The impact of specular color on a surface is also affected by {@link shininess} and {@link specularColor} properties.
                 *
                 * Value ranges from 0 to 1, where higher values correspond to reflecting more.
                 *
                 * The default value is `0.1`.
                 */
                specularReflection: number;
                /**
                 * Controls how strongly the diffuse color is. Diffuse color is the color defined by user.
                 *
                 * Value ranges from 0 to 1, where higher values correspond to reflecting more.
                 *
                 * The default value is `1.0`.
                 */
                diffuseReflection: number;
                /**
                 * Ambient light color.
                 *
                 * Describes light that is present at all points of the surface, kind of like a _background light_.
                 *
                 * The impact of ambient color on a surface is also affected by {@link ambientReflection} property.
                 *
                 * The default setting is black.
                 *
                 * ```js
                 *  // Example, white ambient light.
                 *  ambientColor: ColorRGBA(255, 255, 255)
                 * ```
                 */
                ambientColor: Color;
                /**
                 * Specular highlight color.
                 *
                 * Describes light that is reflected from a shiny surface.
                 * Can be used to get a "shine" effect on surfaces.
                 *
                 * The impact of specular color on a surface is also affected by {@link specularReflection} and {@link shininess} properties.
                 *
                 * The default setting is white.
                 *
                 * ```js
                 *  // Example, red specular light.
                 *  specularColor: ColorRGBA(255, 0, 0)
                 * ```
                 */
                specularColor: Color;
                /**
                 * Specular highlight shininess.
                 *
                 * Describes how _shiny_ the material surface is.
                 *
                 * The impact of specular color on a surface is also affected by {@link specularReflection} and {@link specularColor} properties.
                 *
                 * Value ranges from 1 to 64, where higher values correspond to being _exponentially_ **less** shiny.
                 *
                 * The default value is `32`.
                 */
                shininess: number;
            }
            /**
             * Class represents any kind of picture, it might be raster image rendered as texture,
             * just colored rectangle or polygon of another shape,
             * several different geometry shapes and so on.
             * @public
             */
            export declare abstract class Picture extends InternalUIElement implements Highlightable, StylableComponent {
                /**
                 * Set fill style of Picture
                 * @param value - Fill style object or function which modifies it
                 * @returns Object itself for fluent interface
                 * @public
                 */
                abstract setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                /**
                 * Get fill style of Picture
                 * @public
                 */
                abstract getFillStyle(): FillStyle;
                /**
                 * @returns 1 for highlighted state of object and 0 for basic
                 * @public
                 */
                getHighlight(): number;
                /**
                 * Set state of component highlighting.
                 *
                 * ```ts
                 *  // Example usage
                 *
                 *  component.setHighlight(true)
                 *
                 *  component.setHighlight(0.5)
                 * ```
                 *
                 * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
                 * @returns Object itself
                 * @public
                 */
                setHighlight(highlight: number): this;
            }
            /**
             * Abstract base class for *Pie Charts*.
             * Visualizes proportions and percentages between categories, by dividing a circle into proportional segments.
             *
             * Set data using *PieChart*.**addSlice( name: string, value: number )**
             *
             * There are multiple implementations of *PieChart*, each with their own visual design and *API* for customizing it.
             * List of selectable options can be found in: {@link PieChartTypes}
             * @public
             */
            export declare abstract class PieChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends Chart implements SlicedCharts<PieSlice>, ChartWithCursor<CursorResultTableBackgroundType, CursorPosition2D, Cursor2D<CursorResultTableBackgroundType>, SolveResultPieChart> {
                setCursor(mutator: Mutator<Cursor2D<CursorResultTableBackgroundType>>): this;
                getCursor(): Cursor2D<CursorResultTableBackgroundType>;
                setCursorMode(mode: SolveNearestMode | undefined): this;
                getCursorMode(): SolveNearestMode | undefined;
                setCustomCursor(clbk: undefined | ((event: CursorTargetChangedEvent<SolveResultPieChart>) => unknown)): this;
                setCursorDynamicBehavior(value: CursorDynamicBehavior): this;
                /**
                 * Set cursor formatting, controlling the text displayed in built-in cursor.
                 *
                 * ```ts
                 *  chart.setCursorFormatting((_, hit, hits) => {
                 *      return [
                 *          ['Cursor pointing at'],
                 *          [hit.series], // returning a series will display the series color and its name automatically.
                 *          ['X', '', hit.axisX.formatValue(hit.x)], // utilizing axis formatValue is useful for considering active zoom level and type of axis
                 *          ['Y', '', hit.y.toFixed(2)], // empty string '' results in gap between cells
                 *          [{ text: 'Example', font: { weight: 'bold' }, fillStyle: fillRed }] // any cell can also be styled individually
                 *      ]
                 *  })
                 * ```
                 *
                 * Before overriding default cursor formatting, it is recommended to check if using {@link GenericAxis.setUnits} or configuring Axis cursor formatting would be enough.
                 *
                 * In order to use series specific data properties (e.g. Heatmap sample "intensity"),
                 * you should use type guards to assert the type of the `SolveResult`:
                 *
                 * ```ts
                 *  // Example of using type guard in cursor formatter
                 *  Chart.setCursorFormatting((chart, hit, hits) => {
                 *      if (!isHitHeatmap(hit)) return undefined
                 *      return [hit.intensity.toFixed(1)]
                 *  })
                 * ```
                 *
                 * More details in Developer documentation (Features \> Cursor).
                 * @param   formatter -     Callback function for cursor formatting.
                 * @returns     Object itself
                 * @public
                 */
                setCursorFormatting(formatter: CursorFormatterPieChart): this;
                /**
                 * Get active cursor formatter.
                 * @returns     Cursor formatter.
                 * @public
                 */
                getCursorFormatting(): CursorFormatterPieChart;
                /**
                 * Add manually controlled Cursor object.
                 * These have exactly same functions as built-in cursors but they can be freely controlled by application logic.
                 *
                 * ```ts
                 *  const cursor = chart.addCursor()
                 * ```
                 *
                 * Styling works same as built-in cursors (e.g. {@link setCursor}).
                 *
                 * Position is set using `setPosition` method and displayed content using `setResultTable(table => table.setContent(...))`
                 * For more details, see Developer documentation \> Features \> Cursor \> Manual cursors
                 *
                 * @param   cursorBuilder -     Builder for cursor. Can be used to tweak a handful of properties which can't be changed during runtime.
                 * @returns     Cursor object.
                 * @public
                 */
                addCursor<ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: CursorBuilder2D<ResultTableBackgroundType>): Cursor2D<ResultTableBackgroundType>;
                /**
                 * Add new Slice to the Pie Chart.
                 * The Slice will be automatically assigned an unique style (using SliceFillStylePalette),
                 * that will not be affected by sorting of Slices.
                 *
                 * Currently there is no way to override the individual style of a Slice - style modifications must be done using the API of Pie Chart.
                 *
                 * @param name - Initial name for Slice as string.
                 * @param value - Initial value for Slice as number.
                 * @returns New Slice object.
                 * @public
                 */
                addSlice(name: string, value: number): PieSlice;
                /**
                 * This method is used for the adding multiple slices in the funnel chart.
                 * @param multiSlice - Array of slices
                 * @public
                 */
                addSlices(multiSlice: {
                    name: string;
                    value: number;
                }[]): Array<PieSlice>;
                /**
                 * Get all Slices of Pie Chart.
                 * NOTE: Manual modifications to returned Array can have unforeseen side-effects.
                 * Removing or adding Slices is intended to be done using other APIs (PieChart.addSlice, Slice.dispose, ...)
                 * @returns Array of Slices
                 * @public
                 */
                getSlices(): PieSlice[];
                /**
                 * Set if it is allowed for multiple Slices to be 'exploded' at the same time or not.
                 * When a Slice is exploded, it is drawn differently from non-exploded state
                 * - usually slightly "pushed away" from the center of Pie Chart.
                 *
                 * Does not affect state of already exploded Slices!
                 * @param multipleSliceExplosionAllowed - Is behavior allowed as boolean flag
                 * @returns Pie Chart itself
                 * @public
                 */
                setMultipleSliceExplosion(multipleSliceExplosionAllowed: boolean): this;
                /**
                 * Get a boolean flag which implies whether it is allowed for multiple Slices to be 'exploded' at the same time or not.
                 * When a Slice is exploded, it is drawn differently from non-exploded state
                 * - usually slightly "pushed away" from the center of Pie Chart.
                 * @returns Is behavior allowed as boolean flag
                 * @public
                 */
                getMultipleSliceExplosion(): boolean;
                /**
                 * Set inner radius of Pie Chart.
                 * This method can be used to style the Pie Chart as a "Donut Chart", with the center being hollow.
                 * @param innerRadius - Inner radius as a percentage of outer radius [0, 100]
                 * @returns Pie Chart itself
                 * @public
                 */
                setInnerRadius(innerRadius: number): this;
                /**
                 * Get inner radius of Pie Chart..
                 * This property can be used to style the Pie Chart as a "Donut Chart", with the center being hollow.
                 * @returns Inner radius as a percentage of outer radius [0, 100]
                 * @public
                 */
                getInnerRadius(): number;
                /**
                 * Set offset of exploded Slices in pixels.
                 * @param sliceExplosionOffset - Offset of exploded Slices in pixels
                 * @returns Pie Chart itself
                 * @public
                 */
                setSliceExplosionOffset(sliceExplosionOffset: pixel): this;
                /**
                 * Get offset of exploded Slices in pixels.
                 * @returns Offset of exploded Slices in pixels
                 * @public
                 */
                getSliceExplosionOffset(): pixel;
                /**
                 * Attach lookup table (LUT) to fill the slices with Colors based on value.
                 *
                 * The color for the slice would be selected from a specified *LUT*, which contains the information about gradient steps.
                 * After setting LUT to undefined all the slices stay colorized, but no further lookup.
                 *
                 * LUT class stores information about values and its associated colors,
                 * * which provides efficient lookup of the color based on provided value
                 * * as well as linear and step interpolation between colors.
                 *
                 * ``` javascript
                 * const pie = lightningChart()
                 *  .Pie( { type: PieChartTypes.LabelsOnSides } )
                 *  .setLUT( new LUT (steps: [
                 *          { value: 10, color: ColorRGBA( 0, 0, 0 ) },
                 *          { value: 20, color: ColorRGBA( 30, 255, 0 ) },
                 *          { value: 30, color: ColorRGBA( 60, 204, 0 ) },
                 *          { value: 40, color: ColorRGBA( 90, 128, 0 ) },
                 *          { value: 50, color: ColorRGBA( 255, 0, 0 ) } ) ],
                 *      interpolate: true } )
                 * ```
                 *
                 * @param lut - Lookup table
                 * @returns Pie itself for fluent interface
                 * @public
                 */
                setLUT(lut?: LUT): this;
                /**
                 * Set style of Pie Slices fill.
                 * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Pie will be assigned an incremental index,
                 * which will be used to pick its fill style from this Palette.
                 *
                 * So, for example... We have a Pie Chart with 5 Slices, and we give it a Palette with only 3 possible values
                 * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
                 * Note that this means, that the supplied Palette will have to work in a continuous manner!
                 *
                 * @param sliceFillStylePalette - Palette for FillStyle objects
                 * @returns Pie Chart itself
                 * @public
                 */
                setSliceFillStyle(sliceFillStylePalette: (index: number, slice: PieSlice) => FillStyle): this;
                /**
                 * Get style of Pie Slices fill.
                 * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Pie will be assigned an incremental index,
                 * which will be used to pick its fill style from this Palette.
                 *
                 * So, for example... We have a Pie Chart with 5 Slices, and we give it a Palette with only 3 possible values
                 * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
                 * Note that this means, that the supplied Palette will have to work in a continuous manner!
                 *
                 * @returns Palette<FillStyle>
                 * @public
                 */
                getSliceFillStyle(): (index: number, slice: PieSlice) => FillStyle;
                /**
                 * Set stroke style of Pie Slices border.
                 * @param value - LineStyle object or function which creates a new style based on previous
                 * @returns Pie Chart itself
                 * @public
                 */
                setSliceStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                /**
                 * Get stroke style of Pie Slices border.
                 * @returns LineStyle object
                 * @public
                 */
                getSliceStrokeStyle(): LineStyle;
                /**
                 * Set theme effect enabled on component or disabled.
                 *
                 * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                 * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                 *
                 * ```ts
                 *  // Example, disable theme effect from a particular component.
                 *  Component.setEffect(false)
                 * ```
                 *
                 * For the most part, theme effects are **enabled** by default on most components.
                 *
                 * Theme effect is configured with {@link Theme.effect} property.
                 *
                 * @param enabled - Theme effect enabled
                 * @returns          Object itself.
                 * @public
                 */
                setSliceEffect(enabled: boolean): this;
                /**
                 * Get theme effect enabled on component or disabled.
                 *
                 * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                 * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                 *
                 * ```ts
                 *  // Example, disable theme effect from a particular component.
                 *  Component.setEffect(false)
                 * ```
                 *
                 * For the most part, theme effects are **enabled** by default on most components.
                 *
                 * Theme effect is configured with {@link Theme.effect} property.
                 *
                 * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                 * @public
                 */
                getSliceEffect(): boolean;
                /**
                 * Set sorter of Pies' Slices as a comparator-function.
                 *
                 * For some commonly needed default implementations, can refer to PieSliceSorters-collection.
                 * @param sliceSorter - PieSliceSorter - function which sorts Slices of Pie with JavaScript API: Array.sort.
                 * @returns Pie Chart itself
                 * @public
                 */
                setSliceSorter(sliceSorter: SliceSorter<PieSlice>): this;
                /**
                 * Get sorter of Pies' Slices as a comparator-function.
                 * @returns PieSliceSorter - function which sorts Slices of Pie with JavaScript API: Array.sort.
                 * @public
                 */
                getSliceSorter(): SliceSorter<PieSlice>;
                /**
                 * Set fill style of Pie Slices Labels.
                 * @param value - FillStyle object or function which creates a new style based on previous
                 * @returns Pie Chart itself
                 * @public
                 */
                setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                /**
                 * Get fill style of Pie Slice Labels.
                 * @returns FillStyle object
                 * @public
                 */
                getLabelFillStyle(): FillStyle;
                /**
                 * Not to be confused with {@link GlowEffect}
                 * @public
                 * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
                 */
                setLabelShadow(value: Color | undefined): this;
                /**
                 * Not to be confused with {@link GlowEffect}
                 * @public
                 * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
                 */
                getLabelShadow(): Color | undefined;
                /**
                 * Set font of Slice Labels.
                 * @param value - FontSettings or mutator function for existing settings
                 * @returns Pie Chart itself
                 * @public
                 */
                setLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                /**
                 * Get font of Slice Labels.
                 * @returns FontSettings
                 * @public
                 */
                getLabelFont(): FontSettings;
                /**
                 * Set theme effect enabled on component or disabled.
                 *
                 * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                 * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                 *
                 * ```ts
                 *  // Example, disable theme effect from a particular component.
                 *  Component.setEffect(false)
                 * ```
                 *
                 * For the most part, theme effects are **enabled** by default on most components.
                 *
                 * Theme effect is configured with {@link Theme.effect} property.
                 *
                 * @param enabled - Theme effect enabled
                 * @returns          Object itself.
                 * @public
                 */
                setLabelEffect(enabled: boolean): this;
                /**
                 * Get theme effect enabled on component or disabled.
                 *
                 * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                 * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                 *
                 * ```ts
                 *  // Example, disable theme effect from a particular component.
                 *  Component.setEffect(false)
                 * ```
                 *
                 * For the most part, theme effects are **enabled** by default on most components.
                 *
                 * Theme effect is configured with {@link Theme.effect} property.
                 *
                 * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                 * @public
                 */
                getLabelEffect(): boolean;
                /**
                 * Set formatter of Slice Labels.
                 *
                 * See {@link SliceLabelFormatters} for a collection of default options.
                 * @param labelFormatter - SliceLabelFormatter - function which generates text of Labels per Slice.
                 * @returns Pie Chart itself
                 * @public
                 */
                setLabelFormatter(labelFormatter: SliceLabelFormatter<PieSlice>): this;
                /**
                 * Get formatter of Slice Labels.
                 * @returns SliceLabelFormatter - function which generates text of Labels per Slice.
                 * @public
                 */
                getLabelFormatter(): SliceLabelFormatter<PieSlice>;
                /**
                 * Set if slices should be highlighted on mouse hover / touch. Applies to all Slices.
                 * @param state - True if Slices should be highlighted on hover, false if not. This applies to all existing Slices and new Slices added.
                 * @public
                 */
                setSliceHighlightOnHover(state: boolean): this;
                /**
                 * **Permanently** destroy the component.
                 *
                 * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                 * **to the component and its children** in application code.
                 * ```javascript
                 * let chart = ...ChartXY()
                 * let axisX = chart.getDefaultAxisX()
                 * // Dispose Chart, and remove all references so that they can be garbage-collected.
                 * chart.dispose()
                 * chart = undefined
                 * axisX = undefined
                 * ```
                 * @returns Object itself for fluent interface
                 */
                dispose(): this;
                addEventListener<K extends keyof PieChartEventMap>(type: K, listener: (event: PieChartEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                removeEventListener<K extends keyof PieChartEventMap>(type: K, listener: (event: PieChartEventMap[K], info: unknown) => unknown): void;
            }
            /**
             * Interface of events trackable by {@link PieChart.addEventListener} and the respective Event types.
             * @public
             */
            export declare interface PieChartEventMap extends PanelEventMap, ChartWithCursorEventMap<SolveResultPieChart> {
            }
            /**
             * Interface for readonly configuration of {@link PieChart}.
             *
             * Some properties of `PieChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
             *
             * ```typescript
             *  // Example, create chart with specified color theme.
             *  const chart = LightningChart.Pie({
             *      theme: Themes.light,
             *  })
             * ```
             *
             * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
             *
             * For *standalone* `PieChart`, more parameters are documented in {@link LightningChart.Pie}.
             *
             * For *dashboard* `PieChart`, more parameters are documented in {@link Dashboard.createPieChart}.
             *
             *
             * **Commonly used properties:**
             *
             * - {@link PieChartOptions.type}: Specify pie chart visual design from a collection of options.
             * - {@link PieChartOptions.theme}: Specify chart color *theme*.
             * - {@link PieChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
             *
             * **Example usage:**
             *
             * ```typescript
             *  // Example 1, create chart with default configuration.
             *  const chart = LightningChart.Pie({})
             * ```
             *
             * ```typescript
             *  // Example 2, create pie chart with labels inside slices.
             *  const chart = LightningChart.Pie({
             *      type: PieChartTypes.LabelsInsideSlices
             *  })
             * ```
             *
             * ```typescript
             *  // Example 3, create chart with specified color theme.
             *  const chart = LightningChart.Pie({
             *      theme: Themes.light,
             *  })
             * ```
             * @public
             */
            export declare interface PieChartOptions<PieChartType extends PieChartTypes = PieChartTypes, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
                /**
                 * Specify pie chart visual design from a collection of options.
                 *
                 * Options are located in {@link PieChartTypes} collection. If undefined, will default to `PieChartTypes.LabelsOnSides`.
                 */
                type?: PieChartType;
                /**
                 * Builder for the charts' *auto cursor*.
                 *
                 * For most use cases, it is not recommended to use this, but rather {@link PieChart.setCursor} for a more convenient API.
                 * @public
                 */
                readonly cursorBuilder?: CursorBuilder2D<CursorResultTableBackgroundType>;
            }
            /**
             * Collection of {@link PieChart} implementations. Each option can have their own visual design, and *API* for customization of it.
             *
             * This must be specified when the {@link PieChart} is created (or default one will be used).
             *
             * Example usage:
             *```javascript
             * // Create a PieChart with specified type
             * LightningChart.Pie({ type: PieChartTypes.LabelsInsideSlices })
             * ```
             * @public
             */
            export declare const PieChartTypes: {
                /**
                 * Pie Chart type, where Slice Labels are positioned on the left and right sides of Chart.
                 * Labels are connected to their Slices with lines, which can be styled using unique API for this Pie Chart type.
                 */
                LabelsOnSides: typeof PieChartWithLabelsOnSides;
                /**
                 * Pie Chart type, where Slice Labels inside the Slices.
                 * Works well when Label texts are short and there are not a lot of Slices, as the actual Pie has more space.
                 */
                LabelsInsideSlices: typeof PieChartWithLabelsInsideSlices;
            };
            /**
             * @public
             */
            export declare type PieChartTypes = (typeof PieChartTypes)[keyof typeof PieChartTypes];
            /**
             * {@link PieChart} implementation that draws Slice Labels inside the Slices.
             * Works well when Label texts are short and there are not a lot of Slices, as the actual Pie has more space.
             * Public class
             * @public
             */
            export declare class PieChartWithLabelsInsideSlices extends PieChart {
                /**
                 * Get minimum size of Panel.
                 * Depending on the type of class this value might be automatically computed to fit different elements.
                 * @returns Vec2 minimum size or undefined if unimplemented
                 * @public
                 */
                getMinimumSize(): Point | undefined;
                /**
                 * Set position of Labels.
                 * @param labelPositionInsideSlice - Position of labels inside their respective Slices as a number between [0, 1]
                 * @returns Pie Chart itself
                 * @public
                 */
                setLabelPosition(labelPositionInsideSlice: number): this;
                /**
                 * Get position of Labels.
                 * @returns Position of labels inside their respective Slices as a number between [0, 1]
                 * @public
                 */
                getLabelPosition(): number;
            }
            /**
             * {@link PieChart} implementation that draws Slice Labels on its left and right sides.
             * Slices and Labels are connected by 'label connector lines'.
             * @public
             */
            export declare class PieChartWithLabelsOnSides extends PieChart {
                /**
                 * Set style of Label connector lines.
                 * @param labelConnectorStyle - LineStyle object
                 * @returns Pie Chart itself
                 * @public
                 */
                setLabelConnectorStyle(labelConnectorStyle: LineStyle): this;
                /**
                 * Get style of Label connector lines.
                 * @returns LineStyle object
                 * @public
                 */
                getLabelConnectorStyle(): LineStyle;
                /**
                 * Set distance between slice and label (includes explosion offset), this points to reference position of label, so not necessarily the nearest corner
                 * @param labelSliceOffset - Length as pixels
                 * @returns Pie Chart itself
                 * @public
                 */
                setLabelSliceOffset(labelSliceOffset: pixel): this;
                /**
                 * Get distance between slice and label (includes explosion offset), this points to reference position of label, so not necessarily the nearest corner
                 * @returns Length as pixels
                 * @public
                 */
                getLabelSliceOffset(): number;
                /**
                 * Set gap between slice and connector line start
                 * @param labelConnectorGapStart - Gap as pixels
                 * @returns Pie Chart itself
                 * @public
                 */
                setLabelConnectorGapStart(labelConnectorGapStart: pixel): this;
                /**
                 * Get labelConnectorGapStart
                 * @returns Gap as pixels
                 * @public
                 */
                getLabelConnectorGapStart(): number;
                /**
                 * Set horizontal length of connector line before connecting to label
                 * @param labelConnectorGapStart - Pixels
                 * @returns Pie Chart itself
                 * @public
                 */
                setLabelConnectorEndLength(labelConnectorEndLength: pixel): this;
                /**
                 * Get horizontal length of connector line before connecting to label
                 * @returns Pixels
                 * @public
                 */
                getLabelConnectorEndLength(): number;
                /**
                 * Get minimum size of Panel.
                 * Depending on the type of class this value might be automatically computed to fit different elements.
                 * @returns Vec2 minimum size or undefined if unimplemented
                 * @public
                 */
                getMinimumSize(): Point | undefined;
            }
            /**
             * Interface that can be used to define {@link PieChart}configurations, when inside a {@link Dashboard}, that can't be changed after creation.
             *
             *  Example usage:
             *```javascript
             * // Pie Chart with default type
             * undefined
             * // Pie Chart* with specified type
             * { pieChartOptions: { type: PieChartTypes.PieChartWithLabelsOnSides } }
             * ```
             * @public
             */
            export declare interface PieOptions<PieChartType extends PieChartTypes> extends DashboardCellOptions, PieChartOptions<PieChartType> {
            }
            /**
             * Abstract class represents a Pie & Donut specific slice API.
             * @public
             */
            export declare abstract class PieSlice extends Slice {
                /**
                 * Set is Slice exploded.
                 * When a Slice is exploded, it is drawn differently from non-exploded state
                 * - usually slightly "pushed away" from the center of Pie Chart.
                 * @param exploded - State of explosion as boolean
                 * @returns Slice itself
                 * @public
                 */
                abstract setExploded(exploded: boolean): this;
                /**
                 * Get is Slice exploded.
                 * When a Slice is exploded, it is drawn differently from non-exploded state
                 * - usually slightly "pushed away" from the center of Pie Chart.
                 * @returns State of explosion as boolean
                 * @public
                 */
                abstract getExploded(): boolean;
            }
            /**
             * Decoration for normal number. Indicates that the value should be interpreted as amount of pixels.
             * @public
             */
            export declare type pixel = number;
            /**
             * A style class used to specify style of 3D points rendering as pixelated squares.
             *
             * This rendering style is optimal for rendering large numbers of points that do not require great individual detail.
             * @public
             */
            export declare class PixelatedPoints3D extends PixelatedPoints3DRecord {
                /**
                 * When creating a new PixelatedPoints3D object, any amount of its default parameters can be *overriden*, by supplying the
                 * values to its constructor:
                 * ```javascript
                 *  new PointStyle3D.Pixelated({
                 *      size: 4,
                 *      fillStyle: new SolidFill({ color: ColorHex('#FFF') }),
                 *  })
                 * ```
                 * @param props - Optional object containing any amount of parameters of PixelatedPoints3D
                 * @public
                 */
                constructor(props?: Partial<PixelatedPoints3DProperties>);
                /**
                 * Construct a new PixelatedPoints3D object based on this one, but with different size.
                 *
                 * @param size - Size of the rendered points in **pixels**.
                 * @returns New PixelatedPoints3D object
                 * @public
                 */
                setSize(size: number): this;
                /**
                 * Get size of points rendered with this style object.
                 * @returns Size of the rendered points in **pixels**.
                 * @public
                 */
                getSize(): number;
                /**
                 * Construct a new PixelatedPoints3D object based on this one, but with modified fill style.
                 *
                 * Example usage:
                 *
                 * | Desired result         | Argument                                      |
                 * | :--------------------- | :-------------------------------------------- |
                 * | Specified SolidFill    | new SolidFill(\{ color: ColorHex('#F00') \})    |
                 *
                 * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                 * @returns New PixelatedPoints3D object
                 * @public
                 */
                setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                /**
                 * Get fill style of PixelatedPoints3D.
                 * @returns FillStyle object
                 * @public
                 */
                getFillStyle(): FillStyle;
            }
            /**
             * Interface for all properties of a PixelatedPoints3DProperties.
             * @public
             */
            export declare interface PixelatedPoints3DProperties {
                type: 'pixelated-points-3d';
                /**
                 * Size of the rendered points in **pixels**.
                 *
                 * Some devices / browser configurations always render with 1 pixel, regardless of this setting.
                 */
                size: number;
                /**
                 * *FillStyle* for rendering the points.
                 */
                fillStyle: FillStyle;
            }
            /**
             * Record contractor for PixelatedPoints3DProperties.
             * @public
             */
            declare const PixelatedPoints3DRecord: Record_2.Factory<PixelatedPoints3DProperties>;
            /**
             * Interface for object that can be rendered as part of UI.
             * @public
             */
            declare interface Plotable {
            }
            /**
             * Interface for a immutable data-structure which represents a data point in XY charts.
             * @public
             */
            export declare interface Point {
                /**
                 * Location in X-dimension.
                 */
                readonly x: number;
                /**
                 * Location in Y-dimension.
                 */
                readonly y: number;
            }
            /**
             * Interface for a data-structure which represents a 3-dimensional location.
             *
             * **Required properties:**
             *
             * - {@link Point3D.x} | coordinate along X Axis.
             * - {@link Point3D.y} | coordinate along Y Axis.
             * - {@link Point3D.z} | coordinate along Z Axis.
             *
             * **Optional properties:**
             *
             * - {@link Point3D.color} | data point color.
             * - {@link Point3D.size} | data point size.
             * - {@link Point3D.value} | data point value for dynamic coloring.
             *
             * ```ts
             *  // Example syntax,
             *  PointSeries3D.add([
             *      {
             *          x: 0,
             *          y: 0,
             *          z: 0,
             *          // `color` can be used for individual point coloring.
             *          color: ColorRGBA(255, 0, 0),
             *          // `size` can be used for individual point sizing.
             *          size: 5.0,
             *          // `value` can be used for dynamic point coloring.
             *          value: 160.0,
             *      }
             *  ])
             * ```
             * @public
             */
            export declare interface Point3D {
                /**
                 * Location in X-dimension.
                 */
                readonly x: number;
                /**
                 * Location in Y-dimension.
                 */
                readonly y: number;
                /**
                 * Location in Z-dimension.
                 */
                readonly z: number;
                /**
                 * Optional Color associated with the data point.
                 *
                 * Can be used for individual data point coloring when styled with {@link IndividualPointFill}.
                 *
                 * For some series types, individual data point coloring might have to be explicitly enabled when the series is created.
                 * Refer to series documentation for more detailed information.
                 */
                readonly color?: Color;
                /**
                 * Optional Size associated with the data point.
                 *
                 * Can be used for individual configuration of data points size.
                 *
                 * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
                 * Refer to series documentation for more detailed information.
                 */
                readonly size?: number;
                /**
                 * Optional Value associated with the data point.
                 *
                 * Can be used for dynamic per data point coloring when associated with a Color lookup table {@link LUT}.
                 *
                 * For some series types, dynamic data point coloring might have to be explicitly enabled when the series is created.
                 * Refer to series documentation for more detailed information.
                 */
                readonly value?: number;
                /**
                 * Optional Size on X Axis associated with the data point.
                 *
                 * Can be used for individual configuration of data points size along Axis dimensions.
                 *
                 * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
                 * Refer to series documentation for more detailed information.
                 */
                readonly sizeAxisX?: number;
                /**
                 * Optional Size on Y Axis associated with the data point.
                 *
                 * Can be used for individual configuration of data points size along Axis dimensions.
                 *
                 * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
                 * Refer to series documentation for more detailed information.
                 */
                readonly sizeAxisY?: number;
                /**
                 * Optional Size on Z Axis associated with the data point.
                 *
                 * Can be used for individual configuration of data points size along Axis dimensions.
                 *
                 * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
                 * Refer to series documentation for more detailed information.
                 */
                readonly sizeAxisZ?: number;
            }
            /**
             * Interface for UI elements used for CustomTick Markers.
             *
             * A Pointable has two components: a label and a pointer.
             * @public
             */
            export declare interface Pointable {
                /**
                 * @public
                 */
                setDirection(direction: UIDirections): this;
                /**
                 * @public
                 */
                getDirection(): UIDirections;
                /**
                 * NOTE: Usage is not encouraged, please use {@link CustomTick.setTickLength}
                 * @public
                 */
                setPointerLength(length: pixel): this;
                /**
                 * NOTE: Usage is not encouraged, please use {@link CustomTick.getTickLength}
                 * @public
                 */
                getPointerLength(): pixel;
                /**
                 * NOTE: Usage is not encouraged, please use {@link CustomTick.setTickLabelPadding}
                 * @public
                 */
                setTickLabelPadding(margin: pixel): this;
                /**
                 * NOTE: Usage is not encouraged, please use {@link CustomTick.getTickLabelPadding}
                 * @public
                 */
                getTickLabelPadding(): pixel;
                /**
                 * Set alignment of Label respective to tick line.
                 *
                 * **after**: -1
                 *
                 * **center**: 0
                 *
                 * **before**: +1
                 *
                 * With XY axes, a second alignment value can additionally be passed, which is used along the other dimension (i.e. X for Y axes).
                 *
                 * @param alignment - Label alignment [-1, 1].
                 * @param alignment2 - Opposite dimension label alignment [-1, 1], supported only by XY axes.
                 * @returns New TickStyle object with modified Label alignment
                 * @public
                 */
                setTickLabelAlignment(alignment: number, alignment2?: number): this;
                /**
                 * Get alignment of Label respective to tick line.
                 *
                 * @param alignment - Label alignment [-1, 1].
                 * @returns New TickStyle object with modified Label alignment
                 * @public
                 */
                getTickLabelAlignment(): number;
            }
            /**
             * Background that can be pointed at a direction (left,right,up or down)
             * @public
             */
            export declare interface PointableBackground extends Pointable, UIBackground {
            }
            /**
             * Type of Pointable Background constructor
             * @public
             */
            declare type PointableBackgroundConstructor<T extends InternalBackground & PointableBackground = InternalBackground & PointableBackground> = new (layer: unknown, renderingScale: unknown, scale: unknown, remove: unknown, theme: unknown) => T;
            /**
             * Series type for visualizing a collection of `{ x, y, z }` coordinates by different **2D markers**.
             *
             * `PointCloudSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
             *
             * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
             * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
             *
             * **Creating PointCloudSeries3D:**
             *
             * `PointCloudSeries3D` are created with {@link Chart3D.addPointSeries} method.
             *
             * Some properties of `PointCloudSeries3D` can only be configured when it is created. These arguments are all optional,
             * and are wrapped in a single object parameter:
             *
             * ```typescript
             *  // Example,
             *  const pointCloudSeries3D = Chart3D.addPointSeries({
             *      // Specify point series type as point cloud.
             *      type: PointSeriesTypes3D.Pixelated
             *  })
             * ```
             *
             * To learn about available properties, refer to {@link PointSeriesOptions3D}.
             *
             * **Frequently used methods:**
             *
             * - Append data points to series | {@link add}
             * - Remove all data points from series | {@link clear}
             * - Configure style of points | {@link setPointStyle}
             * - Destroy series permanently | {@link dispose}
             *
             * **Related information:**
             *
             * There is another series type for visualizing large sets of 3D coordinates with markers: {@link PointSeries3D}
             *
             * `PointSeries3D` works otherwise same, except that it renders markers with 3D geometry, with a collection of different shape options,
             * like 3D boxes or spheres. For this reason, `PointCloudSeries3D` is significantly faster than `PointSeries3D`!
             *
             * The main difference between `PointSeries3D` and `PointCloudSeries3D` is that `PointCloudSeries3D` don't have *depth*,
             * so they have same size regardless of how far they are from the camera.
             * @public
             */
            export declare class PointCloudSeries3D extends AbstractPointSeries3D<PixelatedPoints3D> {
                /**
                 * Set point style of Series.
                 *
                 * **Example syntax:**
                 *
                 * ```ts
                 *  // Example syntax, Specify new style
                 *  pointCloudSeries3D.setPointStyle( new PointStyle3D.Pixelated({
                 *      size: 10,
                 *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
                 *  }) )
                 * ```
                 *
                 * ```ts
                 *  // Example syntax, Change point color
                 *  pointCloudSeries3D.setPointStyle( (pointStyle) => pointStyle
                 *      .setFillStyle( new SolidFill({ color: ColorHEX('#FFF') }) )
                 *  )
                 * ```
                 *
                 * ```ts
                 *  // Example syntax, Change point size
                 *  pointCloudSeries3D.setPointStyle( (pointStyle) => pointStyle
                 *      .setSize( 10 )
                 *  )
                 * ```
                 *
                 * **Point coloring:**
                 *
                 * Color of points is configured by the `fillStyle` property of active point style.
                 *
                 * Here is a list of all supported _fill styles_ with feature descriptions and example syntax:
                 *
                 * {@link SolidFill}:
                 *
                 * Solid color for all points in series.
                 *
                 * ```js
                 *  // Example syntax, solid points color.
                 *  pointCloudSeries3D.setPointStyle(new PointStyle3D.Pixelated({
                 *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) }),
                 *      size: 10
                 *  }))
                 * ```
                 *
                 * {@link PalettedFill}:
                 *
                 * Look-up dynamic per-point color based on a _look up property_ (number) and a color look up table ({@link LUT}).
                 *
                 * ```js
                 *  // Example syntax, dynamic points color.
                 *  pointCloudSeries3D.setPointStyle(new PointStyle3D.Pixelated({
                 *      fillStyle: new PalettedFill({
                 *          // lookUpProperty defines basis of selecting look up value (number).
                 *          lookUpProperty: 'value',
                 *          // lut defines table for mapping look up value (number) to a color.
                 *          lut: new LUT({
                 *              interpolate: true,
                 *              steps: [
                 *                  { value: 0, color: ColorRGBA(0, 0, 0) },
                 *                  { value: 1, color: ColorRGBA(255, 0, 0) }
                 *              ]
                 *          })
                 *      }),
                 *      size: 10
                 *  }))
                 * ```
                 *
                 * `pointCloudSeries3D` supports several different look-up modes:
                 *
                 * `lookUpProperty: 'value'`:
                 *
                 * **IMPORTANT:** In order to use `value` property on data points, the feature has to be explicitly activated **when the series is created**:
                 *
                 * ```js
                 *  // Example syntax, enable individual data point values.
                 *  const pointCloudSeries3D = chart3D.addPointSeries({
                 *      type: PointSeriesTypes3D.Pixelated,
                 *      individualLookupValuesEnabled: true
                 *  })
                 * ```
                 *
                 * `value` property is then added for every data point along side `x`, `y` and `z`:
                 *
                 * ```js
                 *  // Example syntax, individual data point values.
                 *  pointCloudSeries3D.add([
                 *      { x: 0, y: 0, z: 0, value: 0 },
                 *      { x: 1, y: 0, z: 2, value: 1 },
                 *  ])
                 * ```
                 *
                 * Look-up value is read from data point `value` property.
                 *
                 * `lookUpProperty: 'x'`:
                 *
                 * Look-up value is set to data point `x` coordinate on Axis.
                 *
                 * `lookUpProperty: 'y'`:
                 *
                 * Look-up value is set to data point `y` coordinate on Axis.
                 *
                 * `lookUpProperty: 'z'`:
                 *
                 * Look-up value is set to data point `z` coordinate on Axis.
                 *
                 * {@link IndividualPointFill}:
                 *
                 * Supply individual color for each data point.
                 *
                 * **IMPORTANT:** In order to use `IndividualPointFill`, the feature has to be explicitly activated **when the series is created**:
                 *
                 * ```js
                 *  // Example syntax, enable individual data point colors.
                 *  const pointCloudSeries3D = chart3D.addPointSeries({
                 *      type: PointSeriesTypes3D.Pixelated,
                 *      individualPointColorEnabled: true
                 *  })
                 * ```
                 *
                 * `color` property is then added for every data point along side `x`, `y` and `z`:
                 *
                 * ```js
                 *  // Example syntax, individual data point colors.
                 *  pointCloudSeries3D.add([
                 *      { x: 0, y: 0, z: 0, color: ColorRGBA(255, 0, 0) },
                 *      { x: 1, y: 0, z: 2, color: ColorRGBA(0, 255, 0) },
                 *  ])
                 * ```
                 *
                 * **Point size:**
                 *
                 * Size of points is configured by the `size` property of active point style.
                 *
                 * If required, points can also be individually sized by adding a `size` property to data points.
                 *
                 * **IMPORTANT:** In order to use `size` property, the feature has to be explicitly activated **when the series is created**:
                 *
                 * ```js
                 *  // Example syntax, enable individual data point size.
                 *  const pointCloudSeries3D = chart3D.addPointSeries({
                 *      type: PointSeriesTypes3D.Pixelated,
                 *      individualPointSizeEnabled: true
                 *  })
                 * ```
                 *
                 * `size` property is then added for every data point along side `x`, `y` and `z`:
                 *
                 * ```js
                 *  // Example syntax, individual data point sizes.
                 *  pointCloudSeries3D.add([
                 *      { x: 0, y: 0, z: 0, size: 5 },
                 *      { x: 1, y: 0, z: 2, size: 10 },
                 *  ])
                 * ```
                 *
                 * @param value - A PixelatedPoints3D object, or a function which modifies the current style.
                 * @returns Object itself for fluent interface
                 * @public
                 */
                setPointStyle(value: PixelatedPoints3D | ImmutableMutator<PixelatedPoints3D>): this;
                /**
                 * Get normal points style.
                 * @returns PixelatedPoints3D
                 * @public
                 */
                getPointStyle(): PixelatedPoints3D;
            }
            /**
             * Series that can visualize any combination of Lines, Points and Area filling.
             * Supports both real-time and static data visualization.
             *
             * Also supports different preprocessing options (step/spline/disabled).
             *
             * See {@link ChartXY.addPointLineAreaSeries} for more information.
             * @public
             */
            export declare class PointLineAreaSeries extends SeriesXY<LinearScaleXY | MixedScaleXY, SolveResultSampleXY> implements DataSetXYAPI {
                /**
                 * Set data set which the series visualizes.
                 * This can be changed at any point.
                 *
                 * If data set is not set using this method, then the series creates it automatically as soon as data is pushed in.
                 *
                 * ```ts
                 *  // Example
                 *  const dataSet = new DataSetXY()
                 *  PointLineAreaSeries.setDataSet(dataSet)
                 * ```
                 * @param   dataSet - data set object.
                 * @public
                 */
                setDataSet(dataSet?: DataSetXY, mapping?: DataMappingXY): this;
                /**
                 * Get active data set of the series.
                 * @public
                 */
                getDataSet(): DataSetXY;
                /**
                 * Set data mapping, specifying which data properties are used from the active data set, and for which visualization purposes.
                 *
                 * ```ts
                 *  // Example
                 *  series.setDataMapping({ x: 'timestamps', y: 'temperature' })
                 * ```
                 *
                 * Data mapping can be changed at any point during runtime.
                 * It must include at least `x` and `y`. Optionally also `color`, `size`, `lookupValue` and `rotation` can be specified.
                 *
                 * The values of mappings refer to data properties of the active data set, which are defined with data APIs or by schema.
                 *
                 * ```ts
                 *  // Example
                 *  series.appendSamples({
                 *      timestamps: myTimestampsArray,
                 *      temperature: myTempArray
                 *  })
                 * ```
                 *
                 * @param   mapping - Data mapping or `undefined` to remove any existing data mapping.
                 * @returns     Object itself.
                 * @public
                 */
                setDataMapping(mapping: DataMappingXY | undefined): this;
                /**
                 * Get data mapping which specifies which data properties are used from the active data set, and for which visualization purposes.
                 * @returns     Current data mapping.
                 * @public
                 */
                getDataMapping(): DataMappingXY | undefined;
                /**
                 * Set stroke style of Series.
                 *
                 * Supported line styles:
                 * - {@link SolidLine}
                 * - {@link DashedLine}
                 * - {@link emptyLine}
                 *
                 * ```ts
                 *  // Example syntax, specify LineStyle
                 *  PointLineAreaSeries.setStrokeStyle(new SolidLine({
                 *      thickness: 2,
                 *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
                 *  }))
                 * ```
                 *
                 * ```ts
                 *  // Example syntax, change active LineStyle
                 *  PointLineAreaSeries.setStrokeStyle((stroke) => stroke.setThickness(5))
                 * ```
                 *
                 * Use `-1` thickness to enable primitive line rendering.
                 * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
                 * ```typescript
                 *  PointLineAreaSeries.setStrokeStyle((stroke) => stroke.setThickness(-1))
                 * ```
                 *
                 * **Supported fill styles:**
                 *
                 * {@link SolidFill}:
                 *
                 * Solid color for entire line series.
                 *
                 * ```ts
                 *  // Example, solid colored line.
                 *  PointLineAreaSeries.setStrokeStyle(new SolidLine({
                 *      thickness: 2,
                 *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                 *  }))
                 * ```
                 *
                 * To learn more about available *Color* factories, see {@link ColorRGBA}
                 *
                 * {@link PalettedFill}:
                 *
                 * Line series supports following look-up modes: `x`, `y` and `value`.
                 *
                 * `lookUpProperty: 'x' | 'y'`:
                 *
                 * Color line stroke dynamically based on `x` or `y` coordinate.
                 *
                 * ```ts
                 *  // Example, dynamic color by Y coordinates
                 *  PointLineAreaSeries.setStrokeStyle(new SolidLine({
                 *      thickness: 2,
                 *      fillStyle: new PalettedFill({
                 *          lookUpProperty: 'y',
                 *          lut: new LUT({
                 *              interpolate: true,
                 *              steps: [
                 *                  { value: 0, color: ColorRGBA(255, 0, 0) },
                 *                  { value: 100, color: ColorRGBA(0, 255, 0) },
                 *              ]
                 *          })
                 *      })
                 *  }))
                 * ```
                 *
                 * To learn more about Color lookup tables, see {@link LUT}.
                 *
                 * `lookUpProperty: 'value'`:
                 *
                 * Color line stroke dynamically based on separately supplied `value` data set.
                 * `value`s are specified when adding data points.
                 *
                 * ```ts
                 *  // Example, dynamic color by Value data set
                 *  const series = ChartXY.addLineSeries()
                 *      .setStrokeStyle(new SolidLine({
                 *           thickness: 2,
                 *           fillStyle: new PalettedFill({
                 *               lookUpProperty: 'value',
                 *               lut: new LUT({
                 *                   interpolate: true,
                 *                   steps: [
                 *                       { value: 0, color: ColorRGBA(255, 0, 0) },
                 *                       { value: 100, color: ColorRGBA(0, 255, 0) },
                 *                   ]
                 *               })
                 *           })
                 *      }))
                 *      .appendSamples({
                 *          xValues: [0, 1],
                 *          yValues: [0, 1],
                 *          lookupValues: [0, 100]
                 *      })
                 * ```
                 *
                 * To learn more about Color lookup tables, see {@link LUT}.
                 *
                 * {@link IndividualPointFill}:
                 *
                 * Color line stroke with individually picked sample colors.
                 * Line segment colors are interpolated between data points.
                 *
                 * ```ts
                 *  // Example, individual colors
                 *  const series = ChartXY.addLineSeries()
                 *      .appendSamples({
                 *          xValues: [0, 1],
                 *          yValues: [0, 1],
                 *          colors: [0xff0000ff, 0xff00ff00]
                 *      })
                 *      .setStrokeStyle(new SolidLine({
                 *          thickness: 2,
                 *          fillStyle: new IndividualPointFill()
                 *      }))
                 * ```
                 *
                 * {@link LinearGradientFill}:
                 *
                 * Color line stroke with a linear configurable gradient palette.
                 *
                 * ```ts
                 *  // Example, linear gradient line color
                 *  PointLineAreaSeries.setStrokeStyle(new SolidLine({
                 *      thickness: 2,
                 *      fillStyle: new LinearGradientFill()
                 *  }))
                 * ```
                 *
                 * To learn more about linear gradient configurations, see {@link LinearGradientFill}.
                 *
                 * {@link RadialGradientFill}:
                 *
                 * Color line stroke with a radial configurable gradient palette.
                 *
                 * ```ts
                 *  // Example, radial gradient line color
                 *  PointLineAreaSeries.setStrokeStyle(new SolidLine({
                 *      thickness: 2,
                 *      fillStyle: new RadialGradientFill()
                 *  }))
                 * ```
                 *
                 * To learn more about radial gradient configurations, see {@link RadialGradientFill}.
                 *
                 * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                /**
                 * Get stroke style of Series.
                 * @returns LineStyle object
                 * @public
                 */
                getStrokeStyle(): LineStyle;
                /**
                 * Set fill style of area under the series trend.
                 *
                 * **Supported fill styles:**
                 *
                 * {@link SolidFill}:
                 *
                 * Solid color for entire area fill.
                 *
                 * ```ts
                 *  // Example, solid colored area fill.
                 *  PointLineAreaSeries.setAreaFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                 * ```
                 *
                 * To learn more about available *Color* factories, see {@link ColorRGBA}
                 *
                 * {@link PalettedFill}:
                 *
                 * Supports following look-up modes: `x`, `y` and `value`.
                 *
                 * `lookUpProperty: 'x' | 'y'`:
                 *
                 * Color dynamically based on `x` or `y` coordinate.
                 *
                 * ```ts
                 *  // Example, dynamic color by Y coordinates
                 *  PointLineAreaSeries.setAreaFillStyle(new PalettedFill({
                 *      lookUpProperty: 'y',
                 *      lut: new LUT({
                 *          interpolate: true,
                 *          steps: [
                 *              { value: 0, color: ColorRGBA(255, 0, 0) },
                 *              { value: 100, color: ColorRGBA(0, 255, 0) },
                 *          ]
                 *      })
                 *  }))
                 * ```
                 *
                 * To learn more about Color lookup tables, see {@link LUT}.
                 *
                 * `lookUpProperty: 'value'`:
                 *
                 * Color dynamically based on separately supplied `value` data set.
                 * `value`s are specified when adding data points.
                 *
                 * ```ts
                 *  // Example, dynamic color by Value data set
                 *  const series = ChartXY.addAreaSeries()
                 *      .setAreaFillStyle(new PalettedFill({
                 *          lookUpProperty: 'value',
                 *          lut: new LUT({
                 *              interpolate: true,
                 *              steps: [
                 *                  { value: 0, color: ColorRGBA(255, 0, 0) },
                 *                  { value: 100, color: ColorRGBA(0, 255, 0) },
                 *              ]
                 *          })
                 *      }))
                 *      .appendSamples({
                 *          xValues: [0, 1],
                 *          yValues: [0, 1],
                 *          lookupValues: [0, 100]
                 *      })
                 * ```
                 *
                 * To learn more about Color lookup tables, see {@link LUT}.
                 *
                 * {@link IndividualPointFill}:
                 *
                 * Color area fill with individually picked sample colors.
                 * Colors are interpolated between data points.
                 *
                 * ```ts
                 *  // Example, individual colors
                 *  const series = ChartXY.addAreaSeries()
                 *      .setAreaFillStyle(new IndividualPointFill())
                 *      .appendSamples({
                 *          xValues: [0, 1],
                 *          yValues: [0, 1],
                 *          colors: [0xff0000ff, 0xff00ff00]
                 *      })
                 * ```
                 *
                 * {@link LinearGradientFill}:
                 *
                 * Color area fill with a linear gradient.
                 *
                 * ```ts
                 *  // Example, linear gradient area fill
                 *  PointLineAreaSeries.setAreaFillStyle(new LinearGradientFill())
                 * ```
                 *
                 * To learn more about linear gradient configurations, see {@link LinearGradientFill}.
                 *
                 * {@link RadialGradientFill}:
                 *
                 * Color area fill with a radial gradient.
                 *
                 * ```ts
                 *  // Example, radial gradient line color
                 *  PointLineAreaSeries.setAreaFillStyle(new RadialGradientFill())
                 * ```
                 *
                 * To learn more about radial gradient configurations, see {@link RadialGradientFill}.
                 *
                 * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setAreaFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                /**
                 * Get current area fill style.
                 * @returns     FillStyle object.
                 * @public
                 */
                getAreaFillStyle(): FillStyle;
                /**
                 * Set fill style of markers displayed at sample locations.
                 *
                 * **Supported fill styles:**
                 *
                 * {@link SolidFill}:
                 *
                 * Solid color.
                 *
                 * ```ts
                 *  // Example, solid colored markers
                 *  PointLineAreaSeries.setPointFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                 * ```
                 *
                 * To learn more about available *Color* factories, see {@link ColorRGBA}
                 *
                 * {@link PalettedFill}:
                 *
                 * Supports following look-up modes: `x`, `y` and `value`.
                 *
                 * `lookUpProperty: 'x' | 'y'`:
                 *
                 * Color dynamically based on `x` or `y` coordinate.
                 *
                 * ```ts
                 *  // Example, dynamic color by Y coordinates
                 *  PointLineAreaSeries.setPointFillStyle(new PalettedFill({
                 *      lookUpProperty: 'y',
                 *      lut: new LUT({
                 *          interpolate: true,
                 *          steps: [
                 *              { value: 0, color: ColorRGBA(255, 0, 0) },
                 *              { value: 100, color: ColorRGBA(0, 255, 0) },
                 *          ]
                 *      })
                 *  }))
                 * ```
                 *
                 * To learn more about Color lookup tables, see {@link LUT}.
                 *
                 * `lookUpProperty: 'value'`:
                 *
                 * Color dynamically based on separately supplied `value` data set.
                 * `value`s are specified when adding data points.
                 *
                 * ```ts
                 *  // Example, dynamic color by Value data set
                 *  const series = ChartXY.addPointSeries()
                 *      .setPointFillStyle(new PalettedFill({
                 *          lookUpProperty: 'value',
                 *          lut: new LUT({
                 *              interpolate: true,
                 *              steps: [
                 *                  { value: 0, color: ColorRGBA(255, 0, 0) },
                 *                  { value: 100, color: ColorRGBA(0, 255, 0) },
                 *              ]
                 *          })
                 *      }))
                 *      .appendSamples({
                 *          xValues: [0, 1],
                 *          yValues: [0, 1],
                 *          lookupValues: [0, 100]
                 *      })
                 * ```
                 *
                 * To learn more about Color lookup tables, see {@link LUT}.
                 *
                 * {@link IndividualPointFill}:
                 *
                 * Color by individually picked sample colors.
                 * Colors are interpolated between data points.
                 *
                 * ```ts
                 *  // Example, individual colors
                 *  const series = ChartXY.addPointSeries()
                 *      .setPointFillStyle(new IndividualPointFill())
                 *      .appendSamples({
                 *          xValues: [0, 1],
                 *          yValues: [0, 1],
                 *          colors: [0xff0000ff, 0xff00ff00]
                 *      })
                 * ```
                 *
                 * {@link ImageFill} (beta feature, introduced in v5.2.0):
                 *
                 * Display custom images.
                 *
                 * ```ts
                 *  // Example syntax
                 *  const image = new Image()
                 *  image.src = 'my-asset.png'
                 *
                 *  const pointSeries = chart.addPointSeries()
                 *      .setPointFillStyle(new ImageFill({ source: image }))
                 *      .appendSample({ x: 0, y: 0 })
                 * ```
                 *
                 * Please note that when `ImageFill` is used, Point line area series behaves a little bit differently:
                 *
                 * 1. Different point shapes are not available. Point shape should always be `PointShape.Square`
                 * 2. Point size is interpreted as multiplier of source Image size. Defaults to `1`.
                 *
                 * {@link LinearGradientFill}:
                 *
                 * Color with a linear gradient.
                 *
                 * ```ts
                 *  // Example, linear gradient area fill
                 *  PointLineAreaSeries.setPointFillStyle(new LinearGradientFill())
                 * ```
                 *
                 * To learn more about linear gradient configurations, see {@link LinearGradientFill}.
                 *
                 * {@link RadialGradientFill}:
                 *
                 * Color with a radial gradient.
                 *
                 * ```ts
                 *  // Example, radial gradient line color
                 *  PointLineAreaSeries.setPointFillStyle(new RadialGradientFill())
                 * ```
                 *
                 * To learn more about radial gradient configurations, see {@link RadialGradientFill}.
                 *
                 * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setPointFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                /**
                 * Get current markers fill style.
                 * @returns     FillStyle object.
                 * @public
                 */
                getPointFillStyle(): FillStyle;
                /**
                 * Configure stroke style for line drawn around edges of the points.
                 * Defaults to `emptyLine` (no stroke).
                 *
                 * ```ts
                 *  // Example syntax, 2px thick black stroke
                 *  series.setPointStrokeStyle(new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(0, 0, 0) }) }))
                 * ```
                 *
                 * Supported values:
                 *  - {@link emptyLine}.
                 *  - {@link SolidLine} with {@link SolidFill} fill style. No other fill style is supported.
                 *
                 * @param   value - LineStyle object or function that returns a LineStyle based on current stroke value.
                 * @returns     Object itself.
                 * @public
                 */
                setPointStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                /**
                 * Get stroke style for line drawn around edges of the points.
                 * @returns     LineStyle
                 * @public
                 */
                getPointStrokeStyle(): LineStyle;
                /**
                 * Set size of point in pixels.
                 *
                 * Point sizes can also be configured individually, see {@link DataSetXY.sizes} for more information.
                 *
                 * @param size - Size of point in pixels.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setPointSize(size: number): this;
                /**
                 * Get current size of points in pixels.
                 * @returns Size of point in pixels.
                 * @public
                 */
                getPointSize(): number;
                /**
                 * Set shape of displayed points, markers.
                 *
                 * ```ts
                 *  // Example syntax
                 *  PointLineAreaSeries.setPointShape(PointShape.Square)
                 * ```
                 *
                 * All valid options are listed under {@link PointShape}
                 *
                 * @param shape - point shape enum
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setPointShape(shape: PointShape): this;
                /**
                 * Set shape of displayed points as a Custom Icon.
                 * This allows using any custom bitmap as the shape of displayed points.
                 *
                 * ```ts
                 *  // Example usage
                 *  const image = new Image()
                 *  image.src = 'my-image.png'
                 *  PointLineAreaSeries.setPointShape(chart.engine.addCustomIcon(image))
                 * ```
                 * @param shape - Icon object.
                 * @returns Object itself for fluent interface.
                 */
                setPointShape(shape: Icon): this;
                /**
                 * Get current shape of displayed points.
                 * @returns     PointShape.
                 * @public
                 */
                getPointShape(): PointShape | Icon;
                /**
                 * Set the rotation of points in degrees.
                 *
                 * ```ts
                 *  // Example syntax, rotate 45 degrees
                 *  PointLineAreaSeries.setPointRotation(45)
                 * ```
                 *
                 * Point rotations can also be configured individually, see {@link DataSetXY.rotations} for more information.
                 *
                 * @param angle - Rotation angle in degrees
                 * @public
                 */
                setPointRotation(angle: number): this;
                /**
                 * Get the current rotation of points as degrees.
                 * @public
                 */
                getPointRotation(): number;
                /**
                 * Set alignment of points.
                 * Defaults to center `{ x: 0, y: 0 }`.
                 *
                 * Can be used to offset points relative to their size.
                 *
                 * ```ts
                 *  // Example, position point by bottom
                 *  PointLineAreaSeries.setPointAlignment({ x: 0, y: -1 })
                 * ```
                 *
                 * ```ts
                 *  // Example, position point by bottom with extra gap
                 *  PointLineAreaSeries.setPointAlignment({ x: 0, y: -1.5 })
                 * ```
                 * @param alignment - Alignment where values are % in range [-1, 1]. Can also be larger values, meaning offsets larger than point size.
                 * @returns             Object itself.
                 * @public
                 */
                setPointAlignment(alignment: Point): this;
                /**
                 * Get alignment of points.
                 * Defaults to center `{ x: 0, y: 0 }`.
                 *
                 * Can be used to offset points relative to their size.
                 * @public
                 */
                getPointAlignment(): Point;
                /**
                 * Set curve preprocessing mode.
                 * See {@link CurvePreprocessing} for more information.
                 *
                 * ```ts
                 *  // Example, enable step preprocessing
                 *  PointLineAreaSeries.setCurvePreprocessing({ type: 'step', step: 'middle' })
                 * ```
                 * @param value - Curve preprocessing description
                 * @returns     Object itself.
                 * @public
                 */
                setCurvePreprocessing(value: CurvePreprocessing | undefined): this;
                /**
                 * Get active curve preprocessing mode.
                 * @returns     CurvePreprocessing interface
                 * @public
                 */
                getCurvePreprocessing(): CurvePreprocessing | undefined;
                appendJSON(array: Array<Record<string, any>>, arg?: {
                    start?: number;
                    step?: number;
                    whitelist?: string[];
                    blacklist?: string[];
                }, fill?: Record<string, number | Color>): this;
                appendSample(sample: Record<string, any>, opts?: {
                    start?: number;
                    step?: number;
                }): this;
                appendSamples(samples: Record<string, any>, opts?: {
                    offset?: number;
                    count?: number;
                    offsetLookupValues?: number;
                    offsetColors?: number;
                    offsetIds?: number;
                    offsetSizes?: number;
                    offsetRotations?: number;
                    start?: number;
                    step?: number;
                }): this;
                fill(arg: Record<string, any>): this;
                setSamples(samples: Record<string, any>, //  number[] | Date[] | string[] | TypedArray
                opts?: {
                    offset?: number;
                    count?: number;
                    start?: number;
                    step?: number;
                }): this;
                alterSamplesStartingFrom(iSampleMin: number, samples: Record<string, any>, //  number[] | Date[] | string[] | TypedArray
                opts?: {
                    offset?: number;
                    count?: number;
                    start?: number;
                    step?: number;
                }): this;
                alterSamplesByIndex(sampleIndexes: TypedArray | number[], values: Record<string, any>): this;
                alterSamplesByMatch(matchKey: string, matchValues: TypedArray | number[], values: Record<string, any>): this;
                getSampleCount(): number;
                getNextSampleIndex(): number;
                setMaxSampleCount(maxSampleCount: number): this;
                setMaxSampleCount(arg: {
                    mode: 'auto';
                    max?: number;
                    initial?: number;
                }): this;
                getMaxSampleCount(): number | undefined;
                clear(): this;
                /**
                 * Read back the current contents of the data set.
                 *
                 * ```ts
                 *  // Read back data
                 *  const data = series.readBack()
                 *  console.log(data)
                 * ```
                 *
                 * If data cleaning (max sample count) is enabled, this can result in allocating new memory (and thus be expensive).
                 * Otherwise, a very efficient operation.
                 *
                 * The returned values should NOT be modified.
                 *
                 * Optionally, you can include the flag `onlyInRange` to find return only samples that are in specified range.
                 * This is only supported if the series is currently mapped to a progressive data property.
                 * The range is always considered to be in the same dimension.
                 *
                 * ```ts
                 *  // Example, read back data that is visible
                 *  chart.axisX.addEventListener('intervalchange', event => {
                 *      const data = series.readBack({ onlyInRange: event })
                 *      console.log(data)
                 *  })
                 * ```
                 *
                 * This operation is not "pixel perfect", meaning it can often return 1 extra sample that is not visible (the next and/or previous ones).
                 *
                 * @param arg -     Optional extra arguments.
                 * @returns     Object with lists of separate data channels, like x coordinates, y coordinates, look up values, colors, etc.
                 * @public
                 */
                readBack(arg?: {
                    onlyInRange?: {
                        start: number;
                        end: number;
                    };
                }): {
                    xValues: TypedArray;
                    yValues: TypedArray;
                    iSampleFirst: number;
                    lookupValues?: TypedArray;
                    colors?: TypedArray;
                    ids?: TypedArray;
                    sizes?: TypedArray;
                    rotations?: TypedArray;
                };
                /**
                 * Method for solving the nearest data point to a given coordinate on screen.
                 *
                 * ```ts
                 *  // Example syntax
                 *  chart.onSeriesBackgroundMouseClick((_, event) => {
                 *      const nearest = series.solveNearest(event, 'show-nearest')
                 *      console.log(nearest)
                 *  })
                 * ```
                 * @param   from -          Reference coordinate on web page as client coordinates. This can for example be directly an `Event` object.
                 * @param   solveMode -     Optional control for solve nearest behavior
                 * @returns                 SolveResult object or `undefined`.
                 * @public
                 */
                solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultSampleXY | undefined;
                /**
                 * Method for solving the nearest data point to a given axis coordinate.
                 *
                 * ```ts
                 *  // Example syntax
                 *  const nearest = series.solveNearest({ x: 0, y: 0 })
                 *  console.log(nearest)
                 * ```
                 * @param   from -          Coordinate along the same Axes as the series exists in.
                 * @param   solveMode -     Optional control for solve nearest behavior
                 * @returns                 SolveResult object or `undefined`.
                 * @public
                 */
                solveNearest(from: CoordinateXY, solveMode?: SolveNearestMode): SolveResultSampleXY | undefined;
                addEventListener<K extends keyof PointLineAreaSeriesEventMap>(type: K, listener: (event: PointLineAreaSeriesEventMap[K], info: SolveResultSampleXY) => unknown, options?: LCJSAddEventListenerOptions): void;
                removeEventListener<K extends keyof PointLineAreaSeriesEventMap>(type: K, listener: (event: PointLineAreaSeriesEventMap[K], info: SolveResultSampleXY) => unknown): void;
            }
            /**
             * Interface of events trackable by {@link PointLineAreaSeries.addEventListener} and the respective Event types.
             * @public
             */
            export declare interface PointLineAreaSeriesEventMap extends ChartComponentEventMap, DataSetXYEventMap {
            }
            /**
             * Interface for readonly configuration of {@link PointLineAreaSeries}.
             *
             * **Example usage:**
             *
             * ```typescript
             *  // Example 1, create series with default configuration.
             *  const series = ChartXY.addPointLineAreaSeries({})
             * ```
             *
             * ```typescript
             *  // Example 2, attach series to non-default X Axis.
             *  const series = ChartXY.addPointLineAreaSeries({
             *      xAxis: myNonDefaultAxisX
             *  })
             * ```
             *
             * ```typescript
             *  // Example 3, specify schema.
             *  const series = ChartXY.addPointLineAreaSeries({
             *      schema: {
             *          timestamps: { pattern: 'progressive' },
             *          temperature: { pattern: null }
             *      }
             *  })
             * ```
             *
             * See {@link SeriesOptionsXY} and {@link DataSetXYOptions} for more detailed information about available properties.
             *
             * @public
             */
            export declare interface PointLineAreaSeriesOptions extends DataSetXYOptions, SeriesOptionsXY {
                /**
                 * Optional flag that can be used to disable automatic grouping of progressive data that is packed **very** tightly together.
                 *
                 * Even if data grouping is enabled, data will be automatically displayed according to the active zoom level so that the data looks accurate at all times.
                 *
                 * Set to `true` or omit for maximum performance.
                 *
                 * ```ts
                 *  // Example, disable data grouping
                 *  const series = ChartXY.addPointLineAreaSeries({ allowDataGrouping: false })
                 * ```
                 */
                allowDataGrouping?: boolean;
            }
            /**
             * Series type for visualizing a collection of `{ x, y, z }` coordinates by a continuous line stroke and markers.
             *
             * `PointLineSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
             *
             * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
             * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
             *
             * **Creating PointLineSeries3D:**
             *
             * `PointLineSeries3D` are created with {@link Chart3D.addPointLineSeries} method.
             *
             * ```typescript
             *  // Example syntax, create point line series 3D
             *  const pointLineSeries3D = Chart3D.addPointLineSeries()
             * ```
             *
             * **Frequently used methods:**
             *
             * - Append data points to series | {@link add}
             * - Remove all data points from series | {@link clear}
             * - Configure style of line stroke | {@link setStrokeStyle}
             * - Configure style of markers | {@link setPointStyle}
             * - Destroy series permanently | {@link dispose}
             *
             * **Color shading style**.
             *
             * By default, `PointLineSeries3D` uses _Phong_ shading style.
             *
             * This can be changed with `PointLineSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())`
             *
             * **Related information:**
             *
             * For series with only line stroke, see {@link LineSeries3D}.
             *
             * For series with only markers, see {@link PointSeries3D}.
             * @public
             */
            export declare class PointLineSeries3D extends LineAndPointSeries3D {
                /**
                 * Set point style of Series.
                 *
                 * Example usage:
                 *
                 * - **New TriangulatedPoints3D object**
                 * ```ts
                 *  pointLineSeries3D.setPointStyle( new PointStyle3D.Triangulated({
                 *      size: 10,
                 *      shape: 'sphere',
                 *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
                 *  }) )
                 * ```
                 * - **Change point size**
                 * ```ts
                 *  pointLineSeries3D.setPointStyle( (pointStyle) => pointStyle
                 *      .setSize( 10 )
                 *  )
                 * ```
                 * - **Change point shape**
                 * ```ts
                 *  pointLineSeries3D.setPointStyle( (pointStyle) => pointStyle
                 *      .setShape( 'cube' )
                 *  )
                 * ```
                 *
                 * **NOTE:** Currently `PointLineSeries3D` only supports Solid filled points.
                 * Alternatively, `PointSeries3D` can be used for various dynamic and powerful coloring features. See {@link PointSeries3D.setPointStyle} for examples and more information.
                 *
                 * @param value - A TriangulatedPoints3D object, or a function which modifies the current style.
                 * @returns Object itself for fluent interface
                 * @public
                 */
                setPointStyle(value: TriangulatedPoints3D | ImmutableMutator<TriangulatedPoints3D>): this;
                /**
                 * Get normal points style.
                 * @returns TriangulatedPoints3D
                 * @public
                 */
                getPointStyle(): TriangulatedPoints3D;
                /**
                 * Set stroke style of Series.
                 *
                 * Supported line styles:
                 * - {@link SolidLine}
                 *
                 * ```ts
                 *  // Example syntax, specify LineStyle
                 *  LineSeries3D.setStrokeStyle(new SolidLine({
                 *      thickness: 2,
                 *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
                 *  }))
                 * ```
                 *
                 * ```ts
                 *  // Example syntax, change active LineStyle
                 *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(5))
                 * ```
                 *
                 * Use `-1` thickness to enable primitive line rendering.
                 * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
                 * ```typescript
                 *  LineSeries3D.setStrokeStyle((solidLine) => solidLine.setThickness(-1))
                 * ```
                 *
                 * - **Supported fill styles:**
                 *
                 * {@link SolidFill}:
                 *
                 * Solid color for entire line series.
                 *
                 * ```ts
                 *  // Example, solid colored line.
                 *  LineSeries3D.setStrokeStyle(new SolidLine({
                 *      thickness: 2,
                 *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                 *  }))
                 * ```
                 *
                 * To learn more about available *Color* factories, see {@link ColorRGBA}
                 *
                 * {@link PalettedFill}:
                 *
                 * Color line stroke dynamically based on `x`, `y` or `z` coordinate.
                 *
                 * ```ts
                 *  // Example, dynamic color by Y coordinates
                 *  LineSeries3D.setStrokeStyle(new SolidLine({
                 *      thickness: 2,
                 *      fillStyle: new PalettedFill({
                 *          lookUpProperty: 'y',
                 *          lut: new LUT({
                 *              interpolate: true,
                 *              steps: [
                 *                  { value: 0, color: ColorRGBA(255, 0, 0) },
                 *                  { value: 100, color: ColorRGBA(0, 255, 0) },
                 *              ]
                 *          })
                 *      })
                 *  }))
                 * ```
                 *
                 * To learn more about Color lookup tables, see {@link LUT}.
                 *
                 * - **Primitive 3D line rendering**
                 *
                 * `LineSeries3D` has a special feature for drawing *primitive* line sets.
                 *
                 * When enabled, this will draw all line segments as exactly 1 pixel thick on the monitor (regardless of distance from camera).
                 *
                 * As a benefit, this is considerably lighter on the GPU, which is especially good with mobile and laptop devices with weak GPUs.
                 *
                 * *Primitive* drawing is enabled by setting stroke thickness to `-1`:
                 *
                 * ```ts
                 *  // Enable primitive 3D line drawing.
                 *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(-1))
                 * ```
                 *
                 * - **Other information**
                 *
                 * In 3D, line thickness is not configured exactly as pixels (since the size of pixel is not affected by distance from camera).
                 *
                 * However, for usage convenience, you can consider line thickness in 3D as pixels just the same as 2D,
                 * even if the resulting visualization will have some differences.
                 *
                 * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setStrokeStyle(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D>): this;
                /**
                 * Method matches highlight point size with that of the supplied line style.
                 */
                private _matchJointHighlightSize;
            }
            /**
             * Interface that can be used to specify readonly parameters when creating a {@link PointLineSeries3D}.
             * @public
             */
            export declare interface PointLineSeriesOptions3D {
            }
            /**
             * Visual that is displayed at the Cursors position.
             * Has customizable fill and border.
             * @public
             */
            export declare interface PointMarker extends Marginable, Interactable {
                /**
                 * Set displayed shape.
                 *
                 * ```ts
                 *  // Example
                 *  setShape(PointShape.Star)
                 * ```
                 *
                 * See {@link PointShape} for all available options.
                 *
                 * @public
                 */
                setShape(shape: PointShape | Icon): this;
                /**
                 * Get displayed shape.
                 * @public
                 */
                getShape(): PointShape | Icon;
                /**
                 * Set rotation of point shape in degrees.
                 * @param   rotationDeg - Rotation in degrees.
                 * @returns     Object itself.
                 * @public
                 */
                setRotation(rotationDeg: number): this;
                /**
                 * Get rotation of point shape in degrees.
                 * @returns     Rotation as degrees
                 * @public
                 */
                getRotation(): number;
                /**
                 * Set origin position of PointMarker
                 * @param origin - (-1 to 1 which specifies position of origin, 0 is center of the object)
                 * @returns Object itself for fluent interface
                 * @public
                 */
                setOrigin: (origin: Point) => this;
                /**
                 * Get origin position of PointMarker
                 * @returns (-1 to 1 which specifies position of origin, 0 is center of the object)
                 * @public
                 */
                getOrigin: () => Point;
                /**
                 * Set size of PointMarker
                 * @param size - Size of PointMarker in pixels
                 * @returns Object itself
                 * @public
                 */
                setSize: (size: Point) => this;
                /**
                 * Get size of PointMarker
                 * @returns Size of PointMarker in pixels
                 * @public
                 */
                getSize: () => Point;
                /**
                 * Set fillStyle of PointMarker
                 * @param fillStyle - FillStyle object or mutator to modify existing one
                 * @returns Object itself
                 * @public
                 */
                setFillStyle: (fillStyle: FillStyle | ImmutableMutator<FillStyle>) => this;
                /**
                 * Get fillStyle of PointMarker
                 * @returns FillStyle object
                 * @public
                 */
                getFillStyle: () => FillStyle;
                /**
                 * Set stroke style of PointMarker
                 * @param value - LineStyle object or mutator to modify existing one
                 * @returns Object itself
                 * @public
                 */
                setStrokeStyle: (value: LineStyle | ImmutableMutator<LineStyle>) => this;
                /**
                 * Get stroke style of PointMarker
                 * @returns LineStyle object
                 * @public
                 */
                getStrokeStyle: () => LineStyle;
            }
            /**
             * Series type for visualizing a collection of `{ x, y, z }` coordinates by different markers
             *
             * `PointSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
             *
             * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
             * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
             *
             * **Creating PointSeries3D:**
             *
             * `PointSeries3D` are created with {@link Chart3D.addPointSeries} method.
             *
             * Some properties of `PointSeries3D` can only be configured when it is created. These arguments are all optional,
             * and are wrapped in a single object parameter:
             *
             * ```typescript
             *  // Example,
             *  const pointSeries3D = Chart3D.addPointSeries({
             *      // Enable individual data points size.
             *      individualPointSizeEnabled: true
             *  })
             * ```
             *
             * To learn about available properties, refer to {@link PointSeriesOptions3D}.
             *
             * **Frequently used methods:**
             *
             * - Append data points to series | {@link add}
             * - Remove all data points from series | {@link clear}
             * - Configure style of points | {@link setPointStyle}
             * - Destroy series permanently | {@link dispose}
             *
             * **Color shading style**.
             *
             * By default, `PointSeries3D` uses _Phong_ shading style.
             *
             * This can be changed with `PointSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())`
             *
             * **Related information:**
             *
             * There is another series type for visualizing large sets of 3D coordinates with markers: {@link PointCloudSeries3D}
             *
             * `PointCloudSeries3D` works otherwise same, except that it has simplified render process (all markers are 2D geometry),
             * which is faster and can be really powerful in visualizing large low-detail data sets!
             * @public
             */
            export declare class PointSeries3D extends AbstractPointSeries3D<TriangulatedPoints3D> {
                /**
                 * Set point style of Series.
                 *
                 * **Example syntax:**
                 *
                 * ```ts
                 *  // Example syntax, Specify new style
                 *  pointSeries3D.setPointStyle( new PointStyle3D.Triangulated({
                 *      size: 10,
                 *      shape: 'sphere',
                 *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
                 *  }) )
                 * ```
                 *
                 * ```ts
                 *  // Example syntax, Change point color
                 *  pointSeries3D.setPointStyle( (pointStyle) => pointStyle
                 *      .setFillStyle( new SolidFill({ color: ColorHEX('#FFF') }) )
                 *  )
                 * ```
                 *
                 * ```ts
                 *  // Example syntax, Change point size
                 *  pointSeries3D.setPointStyle( (pointStyle) => pointStyle
                 *      .setSize( 10 )
                 *  )
                 * ```
                 *
                 * ```ts
                 *  // Example syntax, Change point shape
                 *  pointSeries3D.setPointStyle( (pointStyle) => pointStyle
                 *      .setShape( 'cube' )
                 *  )
                 * ```
                 *
                 * **Point coloring:**
                 *
                 * Color of points is configured by the `fillStyle` property of active point style.
                 *
                 * Here is a list of all supported _fill styles_ with feature descriptions and example syntax:
                 *
                 * {@link SolidFill}:
                 *
                 * Solid color for all points in series.
                 *
                 * ```js
                 *  // Example syntax, solid points color.
                 *  pointSeries3D.setPointStyle(new PointStyle3D.Triangulated({
                 *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) }),
                 *      size: 10,
                 *      shape: 'sphere'
                 *  }))
                 * ```
                 *
                 * {@link PalettedFill}:
                 *
                 * Look-up dynamic per-point color based on a _look up property_ (number) and a color look up table ({@link LUT}).
                 *
                 * ```js
                 *  // Example syntax, dynamic points color.
                 *  pointSeries3D.setPointStyle(new PointStyle3D.Triangulated({
                 *      fillStyle: new PalettedFill({
                 *          // lookUpProperty defines basis of selecting look up value (number).
                 *          lookUpProperty: 'value',
                 *          // lut defines table for mapping look up value (number) to a color.
                 *          lut: new LUT({
                 *              interpolate: true,
                 *              steps: [
                 *                  { value: 0, color: ColorRGBA(0, 0, 0) },
                 *                  { value: 1, color: ColorRGBA(255, 0, 0) }
                 *              ]
                 *          })
                 *      }),
                 *      size: 10,
                 *      shape: 'sphere'
                 *  }))
                 * ```
                 *
                 * `PointSeries3D` supports several different look-up modes:
                 *
                 * `lookUpProperty: 'value'`:
                 *
                 * **IMPORTANT:** In order to use `value` property on data points, the feature has to be explicitly activated **when the series is created**:
                 *
                 * ```js
                 *  // Example syntax, enable individual data point values.
                 *  const pointSeries3D = chart3D.addPointSeries({
                 *      individualLookupValuesEnabled: true
                 *  })
                 * ```
                 *
                 * `value` property is then added for every data point along side `x`, `y` and `z`:
                 *
                 * ```js
                 *  // Example syntax, individual data point values.
                 *  pointSeries3D.add([
                 *      { x: 0, y: 0, z: 0, value: 0 },
                 *      { x: 1, y: 0, z: 2, value: 1 },
                 *  ])
                 * ```
                 *
                 * Look-up value is read from data point `value` property.
                 *
                 * `lookUpProperty: 'x'`:
                 *
                 * Look-up value is set to data point `x` coordinate on Axis.
                 *
                 * `lookUpProperty: 'y'`:
                 *
                 * Look-up value is set to data point `y` coordinate on Axis.
                 *
                 * `lookUpProperty: 'z'`:
                 *
                 * Look-up value is set to data point `z` coordinate on Axis.
                 *
                 * {@link IndividualPointFill}:
                 *
                 * Supply individual color for each data point.
                 *
                 * **IMPORTANT:** In order to use `IndividualPointFill`, the feature has to be explicitly activated **when the series is created**:
                 *
                 * ```js
                 *  // Example syntax, enable individual data point colors.
                 *  const pointSeries3D = chart3D.addPointSeries({
                 *      individualPointColorEnabled: true
                 *  })
                 * ```
                 *
                 * `color` property is then added for every data point along side `x`, `y` and `z`:
                 *
                 * ```js
                 *  // Example syntax, individual data point colors.
                 *  pointSeries3D.add([
                 *      { x: 0, y: 0, z: 0, color: ColorRGBA(255, 0, 0) },
                 *      { x: 1, y: 0, z: 2, color: ColorRGBA(0, 255, 0) },
                 *  ])
                 * ```
                 *
                 * **Point size:**
                 *
                 * Size of points is configured by the `size` property of active point style.
                 *
                 * If required, points can also be individually sized by adding a `size` property to data points.
                 *
                 * **IMPORTANT:** In order to use `size` property, the feature has to be explicitly activated **when the series is created**:
                 *
                 * ```js
                 *  // Example syntax, enable individual data point size.
                 *  const pointSeries3D = chart3D.addPointSeries({
                 *      individualPointSizeEnabled: true
                 *  })
                 * ```
                 *
                 * `size` property is then added for every data point along side `x`, `y` and `z`:
                 *
                 * ```js
                 *  // Example syntax, individual data point sizes.
                 *  pointSeries3D.add([
                 *      { x: 0, y: 0, z: 0, size: 5 },
                 *      { x: 1, y: 0, z: 2, size: 10 },
                 *  ])
                 * ```
                 *
                 *
                 * **Point size 3D:**
                 *
                 * As an alternative method to `size`, each 3D point can also be sized with individual sizes for each Axis (X, Y and Z).
                 *
                 * This is done by adding `sizeAxisX`, `sizeAxisY`, and `sizeAxisZ` properties to data points.
                 *
                 * **IMPORTANT:** In order to use these properties, the feature has to be explicitly activated **when the series is created**:
                 *
                 * ```js
                 *  // Example syntax, enable individual data point 3D axis size.
                 *  const pointSeries3D = chart3D.addPointSeries({
                 *      individualPointSizeAxisEnabled: true
                 *  })
                 * ```
                 *
                 * `sizeAxisX`, `sizeAxisY` and `sizeAxisZ` properties are then added for every data point along side `x`, `y` and `z`:
                 *
                 * ```js
                 *  // Example syntax, individual data point 3D axis sizes.
                 *  pointSeries3D.add([
                 *      { x: 0, y: 0, z: 0, sizeAxisX: 1, sizeAxisY: 10, sizeAxisZ: 5 },
                 *      { x: 1, y: 0, z: 2, sizeAxisX: 1, sizeAxisY: 10, sizeAxisZ: 5 },
                 *  ])
                 * ```
                 *
                 *
                 * **IMPORTANT:** in order for points to be sized based on `sizeAxisX`, `sizeAxisY` and `sizeAxisZ` properties, the active point style must also have a fallback point size definition **as axis dimensions**:
                 *
                 * ```js
                 *  pointSeries3D.setPointStyle(new PointStyle3D.Triangulated({
                 *      // IMPORTANT: fallback `size` must be defined with { x, y, z } syntax!
                 *      size: { x: 1, y: 1, z: 1 },
                 *      shape: 'sphere',
                 *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                 *  }))
                 * ```
                 *
                 * @param value - A TriangulatedPoints3D object, or a function which modifies the current style.
                 * @returns Object itself for fluent interface
                 * @public
                 */
                setPointStyle(value: TriangulatedPoints3D | ImmutableMutator<TriangulatedPoints3D>): this;
                /**
                 * Get normal points style.
                 * @returns TriangulatedPoints3D
                 * @public
                 */
                getPointStyle(): TriangulatedPoints3D;
            }
            /**
             * Interface that can be used to specify readonly parameters when creating a {@link PointSeries3D}.
             *
             * `PointSeries3D` is created with {@link Chart3D.addPointSeries} method.
             * @public
             */
            export declare interface PointSeriesOptions3D<T extends PointSeriesTypes3D = PointSeriesTypes3D> extends SeriesOptions {
                /**
                 * Defines the type of *Point Series 3D*.
                 *
                 * See {@link PointSeriesTypes3D} for a collection of options.
                 *
                 * ```js
                 *  // Example syntax,
                 *  const pointSeries3D = chart3D.addPointSeries({
                 *      type: PointSeriesTypes3D.Triangulated
                 *  })
                 * ```
                 */
                type?: T;
                /**
                 * Flag that can be used to enable data points `color` property on top of `x`, `y` and `z`.
                 * By default this is disabled.
                 *
                 * This feature can be used to color data points individually by user supplied color.
                 *
                 * If required, this must be enabled **when the series is created**.
                 *
                 * ```js
                 *  // Example, enable PointSeries3D data `color` property.
                 *  const pointSeries3D = chart3D.addPointSeries({
                 *      individualPointColorEnabled: true
                 *  })
                 *
                 *  // 'color' property can now be included in data points.
                 *  pointSeries3D.add([
                 *      { x: 0, y: 0, z: 0, color: ColorRGBA(255, 0, 0) }
                 *  ])
                 * ```
                 *
                 * `individualPointColorEnabled` must be enabled in order to style `PointSeries3D` with {@link IndividualPointFill}.
                 * See {@link PointSeries3D.setPointStyle} for more detailed information.
                 *
                 * **Performance side-effects from enabling**:
                 * - Increases CPU scripting time very slightly.
                 * - Slightly increased GPU memory usage.
                 */
                individualPointColorEnabled?: boolean;
                /**
                 * Flag that can be used to enable data points `size` property on top of `x`, `y` and `z`.
                 * By default this is disabled.
                 *
                 * This feature can be used to size data points individually by user supplied values.
                 *
                 * If required, this must be enabled **when the series is created**.
                 *
                 * ```js
                 * // Example, enable PointSeries3D data `size` property.
                 * const pointSeries3D = chart3D.addPointSeries({
                 *     individualPointSizeEnabled: true
                 * })
                 *
                 * // 'size' property can now be included in data points.
                 * pointSeries3D.add([
                 *     { x: 0, y: 0, z: 0, size: 5 }
                 * ])
                 * ```
                 *
                 * **Performance side-effects from enabling**:
                 * - With detailed point geometry (like 'sphere'), the geometry precision will be maximized, resulting in considerable increase in GPU processing time.
                 */
                individualPointSizeEnabled?: boolean;
                /**
                 * Flag that can be used to enable data points 'sizeAxisX', 'sizeAxisY' and 'sizeAxisZ' properties on top of `x`, `y` and `z`.
                 * By default this is disabled.
                 *
                 * This feature can be used to size data points individually as 3D Axis dimensions.
                 *
                 * If required, this must be enabled **when the series is created**.
                 *
                 * ```js
                 *  // Example, enable PointSeries3D data point individual axis size properties.
                 *  const pointSeries3D = chart3D.addPointSeries({
                 *      individualPointSizeAxisEnabled: true
                 *  })
                 *
                 *  // 'sizeAxisX', 'sizeAxisY' and 'sizeAxisZ' properties can now be included in data points.
                 *  pointSeries3D.add([
                 *      { x: 0, y: 0, z: 0, sizeAxisX: 1, sizeAxisY: 10, sizeAxisZ: 5 }
                 *  ])
                 * ```
                 *
                 * **NOTE:** in order for points to be sized based on `sizeAxisX`, `sizeAxisY` and `sizeAxisZ` properties, the active point style must also have a fallback point size definition **as axis dimensions**:
                 *
                 * ```js
                 *  pointSeries3D.setPointStyle(new PointStyle3D.Triangulated({
                 *      // IMPORTANT: fallback `size` must be defined with { x, y, z } syntax!
                 *      size: { x: 1, y: 1, z: 1 },
                 *      shape: 'sphere',
                 *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                 *  }))
                 * ```
                 *
                 * **Performance side-effects from enabling**:
                 * - With detailed point geometry (like 'sphere'), the geometry precision will be maximized, resulting in considerable increase in GPU processing time.
                 */
                individualPointSizeAxisEnabled?: boolean;
                /**
                 * Flag that can be used to enable data points `value` property on top of `x`, `y` and `z`.
                 * By default this is disabled.
                 *
                 * This feature can be used to color data points individually by dynamic color look up.
                 *
                 * If required, this must be enabled **when the series is created**.
                 *
                 * ```js
                 *  // Example, enable PointSeries3D data `value` property.
                 *  const pointSeries3D = chart3D.addPointSeries({
                 *      individualLookupValuesEnabled: true
                 *  })
                 *
                 *  // 'value' property can now be included in data points.
                 *  pointSeries3D.add([
                 *      { x: 0, y: 0, z: 0, value: 5 }
                 *  ])
                 * ```
                 *
                 * `individualLookupValuesEnabled` must be enabled in order to style `PointSeries3D` with {@link PalettedFill} of `lookUpProperty: 'value'`.
                 * See {@link PointSeries3D.setPointStyle} for more detailed information.
                 *
                 * **Performance side-effects from enabling**:
                 * - With detailed point geometry (like 'sphere'), the geometry precision will be maximized, resulting in considerable increase in GPU processing time.
                 */
                individualLookupValuesEnabled?: boolean;
            }
            /**
             * Collection of *PointSeries3D* implementations.
             *
             * Used when creating an *PointSeries3D* with {@link Chart3D.addPointSeries}.
             * Selected option tells what the returned *Series* type will be - *PointSeries3D* implementations are otherwise equal, but
             * their styling APIs expect different *Style* objects.
             *
             * - Select PointSeriesTypes3D.Triangulated for shaded geometries styled with {@link PointStyle3D | PointStyle3D.Triangulated}.
             * - Select PointSeriesTypes3D.Pixelated for pixels styled with {@link PointStyle3D | PointStyle3D.Pixelated}.
             * @public
             */
            export declare const PointSeriesTypes3D: {
                /**
                 * Type of *Point Series 3D* that visualized points by shaded geometry styled using {@link PointStyle3D | PointStyle3D.Triangulated}.
                 */
                Triangulated: typeof PointSeries3D;
                /**
                 * Type of *Point Series 3D* that visualized points by pixels styled using {@link PointStyle3D | PointStyle3D.Pixelated}.
                 */
                Pixelated: typeof PointCloudSeries3D;
            };
            /**
             * Available Point Series 3D types.
             *
             * Used internally for proper type casting. Should not be included in docs,
             * as it overrides the selection object just below, that has the same name.
             * @public
             */
            export declare type PointSeriesTypes3D = (typeof PointSeriesTypes3D)[keyof typeof PointSeriesTypes3D];
            /**
             * Enum for selecting shape of points for Point-based *Series*.
             * Supported by:
             * - {@link PointSeries}
             * - {@link PointLineSeries}
             * - {@link SpiderSeries}
             * - UI buttons, `setButtonShape` methods.
             *
             * This must be specified when the *Series* is created, and can't be changed afterwards.
             * @public
             */
            export declare enum PointShape {
                /**
                 * Square shape.
                 */
                Square = 0,
                /**
                 * Circle shape.
                 */
                Circle = 1,
                /**
                 * Hollow circle (fill is transparent).
                 *
                 * Hollow area is always 60% of point size. This is not configurable.
                 *
                 * @deprecated Deprecated in v8.0.0 in favour of using Circle point shape and newly added point stroke style.
                 */
                HollowCircle = 2,
                /**
                 * Triangle shape.
                 */
                Triangle = 3,
                /**
                 * Cross (X) shape.
                 */
                Cross = 4,
                /**
                 * Diamond (45 deg rotated square) shape.
                 */
                Diamond = 5,
                /**
                 * Plus (+) shape.
                 */
                Plus = 6,
                /**
                 * Minus (-) shape.
                 */
                Minus = 7,
                /**
                 * Arrow shape.
                 * Points up with 0 rotation.
                 */
                Arrow = 8,
                /**
                 * Star shape.
                 */
                Star = 9
            }
            /**
             * Collection of constructors for specifying style of 3D points rendering.
             *
             * Used with:
             * - **PointSeries3D**
             * - **PointCloudSeries3D**
             * @public
             */
            export declare const PointStyle3D: {
                /**
                 * A style class used to specify style of 3D points rendering as triangulated Cubes.
                 */
                Triangulated: typeof TriangulatedPoints3D;
                /**
                 * A style class used to specify style of 3D points rendering as pixelated squares.
                 *
                 * This rendering style is optimal for rendering large numbers of points that do not require great individual detail.
                 */
                Pixelated: typeof PixelatedPoints3D;
            };
            /**
             * Interface for a immutable data-structure which defines a location along the XZ plane, without any Y information.
             * @public
             */
            export declare interface PointXZ {
                /**
                 * Location in X-dimension.
                 */
                readonly x: number;
                /**
                 * Location in Z-dimension.
                 */
                readonly z: number;
            }
            /**
             * Abstract super class for Polar Area Series.
             * @public
             */
            export declare abstract class PolarAreaSeries extends PolarSeries {
                /**
                 * Set data for PolarSeries to render as a list of {@link PolarPoint}s.
                 * @param points - List of {@link PolarPoint}s.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setData(points: PolarPoint[]): this;
                /**
                 * Get user-supplied data points.
                 * @returns Array of {@link PolarPoint}s.
                 * @public
                 */
                getData(): PolarPoint[];
                /**
                 * Set fill style of Series.
                 *
                 * Example usage:
                 *```javascript
                 * // Create a new style
                 * PolarAreaSeries.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                 * // Change transparency
                 * PolarAreaSeries.setFillStyle((solidFill) => solidFill.setA(80))
                 * // Set hidden
                 * PolarAreaSeries.setFillStyle(emptyFill)
                 * ```
                 * @param value - Either a FillStyle object or a function, which will be used to create a new SolidLine based on current value.
                 * @returns Chart itself
                 * @public
                 */
                setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                /**
                 * Get fill style of Series.
                 * @returns FillStyle object
                 * @public
                 */
                getFillStyle(): FillStyle;
                /**
                 * Set stroke style of Series.
                 *
                 * Supported line styles:
                 * - {@link SolidLine}
                 * - {@link emptyLine}
                 *
                 * Example usage:
                 *```javascript
                 * // Specified LineStyle
                 * PolarAreaSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                 * // Changed thickness
                 * PolarAreaSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
                 * // Hidden
                 * PolarAreaSeries.setStrokeStyle(emptyLine)
                 * ```
                 * @param value - Either a LineStyle object or a function, which will be used to create a new SolidLine based on current value.
                 * @returns Chart itself
                 * @public
                 */
                setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                /**
                 * Get stroke style of Series.
                 * @returns LineStyle object
                 * @public
                 */
                getStrokeStyle(): LineStyle;
                /**
                 * Set automatic connection of first and last data points enabled or not.
                 *
                 * **Disabled by default.**
                 * @param enabled - Boolean.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setConnectDataAutomaticallyEnabled(enabled: boolean): this;
                /**
                 * Get automatic connection of first and last data points enabled or not.
                 * @returns Boolean.
                 * @public
                 */
                getConnectDataAutomaticallyEnabled(): boolean;
                addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolar) => unknown, options?: LCJSAddEventListenerOptions): void;
                removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolar) => unknown): void;
            }
            /**
             * Type of *PolarAreaSeries* that fills the Polar area between data points and center of Polar Chart.
             *
             * **Example usage:**
             *
             * - *Plot sub section (\< 360 degrees) of the Polar Chart*
             * ```ts
             *  const areaSeries = polarChart.addAreaSeries()
             *      .setData(
             *          new Array( 90 ).fill( 0 ).map(( _, i ) => ({
             *              angle: i,
             *              amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
             *          }))
             *      )
             * ```
             *
             * - *Plot a fully connected (360 degrees) section of the Polar Chart*
             * ```ts
             *  const areaSeries = polarChart.addAreaSeries()
             *      .setConnectDataAutomaticallyEnabled(true)
             *      .setData(
             *          new Array(360).fill(0).map((_, i) => ({
             *              angle: i,
             *              amplitude: 60 + 25 * Math.cos((5 * i * Math.PI) / 180),
             *          })),
             *      )
             * ```
             * @public
             */
            export declare class PolarAreaSeriesInterior extends PolarAreaSeries {
                solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultPolar | undefined;
            }
            /**
             * Generic super class for {@link PolarAxisAmplitude} and {@link PolarAxisRadial}.
             * @public
             */
            export declare abstract class PolarAxis extends GenericAxis<AxisScale, PolarAxisStrategy, PolarAxisTick, _GenericAxisInput, _GenericTickPlottingVariables, _GenericTickInfo, _UpdateOutputAxisPolar> implements StylableAxisLine {
                /**
                 * Set *TickStrategy* of *Axis*.
                 *
                 * The *TickStrategy* defines the positioning and formatting logic of *Axis* ticks
                 * as well as the style of created ticks.
                 *
                 * **Example usage**:
                 *
                 * **DateTime Axis**:
                 * ```javascript
                 *  Axis.setTickStrategy( AxisTickStrategies.DateTime )
                 * ```
                 *
                 * **Disable automatic ticks completely**:
                 * ```javascript
                 *  Axis.setTickStrategy( AxisTickStrategies.Empty )
                 * ```
                 *
                 * **Customized TickStrategy**:
                 * ```javascript
                 *  Axis.setTickStrategy( AxisTickStrategies.Numeric, ( tickStrategy: NumericTickStrategy ) => tickStrategy
                 *      .setNumericUnits( true )
                 *      .setMajorTickStyle( ( tickStyle ) => tickStyle
                 *          .setLabelFont( ( font ) => font
                 *              .setWeight( 'bold' )
                 *          )
                 *      )
                 *  )
                 * ```
                 *
                 * **Type table for optional second parameter ('styler')**:
                 *
                 * | tickStrategy   | styler                                                        |
                 * | :------------- | :------------------------------------------------------------ |
                 * | 'Numeric'      | `( tickStrategy: **NumericTickStrategy** ) => tickStrategy`   |
                 * | 'Time'         | `( tickStrategy: **TimeTickStrategy** ) => tickStrategy`      |
                 * | 'DateTime'     | `( tickStrategy: **DateTimeTickStrategy** ) => tickStrategy`  |
                 * | 'Empty'        | `undefined`                                                   |
                 *
                 *
                 * @param tickStrategy - Selected TickStrategy.
                 *                          See {@link AxisTickStrategies} for a collection of options.
                 * @param styler - Optional callback that can be used to customize the *TickStrategy*.
                 *                          The type of supplied *TickStrategy* object depends on what was supplied to 'tickStrategy' parameter;
                 *                          See the above method documentation for a value table.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setTickStrategy<TickStrategy extends TickStrategyType>(tickStrategy: TickStrategy, styler?: TickStrategyStyler<TickStrategyParameters, TickStrategy>): this;
                /**
                 * Specifies axis stroke
                 * @param value - Axis stroke style
                 * @returns Axis itself for fluent interface
                 * @public
                 */
                setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                /**
                 * @returns Axis stroke as a LineStyle object
                 * @public
                 */
                getStrokeStyle(): LineStyle;
                addEventListener<K extends keyof GenericAxisEventMap>(type: K, listener: (event: GenericAxisEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                removeEventListener<K extends keyof GenericAxisEventMap>(type: K, listener: (event: GenericAxisEventMap[K], info: unknown) => unknown): void;
                /**
                 * Set whether element can be target of pointer events or not.
                 *
                 * Disabling pointer events means that the objects below this component can be interacted _through_ it.
                 *
                 * @param state - Specifies state of mouse interactions
                 * @returns Object itself for fluent interface
                 * @public
                 */
                setPointerEvents(state: boolean): this;
                /**
                 * Get whether element can be target of pointer events or not.
                 * @returns Pointer events state
                 * @public
                 */
                getPointerEvents(): boolean;
            }
            /**
             * Class that represents the **amplitude** value interval on a {@link PolarChart}.
             *
             * The Amplitude Axis is depicted as a single line segment starting from the very center of the PolarChart and ending at its right side.
             *
             * The Amplitude Axes' tick grid lines travel all over the PolarCharts Series space, doing a full 360 degree until returning to the other end of the tick, along the Amplitude Axis.
             *
             * The Amplitude Axes' title is positioned just below the Axis line and centered horizontally.
             *
             * Here is a list of the most commonly useful methods of Polar Amplitude Axis:
             * - {@link PolarAxisAmplitude.setTitle}            | Set title label.
             * - {@link PolarAxisAmplitude.setInterval}         | Set amplitude interval (start, end).
             * - {@link PolarAxisAmplitude.setScrollStrategy}   | Specify basis of automatic scrolling based on attached Series.
             * - {@link PolarAxisAmplitude.setStrokeStyle}      | Set style of Axis line.
             * - {@link PolarAxisAmplitude.setTickStrategy}     | Set style and creation basis of Axis ticks.
             * @public
             */
            export declare class PolarAxisAmplitude extends PolarAxis {
                /**
                 * Used in phase 1: after we know what ticks will be displayed, formulate generic information for chart layout calculations (e.g. XY layout for XY charts).
                 */
                protected _getAbstractUpdateResult(input: _GenericAxisInput, ticksInfo: Map<PolarAxisTick, _GenericTickInfo>, updatedTicks: boolean): _UpdateOutputAxisPolar;
            }
            /**
             * Axis object that represents a {@link PolarChart}s *radial* dimension,
             * which is depicted as an angle on the Charts center.
             *
             *
             * Class that represents the **radial** value interval on a {@link PolarChart}.
             *
             * The Radial Axis is depicted as a continuous line traversing all the way along the outer edge of the PolarChart.
             *
             * The Radial Axes' ticks are positioned along this line, with the gridlines slicing the PolarChart into equally sized slices.
             *
             * The Radial Axes' title is positioned next to the charts right side, next to where the {@link PolarAxisAmplitude} ends.
             *
             * Here is a list of the most commonly useful methods of Polar Radial Axis:
             * - {@link PolarAxisRadial.setTitle}                   | Set title label.
             * - {@link PolarAxisRadial.setStrokeStyle}             | Set style of Axis line.
             * - {@link PolarAxisRadial.setTickStyle}               | Set style of Axis ticks.
             * - {@link PolarAxisRadial.setDivision}                | Set amount of sections of PolarChart (also amount of Radial ticks).
             * - {@link PolarAxisRadial.setClockwise}               | Set direction of radial progression. Default = Counter Clock-Wise.
             * - {@link PolarAxisRadial.setNorth}                   | Set rotation of Radial Axis.
             * - {@link PolarAxisRadial.setTickFormattingFunction}  | Set formatting of Axis ticks.
             * @public
             */
            export declare interface PolarAxisRadial extends StylableAxisLine, StylableAxisTitle {
                /**
                 * Set style of Axis *ticks*.
                 *
                 * **Example usage:**
                 *
                 * - Modify default style (assuming its type as {@link TickStyle})
                 *
                 * ```ts
                 *  PolarAxisRadial.setTickStyle( ( ticks: TickStyle ) => ticks
                 *      .setLabelFillStyle( new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }) )
                 *  )
                 *
                 * ```
                 *
                 * - Pass a completely custom created TickStyle object
                 *
                 * ```ts
                 *  PolarAxisRadial.setTickStyle( new TickStyle({
                 *      labelFillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
                 *  }) )
                 * ```
                 *
                 * @param value - Either a {@link TickStyle} object or a function, which will be used to modify previous style.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
                /**
                 * Get style of Axis *ticks*.
                 * @returns TickStyle object.
                 * @public
                 */
                getTickStyle(): TickStyle;
                /**
                 * Set whether PolarAxisRadial direction is clockwise or counterclockwise.
                 *
                 * Defaults to counterclockwise (false).
                 * @param clockwise - True for clockwise direction, False for counterclockwise.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setClockwise(clockwise: boolean): this;
                /**
                 * Get whether PolarAxisRadial is clockwise or counterclockwise.
                 * @returns True for clockwise direction, False for counterclockwise.
                 * @public
                 */
                getClockwise(): boolean;
                /**
                 * Set rotation of Radial Axis by specifying degree angle that is depicted at *North* position (horizontally centered, vertically highest).
                 *
                 * Example usage:
                 * ```typescript
                 *  // Rotate Radial Axis so that 0 degrees is shown at North position.
                 *  PolarAxisRadial.setNorth(0)
                 * ```
                 * @param angle - Angle as *degrees* that will be depicted at *North* position. Defaults to 90.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setNorth(angle: number): this;
                /**
                 * Get rotation of Radial Axis as degree angle that is depicted at *North* position (horizontally centered, vertically highest).
                 * @returns Angle as *degrees* that is depicted at *North* position. Defaults to 90.
                 * @public
                 */
                getNorth(angle: number): number;
                /**
                 * Set Axis tick formatting function. This defines text displayed by each tick.
                 *
                 * Formatting function receives `value` as RADIAN angle, not degrees.
                 *
                 * @param formattingFunction - {@link FormattingFunction}.
                 * @returns Object itself for fluent interface.
                 * @public
                 */
                setTickFormattingFunction(formattingFunction: FormattingFunction): this;
                /**
                 * Get Axis tick formatting function. This defines text displayed by each tick.
                 * @returns {@link FormattingFunction}
                     * @public
                     */
                 getTickFormattingFunction(): FormattingFunction;
                 /**
                  * Set how many sections the Radial Axis is divided into by Ticks.
                  * @param sectionsCount - Amount of sections.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setDivision(sectionsCount: number): this;
                 /**
                  * Get how many sections the Radial Axis is divided into by Ticks.
                  * @returns Amount of sections.
                  * @public
                  */
                 getDivision(): number;
                 /**
                  * @returns Padding after axis ticks.
                  * @public
                  */
                 getMarginAfterTicks(): number;
                 /**
                  * Specifies Padding after axis ticks.
                  * @param margin - Gap after axis ticks
                  * @returns Axis itself for fluent interface
                  * @public
                  */
                 setMarginAfterTicks(margin: number): this;
                }
                /**
                 * @public
                 */
                declare interface PolarAxisStrategy extends AbstractAxisStrategy {
                }
                /**
                 * Implementation of Polar Axis Tick.
                 * @public
                 */
                export declare class PolarAxisTick extends _AbstractAxisTick {
                }
                /**
                 * Chart for visualizing data in a *Polar coordinate system* ( **angle** + **amplitude** ).
                 * It has a multitude of methods for adding various types of Series. For example:
                 * - {@link PolarChart.addPointLineSeries}
                 * - {@link PolarChart.addAreaSeries}
                 * - {@link PolarChart.addPolygonSeries}
                 * - {@link PolarChart.addHeatmapSeries}
                 * - {@link PolarChart.addSector}
                 *
                 * *PolarCharts* *Axes* can be styled similarly as those of {@link ChartXY}.
                 * Refer to them via methods:
                 * - {@link PolarChart.getAmplitudeAxis}
                 * - {@link PolarChart.getRadialAxis}
                 *
                 * *Charts* are created by methods of {@link LightningChart} interface or a {@link Dashboard}.
                 * @public
                 */
                export declare class PolarChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithSeries<PolarSeries> implements ChartWithAxis<PolarAxis>, ChartWithCursor<CursorResultTableBackgroundType, CursorPosition2D, Cursor2D<CursorResultTableBackgroundType>, SolveResultPolar> {
                    /**
                     * Selector for "client" _Coordinate System_.
                     *
                     * This references the coordinate system used in HTML.
                     * It starts at top left of the web page and is measured in pixels.
                     * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
                     *
                     * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
                     *
                     * This selector can be used for translating client coordinates to other coordinate systems and vice versa.
                     * For example, in order to:
                     * - Position LCJS UI elements in client coordinates
                     * - Find client coordinate that matches a location along LCJS Axis or Chart.
                     * - etc.
                     *
                     * See {@link translateCoordinate} for more detailed use case information and example usage.
                     *
                     * @public
                     */
                    readonly coordsClient: CoordinateSystemClient;
                    /**
                     * Selector for Polar Axis Coordinate System, measured in angles and amplitudes.
                     *
                     * This selector can be used for translating Polar coordinates to other coordinate systems and vice versa.
                     * For example, in order to:
                     * - Position LCJS UI elements in Polar coordinates
                     * - Find client coordinate that matches a location at Polar amplitude & angle
                     * - Translating user click event location to a Polar amplitude & angle.
                     * - etc.
                     *
                     * See {@link translateCoordinate} for more detailed use case information and example usage.
                     *
                     * @public
                     */
                    readonly coordsAxis: CoordinateSystemPolar;
                    /**
                     * Get series of a chart
                     * @returns Array of series
                     * @public
                     */
                    getSeries(): PolarSeries[];
                    setCursor(mutator: Mutator<Cursor2D<CursorResultTableBackgroundType>>): this;
                    getCursor(): Cursor2D<CursorResultTableBackgroundType>;
                    setCursorMode(mode: SolveNearestMode | undefined): this;
                    getCursorMode(): SolveNearestMode | undefined;
                    setCustomCursor(clbk: undefined | ((event: CursorTargetChangedEvent<SolveResultPolar>) => unknown)): this;
                    setCursorDynamicBehavior(value: CursorDynamicBehavior): this;
                    /**
                     * Set cursor formatting, controlling the text displayed in built-in cursor.
                     *
                     * ```ts
                     *  chart.setCursorFormatting((_, hit, hits) => {
                     *      return [
                     *          ['Cursor pointing at'],
                     *          [hit.series], // returning a series will display the series color and its name automatically.
                     *          ['X', '', hit.axisX.formatValue(hit.x)], // utilizing axis formatValue is useful for considering active zoom level and type of axis
                     *          ['Y', '', hit.y.toFixed(2)], // empty string '' results in gap between cells
                     *          [{ text: 'Example', font: { weight: 'bold' }, fillStyle: fillRed }] // any cell can also be styled individually
                     *      ]
                     *  })
                     * ```
                     *
                     * Before overriding default cursor formatting, it is recommended to check if using {@link GenericAxis.setUnits} or configuring Axis cursor formatting would be enough.
                     *
                     * In order to use series specific data properties (e.g. Heatmap sample "intensity"),
                     * you should use type guards to assert the type of the `SolveResult`:
                     *
                     * ```ts
                     *  // Example of using type guard in cursor formatter
                     *  Chart.setCursorFormatting((chart, hit, hits) => {
                     *      if (!isHitHeatmap(hit)) return undefined
                     *      return [hit.intensity.toFixed(1)]
                     *  })
                     * ```
                     *
                     * More details in Developer documentation (Features \> Cursor).
                     * @param   formatter -     Callback function for cursor formatting.
                     * @returns     Object itself
                     * @public
                     */
                    setCursorFormatting(formatter: CursorFormatterPolarChart): this;
                    /**
                     * Get active cursor formatter.
                     * @returns     Cursor formatter.
                     * @public
                     */
                    getCursorFormatting(): CursorFormatterPolarChart;
                    /**
                     * Method for solving the nearest data point from all existing series relative to a given coordinate on screen.
                     * @param   from -  Reference coordinate on web page as client coordinates. This can for example be directly an `Event` object. `undefined` results in using last registered mouse location.
                     * @param   solveMode -     Optional control for solve nearest behavior
                     * @returns     SolveResult object.
                     * @public
                     */
                    solveNearest(from?: CoordinateClient, solveMode?: SolveNearestMode): SolveResultPolar[];
                    /**
                     * Add manually controlled Cursor object.
                     * These have exactly same functions as built-in cursors but they can be freely controlled by application logic.
                     *
                     * ```ts
                     *  const cursor = chart.addCursor()
                     * ```
                     *
                     * Styling works same as built-in cursors (e.g. {@link setCursor}).
                     *
                     * Position is set using `setPosition` method and displayed content using `setResultTable(table => table.setContent(...))`
                     * For more details, see Developer documentation \> Features \> Cursor \> Manual cursors
                     *
                     * @param   cursorBuilder -     Builder for cursor. Can be used to tweak a handful of properties which can't be changed during runtime.
                     * @returns     Cursor object.
                     * @public
                     */
                    addCursor<ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: CursorBuilder2D<ResultTableBackgroundType>): Cursor2D<ResultTableBackgroundType>;
                    /**
                     * Translate a coordinate to another coordinate system.
                     *
                     * Supports following coordinate systems:
                     *
                     * - HTML client coordinates ({@link CoordinateSystemClient | more information}).
                     * - Relative control coordinates ({@link CoordinateSystemRelative | more information}).
                     * - Polar Axis coordinates ({@link CoordinateSystemPolar | more information}).
                     *
                     * Most common example use cases:
                     *
                     * **(1) Translate a coordinate from HTML client coordinates to Polar axes**
                     *
                     * ```ts
                     *  PolarChart.onSeriesBackgroundMouseClick((_, event) => {
                     *      const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
                     *      // locationAxis tells the clicked location along Axis interval (in same value range as data points).
                     *  })
                     * ```
                     *
                     * **(2) Translate a coordinate from Polar axes to HTML client coordinates**
                     *
                     * ```ts
                     *  const locationAxis = { angle: 45, amplitude: 5 }
                     *  const locationClient = chart.translateCoordinate(locationAxis, chart.coordsClient)
                     * ```
                     *
                     * Client coordinates can be used to absolute position HTML elements using CSS, for example.
                     *
                     * ```ts
                     *  myHTMLElement.style.position = 'absolute'
                     *  myHTMLElement.style.left = locationClient.clientX
                     *  myHTMLElement.style.top = locationClient.clientY
                     * ```
                     *
                     * **(3) Translate a coordinate from Polar axes to relative coordinates**
                     *
                     * ```ts
                     *  const locationAxis = { angle: 45, amplitude: 5 }
                     *  const locationRelative = chart.translateCoordinate(locationAxis, chart.coordsRelative)
                     * ```
                     *
                     * Relative coordinates can be used for positioning LightningChart JS UI components:
                     *
                     * ```ts
                     *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
                     *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
                     *      .setOrigin(UIOrigins.LeftBottom)
                     *      .setPosition({ x: 20, y: 20 })
                     * ```
                     *
                     * **(4) Translate a coordinate from relative chart coordinates to axes**
                     *
                     *
                     * ```ts
                     *  const locationRelative = { x: 0, y: 0 }
                     *  const locationAxis = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsAxis)
                     * ```
                     *
                     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                     *
                     * ```ts
                     *  LineSeries.add(myData)
                     *  requestAnimationFrame(() => {
                     *      // translateCoordinate should now consider data added just now.
                     *  })
                     * ```
                     *
                     * @public
                     */
                    translateCoordinate<T extends CoordinateSystemClient | CoordinateSystemPolar | CoordinateSystemRelative>(coordinate: CoordinateClient | CoordinatePolar | CoordinateXY, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : T extends CoordinateSystemPolar ? CoordinatePolar : T extends CoordinateSystemRelative ? CoordinateXY : never;
                    /**
                     * Translate a coordinate from relative control coordinates to another coordinate system.
                     *
                     * This coordinate system is relative to the bottom left corner of the Control (chart/dashboard/etc.), and is measured as pixels.
                     * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from bottom.
                     *
                     * **(1) Polar axis coordinate system:**
                     *
                     * ```ts
                     *  const locationRelative = { x: 100, y: 200 }
                     *  const locationAxis = polarChart.translateCoordinate(locationRelative, polarChart.coordsRelative, polarChart.coordsAxis)
                     * ```
                     *
                     * Polar axis locations can be used for example with different Polar Series, like {@link PolarPointSeries}.
                     *
                     * **(2) HTML client coordinate system**
                     *
                     * ```ts
                     *  const locationRelative = { x: 100, y: 200 }
                     *  const locationClient = polarChart.translateCoordinate(locationRelative, polarChart.coordsRelative, polarChart.client)
                     * ```
                     *
                     * Client coordinates can be used to absolute position HTML elements using CSS, for example.
                     *
                     * ```ts
                     *  myHTMLElement.style.position = 'absolute'
                     *  myHTMLElement.style.left = locationClient.clientX
                     *  myHTMLElement.style.top = locationClient.clientY
                     * ```
                     *
                     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                     *
                     * ```ts
                     *  LineSeries.add(myData)
                     *  requestAnimationFrame(() => {
                     *      // translateCoordinate should now consider data added just now.
                     *  })
                     * ```
                     *
                     * @public
                     */
                    translateCoordinate<T extends CoordinateSystemClient | CoordinateSystemPolar>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : T extends CoordinateSystemPolar ? CoordinatePolar : never;
                    /**
                     * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
                     *
                     * ```ts
                     *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
                     *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
                     *  // locationRelative is in pixels relative to bottom left corner of the chart
                     * ```
                     *
                     * Relative coordinates can be used for positioning LightningChart JS UI components:
                     *
                     * ```ts
                     *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
                     *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
                     *      .setOrigin(UIOrigins.LeftBottom)
                     *      .setPosition({ x: 20, y: 20 })
                     * ```
                     *
                     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                     *
                     * ```ts
                     *  LineSeries.add(myData)
                     *  requestAnimationFrame(() => {
                     *      // translateCoordinate should now consider data added just now.
                     *  })
                     * ```
                     *
                     * @public
                     * @privateRemarks  This definition of the method originates from the super class.
                     */
                    translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
                    /**
                     * Translate a coordinate from relative control coordinates to HTML client coordinate system.
                     *
                     * ```ts
                     *  // 10 pixels left and 20 pixels up from controls bottom left corner
                     *  const locationRelative = { x: 10, y: 20 }
                     *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
                     * ```
                     *
                     * Client coordinates can be used to absolute position HTML elements using CSS, for example.
                     *
                     * ```ts
                     *  myHTMLElement.style.position = 'absolute'
                     *  myHTMLElement.style.left = locationClient.clientX
                     *  myHTMLElement.style.top = locationClient.clientY
                     * ```
                     *
                     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                     *
                     * ```ts
                     *  LineSeries.add(myData)
                     *  requestAnimationFrame(() => {
                     *      // translateCoordinate should now consider data added just now.
                     *  })
                     * ```
                     *
                     * @public
                     * @privateRemarks  This definition of the method originates from the super class.
                     */
                    translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
                    /**
                     * Add a Line series to the PolarChart.
                     *
                     * {@link PolarLineSeries} are used to render a list of {@link PolarPoint}s
                     * by a continuous line that can be styled arbitrarily.
                     *
                     * **Example usage:**
                     *
                     * ```ts
                     *  const lineSeries = polarChart.addLineSeries().setData(
                     *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                     *          angle: i,
                     *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                     *      }))
                     *  )
                     * ```
                     * @returns {@link PolarLineSeries}.
                         * @public
                         */
                     addLineSeries(options?: SeriesOptions): PolarLineSeries;
                     /**
                      * Add a Point series to the PolarChart.
                      *
                      * {@link PolarPointSeries} are used to render a list of {@link PolarPoint}s
                      * by different shapes.
                      *
                      * **Example usage:**
                      *
                      * ```ts
                      *  const pointSeries = polarChart.addPointSeries().setData(
                      *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                      *          angle: i,
                      *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                      *      }))
                      *  )
                      * ```
                      * @returns {@link PolarPointSeries}.
                          * @public
                          */
                      addPointSeries(options?: SeriesOptions): PolarPointSeries;
                      /**
                       * Add a Point Line series to the PolarChart.
                       *
                       * {@link PolarPointLineSeries} are used to render a list of {@link PolarPoint}s
                       * by a continuous line drawn between the points plus configurable shapes over each data point.
                       *
                       * **Example usage:**
                       *
                       * ```ts
                       *  const pointLineSeries = polarChart.addPointLineSeries().setData(
                       *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                       *          angle: i,
                       *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                       *      }))
                       *  )
                       * ```
                       * @returns {@link PolarPointLineSeries}.
                           * @public
                           */
                       addPointLineSeries(options?: SeriesOptions): PolarPointLineSeries;
                       /**
                        * Add a Area series to the PolarChart.
                        *
                        * {@link PolarAreaSeries} are used to render a list of {@link PolarPoint}s
                        * by filling the enclosed area.
                        *
                        * **Example usage:**
                        *
                        * - *Plot sub section (\< 360 degrees) of the Polar Chart*
                        * ```ts
                        *  const areaSeries = polarChart.addAreaSeries()
                        *      .setData(
                        *          new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                        *              angle: i,
                        *              amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                        *          }))
                        *      )
                        * ```
                        *
                        * - *Plot a fully connected (360 degrees) section of the Polar Chart*
                        * ```ts
                        *  const areaSeries = polarChart.addAreaSeries()
                        *      .setConnectDataAutomaticallyEnabled(true)
                        *      .setData(
                        *          new Array(360).fill(0).map((_, i) => ({
                        *              angle: i,
                        *              amplitude: 60 + 25 * Math.cos((5 * i * Math.PI) / 180),
                        *          })),
                        *      )
                        * ```
                        * @returns {@link PolarAreaSeries}.
                            * @public
                            */
                        addAreaSeries(options?: SeriesOptions): PolarAreaSeriesInterior;
                        /**
                         * Add a Polygon series to the PolarChart.
                         *
                         * {@link PolarPolygonSeries} are used to render a collection of *polygons* inside the Polar coordinate system. They are especially useful for highlighting parts of the Polar coordinate system.
                         *
                         * **Example usage:**
                         *
                         * ```ts
                         *  const polygonSeries = polarChart.addPolygonSeries()
                         *  let ang = 45
                         *  let amplitude = 50
                         *  const polygon = polygonSeries.addPolygon()
                         *      .setGeometry([
                         *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                         *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                         *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                         *          { angle: (ang += 10), amplitude: (amplitude -= 5) },
                         *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                         *          { angle: (ang += 5), amplitude: (amplitude -= 5) },
                         *          { angle: (ang += 0), amplitude: (amplitude -= 10) },
                         *          { angle: (ang -= 5), amplitude: (amplitude -= 5) },
                         *          { angle: (ang -= 10), amplitude: (amplitude -= 10) },
                         *          { angle: (ang -= 10), amplitude: (amplitude -= 5) },
                         *          { angle: (ang -= 10), amplitude: (amplitude += 5) },
                         *          { angle: (ang -= 10), amplitude: (amplitude += 10) },
                         *      ])
                         * ```
                         * @returns {@link PolarPolygonSeries}.
                             * @public
                             */
                         addPolygonSeries(options?: SeriesOptions): PolarPolygonSeries;
                         /**
                          * Add a Series for visualizing a *Polar Heatmap* with a static sector and annuli count. Has API for fast modification of cell values.
                          *
                          * `PolarHeatmapSeries` is optimized for high resolution data. For example, 1 degree precision or less along Radial Axis, and up to 2000 samples along Amplitude Axis.
                          *
                          * To learn more about its features and usage, refer to {@link PolarHeatmapSeries}.
                          *
                          * **Readonly configuration:**
                          *
                          * Some properties of `PolarHeatmapSeries` can only be configured when it is created. Some of these arguments are **mandatory**, while some are optional.
                          * They are wrapped in a single object parameter:
                          *
                          * ```js
                          *  // Example,
                          *  const series = PolarChart.addHeatmapSeries({
                          *      sectors: 360,
                          *      annuli: 100
                          *  })
                          * ```
                          *
                          * To learn about available properties, refer to {@link PolarHeatmapSeriesOptions}.
                          *
                          * Each cell of the heatmap is associated with a *numeric intensity value*, which can be used together with a
                          * Color look up table ({@link LUT}).
                          *
                          * @param options - Configuration parameters for Polar Heatmap Series.
                          * @returns Polar Heatmap Series.
                          * @public
                          */
                         addHeatmapSeries(options: PolarHeatmapSeriesOptions): PolarHeatmapSeries;
                         /**
                          * Add a Sector highlighter to the PolarChart.
                          *
                          * {@link PolarSector}s can be used to highlight areas in the *polar coordinate system*.
                          * @param legendOptions - Configuration parameters for the legend entry. If `null`, no legend entry will be created.
                          * @returns {@link PolarSector}.
                              * @public
                              */
                          addSector(legendOptions?: LegendEntryOptions | null): PolarSector;
                          /**
                           * Get {@link PolarAxisAmplitude} object that represents the PolarCharts *amplitude* dimension,
                           * which is depicted as a distance away from the Charts center.
                           * @returns {@link PolarAxisAmplitude}.
                               * @public
                               */
                           getAmplitudeAxis(): PolarAxisAmplitude;
                           /**
                            * Convenience getter property that does the same as {@link getAmplitudeAxis}.
                            * @public
                            */
                           get amplitudeAxis(): PolarAxisAmplitude;
                           /**
                            * Convenience getter property that does the same as {@link getAmplitudeAxis}.
                            * @public
                            */
                           get axisAmplitude(): PolarAxisAmplitude;
                           /**
                            * Get {@link PolarAxisRadial} object that represents the PolarCharts *radial* dimension,
                            * which is depicted as an angle on the Charts center.
                            * @returns {@link PolarAxisRadial}.
                                * @public
                                */
                            getRadialAxis(): PolarAxisRadial;
                            /**
                             * Convenience getter property that does the same as {@link getRadialAxis}.
                             * @public
                             */
                            get radialAxis(): PolarAxisRadial;
                            /**
                             * Convenience getter property that does the same as {@link getRadialAxis}.
                             * @public
                             */
                            get axisRadial(): PolarAxisRadial;
                            /**
                             * Disable/enable all animations for the chart.
                             * @param animationsEnabled - Boolean value to enable/disable animations.
                             * @returns Chart itself for fluent interface.
                             * @public
                             * @privateRemarks  Override to also apply to axes.
                             */
                            setAnimationsEnabled(animationsEnabled: boolean): this;
                            /**
                             * Get minimum size of Panel.
                             * Depending on the type of class this value might be automatically computed to fit different elements.
                             * @returns Vec2 minimum size or undefined if unimplemented
                             * @public
                             */
                            getMinimumSize(): Point | undefined;
                            /**
                             * Iterate over each Axis of Chart.
                             * @param clbk - Callback function for each Axis.
                             * @public
                             */
                            forEachAxis(clbk: (axis: PolarAxis) => void): this;
                            /**
                             * **Permanently** destroy the component.
                             *
                             * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                             * **to the component and its children** in application code.
                             * ```javascript
                             * let chart = ...ChartXY()
                             * let axisX = chart.getDefaultAxisX()
                             * // Dispose Chart, and remove all references so that they can be garbage-collected.
                             * chart.dispose()
                             * chart = undefined
                             * axisX = undefined
                             * ```
                             * @returns Object itself for fluent interface
                             * @public
                             */
                            dispose(): this;
                            addEventListener<K extends keyof PolarChartEventMap>(type: K, listener: (event: PolarChartEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                            removeEventListener<K extends keyof PolarChartEventMap>(type: K, listener: (event: PolarChartEventMap[K], info: unknown) => unknown): void;
                           }
                           /**
                            * Interface of events trackable by {@link PolarChart.addEventListener} and the respective Event types.
                            * @public
                            */
                           export declare interface PolarChartEventMap extends ChartWithSeriesEventMap<PolarSeries>, ChartWithCursorEventMap<SolveResultPolar> {
                           }
                           /**
                            * Interface for readonly configuration of {@link PolarChart}.
                            *
                            * Some properties of `PolarChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
                            *
                            * ```typescript
                            *  // Example, create chart with specified color theme.
                            *  const chart = LightningChart.Polar({
                            *      theme: Themes.light,
                            *  })
                            * ```
                            *
                            * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
                            *
                            * For *standalone* `PolarChart`, more parameters are documented in {@link LightningChart.Polar}.
                            *
                            * For *dashboard* `PolarChart`, more parameters are documented in {@link Dashboard.createPolarChart}.
                            *
                            *
                            * **Commonly used properties:**
                            *
                            * - {@link PolarChartOptions.theme}: Specify chart color *theme*.
                            * - {@link PolarChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
                            *
                            * **Example usage:**
                            *
                            * ```typescript
                            *  // Example 1, create chart with default configuration.
                            *  const chart = LightningChart.Polar({})
                            * ```
                            *
                            * ```typescript
                            *  // Example 2, create chart with specified color theme.
                            *  const chart = LightningChart.Polar({
                            *      theme: Themes.light,
                            *  })
                            * ```
                            * @public
                            */
                           export declare interface PolarChartOptions<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
                               /**
                                * Builder for the charts' *auto cursor*. Use {@link CursorBuilders | CursorBuilders.Polar} to modify the default builder, using methods of {@link Cursor2DBuilder}.
                                *
                                * ```typescript
                                *  // Example, change cursor ResultTable background shape.
                                *  const chart = LightningChart.Polar({
                                *      cursorBuilder: CursorBuilders.Polar
                                *          .setResultTableBackground(UIBackgrounds.Circle)
                                *  })
                                * ```
                                * @public
                                */
                               cursorBuilder?: CursorBuilder2D<CursorResultTableBackgroundType>;
                           }
                           /**
                            * Series for visualizing a *Polar Heatmap* with a static sector and annuli count. Has API for fast modification of cell values.
                            *
                            * `PolarHeatmapSeries` is optimized for high resolution data. For example, 1 degree precision or less along Radial Axis, and up to more than 2000 samples along Amplitude Axis.
                            * There is no hard cap on how much data you can put into a polar heatmap, the limit is the running device's GPU memory.
                            * Generally several million data points are no problem.
                            *
                            * Created with {@link PolarChart.addHeatmapSeries}.
                            *
                            * Frequently used API:
                            * - Set intensity data {@link invalidateIntensityValues}
                            * - Set fill style {@link setFillStyle}
                            * - Set intensity interpolation {@link setIntensityInterpolation}
                            * - Format auto cursor {@link setCursorResultTableFormatter}
                            * @public
                            */
                           export declare class PolarHeatmapSeries extends PolarSeries<SolveResultPolarHeatmap> {
                               solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultPolarHeatmap | undefined;
                               /**
                                * Invalidate range of heatmap intensity values starting from first sector and annulus, updating coloring if a Color look up table ({@link LUT}) has been attached to the series (see {@link setFillStyle}).
                                *
                                * ```js
                                *  // Example, 3x3 grid full invalidation.
                                *  const heatmapSeries = PolarChart.addHeatmapSeries({
                                *      sectors: 3,
                                *      annuli: 3
                                *  })
                                *
                                *  heatmapSeries.invalidateIntensityValues([
                                *      // Annulus 0 intensity values.
                                *      [0, 0, 0],
                                *      // Annulus 1 intensity values.
                                *      [1, 1, 1],
                                *      // Annulus 2 intensity values.
                                *      [0, 2, 0],
                                *  ])
                                * ```
                                *
                                * Data interpretation basis is defined by {@link PolarHeatmapSeriesOptions.dataOrder} property from when the series was created.
                                *
                                * `invalidateIntensityValues` can trigger warnings when used controversially.
                                * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                *
                                * @param value - Matrix containing intensity values for each data slot of the grid.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               invalidateIntensityValues(value: number[][]): this;
                               /**
                                * Invalidate a partial range of heatmap intensity values, updating coloring if a Color look up table ({@link LUT}) has been attached to the series (see {@link setFillStyle}).
                                *
                                * ```js
                                *  // Example, 100x10 grid invalidate partial section of grid.
                                *
                                *  const heatmapSeries = PolarChart.addHeatmapSeries({
                                *      sectors: 100,
                                *      annuli: 10
                                *  })
                                *
                                *  heatmapSeries.invalidateIntensityValues({
                                *      // Index of first invalidated annulus.
                                *      iAnnulus: 5,
                                *      // Index of first invalidated sector.
                                *      iSector: 10,
                                *      // Intensity values matrix. It's dimensions imply the amount of invalidated sectors and annuli.
                                *      values: [
                                *          // 1st invalidated annuli intensity values.
                                *          [1, 1, 1, 1, 1],
                                *          // 2nd invalidated annuli intensity values.
                                *          [2, 2, 2, 2, 2],
                                *          // 3rd invalidated annuli intensity values.
                                *          [1, 0, 0, 0, 1],
                                *          // 4th invalidated annuli intensity values.
                                *          [0, 1, 0, 1, 0],
                                *          // 5th invalidated annuli intensity values.
                                *          [0, 0, 1, 0, 0],
                                *      ],
                                *  })
                                * ```
                                *
                                * `invalidateIntensityValues` can trigger warnings when used controversially.
                                * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                *
                                * @param value - Partial invalidation information, where `values` is an intensity value matrix, `iSector` the first affected sector and `iAnnulus` the first affected annulus.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               invalidateIntensityValues(value: {
                                   iSector: number;
                                   iAnnulus: number;
                                   values: number[][];
                               }): this;
                               /**
                                * Set fill style of heatmap series.
                                *
                                * **Supported fill styles:**
                                *
                                * {@link PalettedFill}:
                                *
                                * Colors heatmap fill by looking color up from {@link LUT} based on heatmap *intensity values*.
                                *
                                * ```js
                                *  // Example, color look up by intensity values.
                                *  heatmapSeries.setFillStyle(
                                *      new PalettedFill({
                                *          lut: new LUT({
                                *              steps: [
                                *                  { value: 0, color: ColorCSS('red') },
                                *                  { value: 20, color: ColorCSS('blue') },
                                *              ],
                                *              interpolate: true,
                                *          }),
                                *      }),
                                *  )
                                * ```
                                *
                                * Assign *intensity values* with {@link invalidateIntensityValues}.
                                *
                                * {@link SolidFill}:
                                *
                                * Solid color for all heatmap cells. Supported for debugging purposes mainly.
                                *
                                * {@link emptyFill}:
                                *
                                * Disables heatmap fill.
                                *
                                * ```js
                                *  // Example, hide heatmap fill.
                                *  heatmapSeries
                                *      .setFillStyle(emptyFill)
                                * ```
                                *
                                * @param value - FillStyle object or function which modifies current value.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                               /**
                                * Get fill style of series.
                                * @returns FillStyle.
                                * @public
                                */
                               getFillStyle(): FillStyle;
                               /**
                                * Clear all previous data pushed to the series.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               clear(): this;
                               /**
                                * Set heatmap intensity interpolation mode.
                                *
                                * `'disabled'` or `undefined`: Interpolation disabled; draw data exactly as it is.
                                *
                                * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
                                *
                                * @param interpolationMode - Heatmap intensity interpolation mode selection.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               setIntensityInterpolation(interpolationMode: IntensityInterpolationMode | undefined): this;
                               /**
                                * Get heatmap intensity interpolation mode.
                                * @returns Heatmap intensity interpolation mode selection.
                                * @public
                                */
                               getIntensityInterpolation(): IntensityInterpolationMode;
                               addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolarHeatmap) => unknown, options?: LCJSAddEventListenerOptions): void;
                               removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolarHeatmap) => unknown): void;
                           }
                           /**
                            * Interface describing readonly configurations of a {@link PolarHeatmapSeries}.
                            *
                            * **Required properties:**
                            * - {@link sectors}
                            * - {@link annuli}
                            *
                            * **Optional properties:**
                            * - {@link amplitudeStart}
                            * - {@link amplitudeStep}
                            * - {@link amplitudeEnd}
                            * - {@link dataOrder}
                            * @public
                            */
                           export declare interface PolarHeatmapSeriesOptions {
                               /**
                                * Amount of unique data samples along Radial Axis.
                                *
                                * There is no hard cap on how much data you can put into a polar heatmap, the limit is the running device's GPU memory.
                                * Generally several million data points are no problem.
                                */
                               sectors: number;
                               /**
                                * Amount of unique data samples along Amplitude Axis.
                                *
                                * There is no hard cap on how much data you can put into a polar heatmap, the limit is the running device's GPU memory.
                                * Generally several million data points are no problem.
                                */
                               annuli: number;
                               /**
                                * Amplitude value where Polar Heatmap originates at.
                                *
                                * Defaults to `0`.
                                */
                               amplitudeStart?: number;
                               /**
                                * Amplitude step between each ring (`annuli`) of the Polar Heatmap.
                                *
                                * Defaults to `0`.
                                */
                               amplitudeStep?: number;
                               /**
                                * Amplitude value where Polar Heatmap ends at.
                                *
                                * If both are defined, `amplitudeEnd` has priority over `amplitudeStep`.
                                */
                               amplitudeEnd?: number;
                               /**
                                * Select order of data.
                                *
                                * Determines whether new data is processed as list of "sectors" or "annuli".
                                *
                                * `'annuli'` -\> Supply lists of "annuli"
                                *
                                * ```typescript
                                *  const intensityValues = [
                                *      [
                                *          0, // 1st ring counting from inner most, sector (starting at 0 deg, rotating counter clockwise) = 0
                                *          0, // 1st ring counting from inner most, sector (starting at 0 deg, rotating counter clockwise) = 1
                                *          0, // 1st ring counting from inner most, sector (starting at 0 deg, rotating counter clockwise) = n
                                *      ],
                                *      [
                                *          0, // 2nd ring counting from inner most, sector (starting at 0 deg, rotating counter clockwise)
                                *          0, // 2nd ring counting from inner most, sector (starting at 0 deg, rotating counter clockwise)
                                *          0, // 2nd ring counting from inner most, sector (starting at 0 deg, rotating counter clockwise)
                                *      ],
                                *  ]
                                * ```
                                *
                                * `'sectors'` -\> Supply lists of "sectors"
                                *
                                * ```typescript
                                *  const intensityValues = [
                                *      [
                                *          0, // 1st ring counting from inner most, sector 0 (starting at 0 deg, rotating counter clockwise)
                                *          0, // 2nd ring counting from inner most, sector 0 (starting at 0 deg, rotating counter clockwise)
                                *          0, // 3rd ring counting from inner most, sector 0 (starting at 0 deg, rotating counter clockwise)
                                *      ],
                                *      [
                                *          0, // 1st ring counting from inner most, sector 1 (starting at 0 deg, rotating counter clockwise)
                                *          0, // 2nd ring counting from inner most, sector 1 (starting at 0 deg, rotating counter clockwise)
                                *          0, // 3rd ring counting from inner most, sector 1 (starting at 0 deg, rotating counter clockwise)
                                *      ],
                                *  ]
                                * ```
                                *
                                * Defaults to `annuli`.
                                */
                               dataOrder?: 'annuli' | 'sectors';
                               /**
                                * Legend options for the series.
                                */
                               legend?: LegendEntryOptions;
                           }
                           /**
                            * Type of *PolarSeries* for visualizing a collection of {@link PolarPoint | PolarPoints} by connecting them with a line.
                            *
                            * *PolarLineSeries* are created with {@link PolarChart.addLineSeries}.
                            *
                            * Set data with {@link PolarLineSeries.setData}:
                            *
                            * ```ts
                            *  PolarSeries.setData(
                            *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                            *          angle: i,
                            *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                            *      }))
                            *  )
                            * ```
                            * @public
                            */
                           export declare class PolarLineSeries extends PolarSeries {
                               solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultPolar | undefined;
                               /**
                                * Set data for PolarSeries to render as a list of {@link PolarPoint}s.
                                * @param points - List of {@link PolarPoint}s.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               setData(points: PolarPoint[]): this;
                               /**
                                * Get user-supplied data points.
                                * @returns Array of {@link PolarPoint}s.
                                * @public
                                */
                               getData(): PolarPoint[];
                               /**
                                * Set stroke style of Series.
                                *
                                * Supported line styles:
                                * - {@link SolidLine}
                                * - {@link DashedLine}
                                * - {@link emptyLine}
                                *
                                * Example usage:
                                *```javascript
                                * // Specified LineStyle
                                * PolarLineSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                * // Changed thickness
                                * PolarLineSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
                                * // Hidden must be done with setVisible() method, emptyLine is not supported
                                * ```
                                * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
                                * @returns Chart itself
                                * @public
                                */
                               setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                               /**
                                * Get stroke style of Series.
                                * @returns LineStyle object
                                * @public
                                */
                               getStrokeStyle(): LineStyle;
                               /**
                                * Set automatic connection of first and last data points enabled or not.
                                *
                                * **Disabled by default.**
                                * @param enabled - Boolean.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               setConnectDataAutomaticallyEnabled(enabled: boolean): this;
                               /**
                                * Get automatic connection of first and last data points enabled or not.
                                * @returns Boolean.
                                * @public
                                */
                               getConnectDataAutomaticallyEnabled(): boolean;
                               addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolar) => unknown, options?: LCJSAddEventListenerOptions): void;
                               removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolar) => unknown): void;
                           }
                           /**
                            * Interface that can be used to define {@link PolarChart} configurations, when inside a  {@link Dashboard},
                            * that can't be changed after creation.
                            *
                            *  Example usage:
                            *```javascript
                            * // Specified Cursor ResultTable Background
                            * { polarChartOptions: { cursorBuilder: CursorBuilders.Polar.setResultTableBackground(UIBackgrounds.Circle) } }
                            * ```
                            * @public
                            */
                           export declare interface PolarOptions<CursorResultTableBackgroundType extends UIBackground> extends DashboardCellOptions, PolarChartOptions<CursorResultTableBackgroundType> {
                           }
                           /**
                            * Data-structure for describing a point in a Polar coordinate system.
                            *
                            * Used with {@link PolarChart} and *Polar series*.
                            * @public
                            */
                           export declare interface PolarPoint {
                               /**
                                * Angle value in degrees [ 0, 360 ].
                                * @public
                                */
                               readonly angle: number;
                               /**
                                * Amplitude value.
                                * @public
                                */
                               readonly amplitude: number;
                               /**
                                * Optional point specific color.
                                *
                                * Usable with {@link PolarPointSeries} when styled with {@link IndividualPointFill}.
                                * @public
                                */
                               readonly color?: Color;
                           }
                           /**
                            * Type of *PolarSeries* for visualizing a collection of {@link PolarPoint | PolarPoints} by filling them with a specifiable {@link PointShape},
                            * as well as connecting them with a line.
                            *
                            * *PolarPointLineSeries* are created with {@link PolarChart.addPointLineSeries}.
                            *
                            * Set data with {@link PolarPointLineSeries.setData}:
                            *
                            * ```ts
                            *  PolarSeries.setData(
                            *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                            *          angle: i,
                            *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                            *      }))
                            *  )
                            * ```
                            * @public
                            */
                           export declare class PolarPointLineSeries extends PolarSeries {
                               solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultPolar | undefined;
                               /**
                                * Set data for `PolarPointSeries` to render as a list of {@link PolarPoint}s.
                                * @param points - List of {@link PolarPoint}s.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               setData(points: PolarPoint[]): this;
                               /**
                                * Get user-supplied data points.
                                * @returns Array of {@link PolarPoint}s.
                                * @public
                                */
                               getData(): PolarPoint[];
                               /**
                                * Set stroke style of Series.
                                *
                                * Supported line styles:
                                * - {@link SolidLine}
                                * - {@link DashedLine}
                                * - {@link emptyLine}
                                *
                                * Example usage:
                                *```javascript
                                * // Specified LineStyle
                                * PolarLineSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                * // Changed thickness
                                * PolarLineSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
                                * // Hidden must be done with setVisible() method, emptyLine is not supported
                                * ```
                                * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
                                * @returns Chart itself
                                * @public
                                */
                               setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                               /**
                                * Get stroke style of Series.
                                * @returns LineStyle object
                                * @public
                                */
                               getStrokeStyle(): LineStyle;
                               /**
                                * Set point fill style of Series.
                                *
                                * Example usage:
                                *```javascript
                                * // Create a new style
                                * PolarPointSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                * // Change transparency
                                * PolarPointSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
                                * // Set hidden
                                * PolarPointSeries.setPointFillStyle(emptyFill)
                                * // Individual point style (required for using 'color' properties in data points)
                                * PolarPointSeries.setPointFillStyle(new IndividualPointFill())
                                *
                                * ```
                                * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                                * @returns Series itself for fluent interface.
                                * @public
                                */
                               setPointFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                               /**
                                * Get normal points fill style.
                                * @returns Normal point fillStyle
                                * @public
                                */
                               getPointFillStyle(): FillStyle;
                               /**
                                * Set size of point in pixels.
                                * @param size - Size of point in pixels.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               setPointSize(size: number): this;
                               /**
                                * Get current size of points in pixels.
                                * @returns Size of point in pixels.
                                * @public
                                */
                               getPointSize(): number;
                               /**
                                * Set shape of points.
                                * @param shape - One of {@link PointShape} options.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               setPointShape(shape: PointShape): this;
                               /**
                                * Get shape of points.
                                * @returns PointShape
                                * @public
                                */
                               getPointShape(): PointShape;
                               /**
                                * Set the rotation of points in degrees.
                                * @param angle - Rotation angle in degrees
                                * @public
                                */
                               setPointRotation(angle: number): this;
                               /**
                                * Get the current rotation of points.
                                * @public
                                */
                               getPointRotation(): number;
                               /**
                                * Set automatic connection of first and last data points enabled or not.
                                *
                                * **Disabled by default.**
                                * @param enabled - Boolean.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               setConnectDataAutomaticallyEnabled(enabled: boolean): this;
                               /**
                                * Get automatic connection of first and last data points enabled or not.
                                * @returns Boolean.
                                * @public
                                */
                               getConnectDataAutomaticallyEnabled(): boolean;
                               addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolar) => unknown, options?: LCJSAddEventListenerOptions): void;
                               removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolar) => unknown): void;
                           }
                           /**
                            * Type of *PolarSeries* for visualizing a collection of {@link PolarPoint | PolarPoints} by filling them with a specifiable {@link PointShape}.
                            *
                            * *PointShape* can be configured with {@link PolarPointSeries.setPointShape}.
                            *
                            * *PolarPointSeries* are created with {@link PolarChart.addPointSeries}.
                            *
                            * Set data with {@link PolarPointSeries.setData}:
                            *
                            * ```ts
                            *  PolarSeries.setData(
                            *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                            *          angle: i,
                            *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                            *      }))
                            *  )
                            * ```
                            * @public
                            */
                           export declare class PolarPointSeries extends PolarSeries {
                               solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultPolar | undefined;
                               /**
                                * Set data for PolarSeries to render as a list of {@link PolarPoint}s.
                                * @param points - List of {@link PolarPoint}s.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               setData(points: PolarPoint[]): this;
                               /**
                                * Get user-supplied data points.
                                * @returns Array of {@link PolarPoint}s.
                                * @public
                                */
                               getData(): PolarPoint[];
                               /**
                                * Set alignment of points.
                                * Defaults to center `{ x: 0, y: 0 }`.
                                *
                                * Can be used to offset points relative to their size.
                                *
                                * ```ts
                                *  // Example, position point by bottom
                                *  PointLineAreaSeries.setPointAlignment({ x: 0, y: -1 })
                                * ```
                                *
                                * ```ts
                                *  // Example, position point by bottom with extra gap
                                *  PointLineAreaSeries.setPointAlignment({ x: 0, y: -1.5 })
                                * ```
                                * @param alignment - Alignment where values are % in range [-1, 1]. Can also be larger values, meaning offsets larger than point size.
                                * @returns             Object itself.
                                * @public
                                */
                               setPointAlignment(alignment: Point): this;
                               /**
                                * Get alignment of points.
                                * Defaults to center `{ x: 0, y: 0 }`.
                                *
                                * Can be used to offset points relative to their size.
                                * @public
                                */
                               getPointAlignment(): Point;
                               /**
                                * Set point fill style of Series.
                                *
                                * Example usage:
                                *```javascript
                                * // Create a new style
                                * PolarPointSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                * // Change transparency
                                * PolarPointSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
                                * // Set hidden
                                * PolarPointSeries.setPointFillStyle(emptyFill)
                                * // Individual point style (required for using 'color' properties in data points)
                                * PolarPointSeries.setPointFillStyle(new IndividualPointFill())
                                *
                                * ```
                                * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                                * @returns Series itself for fluent interface.
                                * @public
                                */
                               setPointFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                               /**
                                * Get normal points fill style.
                                * @returns Normal point fillStyle
                                * @public
                                */
                               getPointFillStyle(): FillStyle;
                               /**
                                * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
                                * @returns Series itself for fluent interface.
                                * @public
                                */
                               setPointStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                               /**
                                * @returns LineStyle
                                * @public
                                */
                               getPointStrokeStyle(): LineStyle;
                               /**
                                * Set size of point in pixels.
                                * @param size - Size of point in pixels.
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               setPointSize(size: number): this;
                               /**
                                * Get current size of points in pixels.
                                * @returns Size of point in pixels.
                                * @public
                                */
                               getPointSize(): number;
                               /**
                                * Set shape of displayed points, markers.
                                *
                                * ```ts
                                *  // Example syntax
                                *  PointLineAreaSeries.setPointShape(PointShape.Square)
                                * ```
                                *
                                * All valid options are listed under {@link PointShape}
                                *
                                * @param shape - point shape enum
                                * @returns Object itself for fluent interface.
                                * @public
                                */
                               setPointShape(shape: PointShape): this;
                               /**
                                * Set shape of displayed points as a Custom Icon.
                                * This allows using any custom bitmap as the shape of displayed points.
                                *
                                * ```ts
                                *  // Example usage
                                *  const image = new Image()
                                *  image.src = 'my-image.png'
                                *  PointLineAreaSeries.setPointShape(chart.engine.addCustomIcon(image))
                                * ```
                                * @param shape - Icon object.
                                * @returns Object itself for fluent interface.
                                */
                               setPointShape(shape: Icon): this;
                               /**
                                * Get shape of points.
                                * @returns PointShape
                                * @public
                                */
                               getPointShape(): PointShape | Icon;
                               /**
                                * Set the rotation of points in degrees.
                                * @param angle - Rotation angle in degrees
                                * @public
                                */
                               setPointRotation(angle: number): this;
                               /**
                                * Get the current rotation of points.
                                * @public
                                */
                               getPointRotation(): number;
                               addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolar) => unknown, options?: LCJSAddEventListenerOptions): void;
                               removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolar) => unknown): void;
                           }
                           /**
                            * Class that represents a single *polygon* from the collection of a {@link PolarPolygonSeries}.
                            *
                            * The geometry of the *polygon* can be mutated at any time.
                            *
                            * Note, that the style of *PolarPolygon*s is managed by the owning *PolarPolygonSeries*, to change the style, refer to the API of the Series.
                            *
                            * **Example usage:**
                            *
                            * ```ts
                            *  const polygonSeries = polarChart.addPolygonSeries()
                            *  let ang = 45
                            *  let amplitude = 50
                            *  const polygon = polygonSeries.addPolygon()
                            *      .setGeometry([
                            *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                            *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                            *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                            *          { angle: (ang += 10), amplitude: (amplitude -= 5) },
                            *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                            *          { angle: (ang += 5), amplitude: (amplitude -= 5) },
                            *          { angle: (ang += 0), amplitude: (amplitude -= 10) },
                            *          { angle: (ang -= 5), amplitude: (amplitude -= 5) },
                            *          { angle: (ang -= 10), amplitude: (amplitude -= 10) },
                            *          { angle: (ang -= 10), amplitude: (amplitude -= 5) },
                            *          { angle: (ang -= 10), amplitude: (amplitude += 5) },
                            *          { angle: (ang -= 10), amplitude: (amplitude += 10) },
                            *      ])
                            * ```
                            * @public
                            */
                           export declare class PolarPolygon implements HideableEvents {
                               /**
                                * Set *polygon* geometry as a list of {@link PolarPoint}s.
                                *
                                * **NOTE: points have to be in either clockwise or counter-clockwise order**. The polygon coordinates should also not intersect with themselves.
                                *
                                * Example usage:
                                * ```ts
                                *  let ang = 45
                                *  let amplitude = 50
                                *  polarPolygon.setGeometry([
                                *      { angle: (ang += 10), amplitude: (amplitude += 10) },
                                *      { angle: (ang += 10), amplitude: (amplitude += 5) },
                                *      { angle: (ang += 10), amplitude: (amplitude += 10) },
                                *      { angle: (ang += 10), amplitude: (amplitude -= 5) },
                                *      { angle: (ang += 10), amplitude: (amplitude += 5) },
                                *      { angle: (ang += 5), amplitude: (amplitude -= 5) },
                                *      { angle: (ang += 0), amplitude: (amplitude -= 10) },
                                *      { angle: (ang -= 5), amplitude: (amplitude -= 5) },
                                *      { angle: (ang -= 10), amplitude: (amplitude -= 10) },
                                *      { angle: (ang -= 10), amplitude: (amplitude -= 5) },
                                *      { angle: (ang -= 10), amplitude: (amplitude += 5) },
                                *      { angle: (ang -= 10), amplitude: (amplitude += 10) },
                                * ])
                                * ```
                                * @param geometry - List of *PolarPoints* that form the contour of the desired polygon. Automatically closed.
                                * @public
                                */
                               setGeometry(geometry: PolarPoint[]): this;
                               /**
                                * Get *polygon* geometry as a list of {@link PolarPoint}s.
                                *
                                * **NOTE: points have to be in either clockwise or counter-clockwise order**
                                * @returns List of *PolarPoints* that form the contour of the desired polygon. Automatically closed.
                                * @public
                                */
                               getGeometry(): PolarPoint[] | undefined;
                               setPointerEvents(state: boolean): this;
                               /**
                                * **Permanently** destroy the component.
                                *
                                * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                * **to the component and its children** in application code.
                                * ```javascript
                                * let chart = ...ChartXY()
                                * let axisX = chart.getDefaultAxisX()
                                * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                * chart.dispose()
                                * chart = undefined
                                * axisX = undefined
                                * ```
                                * @returns Object itself for fluent interface
                                * @public
                                */
                               dispose(): this;
                               /**
                                * Set element visibility.
                                *
                                * @param state - `true` when element should be visible and `false` when element should be hidden.
                                * @returns Object itself.
                                * @public
                                */
                               setVisible(state: boolean): this;
                               /**
                                * Get element visibility.
                                *
                                * @returns `true` when element is set to be visible and `false` otherwise.
                                * @public
                                */
                               getVisible(): boolean;
                               addEventListener<K extends keyof PolarPolygonEventMap>(type: K, listener: (event: PolarPolygonEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                               removeEventListener<K extends keyof PolarPolygonEventMap>(type: K, listener: (event: PolarPolygonEventMap[K], info: unknown) => unknown): void;
                           }
                           /**
                            * Interface of events trackable by {@link PolarPolygon.addEventListener} and the respective Event types.
                            * @public
                            */
                           export declare interface PolarPolygonEventMap extends DisposableEventMap, HideableEventMap {
                           }
                           /**
                            * Type of *PolarSeries* for visualizing a collection of *polygons* inside the Polar coordinate system. They are especially useful for highlighting parts of the Polar coordinate system.
                            *
                            * *PolarPolygonSeries* are created with {@link PolarChart.addPolygonSeries}.
                            *
                            * Create a {@link PolarPolygon} with {@link PolarPolygonSeries.addPolygon}.
                            *
                            * **Example usage:**
                            *
                            * ```ts
                            *  const polygonSeries = polarChart.addPolygonSeries()
                            *  let ang = 45
                            *  let amplitude = 50
                            *  const polygon = polygonSeries.addPolygon()
                            *      .setGeometry([
                            *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                            *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                            *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                            *          { angle: (ang += 10), amplitude: (amplitude -= 5) },
                            *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                            *          { angle: (ang += 5), amplitude: (amplitude -= 5) },
                            *          { angle: (ang += 0), amplitude: (amplitude -= 10) },
                            *          { angle: (ang -= 5), amplitude: (amplitude -= 5) },
                            *          { angle: (ang -= 10), amplitude: (amplitude -= 10) },
                            *          { angle: (ang -= 10), amplitude: (amplitude -= 5) },
                            *          { angle: (ang -= 10), amplitude: (amplitude += 5) },
                            *          { angle: (ang -= 10), amplitude: (amplitude += 10) },
                            *      ])
                            * ```
                            * @public
                            */
                           export declare class PolarPolygonSeries extends PolarSeries {
                               solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultPolar | undefined;
                               /**
                                * Create new *polygon* to the Series.
                                *
                                * The style of *polygons* is shared, and can be modified with the Series API: {@link PolarPolygonSeries.setFillStyle} and {@link PolarPolygonSeries.setStrokeStyle}.
                                *
                                * Specify the *polygon* geometry with {@link PolarPolygon.setGeometry}
                                *
                                * **Example usage:**
                                *
                                * ```ts
                                *  const polygonSeries = polarChart.addPolygonSeries()
                                *  let ang = 45
                                *  let amplitude = 50
                                *  const polygon = polygonSeries.addPolygon()
                                *      .setGeometry([
                                *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                                *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                                *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                                *          { angle: (ang += 10), amplitude: (amplitude -= 5) },
                                *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                                *          { angle: (ang += 5), amplitude: (amplitude -= 5) },
                                *          { angle: (ang += 0), amplitude: (amplitude -= 10) },
                                *          { angle: (ang -= 5), amplitude: (amplitude -= 5) },
                                *          { angle: (ang -= 10), amplitude: (amplitude -= 10) },
                                *          { angle: (ang -= 10), amplitude: (amplitude -= 5) },
                                *          { angle: (ang -= 10), amplitude: (amplitude += 5) },
                                *          { angle: (ang -= 10), amplitude: (amplitude += 10) },
                                *      ])
                                * ```
                                * @returns {@link PolarPolygon}
                                    * @public
                                    */
                                addPolygon(): PolarPolygon;
                                /**
                                 * Set fill style of Series.
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Create a new style
                                 * PolarPolygonSeries.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                 * // Change transparency
                                 * PolarPolygonSeries.setFillStyle((solidFill) => solidFill.setA(80))
                                 * // Set hidden
                                 * PolarPolygonSeries.setFillStyle(emptyFill)
                                 * ```
                                 * @param value - Either a FillStyle object or a function, which will be used to create a new LineStyle based on current value.
                                 * @returns Chart itself
                                 * @public
                                 */
                                setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                /**
                                 * Get fill style of Series.
                                 * @returns FillStyle object
                                 * @public
                                 */
                                getFillStyle(): FillStyle;
                                /**
                                 * Set stroke style of Series.
                                 *
                                 * Supported line styles:
                                 * - {@link SolidLine}
                                 * - {@link emptyLine}
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Specified LineStyle
                                 * PolarPolygonSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                 * // Changed thickness
                                 * PolarPolygonSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
                                 * // Hidden
                                 * PolarPolygonSeries.setStrokeStyle(emptyLine)
                                 * ```
                                 * @param value - Either a LineStyle object or a function, which will be used to create a new SolidLine based on current value.
                                 * @returns Chart itself
                                 * @public
                                 */
                                setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                /**
                                 * Get stroke style of Series.
                                 * @returns LineStyle object
                                 * @public
                                 */
                                getStrokeStyle(): LineStyle;
                                addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolar) => unknown, options?: LCJSAddEventListenerOptions): void;
                                removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolar) => unknown): void;
                               }
                               /**
                                * Highlighter component that lives under {@link PolarChart}.
                                *
                                * Can be used to highlight sectors in the *polar coordinate* system,
                                * specified by four values:
                                * - **start angle**
                                * - **end angle**
                                * - **start amplitude**
                                * - **end amplitude**
                                *
                                * Created with {@link PolarChart.addSector}.
                                * @public
                                */
                               export declare class PolarSector extends ChartComponent {
                                   /**
                                    * Set Sectors start angle in degrees.
                                    * @param angleStart - Start angle in degrees.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setAngleStart(angleStart: number): this;
                                   /**
                                    * Get Sectors start angle in degrees.
                                    * @returns Start angle  in degrees.
                                    * @public
                                    */
                                   getAngleStart(): number;
                                   /**
                                    * Set Sectors end angle in degrees.
                                    * @param angleEnd - End angle in degrees
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setAngleEnd(angleEnd: number): this;
                                   /**
                                    * Get Sectors end angle in degrees.
                                    * @returns End angle in degrees
                                    * @public
                                    */
                                   getAngleEnd(): number;
                                   /**
                                    * Set Sectors start amplitude.
                                    * @param amplitudeStart - Start amplitude. Setting to *undefined* results in tracking the *PolarAxes* start value.
                                    *                          This doesn't have to be less than amplitude end value.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setAmplitudeStart(amplitudeStart: number): this;
                                   /**
                                    * Get Sectors start amplitude.
                                    * @returns Start amplitude. Setting to *undefined* results in tracking the *PolarAxes* start value.
                                    *                      This doesn't have to be less than amplitude end value.
                                    * @public
                                    */
                                   getAmplitudeStart(): number | undefined;
                                   /**
                                    * Set Sectors end amplitude.
                                    * @param amplitudeEnd - End amplitude. Setting to *undefined* results in tracking the *PolarAxes* end value.
                                    *                      This doesn't have to be greater than amplitude start value.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setAmplitudeEnd(amplitudeEnd: number | undefined): this;
                                   /**
                                    * Get Sectors end amplitude.
                                    * @returns End amplitude. Setting to *undefined* results in tracking the *PolarAxes* end value.
                                    *                      This doesn't have to be greater than amplitude start value.
                                    * @public
                                    */
                                   getAmplitudeEnd(): number | undefined;
                                   /**
                                    * Set Fill Style of Sector.
                                    *
                                    * Example use:
                                    *
                                    * ```javascript
                                    * // Create a new style
                                    * PolarSector.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                    * // Change transparency
                                    * PolarSector.setFillStyle((solidFill) => solidFill.setA(80))
                                    * // Set hidden
                                    * PolarSector.setFillStyle(emptyFill)
                                    * ```
                                    *
                                    * @param value - FillStyle object or function which mutates existing value.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get Fill Style of Sector.
                                    * @returns FillStyle
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set stroke style of PolarSector.
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Specified SolidLine
                                    * PolarSector.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                    * // Changed thickness
                                    * PolarSector.setStrokeStyle((solidLine) => solidLine.setThickness(5))
                                    * // Hidden
                                    * PolarSector.setStrokeStyle(emptyLine)
                                    * ```
                                    * @param value - Either a LineStyle object or a function, which will be used to create a new SolidLine based on current value.
                                    * @returns Chart itself
                                    * @public
                                    */
                                   setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get stroke style of PolarSector.
                                    * @returns Normal StrokeStyle
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                                   addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: unknown) => unknown): void;
                               }
                               /**
                                * Abstract super class for all PolarSeries.
                                * @public
                                */
                               export declare abstract class PolarSeries<SolveResultType extends SolveResultPolar = SolveResultPolar> extends Series2D<SolveResultType> {
                                   /**
                                    * Scale of the series
                                    * @public
                                    */
                                   readonly scale: RadialScale;
                                   /**
                                    * Method for solving the nearest data point to a given coordinate on screen.
                                    *
                                    * ```ts
                                    *  // Example syntax
                                    *  chart.onSeriesBackgroundMouseClick((_, event) => {
                                    *      const nearest = series.solveNearest(event, 'show-nearest')
                                    *      console.log(nearest)
                                    *  })
                                    * ```
                                    * @param   from -  Reference coordinate on web page as client coordinates. This can for example be directly an `Event` object.
                                    * @param   solveMode -     Optional control for solve nearest behavior
                                    * @returns     SolveResult object or `undefined`.
                                    * @public
                                    */
                                   abstract solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultType | undefined;
                                   /**
                                    * Get min amplitude value of PolarSeries' data points.
                                    * @returns number or undefined if no data is set.
                                    * @public
                                    */
                                   getAmplitudeMin(): number | undefined;
                                   /**
                                    * Get max amplitude value of PolarSeries' data points.
                                    * @returns number or undefined if no data is set.
                                    * @public
                                    */
                                   getAmplitudeMax(): number | undefined;
                               }
                               /**
                                * Class for series visual that is a Polygon.
                                * @public
                                */
                               export declare class PolygonFigure extends Figure<SolveResultPolygonSeries> {
                                   /**
                                    * @public
                                    */
                                   readonly scale: LinearScaleXY;
                                   /**
                                    * Get boundaries that contain figure.
                                    * @returns Interval<Point>
                                    * @public
                                    */
                                   _getBoundaries(): Interval<Point>;
                                   /**
                                    * Set new dimensions for figure.
                                    * @param polygonCoordinates - List of polygon coordinates
                                    * @returns Object itself
                                    * @remarks                  Owning series will be informed of change in size, possibly initiating scrolling.
                                    * @public
                                    */
                                   setDimensions(polygonCoordinates: Point[]): this;
                                   /**
                                    * Get current dimensions of figure as list of polygon coordinates.
                                    * @returns List of Polygon coordinates.
                                    * @public
                                    */
                                   getDimensions(): Point[];
                                   /**
                                    * Set fill style of Polygon.
                                    * @param value - FillStyle object or mutator to modify existing one
                                    * @returns Object itself
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Polygon.
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set stroke style of Polygon.
                                    *
                                    * Supported line styles:
                                    * - {@link SolidLine}
                                    * - {@link emptyLine}
                                    *
                                    * @param value - LineStyle object or mutator to modify existing one
                                    * @returns Object itself
                                    * @public
                                    */
                                   setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get stroke style of Polygon.
                                    * @returns LineStyle object
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                                   /**
                                    * Return some dominant fill style of the figure
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getDominantStyle(): FillStyle;
                               }
                               /**
                                * Series that lets user draw Polygon with independent figures.
                                * @public
                                */
                               export declare class PolygonSeries extends FigureSeries<SolveResultPolygonSeries, PolygonFigure, Point[], LinearScaleXY> {
                                   solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultPolygonSeries | undefined;
                                   /**
                                    * Add new figure to the series.
                                    * @param dimensions - Dimensions that figure must represent
                                    * @returns Created figure
                                    * @public
                                    */
                                   add(dimensions: Point[]): PolygonFigure;
                                   addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolygonSeries) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultPolygonSeries) => unknown): void;
                               }
                               /**
                                * Interface for supplying readonly configurations to a {@link PolygonSeries}.
                                * @public
                                */
                               export declare interface PolygonSeriesOptions extends SeriesOptionsXY {
                               }
                               /**
                                * Interface for end user API of an LCJS engine.
                                * In most cases this concerns only 1 individual chart (e.g. {@link ChartXY}, etc.)
                                *
                                * ```ts
                                *  // Example access
                                *  chart.engine.container
                                * ```
                                * @public
                                */
                               export declare interface PublicEngine extends EventInterface<PublicEngineEventMap> {
                                   /**
                                    * HTML Div element that contains the rendering Engine.
                                    * @public
                                    */
                                   container: HTMLDivElement;
                                   /**
                                    * Set Mouse style.
                                    * @param presetName - Name of a Mouse preset in js.
                                    * @param existingKey - Key for existing request to refresh
                                    * @returns Key that can be used to restore Mouse style
                                    * @public
                                    */
                                   setMouseStyle: (presetName: string, existingKey?: number) => number;
                                   /**
                                    * Restore Mouse style.
                                    * @param key - Key generated using 'setMouseStyle'
                                    * @public
                                    */
                                   restoreMouseStyle: (key?: number) => undefined;
                                   /**
                                    * Clear LCJS mouse styles. This effectively results in clearing the chart containers `style.cursor` property to get default cursor behavior.
                                    * Using this method is preferred over directly modifying the CSS property.
                                    * @public
                                    */
                                   clearMouseStyle: () => void;
                                   /**
                                    * Capture state of rendering Engines canvas. Returns the captured image as a Blob-object.
                                    *
                                    * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL:
                                    *
                                    * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
                                    *
                                    * @param type - A DOMString indicating the image format. The default format type is image/png.
                                    * @param encoderOptions - A Number between 0 and 1 indicating the image quality to use for image formats
                                    *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
                                    *                          the default value for image quality is used. The default value is 0.92. Other arguments are ignored.
                                    * @param asDataUrl - Return the captured frame as data url instead of as a Blob.
                                    * @param scale - Convenience output scaling factor. This doesn't actually stretch the result, but instead draws an altered scaled version and captures that.
                                    * @returns JavaScript Blob whose 'type' depends on what was passed to 'type' parameter of this method. Or as a [data url](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs) if the `asDataUrl` option was set to `true`
                                    *          Defaults to image/png
                                    * @public
                                    */
                                   captureFrame(type?: string, encoderOptions?: number): Blob;
                                   captureFrame(type?: string, encoderOptions?: number, asDataUrl?: boolean, scale?: number): Blob | string;
                                   /**
                                    * Render a frame of specific size to a ArrayBuffer.
                                    *
                                    * Mainly for Node JS usage. In browser the chart itself will not be resized correctly.
                                    * @param width - Horizontal resolution
                                    * @param height - Vertical resolution
                                    * @param noFlip - Leave the image upside down
                                    * @public
                                    */
                                   renderFrame(width: number, height: number, noFlip?: boolean): Uint8Array;
                                   /**
                                    * Calculate the layout again.
                                    *
                                    * This is used to inform charts that their position may have changed as a result of an Event that the charts are not aware of.
                                    * For example, if the chart is positioned within a scrollable DIV.
                                    *
                                    * ```js
                                    *  // Example syntax, trigger chart layout when it is scrolled.
                                    *  div.onscroll = () => chart.engine.layout()
                                    * ```
                                    * @public
                                    */
                                   layout(): void;
                                   /**
                                    * Set Fill Style of engine background.
                                    *
                                    * Every LCJS component has an Engine background under it. In case of Dashboard, there is only 1 shared engine background.
                                    *
                                    * **Transparent chart backgrounds:**
                                    *
                                    * LightningChart JS charts can be configured to be fully or partially transparent.
                                    *
                                    * ```ts
                                    *  // Example, partially transparent chart
                                    *
                                    *  // Engine background exists under all LCJS components. In case of Dashboard, there is only 1 shared engine background.
                                    *  chart.engine.setBackgroundFillStyle(emptyFill)
                                    *  // Chart background covers every 1 chart. In case of Dashboard, every chart has its own chart background.
                                    *  chart.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
                                    *  // Some charts also have a separate series background.
                                    *  chart.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
                                    * ```
                                    *
                                    * @param fillStyle - FillStyle or mutator to modify existing one.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setBackgroundFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get Fill Style of engine background.
                                    * @returns FillStyle
                                    * @public
                                    */
                                   getBackgroundFillStyle(): FillStyle;
                                   /**
                                    * Set Stroke Style of engine background.
                                    * @param value - LineStyle
                                    * @returns Object itself
                                    * @public
                                    */
                                   setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get Stroke Style of engine background.
                                    * @returns LineStyle
                                    * @public
                                    */
                                   getBackgroundStrokeStyle(): LineStyle;
                                   /**
                                    * Register a custom Icon that can be used within the engine (all charts, panels, series, etc. using the same engine).
                                    *
                                    * Note that currently the _Icon_ concept is not widely supported, and can only be used with the {@link DataGrid} feature as cell content.
                                    * In the future, Icons will be more widely utilizable, for example in Legends, Cursors and UI elements.
                                    *
                                    * ```ts
                                    *  // Example, load a custom icon.
                                    *  const img = new Image()
                                    *  img.src = `my-icon-url.jpg`
                                    *  const icon = chart.engine.addCustomIcon(img, {})
                                    * ```
                                    *
                                    * Icon properties can be supplied with the optional second parameter.
                                    * For all available options, see {@link IconProperties}.
                                    *
                                    * ```ts
                                    *  // Example, specify icon width as pixels and maintain source aspect ratio.
                                    *  const icon = chart.engine.addCustomIcon(img, { width: 32 })
                                    * ```
                                    *
                                    * Icon properties can also be adjusted using setter methods on an existing `Icon` object.
                                    * **All setters return a new Icon object, leaving the original Icon unmodified!**
                                    *
                                    * ```ts
                                    *  // Example, make a second Icon object by adjusting an existing one.
                                    *  const icon2 = icon.setSize(16, 24)
                                    * ```
                                    *
                                    * When a custom icon is no longer needed, it is recommended to inform the engine by _disposing_ the Icon:
                                    *
                                    * ```ts
                                    *  // Example, inform engine that an Icon is no longer needed.
                                    *  icon.dispose()
                                    * ```
                                    *
                                    * @param   source - Graphics source for the Icon.
                                    * @param   opts   - Optional properties for configuring the Icon.
                                    * @returns          Icon object.
                                    * @public
                                    */
                                   addCustomIcon(source: ImageFillSource, opts?: Partial<IconProperties>): Icon;
                                   addEventListener<K extends keyof PublicEngineEventMap>(type: K, listener: (event: PublicEngineEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof PublicEngineEventMap>(type: K, listener: (event: PublicEngineEventMap[K], info: unknown) => unknown): void;
                               }
                               /**
                                * @public
                                */
                               export declare interface PublicEngineEventMap {
                                   renderframe: {};
                                   locationchange: {};
                               }
                               /**
                                * Abstract base class for *Pyramid Charts*.
                                * Visualizes proportions and percentages between categories, by dividing a pyramid into proportional segments.
                                *
                                * Set data using *PyramidChart*.**addSlice( name: string, value: number )**
                                *
                                * There are multiple implementations of *PyramidChart*, each with their own visual design and *API* for customizing it.
                                * List of selectable options can be found in: {@link PyramidChartTypes}
                                * @public
                                */
                               export declare abstract class PyramidChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends Chart implements SlicedCharts<PyramidSlice>, ChartWithCursor<CursorResultTableBackgroundType, CursorPosition2D, Cursor2D<CursorResultTableBackgroundType>, SolveResultPyramidChart> {
                                   setCursor(mutator: Mutator<Cursor2D<CursorResultTableBackgroundType>>): this;
                                   getCursor(): Cursor2D<CursorResultTableBackgroundType>;
                                   setCursorMode(mode: SolveNearestMode | undefined): this;
                                   getCursorMode(): SolveNearestMode | undefined;
                                   setCustomCursor(clbk: undefined | ((event: CursorTargetChangedEvent<SolveResultPyramidChart>) => unknown)): this;
                                   setCursorDynamicBehavior(value: CursorDynamicBehavior): this;
                                   /**
                                    * Set cursor formatting, controlling the text displayed in built-in cursor.
                                    *
                                    * ```ts
                                    *  chart.setCursorFormatting((_, hit, hits) => {
                                    *      return [
                                    *          ['Cursor pointing at'],
                                    *          [hit.series], // returning a series will display the series color and its name automatically.
                                    *          ['X', '', hit.axisX.formatValue(hit.x)], // utilizing axis formatValue is useful for considering active zoom level and type of axis
                                    *          ['Y', '', hit.y.toFixed(2)], // empty string '' results in gap between cells
                                    *          [{ text: 'Example', font: { weight: 'bold' }, fillStyle: fillRed }] // any cell can also be styled individually
                                    *      ]
                                    *  })
                                    * ```
                                    *
                                    * Before overriding default cursor formatting, it is recommended to check if using {@link GenericAxis.setUnits} or configuring Axis cursor formatting would be enough.
                                    *
                                    * In order to use series specific data properties (e.g. Heatmap sample "intensity"),
                                    * you should use type guards to assert the type of the `SolveResult`:
                                    *
                                    * ```ts
                                    *  // Example of using type guard in cursor formatter
                                    *  Chart.setCursorFormatting((chart, hit, hits) => {
                                    *      if (!isHitHeatmap(hit)) return undefined
                                    *      return [hit.intensity.toFixed(1)]
                                    *  })
                                    * ```
                                    *
                                    * More details in Developer documentation (Features \> Cursor).
                                    * @param   formatter -     Callback function for cursor formatting.
                                    * @returns     Object itself
                                    * @public
                                    */
                                   setCursorFormatting(formatter: CursorFormatterPyramidChart): this;
                                   /**
                                    * Get active cursor formatter.
                                    * @returns     Cursor formatter.
                                    * @public
                                    */
                                   getCursorFormatting(): CursorFormatterPyramidChart;
                                   /**
                                    * Add manually controlled Cursor object.
                                    * These have exactly same functions as built-in cursors but they can be freely controlled by application logic.
                                    *
                                    * ```ts
                                    *  const cursor = chart.addCursor()
                                    * ```
                                    *
                                    * Styling works same as built-in cursors (e.g. {@link setCursor}).
                                    *
                                    * Position is set using `setPosition` method and displayed content using `setResultTable(table => table.setContent(...))`
                                    * For more details, see Developer documentation \> Features \> Cursor \> Manual cursors
                                    *
                                    * @param   cursorBuilder -     Builder for cursor. Can be used to tweak a handful of properties which can't be changed during runtime.
                                    * @returns     Cursor object.
                                    * @public
                                    */
                                   addCursor<ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: CursorBuilder2D<ResultTableBackgroundType>): Cursor2D<ResultTableBackgroundType>;
                                   /**
                                    * This method is used for the adding slices in the pyramid chart.
                                    * @param title - Pyramid slice title
                                    * @param value - pyramid slice value
                                    * @public
                                    */
                                   addSlice(title: string, value: number): PyramidSlice;
                                   /**
                                    * This method is used for the adding multiple slices in the pyramid chart.
                                    * @param slices - Array of slices
                                    * @public
                                    */
                                   addSlices(slices: {
                                       name: string;
                                       value: number;
                                   }[]): Array<PyramidSlice>;
                                   /**
                                    * Get all Slices of Pyramid Chart.
                                    * NOTE: Manual modifications to returned Array can have unforeseen side-effects.
                                    * Removing or adding Slices is intended to be done using other APIs (PyramidChart.addSlice, Slice.dispose, ...)
                                    * @returns Array of Slices
                                    * @public
                                    */
                                   getSlices(): PyramidSlice[];
                                   /**
                                    * Set Pyramid Neck Width
                                    * @param neckWidth - Pyramid Neck Width range from 1 to 100
                                    * @returns Pyramid Chart itself
                                    * @public
                                    */
                                   setNeckWidth(neckWidth: number): this;
                                   /**
                                    * Get Pyramid Neck Width
                                    * @returns number (1 - 100)
                                    * @public
                                    */
                                   getNeckWidth(): number;
                                   /**
                                    * Set gap between Slice / start of label connector, and end of label connector / Label.
                                    * @param sliceGap - Gap as pixels. Clamped between [0, 20] !
                                    * @returns Pyramid Chart itself
                                    * @public
                                    */
                                   setSliceGap(sliceGap: pixel): this;
                                   /**
                                    * Set PyramidSliceMode. Can be used to select between different drawing approaches for Slices.
                                    *
                                    * See {@link PyramidSliceModes} for a collection of options.
                                    * @param sliceMode - PyramidSliceMode
                                    * @returns Pyramid Chart itself
                                    * @public
                                    */
                                   setSliceMode(sliceMode: PyramidSliceModes): this;
                                   /**
                                    * Get PyramidSliceMode. Can be used to select between different drawing approaches for Slices.
                                    *
                                    * See {@link PyramidSliceModes} for a collection of options.
                                    * @returns PyramidSliceMode
                                    * @public
                                    */
                                   getPyramidSliceMode(): PyramidSliceModes;
                                   /**
                                    * Attach lookup table (LUT) to fill the slices with Colors based on value.
                                    *
                                    * The color for the slice would be selected from a specified *LUT*, which contains the information about gradient steps.
                                    * After setting LUT to undefined all the slices stay colorized, but no further lookup.
                                    *
                                    * LUT class stores information about values and its associated colors,
                                    * * which provides efficient lookup of the color based on provided value
                                    * * as well as linear and step interpolation between colors.
                                    *
                                    * ``` javascript
                                    * const pyramid = lightningChart()
                                    *  .Pyramid( { type: PyramidChartTypes.LabelsOnSides } )
                                    *  .setLUT( new LUT (steps: [
                                    *          { value: 10, color: ColorRGBA( 0, 0, 0 ) },
                                    *          { value: 20, color: ColorRGBA( 30, 255, 0 ) },
                                    *          { value: 30, color: ColorRGBA( 60, 204, 0 ) },
                                    *          { value: 40, color: ColorRGBA( 90, 128, 0 ) },
                                    *          { value: 50, color: ColorRGBA( 255, 0, 0 ) } ) ],
                                    *      interpolate: true } )
                                    * ```
                                    * @param value - Lookup table
                                    * @returns Pyramid itself for fluent interface
                                    * @public
                                    */
                                   setLUT(value: LUT): this;
                                   /**
                                    * Set style of Pyramid Slices fill.
                                    * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Pyramid will be assigned an incremental index,
                                    * which will be used to pick its fill style from this Palette.
                                    *
                                    * So, for example... We have a Pyramid Chart with 5 Slices, and we give it a Palette with only 3 possible values
                                    * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
                                    * Note that this means, that the supplied Palette will have to work in a continuous manner!
                                    *
                                    * @param sliceFillStylePalette - Palette for FillStyle objects
                                    * @returns Pyramid Chart itself
                                    * @public
                                    */
                                   setSliceFillStyle(sliceFillStylePalette: (index: number, slice: PyramidSlice) => FillStyle): this;
                                   /**
                                    * Get style of Pyramid Slices fill.
                                    * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Pyramid will be assigned an incremental index,
                                    * which will be used to pick its fill style from this Palette.
                                    *
                                    * So, for example... We have a Pyramid Chart with 5 Slices, and we give it a Palette with only 3 possible values
                                    * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
                                    * Note that this means, that the supplied Palette will have to work in a continuous manner!
                                    *
                                    * @returns Palette<FillStyle>
                                    * @public
                                    */
                                   getSliceFillStyle(): (index: number, slice: PyramidSlice) => FillStyle;
                                   /**
                                    * Set style of Pyramid Slices Stroke.
                                    * @param value - LineStyle object or function which creates a new style based on previous
                                    * @returns Pyramid Chart itself
                                    * @public
                                    */
                                   setSliceStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get style of Pyramid Slices Stroke.
                                    * @returns LineStyle object
                                    * @public
                                    */
                                   getSliceStrokeStyle(): LineStyle;
                                   /**
                                    * Set theme effect enabled on component or disabled.
                                    *
                                    * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                    * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                    *
                                    * ```ts
                                    *  // Example, disable theme effect from a particular component.
                                    *  Component.setEffect(false)
                                    * ```
                                    *
                                    * For the most part, theme effects are **enabled** by default on most components.
                                    *
                                    * Theme effect is configured with {@link Theme.effect} property.
                                    *
                                    * @param enabled - Theme effect enabled
                                    * @returns          Object itself.
                                    * @public
                                    */
                                   setSliceEffect(enabled: boolean): this;
                                   /**
                                    * Get theme effect enabled on component or disabled.
                                    *
                                    * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                    * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                    *
                                    * ```ts
                                    *  // Example, disable theme effect from a particular component.
                                    *  Component.setEffect(false)
                                    * ```
                                    *
                                    * For the most part, theme effects are **enabled** by default on most components.
                                    *
                                    * Theme effect is configured with {@link Theme.effect} property.
                                    *
                                    * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                                    * @public
                                    */
                                   getSliceEffect(): boolean;
                                   /**
                                    * Set sorter of Pyramids' Slices as a comparator-function.
                                    *
                                    * For some commonly needed default implementations, can refer to SliceSorters-collection.
                                    * @param sliceSorter - SliceSorter - function which sorts Slices of Pyramid with JavaScript API: Array.sort.
                                    * @returns Pyramid Chart itself
                                    * @public
                                    */
                                   setSliceSorter(sliceSorter: SliceSorter<PyramidSlice>): this;
                                   /**
                                    * Get sorter of Pyramids' Slices as a comparator-function.
                                    * @returns SliceSorter - function which sorts Slices of Pyramid with JavaScript API: Array.sort.
                                    * @public
                                    */
                                   getSliceSorter(): SliceSorter<PyramidSlice>;
                                   /**
                                    * Set fill style of Pyramid Slices Labels.
                                    * @param value - FillStyle object or function which creates a new style based on previous
                                    * @returns Pyramid Chart itself
                                    * @public
                                    */
                                   setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Pyramid Slice Labels.
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getLabelFillStyle(): FillStyle;
                                   /**
                                    * Not to be confused with {@link GlowEffect}
                                    * @public
                                    * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
                                    */
                                   setLabelShadow(value: Color | undefined): this;
                                   /**
                                    * Not to be confused with {@link GlowEffect}
                                    * @public
                                    * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
                                    */
                                   getLabelShadow(): Color | undefined;
                                   /**
                                    * Set font of Slice Labels.
                                    * @param value - FontSettings or mutator function for existing settings
                                    * @returns Pyramid Chart itself
                                    * @public
                                    */
                                   setLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get font of Slice Labels.
                                    * @returns FontSettings
                                    * @public
                                    */
                                   getLabelFont(): FontSettings;
                                   /**
                                    * Set theme effect enabled on component or disabled.
                                    *
                                    * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                    * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                    *
                                    * ```ts
                                    *  // Example, disable theme effect from a particular component.
                                    *  Component.setEffect(false)
                                    * ```
                                    *
                                    * For the most part, theme effects are **enabled** by default on most components.
                                    *
                                    * Theme effect is configured with {@link Theme.effect} property.
                                    *
                                    * @param enabled - Theme effect enabled
                                    * @returns          Object itself.
                                    * @public
                                    */
                                   setLabelEffect(enabled: boolean): this;
                                   /**
                                    * Get theme effect enabled on component or disabled.
                                    *
                                    * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                    * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                    *
                                    * ```ts
                                    *  // Example, disable theme effect from a particular component.
                                    *  Component.setEffect(false)
                                    * ```
                                    *
                                    * For the most part, theme effects are **enabled** by default on most components.
                                    *
                                    * Theme effect is configured with {@link Theme.effect} property.
                                    *
                                    * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                                    * @public
                                    */
                                   getLabelEffect(): boolean;
                                   /**
                                    * Set formatter of Slice Labels.
                                    *
                                    * See {@link SliceLabelFormatters} for a collection of default options.
                                    * @param labelFormatter - SliceLabelFormatter - function which generates text of Labels per Slice.
                                    * @returns Pyramid Chart itself
                                    * @public
                                    */
                                   setLabelFormatter(labelFormatter: SliceLabelFormatter<PyramidSlice>): this;
                                   /**
                                    * Get formatter of Slice Labels.
                                    * @returns SliceLabelFormatter - function which generates text of Labels per Slice.
                                    * @public
                                    */
                                   getLabelFormatter(): SliceLabelFormatter<PyramidSlice>;
                                   /**
                                    * Set if slices should be highlighted on mouse hover / touch. Applies to all Slices.
                                    * @param state - True if Slices should be highlighted on hover, false if not. This applies to all existing Slices and new Slices added.
                                    * @public
                                    */
                                   setSliceHighlightOnHover(state: boolean): this;
                                   /**
                                    * **Permanently** destroy the component.
                                    *
                                    * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                    * **to the component and its children** in application code.
                                    * ```javascript
                                    * let chart = ...ChartXY()
                                    * let axisX = chart.getDefaultAxisX()
                                    * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                    * chart.dispose()
                                    * chart = undefined
                                    * axisX = undefined
                                    * ```
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   dispose(): this;
                                   addEventListener<K extends keyof PyramidChartEventMap>(type: K, listener: (event: PyramidChartEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof PyramidChartEventMap>(type: K, listener: (event: PyramidChartEventMap[K], info: unknown) => unknown): void;
                               }
                               /**
                                * Interface of events trackable by {@link PyramidChart.addEventListener} and the respective Event types.
                                * @public
                                */
                               export declare interface PyramidChartEventMap extends PanelEventMap, ChartWithCursorEventMap<SolveResultPyramidChart> {
                               }
                               /**
                                * Interface for readonly configuration of {@link PyramidChart}.
                                *
                                * Some properties of `PyramidChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
                                *
                                * ```typescript
                                *  // Example, create chart with specified color theme.
                                *  const chart = LightningChart.Pyramid({
                                *      theme: Themes.light,
                                *  })
                                * ```
                                *
                                * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
                                *
                                * For *standalone* `PyramidChart`, more parameters are documented in {@link LightningChart.Pyramid}.
                                *
                                * For *dashboard* `PyramidChart`, more parameters are documented in {@link Dashboard.createPyramidChart}.
                                *
                                *
                                * **Commonly used properties:**
                                *
                                * - {@link PyramidChartOptions.type}: Specify visual design of *pyramid chart* from a collection of options.
                                * - {@link PyramidChartOptions.theme}: Specify chart color *theme*.
                                * - {@link PyramidChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
                                *
                                * **Example usage:**
                                *
                                * ```typescript
                                *  // Example 1, create pyramid chart with default configuration.
                                *  const chart = LightningChart.Pyramid({})
                                * ```
                                *
                                * ```typescript
                                *  // Example 2, create pyramid chart with labels inside slices.
                                *  const chart = LightningChart.Pyramid({
                                *      type: PyramidChartTypes.LabelsInsideSlices
                                *  })
                                * ```
                                *
                                * ```typescript
                                *  // Example 3, create pyramid chart with specified color theme.
                                *  const chart = LightningChart.Pyramid({
                                *      theme: Themes.light,
                                *  })
                                * ```
                                * @public
                                */
                               export declare interface PyramidChartOptions<PyramidChartType extends PyramidChartTypes = PyramidChartTypes, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
                                   /**
                                    * Interface for specifying desired "type" of Pyramid Chart.
                                    * This can be used to select different rendering approaches, mainly reflecting how Slice Labels are positioned.
                                    *
                                    * Options are located in {@link PyramidChartTypes} collection. If undefined, will default to {@link PyramidChartWithLabelsOnSides}.
                                    */
                                   type?: PyramidChartType;
                                   /**
                                    * Builder for the charts' *auto cursor*.
                                    *
                                    * For most use cases, it is not recommended to use this, but rather {@link PyramidChart.setCursor} for a more convenient API.
                                    * @public
                                    */
                                   readonly cursorBuilder?: CursorBuilder2D<CursorResultTableBackgroundType>;
                               }
                               /**
                                * Collection of {@link PyramidChart} implementations. Each option can have their own visual type, and *API* for customization of it.
                                *
                                * This must be specified when the {@link PyramidChart} is created (or default one will be used).
                                *
                                * Example usage:
                                *```javascript
                                * // Create a PyramidChart with default type
                                * LightningChart.Pyramid()
                                * // Create a PyramidChart with specified type
                                * LightningChart.Pyramid({ type: PyramidChartTypes.LabelsInsideSlices })
                                * ```
                                * @public
                                */
                               export declare const PyramidChartTypes: {
                                   /**
                                    * Pyramid Chart type, where Slice Labels are positioned on the either left or right sides of Chart.
                                    * The side can be set using setLabelSide
                                    * Labels are connected to their Slices with lines, which can be styled using unique API for this Pyramid Chart type.
                                    */
                                   LabelsOnSides: typeof PyramidChartWithLabelsOnSides;
                                   /**
                                    * Pyramid Chart type, where Slice Labels inside the Slices.
                                    */
                                   LabelsInsideSlices: typeof PyramidChartWithLabelsInsideSlices;
                               };
                               /**
                                * Available Pyramid Chart types
                                * @public
                                */
                               export declare type PyramidChartTypes = (typeof PyramidChartTypes)[keyof typeof PyramidChartTypes];
                               /**
                                * {@link PyramidChart} implementation that draws Slice Labels inside the Slices.
                                * Works well when Label texts are short and there are not a lot of Slices, as the actual Pyramid has more space.
                                * @public
                                */
                               export declare class PyramidChartWithLabelsInsideSlices extends PyramidChart {
                                   /**
                                    * Get minimum size of Panel.
                                    * Depending on the type of class this value might be automatically computed to fit different elements.
                                    * @returns Point
                                    * @public
                                    */
                                   getMinimumSize(): Point | undefined;
                               }
                               /**
                                * {@link PyramidChart} implementation that draws Slice Labels on its left and right sides.
                                * Slices and Labels are connected by 'label connector lines'.
                                * @public
                                */
                               export declare class PyramidChartWithLabelsOnSides extends PyramidChart {
                                   /**
                                    * Set style of Label connector lines.
                                    * @param labelConnectorStyle - LineStyle object
                                    * @returns Pyramid Chart itself
                                    * @public
                                    */
                                   setLabelConnectorStyle(labelConnectorStyle: LineStyle): this;
                                   /**
                                    * Get style of Label connector lines.
                                    * @returns LineStyle object
                                    * @public
                                    */
                                   getLabelConnectorStyle(): LineStyle;
                                   /**
                                    * @public
                                    */
                                   setLabelConnectorGapBeforeLabel(gap: number): this;
                                   /**
                                    * @public
                                    */
                                   getLabelConnectorGapBeforeLabel(): number;
                                   /**
                                    * @public
                                    */
                                   setLabelConnectorGapBeforeSlice(gap: number): this;
                                   /**
                                    * @public
                                    */
                                   getLabelConnectorGapBeforeSlice(): number;
                                   /**
                                    * @public
                                    */
                                   setLabelConnectorLengthAfterSlice(length: number): this;
                                   /**
                                    * @public
                                    */
                                   getLabelConnectorLengthAfterSlice(): number;
                                   /**
                                    * @public
                                    */
                                   setLabelConnectorMinLengthBeforeSlice(length: number): this;
                                   /**
                                    * @public
                                    */
                                   getLabelConnectorMinLengthBeforeSlice(): number;
                                   /**
                                    * Set the side where label should display
                                    * @param labelSide - Left / Right
                                    * @returns Pyramid Chart itself
                                    * @public
                                    */
                                   setLabelSide(labelSide: PyramidLabelSide): this;
                                   /**
                                    * Get the side where label shown
                                    * @returns The label side
                                    * @public
                                    */
                                   getLabelSide(): PyramidLabelSide;
                                   /**
                                    * Get minimum size of Panel.
                                    * Depending on the type of class this value might be automatically computed to fit different elements.
                                    * @returns Point minimum size or undefined if unimplemented
                                    * @public
                                    */
                                   getMinimumSize(): Point | undefined;
                               }
                               /**
                                * Options for selecting side of labels in a {@link PyramidChartWithLabelsOnSides}.
                                *
                                * Use with {@link PyramidChartWithLabelsOnSides.setLabelSide}
                                * @public
                                */
                               export declare enum PyramidLabelSide {
                                   /**
                                    * Label Side  - Right
                                    */
                                   Right = 0,
                                   /**
                                    * Label Side  - Left
                                    */
                                   Left = 1
                               }
                               /**
                                * Interface that can be used to define {@link PyramidChart} configurations, when inside a {@link Dashboard}, that can't be changed after creation.
                                *
                                * Example usage:
                                * ```javascript
                                * // Pyramid Chart with default type
                                * undefined
                                * // Pyramid Chart with specified type
                                * { pyramidOptions: { type: PyramidChartTypes.LabelsInsideSlices } }
                                * ```
                                * @public
                                */
                               export declare interface PyramidOptions<PyramidChartType extends PyramidChartTypes> extends DashboardCellOptions, PyramidChartOptions<PyramidChartType> {
                               }
                               /**
                                * Class that represents a single Slice of a Pyramid Chart.
                                * It is given to users when a Slice is added.
                                * @public
                                */
                               export declare abstract class PyramidSlice extends Slice {
                                   /**
                                    * Set value of Slice.
                                    * @param value - Numeric value
                                    * @returns Slice itself
                                    * @public
                                    */
                                   abstract setValue(value: number): this;
                                   /**
                                    * Get value of Slice.
                                    * @returns Numeric value
                                    * @public
                                    */
                                   abstract getValue(): number;
                               }
                               /**
                                * Enum for selecting different drawing approaches for {@link PyramidChart}.
                                *
                                * Use with {@link PyramidChart.setSliceMode}
                                * @public
                                */
                               export declare enum PyramidSliceModes {
                                   /**
                                    * Slices **height** represents its relative value inside the Pyramid Chart.
                                    */
                                   VariableHeight = 0,
                                   /**
                                    * Slices **width** represents its relative value inside the Pyramid Chart.
                                    */
                                   VariableWidth = 1
                               }
                               /**
                                * Used with {@link MeshModel3D.setModelRotationQuaternion}.
                                * @public
                                */
                               export declare interface Quaternion {
                                   w: number;
                                   x: number;
                                   y: number;
                                   z: number;
                               }
                               /**
                                * Radial Gradient fill style.
                                *
                                * Instances of RadialGradientFill are *immutable*, meaning that its setters don't modify the object,
                                * but instead return a completely new modified object.
                                * @public
                                */
                               export declare class RadialGradientFill extends RadialGradientFillStyleRecord implements Gradient, FillStyle {
                                   /** @public */
                                   constructor(props?: Partial<RadialGradientFillStyleProperties>);
                                   /**
                                    * Get CSS representation of the FillStyle.
                                    * @public
                                    */
                                   toCSS(): string;
                                   /**
                                    * Set color stops for the gradient.
                                    *
                                    * All style object setter methods return a new object rather than modifying the current one.
                                    * @param stops - Color Stops
                                    * @public
                                    */
                                   setColorStops(stops: ColorStop[]): this;
                                   /**
                                    * Get current color stops from the gradient.
                                    * @public
                                    */
                                   getColorStops(): ColorStop[];
                                   /**
                                    * Set the center position of the gradient.
                                    *
                                    * All style object setter methods return a new object rather than modifying the current one.
                                    * @param position - Local XY coordinate in x: [0-1], y: [0-1] range
                                    * @public
                                    */
                                   setPosition(position: Point): this;
                                   /**
                                    * Get the center position of the gradient.
                                    * @public
                                    */
                                   getPosition(): Point;
                                   /**
                                    * Set the shape of the gradient
                                    *
                                    * All style object setter methods return a new object rather than modifying the current one.
                                    * @param shape - Gradient Shape
                                    * @public
                                    */
                                   setShape(shape: GradientShape): this;
                                   /**
                                    * Get the shape of the gradient
                                    * @public
                                    */
                                   getShape(): GradientShape;
                                   /**
                                    * Set the extent of the gradient.
                                    *
                                    * All style object setter methods return a new object rather than modifying the current one.
                                    * @param extent - Gradient Extent
                                    * @public
                                    */
                                   setExtent(extent: GradientExtent): this;
                                   /**
                                    * Get the extent of the gradient
                                    * @public
                                    */
                                   getExtent(): GradientExtent;
                                   /**
                                    * Set the fill sub type of the gradient. Default is true.
                                    *
                                    * All style object setter methods return a new object rather than modifying the current one.
                                    * @param extent - Sub type.
                                    * @public
                                    */
                                   setDitheringEnabled(enabled: boolean): this;
                                   /**
                                    * Get the fill sub type of the gradient.
                                    * @public
                                    */
                                   getDitheringEnabled(): boolean;
                               }
                               /**
                                * Factory for creating a RadialGradientFill palette.
                                * @param colorPalettes - Collection of default colors from PaletteFactory
                                * @param amount - Amount of colors in the palette
                                * @returns A new RadialGradientFill palette
                                * @public
                                */
                               export declare const RadialGradientFillPalette: (colorPalettes: PaletteFactory<Color>, amount: number, color?: Color) => Palette<FillStyle>;
                               /**
                                * Interface for all properties of a RadialGradientFillStyle.
                                * @public
                                */
                               export declare interface RadialGradientFillStyleProperties {
                                   type: 'fillstyle';
                                   fillType: 'radial-gradient';
                                   /**
                                    * Is dithering enabled.
                                    */
                                   ditheringEnabled: boolean;
                                   /**
                                    * Gradient color stops
                                    */
                                   stops: ColorStop[];
                                   /**
                                    * Gradient center position.
                                    *
                                    * A element relative coordinate. 0 to 1 coordinate space.
                                    * `{ x: 0, y: 0 }` is bottom left.
                                    * `{ x: 1, y: 1 }` is top right.
                                    */
                                   position: Point;
                                   /**
                                    * The shape for the gradient
                                    */
                                   shape: GradientShape;
                                   /**
                                    * The extent for gradient.
                                    *
                                    * Defines where the gradient takes it's size.
                                    */
                                   extent: GradientExtent;
                               }
                               /**
                                * Record contractor for RadialGradientFillStyleProperties.
                                * @public
                                */
                               declare const RadialGradientFillStyleRecord: Record_2.Factory<RadialGradientFillStyleProperties>;
                               /**
                                * RadialScale is a two dimensional Scale:
                                * - Amplitude ( radius on circle )
                                * - Angle ( angle along circle, always in range [0, 2 pi] )
                                *
                                * It is configured by its cell size and margins, always representing a circle, maintaining symmetric X and Y radius
                                * as defined by margins.
                                *
                                * Basically the same as what PieChart logic does with its Scales,
                                * but at a different place in library hierarchy ( Chart -\> Scale -\> Engine ).
                                * Could be used for PieChart just as well, but why bother.
                                *
                                * @public
                                */
                               declare class RadialScale extends ScaleXY<LinearScale1D> {
                               }
                               /**
                                * The abstact class implements the most part of general logic for mountains.
                                * The series contains the following elements:
                                * - Junction area with stylable and switchable fill styles for High and Low values.
                                * - Line with points for High values border.
                                * - Line with points for Low values border.
                                * @public
                                */
                               export declare abstract class RangeSeries extends SeriesXY<LinearScaleXY | MixedScaleXY, SolveResultXY> implements SeriesWithDataCleaning {
                                   /**
                                    * Disable automatic data cleaning.
                                    *
                                    * ```js
                                    *  // Example syntax, disable data cleaning.
                                    *  series.setDataCleaning(undefined)
                                    * ```
                                    *
                                    * @param arg - Data cleaning configuration.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setDataCleaning(arg: undefined): this;
                                   /**
                                    * Enable automatic data cleaning by `minDataPointCount` configuration.
                                    *
                                    * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
                                    *
                                    * ```js
                                    *  // Example syntax for specifying minDataPointCount
                                    *  series.setDataCleaning({ minDataPointCount: 10000 })
                                    * ```
                                    *
                                    * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
                                    * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
                                    *
                                    * ```js
                                    *  // Example, enable lazy data cleaning of out of view data.
                                    *  series.setDataCleaning({ minDataPointCount: 1 })
                                    * ```
                                    *
                                    * @param arg - Data cleaning configuration.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setDataCleaning(arg: {
                                       minDataPointCount: number | undefined;
                                   }): this;
                                   /**
                                    * Clear all previously pushed data points from the *series*.
                                    *
                                    * ```ts
                                    *  // Example usage
                                    *  LineSeries.clear()
                                    * ```
                                    *
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   clear(): this;
                                   /**
                                    * Get amount of points that series currently has.
                                    * @returns Number of points
                                    * @public
                                    */
                                   getPointAmount(): number;
                               }
                               /**
                                * Interface of events trackable by {@link RangeSeries.addEventListener} and the respective Event types.
                                * @public
                                */
                               export declare interface RangeSeriesEventMap extends ChartComponentEventMap {
                               }
                               /**
                                * Class for series visual that is a Rectangle.
                                * @public
                                */
                               export declare class RectangleFigure extends Figure<SolveResultRectangleSeries> implements RoundableCorners {
                                   /**
                                    * @public
                                    */
                                   readonly scale: LinearScaleXY | MixedScaleXY;
                                   /**
                                    * Configure rounded-ness of corners.
                                    *
                                    * ```ts
                                    *  obj.setCornerRadius(10)             // 10 px rounding radius
                                    *  obj.setCornerRadius(undefined)     // straight corners
                                    * ```
                                    *
                                    * @param radius -  Number (pixel radius) or undefined.
                                    * @public
                                    * @beta    Introduced in v7.0. API might be changed depending on user feedback.
                                    */
                                   setCornerRadius(radius: number | undefined): this;
                                   /**
                                    * Get rounded-ness of corners.
                                    * @returns     Number or undefined.
                                    * @public
                                    * @beta    Introduced in v7.0. API might be changed depending on user feedback.
                                    */
                                   getCornerRadius(): number | undefined;
                                   /**
                                    * Get boundaries that contain figure.
                                    * @returns Interval<Point>
                                    * @public
                                    */
                                   _getBoundaries(): Interval<Point>;
                                   /**
                                    * Set new dimensions for figure.
                                    * @param dimensions - Dimensions as either of supported Rectangle interfaces
                                    * @returns Object itself
                                    * @remarks          Owning series will be informed of change in size, possible initiating scrolling.
                                    * @public
                                    */
                                   setDimensions(dimensions: RectanglePositionAndSize | RectangleTwoPoints): this;
                                   /**
                                    * Get current dimensions of figure as interface 'RectanglePositionAndSize'.
                                    * @returns RectanglePositionAndSize
                                    * @public
                                    */
                                   getDimensionsPositionAndSize(): RectanglePositionAndSize;
                                   /**
                                    * Get current dimensions of figure as interface 'RectangleTwoPoints'.
                                    * @returns RectangleTwoPoints
                                    * @public
                                    */
                                   getDimensionsTwoPoints(): RectangleTwoPoints;
                                   /**
                                    * Set fill style of Rectangle.
                                    * @param value - FillStyle object or mutator to modify existing one
                                    * @returns Object itself
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Rectangle.
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set stroke style of Rectangle.
                                    *
                                    * Supported line styles:
                                    * - {@link SolidLine}
                                    * - {@link emptyLine}
                                    *
                                    * @param value - LineStyle object or mutator to modify existing one
                                    * @returns Object itself
                                    * @public
                                    */
                                   setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get stroke style of Rectangle.
                                    * @returns LineStyle object
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                                   /**
                                    * @public
                                    */
                                   getDominantStyle(): FillStyle;
                               }
                               /**
                                * Interface for defining dimensions of a Rectangle with position and size.
                                * @public
                                */
                               export declare interface RectanglePositionAndSize {
                                   /**
                                    * X coordinate of rectangles bottom-left corner.
                                    */
                                   readonly x: number;
                                   /**
                                    * Y coordinate of rectangles bottom-left corner.
                                    */
                                   readonly y: number;
                                   /**
                                    * Width of rectangle
                                    */
                                   readonly width: number;
                                   /**
                                    * Height of rectangle
                                    */
                                   readonly height: number;
                               }
                               /**
                                * Series that lets user draw Rectangles with independent figures.
                                * @public
                                */
                               export declare class RectangleSeries extends FigureSeries<SolveResultRectangleSeries, RectangleFigure, RectanglePositionAndSize | RectangleTwoPoints, LinearScaleXY | MixedScaleXY> {
                                   solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultRectangleSeries | undefined;
                                   /**
                                    * Add new figure to the series.
                                    * @param dimensions - Dimensions that figure must represent
                                    * @returns Created figure
                                    * @public
                                    */
                                   add(dimensions: RectanglePositionAndSize | RectangleTwoPoints): RectangleFigure;
                                   addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultRectangleSeries) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultRectangleSeries) => unknown): void;
                               }
                               /**
                                * Interface for supplying readonly configurations to a {@link RectangleSeries}.
                                * @public
                                */
                               export declare interface RectangleSeriesOptions extends SeriesOptionsXY {
                                   /**
                                    * Option to specify cursor / solve nearest behavior.
                                    * Whether it should consider only X plane, only Y plane or both.
                                    *
                                    * By default, this is automatically selected based on rectangle figure dimensions.
                                    *
                                    * ```ts
                                    *  // Example syntax
                                    *  const rectangles = chart.addRectangleSeries({
                                    *      solvePlane: 'x'
                                    *  })
                                    * ```
                                    */
                                   solvePlane?: 'x' | 'y' | 'xy';
                               }
                               /**
                                * Interface for defining dimensions of a Rectangle with two locations.
                                * @public
                                */
                               export declare interface RectangleTwoPoints {
                                   /**
                                    * X coordinate of rectangles bottom-left corner.
                                    */
                                   readonly x1: number;
                                   /**
                                    * Y coordinate of rectangles bottom-left corner.
                                    */
                                   readonly y1: number;
                                   /**
                                    * X coordinate of rectangles top-right corner.
                                    */
                                   readonly x2: number;
                                   /**
                                    * Y coordinate of rectangles top-right corner.
                                    */
                                   readonly y2: number;
                               }
                               /**
                                * Convenience function that maps a color palette + value range to Color Lookup Table steps.
                                *
                                * Equal to following one-liner:
                                *
                                * ```ts
                                *  const steps = colorPalette.map((color, i) => ({ color, value: valueMin + (i / (colorPalette.length - 1)) * (valueMax - valueMin) }))
                                * ```
                                *
                                * Used like this:
                                *
                                * ```ts
                                *  // Example, construct LUT with regular color steps from an array of colors.
                                *  const lut = new LUT({
                                *      interpolate: true,
                                *      steps: regularColorSteps(0, 100, [ ColorCSS('red'), ColorCSS('blue'), ColorCSS('green') ])
                                *  })
                                * ```
                                *
                                * @param   valueMin      -  Min LUT value. Attached to the first color in the palette.
                                * @param   valueMax      -  Max LUT value. Attached to the last color in the palette.
                                * @param   opts          -  Optional extra options.
                                * @param   formatLabels  -  Optional callback function for mapping each {@link LUTStep.value} to value of {@link LUTStep.label}.
                                * @param   alpha         -  Optional specific Alpha value [0, 255] to use with each color.
                                * @returns                  Array of LUTSteps which can be used to construct a {@link LUT} object.
                                * @public
                                */
                               export declare const regularColorSteps: (valueMin: number, valueMax: number, colorPalette: Color[], opts?: {
                                   formatLabels?: ((value: number) => string) | undefined;
                                   alpha?: number | undefined;
                               } | undefined) => LUTStep[];
                               /**
                                * @public
                                */
                               export declare interface ResizableEventMap {
                                   resize: ResizeEvent;
                               }
                               /**
                                * @public
                                */
                               export declare interface ResizableEvents extends EventInterface<ResizableEventMap> {
                               }
                               /**
                                * @public
                                */
                               export declare interface ResizeEvent {
                                   width: number;
                                   height: number;
                                   engineWidth: number;
                                   engineHeight: number;
                               }
                               /**
                                * Public interface for ResultTable.
                                * Part of Cursor that displays information about current data-point.
                                * @public
                                */
                               export declare interface ResultTable<BackgroundType extends UIBackground = UIBackground> extends Marginable, ComponentWithEffects {
                                   /**
                                    * Set displayed data of ResultTable
                                    * @param data - TableContent
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setContent: (data: ResultTableContent) => this;
                                   /**
                                    * Set origin position of ResultTable
                                    * @param origin - (-1 to 1 which specifies position of origin, 0 is center of the object)
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setOrigin: (origin: Point) => this;
                                   /**
                                    * Get origin position of v
                                    * @returns (-1 to 1 which specifies position of origin, 0 is center of the object)
                                    * @public
                                    */
                                   getOrigin: () => Point;
                                   /**
                                    * Set text fillStyle of ResultTable text
                                    * @param fillStyle - FillStyle object or mutator to modify existing one
                                    * @returns Object itself
                                    * @public
                                    */
                                   setTextFillStyle: (fillStyle: FillStyle | ImmutableMutator<FillStyle>) => this;
                                   /**
                                    * Get text fillStyle of ResultTable
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getTextFillStyle: () => FillStyle;
                                   /**
                                    * Set text font of ResultTable text
                                    * @param value - FontSettings or mutator function for existing settings
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get text font of ResultTable text
                                    * @returns FontSettings
                                    * @public
                                    */
                                   getTextFont(): FontSettings;
                                   /**
                                    * Mutator function for Background of ResultTable.
                                    * @param mutator - Mutator function
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setBackground(mutator: Mutator<BackgroundType>): this;
                                   /**
                                    * Get background object of ResultTable
                                    * @returns Background object
                                    * @public
                                    */
                                   getBackground(): BackgroundType;
                                   /**
                                    * Set padding of ResultTable in pixels
                                    * @param padding - Number with pixel padding for all sides or data structure with individual pixel paddings
                                    *                      for each side. Any side can be omitted, only passed values will be overridden.
                                    * @returns Background object
                                    * @public
                                    */
                                   setPadding(padding: Partial<Padding> | number): this;
                                   /**
                                    * Get padding of object in pixels.
                                    * @returns padding datastructure
                                    * @public
                                    */
                                   getPadding(): Padding;
                               }
                               /**
                                * @public
                                */
                               export declare type ResultTableCellContent = string | {
                                   text?: string;
                                   component?: ChartComponent;
                                   componentColor?: Color;
                                   componentFillStyle?: FillStyle;
                                   icon?: Icon;
                                   font?: Partial<FontProperties>;
                                   fillStyle?: FillStyle;
                                   rowFillStyle?: FillStyle;
                               } | Icon | ChartComponent | undefined;
                               /**
                                * @public
                                */
                               export declare type ResultTableContent = ResultTableCellContent | Array<ResultTableCellContent | Array<ResultTableCellContent>> | undefined;
                               /**
                                * @public
                                */
                               export declare interface RotationPoint extends Point {
                                   /**
                                    * Point rotation as degrees.
                                    */
                                   rotation: number;
                               }
                               /**
                                * Interface for a data point that contains an associated rotation property.
                                *
                                * Can be used for individual configuration of data points rotation.
                                *
                                * For some series types, individually rotated data points might have to be explicitly enabled when the series is created.
                                * Refer to series documentation for more detailed information.
                                * @public
                                */
                               export declare interface RotationValue {
                                   /**
                                    * Data point rotation as degrees.
                                    *
                                    * Can be used for individual configuration of data points rotation.
                                    *
                                    * For some series types, individually rotated data points might have to be explicitly enabled when the series is created.
                                    * Refer to series documentation for more detailed information.
                                    */
                                   readonly rotation?: number;
                               }
                               /**
                                * @public
                                * @beta    Introduced in v7.0. API might be changed depending on user feedback.
                                */
                               export declare interface RoundableCorners {
                                   /**
                                    * Configure rounded-ness of corners.
                                    *
                                    * ```ts
                                    *  obj.setCornerRadius(10)             // 10 px rounding radius
                                    *  obj.setCornerRadius(undefined)     // straight corners
                                    * ```
                                    *
                                    * @param radius -  Number (pixel radius) or undefined.
                                    * @public
                                    * @beta    Introduced in v7.0. API might be changed depending on user feedback.
                                    */
                                   setCornerRadius(radius: number | undefined): this;
                                   /**
                                    * Get rounded-ness of corners.
                                    * @returns     Number or undefined.
                                    * @public
                                    * @beta    Introduced in v7.0. API might be changed depending on user feedback.
                                    */
                                   getCornerRadius(): number | undefined;
                               }
                               /**
                                * Reference to a sample in XY data set.
                                * Always has X + Y values.
                                * Situationally, may also have extra properties for:
                                *  - lookup value
                                *  - color
                                *  - id
                                *
                                * The `SampleXY` interface is utilized by cursor result table formatters {@link SeriesXYFormatterNew}, solve nearest APIs as well as interaction events ('pointermove', etc.)
                                * @public
                                */
                               export declare interface SampleXY {
                                   /**
                                    * X value of the visualized sample after data mapping.
                                    *
                                    * For original data properties, refer to {@link sample}
                                    */
                                   readonly x: number;
                                   /**
                                    * Y value of the visualized sample after data mapping.
                                    *
                                    * For original data properties, refer to {@link sample}
                                    */
                                   readonly y: number;
                                   /**
                                    * Look-up value of the visualized sample after data mapping.
                                    *
                                    * For original data properties, refer to {@link sample}
                                    */
                                   readonly lookupValue?: number;
                                   /**
                                    * Color value of the visualized sample after data mapping.
                                    *
                                    * For original data properties, refer to {@link sample}
                                    *
                                    * NOTE: Uint32 encoded RGBA where Red is least significant byte.
                                    * Can be translated to Color object with {@link ColorUint32}
                                    */
                                   readonly color?: number;
                                   /**
                                    * Size value of the visualized sample after data mapping.
                                    *
                                    * For original data properties, refer to {@link sample}
                                    *
                                    * NOTE: Unit = Pixels
                                    */
                                   readonly size?: number;
                                   /**
                                    * Rotation value of the visualized sample after data mapping.
                                    *
                                    * For original data properties, refer to {@link sample}
                                    *
                                    * NOTE: Unit = Degrees
                                    */
                                   readonly rotation?: number;
                                   /**
                                    * All sample values from the originating data set.
                                    *
                                    * When interpolation is used, this will be either sample A or B (it shouldn't really be used in this case)
                                    */
                                   readonly sample: Record<string, number>;
                               }
                               /**
                                * Capture rendered state in an image file. Prompts the browser to download the created file.
                                *
                                * **NOTE: The download might be blocked by browser/plugins as harmful.**
                                * To prevent this, only call the method in events tied to user-interactions.
                                * From mouse-event handlers, for example.
                                *
                                * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
                                * For supported image formats, compression quality, Etc. refer to:
                                *
                                * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
                                *
                                * Example usage:
                                *```javascript
                                * // Download 'screenshot.png'
                                * saveToFile(chart.engine, 'screenshot')
                                * // Attempt download 'maybeNotSupported.bmp'
                                * saveToFile(chart.engine, 'maybeNotSupported', 'image/bmp')
                                * // Attempt download jpeg.file with specified compression quality
                                * saveToFile(chart.engine, 'fileName', 'image/jpeg', 0.50)
                                * ```
                                *
                                * @remarks              **If 'type' is not supported by browser, an Error will be thrown.**
                                *
                                * @param engine - [PublicEngine] reference of a chart which you would like to save to a file.
                                * @param fileName - Name of prompted download file as string. **File extension shouldn't be included**
                                *                          as it is automatically detected from 'type'-argument.
                                * @param type - A DOMString indicating the image format. The default format type is image/png.
                                * @param encoderOptions - A Number between 0 and 1 indicating the image quality to use for image formats
                                *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
                                *                          the default value for image quality is used. The default value is 0.92.
                                * @param scale - Convenience output scaling factor. This doesn't actually stretch the result, but instead draws an altered scaled version and captures that.
                                * @public
                                */
                               export declare const saveToFile: (engine: PublicEngine, fileName: string, type?: string, encoderOptions?: number, scale?: number) => void;
                               /**
                                * Abstract base class for 1 Dimensional Scale object.
                                *
                                * Describes an abstract virtual number interval (start - end).
                                *
                                * Scale1D is defined within an (optional) dashboard cell, allocating a sub section of the whole dashboard for the Scale.
                                * @public
                                */
                               declare abstract class Scale1D {
                                   /**
                                    * Get start coordinate on Scale. NOT necessarily smaller than end coordinate!
                                    * @returns number.
                                    * @public
                                    */
                                   getInnerStart(): number;
                                   /**
                                    * Get end coordinate on Scale. NOT necessarily higher than start coordinate!
                                    * @returns number.
                                    * @public
                                    */
                                   getInnerEnd(): number;
                                   /**
                                    * Get absolute interval of Scale. Calculated by:
                                    *
                                    * ```ts
                                    * const innerInterval = Math.abs( Scale1D.getInnerEnd() - Scale1D.getInnerStart() )
                                    * ```
                                    * @returns number.
                                    * @public
                                    */
                                   getInnerInterval(): number;
                               }
                               declare interface _Scale3DEventMap {
                                   cellresize: {};
                               }
                               /**
                                * Convenience function to up or downscale font sizes of a {@link Theme} object.
                                * Similarly also scales relevant paddings and margins to make font sizes sit better with the overall style defaults.
                                *
                                * ```ts
                                *  // Example syntax
                                *  const chart = lightningChart().ChartXY({
                                *      theme: scaleTheme(Themes.darkGold, 0.6) // fonts, paddings etc. will be smaller than normal
                                *  })
                                * ```
                                *
                                * This was designed as an easy way to adjust chart themes for mobile view (generally themes are downscaled in this case as screen space is more limited),
                                * but it can also be convenient tool to scaling general chart elements size.
                                *
                                * @param theme     - Theme object to use as a base.
                                * @param scaler    - Number around [.1, 4] range. 2 means twice as bigger fonts. 0.5 means half size fonts.
                                * @returns     New theme object.
                                * @public
                                */
                               export declare const scaleTheme: (theme: Theme, scaler: number) => Theme;
                               /**
                                * Scale class that directly represents the XY viewport (e.g. X scale = width, Y scale = height).
                                *
                                * e.g. "ViewportScaleXY"
                                *
                                * If Polar coordinate transformation is moved to shared, or some similar feature is implemented
                                * we would then need a higher level ScaleXY abstraction that would allow the creation of a Scale
                                * defined without X and Y planes (e.g. Polar = amplitude, angle ).
                                * @public
                                */
                               declare abstract class ScaleXY<T extends ViewportScale1D = ViewportScale1D> {
                                   /**
                                    * Scale that represents viewport width.
                                    * @public
                                    */
                                   x: T;
                                   /**
                                    * Scale that represents viewport height.
                                    * @public
                                    */
                                   y: T;
                                   /**
                                    * Get size of Scales interval as pixels on the viewport, with its margins deducted (starting from START to END of Scale).
                                    *
                                    * Equal to getting cell size and subtracting margins.
                                    * @public
                                    */
                                   getInnerIntervalPixels(): Point;
                               }
                               /**
                                * Data structure that defines dimensions of a line-segment
                                * @public
                                */
                               export declare interface SegmentDimensions {
                                   /**
                                    * X value of start location
                                    */
                                   startX: number;
                                   /**
                                    * Y value of start location
                                    */
                                   startY: number;
                                   /**
                                    * X value of end location
                                    */
                                   endX: number;
                                   /**
                                    * Y value of end location
                                    */
                                   endY: number;
                               }
                               /**
                                * Class for series visual that is a Segment.
                                * @public
                                */
                               export declare class SegmentFigure extends Figure<SolveResultSegmentSeries> {
                                   /**
                                    * @public
                                    */
                                   readonly scale: LinearScaleXY | MixedScaleXY;
                                   /**
                                    * Get boundaries that contain figure.
                                    * @returns Interval<Point>
                                    * @public
                                    */
                                   _getBoundaries(): Interval<Point>;
                                   /**
                                    * Set new dimensions for figure.
                                    * @param dimensions - Dimensions
                                    * @returns Object itself
                                    * @remarks          Owning series will be informed of change in size, possible initiating scrolling.
                                    * @public
                                    */
                                   setDimensions(dimensions: SegmentDimensions): this;
                                   /**
                                    * Get current dimensions of figure.
                                    * @returns Dimensions
                                    * @public
                                    */
                                   getDimensions(): SegmentDimensions;
                                   /**
                                    * Set stroke style of Segment.
                                    *
                                    * Supported line styles:
                                    * - {@link SolidLine}
                                    * - {@link DashedLine}
                                    * - {@link emptyLine}
                                    *
                                    * @param value - FillStyle object or mutator to modify existing one
                                    * @returns Object itself
                                    * @public
                                    */
                                   setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get stroke style of Segment.
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                                   /**
                                    * Return some dominant fill style of the figure
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getDominantStyle(): FillStyle;
                               }
                               /**
                                * Series for that lets user draw Segments with independent figures.
                                * @public
                                */
                               export declare class SegmentSeries extends FigureSeries<SolveResultSegmentSeries, SegmentFigure, SegmentDimensions, LinearScaleXY | MixedScaleXY> {
                                   solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultSegmentSeries | undefined;
                                   /**
                                    * Add new figure to the series.
                                    * @param dimensions - Dimensions that figure must represent
                                    * @returns Created figure
                                    * @public
                                    */
                                   add(dimensions: SegmentDimensions): SegmentFigure;
                                   addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultSegmentSeries) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultSegmentSeries) => unknown): void;
                               }
                               /**
                                * Interface for supplying readonly configurations to a {@link SegmentSeries}.
                                * @public
                                */
                               export declare interface SegmentSeriesOptions extends SeriesOptionsXY {
                               }
                               /**
                                * Internal interface for any type of Series (2D, 3D, ...).
                                *
                                * Intended for sharing Axis logic which interfaces with all kinds of Axes.
                                * @public
                                */
                               export declare interface Series extends ChartComponent {
                                   /**
                                    * Set whether series is taken into account with automatic scrolling and fitting of attached axes.
                                    *
                                    * By default, this is true for all series.
                                    *
                                    * By setting this to `false`, any series can be removed from axis scrolling/fitting.
                                    *
                                    * ```ts
                                    *  // Example syntax, remove series from automatic scrolling / fitting.
                                    *  LineSeries.setAutoScrollingEnabled(false)
                                    * ```
                                    * @param enabled - `true` default, axes will take series into account in scrolling and fitting operations.
                                    *                      `false`, axes will ignore series boundaries.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setAutoScrollingEnabled(enabled: boolean): this;
                                   /**
                                    * Get whether series is taken into account with automatic scrolling and fitting of attached axes.
                                    *
                                    * By default, this is true for all series.
                                    *
                                    * @returns `true` default, axes will take series into account in scrolling and fitting operations.
                                    *                      `false`, axes will ignore series boundaries.
                                    * @public
                                    */
                                   getAutoScrollingEnabled(): boolean;
                               }
                               /**
                                * Base class for a major group of ChartComponents - Series.
                                * Adds Cursor / solveNearest logic.
                                * Base class for all Series. Series are chart components which support cursors, basically.
                                * @public
                                */
                               export declare abstract class Series2D<SolveResultType extends SolveResult> extends ChartComponent<SolveResultType> implements _InternalSeriesWithCursor<SolveResultType> {
                                   /**
                                    * Set whether series is taken into account with automatic scrolling and fitting of attached axes.
                                    *
                                    * By default, this is true for all series.
                                    *
                                    * By setting this to `false`, any series can be removed from axis scrolling/fitting.
                                    *
                                    * ```ts
                                    *  // Example syntax, remove series from automatic scrolling / fitting.
                                    *  LineSeries.setAutoScrollingEnabled(false)
                                    * ```
                                    * @param enabled - `true` default, axes will take series into account in scrolling and fitting operations.
                                    *                      `false`, axes will ignore series boundaries.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setAutoScrollingEnabled(enabled: boolean): this;
                                   /**
                                    * Get whether series is taken into account with automatic scrolling and fitting of attached axes.
                                    *
                                    * By default, this is true for all series.
                                    *
                                    * @returns `true` default, axes will take series into account in scrolling and fitting operations.
                                    *                      `false`, axes will ignore series boundaries.
                                    * @public
                                    */
                                   getAutoScrollingEnabled(): boolean;
                                   /**
                                    * Configure whether *cursors* should pick on this particular *series* or not.
                                    *
                                    * ```typescript
                                    *  // Example, prevent chart auto cursor from snapping to a series.
                                    *  LineSeries.setCursorEnabled(false)
                                    * ```
                                    *
                                    * **Related API:**
                                    *
                                    * - {@link ChartXY.setCursorMode} | configure behavior when auto cursor is visible.
                                    * @public
                                    */
                                   setCursorEnabled(state: boolean): this;
                                   /**
                                    * @returns Whether Cursor is enabled or not
                                    * @public
                                    */
                                   getCursorEnabled(): boolean;
                                   /**
                                    * Set override behavior for when this series is formatted to be displayed by a cursor.
                                    * This can be used to alter and expand on cursor formatting done for a specific series, either by the library's default cursor formatters or even the users own cursor formatters defined on chart level.
                                    *
                                    * ```ts
                                    *  // Example syntax, add extra row to display a custom data property
                                    *  series.setCursorFormattingOverride((hit, before) => {
                                    *      if (!isHitSampleXY(hit)) return before
                                    *      const customPropertyValue = data[hit.iSample].customProperty
                                    *      return [...before, ['ASD', '', customPropertyValue.toFixed(3)]]
                                    *  })
                                    * ```
                                    *
                                    * To use this with users own cursor formatters, you can use {@link useCursorFormatterSeriesOverride}:
                                    *
                                    * ```ts
                                    *  // Example syntax, define custom cursor formatting with support for series overrides
                                    *  chart.setCursorFormatting((_, __, hits) => {
                                    *      return [
                                    *          [hits[0].axisX.formatValue(hits[0].x)],
                                    *          ...hits.map((hit) => useCursorFormatterSeriesOverride(hit, [['Y:', '', hit.axisY.formatValue(hit.y)]])).flat(),
                                    *      ]
                                    *  })
                                    * ```
                                    *
                                    * @param   override    - Override callback or `undefined`
                                    * @returns         Object itself.
                                    * @public
                                    */
                                   setCursorFormattingOverride(override: CursorFormatterSeriesOverride<SolveResultType> | undefined): this;
                                   /**
                                    * Get override behavior for when this series is formatted to be displayed by a cursor.
                                    * @returns     Override callback or `undefined`
                                    * @public
                                    */
                                   getCursorFormattingOverride(): CursorFormatterSeriesOverride<SolveResultType> | undefined;
                                   abstract addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultType) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   abstract removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultType) => unknown): void;
                               }
                               /**
                                * Abstract base class for all _3D series types_.
                                *
                                * 3D series are created with methods of {@link Chart3D}, for example {@link Chart3D.addPointSeries}.
                                *
                                * List of 3D series types:
                                *
                                * - {@link PointSeries3D}
                                * - {@link LineSeries3D}
                                * - {@link PointLineSeries3D}
                                * - {@link BoxSeries3D}
                                * - {@link SurfaceGridSeries3D}
                                * - {@link SurfaceScrollingGridSeries3D}
                                * @public
                                */
                               export declare abstract class Series3D<SolveResultType extends SolveResult3D = SolveResult3D> extends ChartComponent<SolveResultType> implements _InternalSeriesWithCursor<SolveResultType> {
                                   protected _shadingStyle: ColorShadingStyle;
                                   /**
                                    * @public
                                    */
                                   readonly chart: Chart3D;
                                   /**
                                    * @public
                                    */
                                   readonly axisX: Axis3D;
                                   /**
                                    * @public
                                    */
                                   readonly axisY: Axis3D;
                                   /**
                                    * @public
                                    */
                                   readonly axisZ: Axis3D;
                                   /**
                                    * Configure whether *cursors* should pick on this particular *series* or not.
                                    *
                                    * ```typescript
                                    *  // Example, prevent chart auto cursor from snapping to a series.
                                    *  LineSeries.setCursorEnabled(false)
                                    * ```
                                    *
                                    * **Related API:**
                                    *
                                    * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                    * @public
                                    */
                                   setCursorEnabled(state: boolean): this;
                                   /**
                                    * @returns Whether Cursor is enabled or not
                                    * @public
                                    */
                                   getCursorEnabled(): boolean;
                                   /**
                                    * Set override behavior for when this series is formatted to be displayed by a cursor.
                                    * This can be used to alter and expand on cursor formatting done for a specific series, either by the library's default cursor formatters or even the users own cursor formatters defined on chart level.
                                    *
                                    * ```ts
                                    *  // Example syntax, add extra row to display a custom data property
                                    *  series.setCursorFormattingOverride((hit, before) => {
                                    *      if (!isHitSampleXY(hit)) return before
                                    *      const customPropertyValue = data[hit.iSample].customProperty
                                    *      return [...before, ['ASD', '', customPropertyValue.toFixed(3)]]
                                    *  })
                                    * ```
                                    *
                                    * To use this with users own cursor formatters, you can use {@link useCursorFormatterSeriesOverride}:
                                    *
                                    * ```ts
                                    *  // Example syntax, define custom cursor formatting with support for series overrides
                                    *  chart.setCursorFormatting((_, __, hits) => {
                                    *      return [
                                    *          [hits[0].axisX.formatValue(hits[0].x)],
                                    *          ...hits.map((hit) => useCursorFormatterSeriesOverride(hit, [['Y:', '', hit.axisY.formatValue(hit.y)]])).flat(),
                                    *      ]
                                    *  })
                                    * ```
                                    *
                                    * @param   override    - Override callback or `undefined`
                                    * @returns         Object itself.
                                    * @public
                                    */
                                   setCursorFormattingOverride(override: CursorFormatterSeriesOverride<SolveResultType> | undefined): this;
                                   /**
                                    * Get override behavior for when this series is formatted to be displayed by a cursor.
                                    * @returns     Override callback or `undefined`
                                    * @public
                                    */
                                   getCursorFormattingOverride(): CursorFormatterSeriesOverride<SolveResultType> | undefined;
                                   /**
                                    * Set whether series is taken into account with automatic scrolling and fitting of attached axes.
                                    *
                                    * By default, this is true for all series.
                                    *
                                    * By setting this to `false`, any series can be removed from axis scrolling/fitting.
                                    *
                                    * ```ts
                                    *  // Example syntax, remove series from automatic scrolling / fitting.
                                    *  LineSeries.setAutoScrollingEnabled(false)
                                    * ```
                                    * @param enabled - `true` default, axes will take series into account in scrolling and fitting operations.
                                    *                      `false`, axes will ignore series boundaries.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setAutoScrollingEnabled(enabled: boolean): this;
                                   /**
                                    * Get whether series is taken into account with automatic scrolling and fitting of attached axes.
                                    *
                                    * By default, this is true for all series.
                                    *
                                    * @returns `true` default, axes will take series into account in scrolling and fitting operations.
                                    *                      `false`, axes will ignore series boundaries.
                                    * @public
                                    */
                                   getAutoScrollingEnabled(): boolean;
                                   /**
                                    * Set Color Shading Style for series.
                                    *
                                    * Shading style changes the visual style of the rendering. See {@link ColorShadingStyles} for available shading styles.
                                    *
                                    * Use Simple color shading style:
                                    * ```js
                                    * series3D.setShadingStyle(new ColorShadingStyles.Simple())
                                    * ```
                                    *
                                    * Use Phong color shading style:
                                    * ```js
                                    * series3D.setShadingStyle(new ColorShadingStyles.Phong())
                                    * ```
                                    *
                                    * Configuring specular highlight for Phong shading style:
                                    * ```js
                                    * series3D.setShadingStyle(new ColorShadingStyles.Phong({
                                    *      specularReflection: 0.5,
                                    *      specularColor: ColorRGBA(255, 255, 255)
                                    * }))
                                    * ```
                                    *
                                    * @param shadingStyle - Color shading style to use for this series.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setColorShadingStyle(shadingStyle: ColorShadingStyle): this;
                                   /**
                                    * Get the currently used {@link ColorShadingStyle}.
                                    * @returns The Color Shading Style for the series.
                                    * @public
                                    */
                                   getColorShadingStyle(): ColorShadingStyle;
                                   /**
                                    * Set _3D depth test_ enabled for this series.
                                    *
                                    * By default this is enabled, meaning that any series that is rendered after this series and is behind this series will not be rendered.
                                    *
                                    * Can be disabled to alter 3D rendering behavior.
                                    *
                                    * ```js
                                    *  // Example syntax, disable depth test.
                                    *  pointSeries3D.setDepthTestEnabled(false)
                                    * ```
                                    *
                                    * @param enabled - Depth test enabled?
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setDepthTestEnabled(enabled: boolean): this;
                                   /**
                                    * Get _3D depth test_ enabled for this series.
                                    *
                                    * By default this is enabled, meaning that any series that is rendered after this series and is behind this series will not be rendered.
                                    *
                                    * Can be disabled to alter 3D rendering behavior.
                                    * @returns Depth test enabled?
                                    * @public
                                    */
                                   getDepthTestEnabled(): boolean;
                                   /**
                                    * @returns Max X value of the series
                                    * @public
                                    */
                                   getXMax(): number;
                                   /**
                                    * @returns Min X value of the series
                                    * @public
                                    */
                                   getXMin(): number;
                                   /**
                                    * @returns Max Y value of the series
                                    * @public
                                    */
                                   getYMax(): number;
                                   /**
                                    * @returns Min Y value of the series
                                    * @public
                                    */
                                   getYMin(): number;
                                   /**
                                    * @returns Max Z value of the series
                                    * @public
                                    */
                                   getZMax(): number;
                                   /**
                                    * @returns Min Z value of the series
                                    * @public
                                    */
                                   getZMin(): number;
                                   abstract addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultType) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   abstract removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultType) => unknown): void;
                               }
                               /**
                                * @public
                                */
                               export declare interface SeriesAddedEvent<T> {
                                   series: T;
                               }
                               /**
                                * @public
                                */
                               export declare interface SeriesDisposedEvent<T> {
                                   series: T;
                               }
                               /**
                                * Interface describing options for all series that can be specified during creation time.
                                * @public
                                */
                               declare interface SeriesOptions {
                                   /**
                                    * Optional index to use for automatic coloring of series.
                                    *
                                    * Normally series are automatically colored differently when you create several series in the same chart.
                                    * However, in some cases you might want to alter this order of automatic coloring, or use the automatic color palettes on series that belong to different charts.
                                    *
                                    * In these scenarios you can use `automaticColorIndex` to tell each series individually what is its place in the default color palette.
                                    *
                                    * ```ts
                                    *  // Create series using the first color in default Theme palette.
                                    *  const series1 = chart.addLineSeries({ automaticColorIndex: 0 })
                                    *  // Create another series colored with the 3rd color.
                                    *  const series2 = chart.addLineSeries({ automaticColorIndex: 2 })
                                    * ```
                                    */
                                   automaticColorIndex?: number;
                                   /**
                                    * Legend options for the series.
                                    * If null, no legend entry will be created for the series.
                                    */
                                   legend?: LegendEntryOptions | null;
                               }
                               /**
                                * Interface describing options for series that can be specified during creation time.
                                * @public
                                */
                               declare interface SeriesOptionsXY extends SeriesOptions {
                                   /**
                                    * Optional non-default X Axis to attach series to.
                                    *
                                    * By default, series are attached to the same X Axis, that is returned by {@link ChartXY.getDefaultAxisX}.
                                    */
                                   xAxis?: Axis;
                                   /**
                                    * Optional non-default X Axis to attach series to.
                                    *
                                    * By default, series are attached to the same X Axis, that is returned by {@link ChartXY.getDefaultAxisX}.
                                    */
                                   axisX?: Axis;
                                   /**
                                    * Optional non-default Y Axis to attach series to.
                                    *
                                    * By default, series are attached to the same Y Axis, that is returned by {@link ChartXY.getDefaultAxisY}.
                                    */
                                   yAxis?: Axis;
                                   /**
                                    * Optional non-default Y Axis to attach series to.
                                    *
                                    * By default, series are attached to the same Y Axis, that is returned by {@link ChartXY.getDefaultAxisY}.
                                    */
                                   axisY?: Axis;
                               }
                               /**
                                * Interface that describes API for configuring data cleaning. There are a multitude of different basis' of configuring automatic data cleaning.
                                *
                                * Data cleaning by `minDataPointCount`:
                                *
                                * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
                                *
                                * ```js
                                *  // Example syntax for specifying minDataPointCount
                                *  series.setDataCleaning({ minDataPointCount: 10000 })
                                * ```
                                *
                                * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
                                * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
                                *
                                * **Partially supported data cleaning configurations:**
                                *
                                * These syntaxes are supported by only some select series types, refer to that particular series' API documentation to learn more.
                                *
                                * Data cleaning by `maxDataPointCount`:
                                *
                                * Specifying `maxDataPointCount` results in data cleaning always happening **exactly** when total data amount exceeds the supplied threshold.
                                *
                                * ```js
                                *  // Example syntax for specifying maxDataPointCount
                                *  series.setDataCleaning({ maxDataPointCount: 10000 })
                                * ```
                                *
                                * `maxDataPointCount` is usually used in memory limited applications to prevent running out of memory.
                                *
                                * **`maxDataPointCount` is currently only supported by only select series:**
                                * - {@link HeatmapScrollingGridSeries}.
                                * - {@link OHLCSeries}.
                                *
                                * If the feature receives good support and usage from the user base, it might be expanded to all series types in a future release.
                                * @public
                                */
                               export declare interface SeriesWithDataCleaning {
                                   /**
                                    * Disable automatic data cleaning.
                                    *
                                    * ```js
                                    *  // Example syntax, disable data cleaning.
                                    *  series.setDataCleaning(undefined)
                                    * ```
                                    *
                                    * @param arg - Data cleaning configuration.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setDataCleaning(arg: undefined): this;
                                   /**
                                    * Enable automatic data cleaning by `minDataPointCount` configuration.
                                    *
                                    * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
                                    *
                                    * ```js
                                    *  // Example syntax for specifying minDataPointCount
                                    *  series.setDataCleaning({ minDataPointCount: 10000 })
                                    * ```
                                    *
                                    * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
                                    * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
                                    *
                                    * ```js
                                    *  // Example, enable lazy data cleaning of out of view data.
                                    *  series.setDataCleaning({ minDataPointCount: 1 })
                                    * ```
                                    *
                                    * @param arg - Data cleaning configuration.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setDataCleaning(arg: {
                                       minDataPointCount: number | undefined;
                                   }): this;
                               }
                               /**
                                * Abstract super-class for 2D-series with X&Y axes
                                * @public
                                */
                               export declare abstract class SeriesXY<ScaleType extends ScaleXY = ScaleXY, SolveResultType extends SolveResultXY = SolveResultXY> extends Series2D<SolveResultType> implements ClippableXY {
                                   /**
                                    * Scale of the series
                                    * @public
                                    */
                                   readonly scale: ScaleType;
                                   /**
                                    * @public
                                    */
                                   readonly chart: ChartXY;
                                   /**
                                    * @public
                                    */
                                   readonly axisX: Axis;
                                   /**
                                    * @public
                                    */
                                   readonly axisY: Axis;
                                   /**
                                    * @public
                                    */
                                   get xAxis(): Axis;
                                   /**
                                    * @public
                                    */
                                   get yAxis(): Axis;
                                   /**
                                    * Method for solving the nearest data point to a given coordinate on screen.
                                    *
                                    * ```ts
                                    *  // Example syntax
                                    *  chart.onSeriesBackgroundMouseClick((_, event) => {
                                    *      const nearest = series.solveNearest(event, 'show-nearest')
                                    *      console.log(nearest)
                                    *  })
                                    * ```
                                    * @param   from -          Reference coordinate on web page as client coordinates. This can for example be directly an `Event` object.
                                    * @param   solveMode -     Optional control for solve nearest behavior
                                    * @returns                 SolveResult object or `undefined`.
                                    * @public
                                    */
                                   abstract solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultType | undefined;
                                   /**
                                    * Configure whether series rendering should be clipped to the area enclosed by its owning axes or not.
                                    * All series rendering is ALWAYS clipped so that it doesn't leak outside the owning charts series area.
                                    * However, it is optional whether the series rendering should be able to leak outside the series owning axes viewport, which might be smaller than the charts viewport (for example, when using stacked axes).
                                    *
                                    * By default, clipping is enabled (`true`).
                                    *
                                    * ```ts
                                    *  // Example, disable clipping, allowing the series rendering to leak outside its own axes.
                                    *  SeriesXY.setClipping(false)
                                    * ```
                                    *
                                    * @param clipping - Clipping enabled or disabled.
                                    * @returns     Object itself
                                    * @public
                                    */
                                   setClipping(clipping: boolean): this;
                                   /**
                                    * Read whether series rendering should be clipped to the area enclosed by its owning axes or not.
                                    * All series rendering is ALWAYS clipped so that it doesn't leak outside the owning charts series area.
                                    * However, it is optional whether the series rendering should be able to leak outside the series owning axes viewport, which might be smaller than the charts viewport (for example, when using stacked axes).
                                    *
                                    * By default, clipping is enabled (`true`).
                                    * @returns     True or false.
                                    * @public
                                    */
                                   getClipping(): boolean;
                                   /**
                                    * Get the name of the Component.
                                    * @returns The name of the Component.
                                    * @public
                                    * @privateRemarks  Override
                                    */
                                   getName(): string;
                                   /**
                                    * Configure draw order of the series.
                                    *
                                    * The drawing order of series inside same chart can be configured by configuring their `seriesDrawOrderIndex`.
                                    * This is a simple number that indicates which series is drawn first, and which last.
                                    *
                                    * The values can be any JS number, even a decimal. Higher number results in series being drawn closer to the top.
                                    *
                                    * By default, each series is assigned a running counter starting from `0` and increasing by `1` for each series.
                                    *
                                    * ```ts
                                    * 	// Example, create 2 series and configure them to be drawn in reverse order.
                                    * 	const series1 = ChartXY.addLineSeries()
                                    * 		.setDrawOrder({ seriesDrawOrderIndex: 1 })
                                    * 	const series2 = ChartXY.addLineSeries()
                                    * 		.setDrawOrder({ seriesDrawOrderIndex: 0 })
                                    * ```
                                    *
                                    * ```ts
                                    * 	// Example, ensure a series is drawn above other series.
                                    * 	SeriesXY.setDrawOrder({ seriesDrawOrderIndex: 1000 })
                                    * ```
                                    *
                                    * @param 	arg - Object with `seriesDrawOrderIndex` property.
                                    * @returns 		Object itself.
                                    * @public
                                    */
                                   setDrawOrder(arg: {
                                       seriesDrawOrderIndex: number;
                                   }): this;
                                   /**
                                    * **Permanently** destroy the component.
                                    *
                                    * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                    * **to the component and its children** in application code.
                                    * ```javascript
                                    * let chart = ...ChartXY()
                                    * let axisX = chart.getDefaultAxisX()
                                    * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                    * chart.dispose()
                                    * chart = undefined
                                    * axisX = undefined
                                    * ```
                                    * @returns  Object itself for fluent interface
                                    * @public
                                    */
                                   dispose(): this;
                                   /**
                                    * @returns Max X value of the series
                                    * @public
                                    */
                                   getXMax(): number;
                                   /**
                                    * @returns Min X value of the series
                                    * @public
                                    */
                                   getXMin(): number;
                                   /**
                                    * @returns Max Y value of the series
                                    * @public
                                    */
                                   getYMax(): number;
                                   /**
                                    * @returns Min Y value of the series
                                    * @public
                                    */
                                   getYMin(): number;
                                   getBoundaries(): Interval<Point>;
                                   /**
                                    * Configure whether *cursors* should pick on this particular *series* or not.
                                    *
                                    * ```typescript
                                    *  // Example, prevent chart auto cursor from snapping to a series.
                                    *  LineSeries.setCursorEnabled(false)
                                    * ```
                                    *
                                    * **Related API:**
                                    *
                                    * - {@link ChartXY.setCursorMode} | configure behavior when auto cursor is visible.
                                    * @public
                                    */
                                   setCursorEnabled(state: boolean): this;
                               }
                               /**
                                * @public
                                */
                               export declare interface SettableText {
                                   /**
                                    * Set the text of the entire shape.
                                    * @param text - Text string.
                                    * @public
                                    */
                                   setText(text: string): this;
                               }
                               /**
                                * @public
                                * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                */
                               declare type _ShapeCollectionProvider<UniqueProperties extends object, SharedProperties extends object> = {
                                   add: (instanceUniqueProperties: UniqueProperties, instanceSharedProperties: SharedProperties) => void;
                                   finishPlot: () => void;
                               };
                               /**
                                * Simple color shading style.
                                *
                                * Colors each pixel exactly according to its material color.
                                *
                                * Colors are **not** affected by camera angle, lighting, etc.
                                *
                                * ```js
                                *  // Example syntax, select simple color shading style.
                                *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())
                                * ```
                                *
                                * Color shading style is specified with {@link Series3D.setColorShadingStyle} method.
                                *
                                * _Simple color shading_ is really fast, which can be a crucial difference especially on low end devices, like laptops and mobile phones.
                                * @public
                                */
                               export declare class SimpleShadingStyle {
                                   readonly type = "simple";
                               }
                               /**
                                * @public
                                */
                               export declare interface SizePoint extends Point {
                                   size: number;
                               }
                               /**
                                * Interface for a data point that contains an associated size property.
                                *
                                * Can be used for individual configuration of data points size.
                                *
                                * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
                                * Refer to series documentation for more detailed information.
                                * @public
                                */
                               export declare interface SizeValue {
                                   /**
                                    * Numeric size associated with the data point.
                                    *
                                    * Can be used for individual configuration of data points size.
                                    *
                                    * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
                                    * Refer to series documentation for more detailed information.
                                    */
                                   readonly size?: number;
                               }
                               /**
                                * Class that represents a single Slice of a Pie Chart.
                                * @public
                                */
                               export declare abstract class Slice extends ChartComponent<never> {
                                   /**
                                    * Set value of Slice.
                                    * @param value - Numeric value
                                    * @returns Slice itself
                                    * @public
                                    */
                                   abstract setValue(value: number): this;
                                   /**
                                    * Get value of Slice.
                                    * @returns Numeric value
                                    * @public
                                    */
                                   abstract getValue(): number;
                                   /**
                                    * Get animated value of Slice.
                                    *
                                    * This always returns the currently **rendered value** of the Slice, which might be delayed by animations.
                                    * @returns Numeric value
                                    * @public
                                    */
                                   abstract getAnimatedValue(): number;
                               }
                               /**
                                * Interface exists for enforcing shared APIs between Pie, Funnel and Pyramid Charts.
                                * @public
                                */
                               export declare interface SlicedCharts<T extends SliceTypes> {
                                   /**
                                    * Set lookup table
                                    * @param lookup - table
                                    * @returns Chart itself
                                    * @public
                                    */
                                   setLUT(value: LUT): this;
                                   /**
                                    * Set fill style of Slices Labels.
                                    * @param value - FillStyle object or function which creates a new style based on previous
                                    * @returns Chart itself
                                    * @public
                                    */
                                   setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Slice Labels.
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getLabelFillStyle(): FillStyle;
                                   /**
                                    * Set font of Slice Labels.
                                    * @param value - FontSettings or mutator function for existing settings
                                    * @returns Chart itself
                                    * @public
                                    */
                                   setLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get font of Slice Labels.
                                    * @returns FontSettings
                                    * @public
                                    */
                                   getLabelFont(): FontSettings;
                                   /**
                                    * Set formatter of Slice Labels.
                                    *
                                    * See {@link SliceLabelFormatters} for a collection of default options.
                                    * @param labelFormatter - SliceLabelFormatter - function which generates text of Labels per Slice.
                                    * @returns Chart itself
                                    * @public
                                    */
                                   setLabelFormatter(labelFormatter: SliceLabelFormatter<T>): this;
                                   /**
                                    * Get formatter of Slice Labels.
                                    * @returns SliceLabelFormatter - function which generates text of Labels per Slice.
                                    * @public
                                    */
                                   getLabelFormatter(): SliceLabelFormatter<T>;
                                   /**
                                    * Set style of Slices fill.
                                    * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Chart will be assigned an incremental index,
                                    * which will be used to pick its fill style from this Palette.
                                    *
                                    * So, for example... We have a Sliced Chart with 5 Slices, and we give it a Palette with only 3 possible values
                                    * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
                                    * Note that this means, that the supplied Palette will have to work in a continuous manner!
                                    *
                                    * @param sliceFillStylePalette - Palette for FillStyle objects
                                    * @returns Chart itself
                                    * @public
                                    */
                                   setSliceFillStyle(sliceFillStylePalette: (index: number, slice: T) => FillStyle): this;
                                   /**
                                    * Get style of Slices fill.
                                    * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Chart will be assigned an incremental index,
                                    * which will be used to pick its fill style from this Palette.
                                    *
                                    * So, for example... We have a Sliced Chart with 5 Slices, and we give it a Palette with only 3 possible values
                                    * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
                                    * Note that this means, that the supplied Palette will have to work in a continuous manner!
                                    *
                                    * @returns Palette<FillStyle>
                                    * @public
                                    */
                                   getSliceFillStyle(): (index: number, slice: T) => FillStyle;
                                   /**
                                    * Set style of Slices Stroke.
                                    * @param value - LineStyle object or function which creates a new style based on previous
                                    * @returns Chart itself
                                    * @public
                                    */
                                   setSliceStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get style of Slices Stroke.
                                    * @returns LineStyle object
                                    * @public
                                    */
                                   getSliceStrokeStyle(): LineStyle;
                                   /**
                                    * Set sorter of Slices as a comparator-function.
                                    *
                                    * For some commonly needed default implementations, can refer to {@link SliceSorters} collection.
                                    * @param sliceSorter - SliceSorter - function which sorts Slices of the Chart with JavaScript API: Array.sort.
                                    * @returns Chart itself
                                    * @public
                                    */
                                   setSliceSorter(sliceSorter: SliceSorter<T>): this;
                                   /**
                                    * Get sorter of Slices as a comparator-function.
                                    * @returns SliceSorter - function which sorts Slices of the Chart with JavaScript API: Array.sort.
                                    * @public
                                    */
                                   getSliceSorter(): SliceSorter<T>;
                                   /**
                                    * This method is used for the adding slices in the Chart.
                                    * @param title - Slice title
                                    * @param value - Slice value
                                    * @public
                                    */
                                   addSlice(title: string, value: number): T;
                                   /**
                                    * This method is used for the adding multiple slices in the Chart.
                                    * @param multiSlice - Array of slices
                                    * @public
                                    */
                                   addSlices(multiSlice: {
                                       name: string;
                                       value: number;
                                   }[]): Array<T>;
                                   /**
                                    * Set if Slice should be highlighted when hovered over for all Slices.
                                    * @param state - True if Slice should highlight on hover, false if not.
                                    * @returns Chart itself
                                    * @public
                                    */
                                   setSliceHighlightOnHover(state: boolean): this;
                               }
                               /**
                                * Type of function which is used to format text of Slice Labels.
                                * It is a function which generates a string based on a Slice along with some additional information.
                                *
                                * See {@link SliceLabelFormatters}-collection for quick access to some example implementations.
                                *
                                * Use with {@link SlicedCharts.setLabelFormatter}
                                *
                                * Example usage:
                                *```javascript
                                * // Use a default implementation
                                * SlicedCharts.setLabelFormatter(SliceLabelFormatters.NamePlusRelativeValue)
                                * // Use a custom implementation
                                * SlicedCharts.setLabelFormatter((slice, relativeValue) => slice.getValue() + ' ')
                                * ```
                                * @param slice - Slice
                                * @param relativeValue - Value of the Slice as a % of all Slice values
                                * @returns String text for Label
                                * @public
                                */
                               export declare type SliceLabelFormatter<T extends SliceTypes> = (slice: T, relativeValue: number) => string;
                               /**
                                * Collection of some example implementations of {@link SliceLabelFormatters}.
                                *
                                * Use with {@link SlicedCharts.setLabelFormatter}
                                *
                                * Example usage:
                                *```javascript
                                * // Use a default implementation
                                * SlicedCharts.setLabelFormatter(SliceLabelFormatters.NamePlusRelativeValue)
                                * // Use a custom implementation
                                * SlicedCharts.setLabelFormatter((slice, relativeValue) => slice.getValue() + ' ')
                                * ```
                                * @public
                                */
                               export declare const SliceLabelFormatters: {
                                   /**
                                    * Slice Label formatter for `${name}`.
                                    * @public
                                    */
                                   Name: SliceLabelFormatter<SliceTypes>;
                                   /**
                                    * Slice Label formatter for `${name}: ${Math.round(animatedValue)}`.
                                    * @public
                                    */
                                   NamePlusValue: SliceLabelFormatter<SliceTypes>;
                                   /**
                                    * Slice Label formatter for `${name}: ${(relativeValue * 100).toFixed(1)}%`.
                                    * @public
                                    */
                                   NamePlusRelativeValue: SliceLabelFormatter<SliceTypes>;
                               };
                               /**
                                * SliceLabelIndices enum defines types of Slice labels.
                                * @public
                                */
                               export declare enum SliceLabelIndices {
                                   LabelsInsideSlices = 0,
                                   LabelsOnSides = 1
                               }
                               /**
                                * Type of function which is used to sort Slices of a Chart with Slices.
                                * It is a comparator function used with JavaScript API: Array.sort.
                                *
                                * See {@link SliceSorters} collection for quick access to some example implementations.
                                *
                                * Use with {@link SlicedCharts.setSliceSorter}
                                *
                                * Example usage:
                                *```javascript
                                * // Use a default implementation
                                * SlicedCharts.setSliceSorter(SliceSorters.SortByValueDescending)
                                * // Use a custom implementation
                                * SlicedCharts.setSliceSorter((a, b) => a.getValue() - b.getValue())
                                * ```
                                * @param sliceA - Slice A
                                * @param sliceB - Slice B
                                * @returns Number which implies the sorted order between Slices A and B.
                                *                  For more details, refer to Array documentation.
                                * @public
                                */
                               export declare type SliceSorter<T extends SliceTypes> = (sliceA: T, sliceB: T) => number;
                               /**
                                * Collection of some example implementations of {@link SliceSorter}
                                *
                                * Use with {@link SlicedCharts.setSliceSorter}
                                *
                                * Example usage:
                                *```javascript
                                * // Use a default implementation
                                * SlicedCharts.setSliceSorter(SliceSorters.SortByValueDescending)
                                * // Use a custom implementation
                                * SlicedCharts.setSliceSorter((a, b) => a.getValue() - b.getValue())
                                * ```
                                * @public
                                */
                               export declare const SliceSorters: {
                                   /**
                                    * SliceSorter that sorts Slices based on their names using JS API: String.localeCompare.
                                    * @public
                                    */
                                   SortByName: SliceSorter<SliceTypes>;
                                   /**
                                    * SliceSorter that sorts Slices to ascending value order.
                                    * @public
                                    */
                                   SortByValueAscending: SliceSorter<SliceTypes>;
                                   /**
                                    * SliceSorter that sorts Slices to descending value order.
                                    * @public
                                    */
                                   SortByValueDescending: SliceSorter<SliceTypes>;
                                   /**
                                    * Disabled Slice sorting.
                                    * @public
                                    */
                                   None: SliceSorter<SliceTypes>;
                               };
                               /** @public */
                               export declare type SliceTypes = PieSlice | FunnelSlice;
                               /**
                                * Style class for describing a *solid fill color*.
                                *
                                * Instances of SolidFill, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
                                * but instead return a completely new modified object.
                                *
                                * **Properties of SolidFill:**
                                * - `color`: fill color. Construct a *LCJS color* using one of the many available *factories*:
                                *      * {@link ColorRGBA}
                                *      * {@link ColorHEX}
                                *      * {@link ColorCSS}
                                *      * {@link ColorHSV}
                                *
                                * **SolidFill Usage:**
                                *
                                * Use SolidFill with:
                                * - `setFillStyle` methods:
                                *      * {@link PointSeries.setPointFillStyle}
                                *      * {@link ChartXY.setTitleFillStyle}
                                *
                                * ```typescript
                                *  // Example, style points fill with solid red color.
                                *  PointSeries.setPointFillStyle(new SolidFill({
                                *      color: ColorRGBA( 255, 0, 0 )
                                *  }))
                                * ```
                                *
                                * - Creating a {@link SolidLine}, or other *line style*, which can be used for styling a stroke, or border.
                                *
                                * *Watch out!* A common misuse is to attempt styling strokes or borders directly using *fill style* or *color*.
                                * Remember, when calling a `setStrokeStyle` method, a *line style* is expected! Carefully observe the order of wrapped styles: *line style \<- fill style \<- color*
                                *
                                * ```typescript
                                *  // Example, style line series stroke with solid red line.
                                *  LineSeries.setStrokeStyle(new SolidLine({
                                *      thickness: 1,
                                *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
                                *  }))
                                * ```
                                *
                                * **Related information:**
                                *
                                * For more *fill styles*, see:
                                * - {@link emptyFill}
                                * - {@link IndividualPointFill}
                                * - {@link PalettedFill}
                                * - {@link RadialGradientFill}
                                * - {@link LinearGradientFill}
                                * - {@link ImageFill}
                                * @public
                                */
                               export declare class SolidFill extends VisibleFill {
                                   /**
                                    * Construct a SolidFill object, specifying any amount of its properties.
                                    *
                                    * ```typescript
                                    *  // Example using RGBA color factory.
                                    *  const solidRed = new SolidFill({
                                    *      color: ColorRGBA( 255, 0, 0 )
                                    *  })
                                    * ```
                                    *
                                    * ```typescript
                                    *  // Example using HEX color factory.
                                    *  const solidRed = new SolidFill({
                                    *      color: ColorHEX( '#ff0000' )
                                    *  })
                                    * ```
                                    * @param props - Object containing any amount of SolidFill properties.
                                    * @public
                                    */
                                   constructor(props?: Partial<VisibleFillStyleProperties>);
                                   /**
                                    * Get CSS representation of the FillStyle.
                                    * @public
                                    */
                                   toCSS(): string;
                                   /**
                                    * Construct a new SolidFill object based on this one, but with modified color.
                                    *
                                    * Example:
                                    * ```javascript
                                    * // specify new color
                                    * solidfill.setColor( ColorHEX('#F00') )
                                    *
                                    * // change individual color properties
                                    * solidfill.setColor( color => color.setA(80) )
                                    * ```
                                    * @param value - Either a Color object or a function, which will be used to create a new Color based on current value.
                                    * @returns New SolidFill object
                                    * @public
                                    */
                                   setColor(value: Color | ImmutableMutator<Color>): this;
                                   /**
                                    * Get color of SolidFill.
                                    * @returns Color object
                                    * @public
                                    */
                                   getColor(): Color;
                                   /**
                                    * Construct a new SolidFill object based on this one, but with a modified Alpha value.
                                    *
                                    * @param alpha - Value of Alpha channel [0-255]
                                    * @returns New SolidFill object
                                    * @public
                                    */
                                   setA(alpha: number): SolidFill;
                                   /**
                                    * Construct a new SolidFill object based on this one, but with a modified Red value.
                                    *
                                    * @param alpha - Value of Red channel [0-255]
                                    * @returns New SolidFill object
                                    * @public
                                    */
                                   setR(red: number): SolidFill;
                                   /**
                                    * Construct a new SolidFill object based on this one, but with a modified Green value.
                                    *
                                    * @param green - Value of Green channel [0-255]
                                    * @returns New SolidFill object
                                    * @public
                                    */
                                   setG(green: number): SolidFill;
                                   /**
                                    * Construct a new SolidFill object based on this one, but with a modified Blue value.
                                    *
                                    * @param blue - Value of Blue channel [0-255]
                                    * @returns New SolidFill object
                                    * @public
                                    */
                                   setB(blue: number): SolidFill;
                               }
                               /**
                                * Factory for creating a SolidFill palette.
                                * @param colorPalettes - Collection of default colors from PaletteFactory
                                * @param amount - Amount of colors in the palette
                                * @returns A new SolidFill palette
                                * @public
                                */
                               export declare const SolidFillPalette: (colorPalettes: PaletteFactory<Color>, amount: number, color?: Color) => Palette<FillStyle>;
                               /**
                                * Style class for describing a *solid line*.
                                *
                                * Instances of SolidLine, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
                                * but instead return a completely new modified object.
                                *
                                * **Properties of SolidLine:**
                                * - `thickness`: thickness of line as pixels.
                                * - `fillStyle`: description of line fill color. The supported fillStyles vary per component.
                                *
                                * **SolidLine Usage:**
                                *
                                * Use SolidLine with:
                                * - `setStrokeStyle` methods:
                                *      * {@link LineSeries.setStrokeStyle}
                                *      * {@link Axis.setStrokeStyle}
                                *      * {@link CustomTick.setGridStrokeStyle}
                                *      * etc.
                                *
                                * *Watch out!* A common misuse is to attempt styling strokes or borders directly using *fill style* or *color*.
                                * Remember, when calling a `setStrokeStyle` method, a *line style* is expected! Carefully observe the order of wrapped styles: *line style \<- fill style \<- color*
                                *
                                * ```typescript
                                *  // Example, set line series stroke style to 1px solid red.
                                *  LineSeries.setStrokeStyle(new SolidLine({
                                *      thickness: 1,
                                *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
                                *  }))
                                * ```
                                *
                                * **Related information:**
                                *
                                * For more *line styles*, see:
                                * - {@link emptyLine}
                                * - {@link DashedLine}
                                * @public
                                */
                               export declare class SolidLine extends SolidLineStyleRecord implements LineStyle, StylePropFuncs<ThisType<SolidLine>, Omit<SolidLineStyleProperties, 'type' | 'lineType'>> {
                                   /**
                                    * Construct a SolidLine object, specifying any amount of its properties.
                                    *
                                    * ```typescript
                                    *  // Example, 1px solid red line.
                                    *  const solidRed = new SolidLine({
                                    *      thickness: 1,
                                    *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
                                    *  })
                                    *
                                    *  LineSeries.setStrokeStyle(solidRed)
                                    * ```
                                    * @param props - Object containing any amount of SolidLine properties.
                                    * @public
                                    */
                                   constructor(props?: Partial<Omit<SolidLineStyleProperties, 'type' | 'lineType'>>);
                                   /**
                                    * Construct a new Visible line object based on this one, but with modified fill style.
                                    *
                                    * Example (SolidFill):
                                    * ```javascript
                                    * // specify new fillstyle
                                    * solidLineStyle.setFillStyle( new SolidFill({
                                    *  color: ColorHex('#F00')
                                    * }) )
                                    * // change fillstyle properties
                                    * solidLineStyle.setFillStyle(
                                    *  solidfill => solidfill.setA( 80 )
                                    * )
                                    * ```
                                    * @param value - Either a SolidFill object or a function, which will be used to create a new VisibleFill based on current value.
                                    * @returns New SolidLine object
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): SolidLine;
                                   /**
                                    * Get fill style of SolidLine.
                                    * @returns SolidFill object
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Construct a new SolidLine object based on this one, but with modified thickness.
                                    *
                                    * -1 can be used to signify smallest available thickness.
                                    * With most features, this will result in slightly better GPU performance, but less detailed line.
                                    *
                                    * @param thickness - Thickness as pixels.
                                    * @public
                                    */
                                   setThickness(thickness: number | ImmutableMutator<number, number>): this;
                                   /**
                                    * Get thickness of SolidLine
                                    * @returns Thickness as pixels
                                    * @public
                                    */
                                   getThickness(): number;
                               }
                               /**
                                * Interface for all properties of a LineStyle.
                                * @public
                                */
                               export declare interface SolidLineStyleProperties {
                                   type: 'linestyle';
                                   lineType: 'solid' | 'dashed';
                                   /**
                                    * Line fill style.
                                    */
                                   fillStyle: FillStyle;
                                   /**
                                    * Line thickness.
                                    *
                                    * -1 can be used to signify smallest available thickness.
                                    * With most features, this will result in slightly better GPU performance, but less detailed line.
                                    *
                                    * Default value: 1.
                                    */
                                   thickness: number;
                               }
                               /**
                                * Record contractor for LineStyleProperties
                                * @public
                                */
                               declare const SolidLineStyleRecord: Record_2.Factory<SolidLineStyleProperties>;
                               /**
                                * Type that is used to describe behavior of solving nearest data point from a reference location.
                                * This is used by:
                                * - Built-in cursors
                                * - Manual cursors
                                * - Programmatic "solve nearest" methods
                                *
                                * Most often used together with `Chart.setCursorMode` methods.
                                *
                                * **Possible values:**
                                *
                                * - `"show-nearest"` - show the nearest value to reference location.
                                * - `"show-nearest-interpolated"` - show the nearest interpolated value to reference location.
                                * - `"show-pointed"` - show the exact pointed value (directly under user pointer).
                                * - `"show-pointed-interpolated"` - show the pointed interpolated value (directly under user pointer).
                                * - `"show-all"` - show values from all trackables simultaneously.
                                * - `"show-all-interpolated"` - show interpolated values from all trackables simultaneously.
                                * @public
                                */
                               export declare type SolveNearestMode = 'show-all' | 'show-all-interpolated' | 'show-nearest' | 'show-nearest-interpolated' | 'show-pointed' | 'show-pointed-interpolated';
                               /**
                                * @public
                                */
                               export declare interface SolveResult<CursorPositionType = unknown> {
                                   readonly cursorPosition: CursorPositionType;
                               }
                               /**
                                * @public
                                */
                               export declare interface SolveResult2D extends SolveResult<CursorPosition2D> {
                               }
                               /**
                                * @public
                                */
                               export declare interface SolveResult3D extends SolveResult<CursorPosition3D> {
                                   readonly axisX: Axis3D;
                                   readonly axisY: Axis3D;
                                   readonly axisZ: Axis3D;
                                   readonly x: number;
                                   readonly y: number;
                                   readonly z: number;
                                   readonly series: Series3D;
                               }
                               /**
                                * @public
                                */
                               export declare interface SolveResultBar extends SolveResult2D {
                                   category: string;
                                   subCategory?: string;
                                   value: number;
                                   bar: BarChartBar;
                               }
                               /**
                                * @public
                                */
                               export declare type SolveResultBoxSeries = SolveResultXY & Point & {
                                   figure: BoxFigure;
                               } & BoxFigureDimensions;
                               /**
                                * @public
                                */
                               export declare interface SolveResultBoxSeries3D extends SolveResult3D {
                                   readonly xSize: number;
                                   readonly ySize: number;
                                   readonly zSize: number;
                                   readonly r: number | undefined;
                                   readonly g: number | undefined;
                                   readonly b: number | undefined;
                                   readonly a: number | undefined;
                                   readonly intensity: number | undefined;
                                   readonly id: string | undefined;
                               }
                               /**
                                * @public
                                */
                               export declare type SolveResultEllipseSeries = SolveResultXY & Point & {
                                   figure: EllipseFigure;
                               } & EllipseDimensions;
                               /**
                                * @public
                                */
                               export declare interface SolveResultFunnelChart extends SolveResult2D {
                                   readonly category: string;
                                   readonly value: number;
                                   readonly relativeValue: number;
                                   readonly slice: FunnelSlice;
                               }
                               /**
                                * @public
                                */
                               export declare interface SolveResultHeatmap extends SolveResultXY {
                                   readonly column: number;
                                   readonly row: number;
                                   readonly intensity: number;
                                   readonly lut: LUT | undefined;
                               }
                               /**
                                * @public
                                */
                               export declare interface SolveResultMap<SelectedMapType extends MapType = MapType> extends SolveResult2D {
                                   readonly region: MapTypeRegionProperties[SelectedMapType];
                                   readonly value: number | undefined;
                                   readonly longitude: number;
                                   readonly latitude: number;
                                   readonly lut: LUT | undefined;
                               }
                               /**
                                * @public
                                */
                               export declare interface SolveResultMeshModel3D extends SolveResult3D {
                                   readonly index: number;
                                   readonly value: number | undefined;
                                   readonly lut: LUT | undefined;
                                   readonly coordModel: Coord3D;
                                   readonly coordAxis: Coord3D;
                               }
                               /**
                                * @public
                                */
                               export declare type SolveResultOHLC = SolveResultXY & OHLCSegment;
                               /**
                                * @public
                                */
                               export declare interface SolveResultParallelCoordinate extends SolveResult2D {
                                   readonly value: number;
                                   readonly series: ParallelCoordinateSeries;
                                   readonly axis: ParallelCoordinateAxis;
                               }
                               /**
                                * @public
                                */
                               export declare interface SolveResultPieChart extends SolveResult2D {
                                   readonly category: string;
                                   readonly value: number;
                                   readonly relativeValue: number;
                                   readonly slice: PieSlice;
                               }
                               /**
                                * @public
                                */
                               export declare interface SolveResultPolar extends SolveResult2D, PolarPoint {
                                   readonly series: PolarSeries;
                               }
                               /**
                                * @public
                                */
                               export declare interface SolveResultPolarHeatmap extends SolveResultPolar {
                                   readonly annulus: number;
                                   readonly sector: number;
                                   readonly intensity: number;
                                   readonly lut: LUT | undefined;
                               }
                               /**
                                * @public
                                */
                               export declare type SolveResultPolygonSeries = SolveResultXY & Point & {
                                   figure: PolygonFigure;
                                   coordinates: Point[];
                               };
                               /**
                                * @public
                                */
                               export declare interface SolveResultPyramidChart extends SolveResult2D {
                                   readonly category: string;
                                   readonly value: number;
                                   readonly relativeValue: number;
                                   readonly slice: PyramidSlice;
                               }
                               /**
                                * @public
                                */
                               export declare type SolveResultRectangleSeries = SolveResultXY & RectangleTwoPoints & {
                                   figure: RectangleFigure;
                                   positionAndSize: RectanglePositionAndSize;
                               };
                               /**
                                * @public
                                */
                               export declare interface SolveResultSampleXY extends SolveResultXY, SampleXY {
                                   /**
                                    * NOTE: When solve result / cursor interpolation is enabled this will not be an integer!
                                    */
                                   readonly iSample: number;
                                   readonly pointShape: undefined | PointShape | Icon;
                               }
                               /**
                                * @public
                                */
                               export declare type SolveResultSegmentSeries = SolveResultXY & Point & {
                                   figure: SegmentFigure;
                               } & SegmentDimensions;
                               /**
                                * @public
                                */
                               export declare interface SolveResultSpider extends SolveResult2D, SpiderPoint {
                                   readonly series: SpiderSeries;
                               }
                               /**
                                * @public
                                */
                               export declare interface SolveResultSurface3D extends SolveResult3D {
                                   readonly column: number;
                                   readonly row: number;
                                   readonly intensity: number | undefined;
                                   readonly lut: LUT | undefined;
                               }
                               /**
                                * @public
                                */
                               export declare type SolveResultTextSeries = SolveResultXY & Point & {
                                   figure: TextFigure;
                               };
                               /**
                                * @public
                                */
                               export declare interface SolveResultTreeMapChart extends SolveResult2D {
                                   readonly name: string;
                                   readonly value: number;
                                   readonly node: TreeMapUserNode;
                               }
                               /**
                                * @public
                                */
                               export declare interface SolveResultXY extends SolveResult<CursorPositionXY> {
                                   readonly axisX: Axis;
                                   readonly axisY: Axis;
                                   readonly series: SeriesXY;
                                   readonly x: number;
                                   readonly y: number;
                                   /**
                                    * Only for AreaRangeSeries and AreaSeriesBipolar (1 series has 2 locations in 1 solve result, high + low).
                                    */
                                   readonly multiHit?: {
                                       x: number;
                                       y: number;
                                   }[];
                               }
                               /**
                                * Description of a _Spark Area Chart_.
                                *
                                * Displays a miniature area chart.
                                *
                                * Can be used with {@link DataGrid}.
                                *
                                * ```ts
                                *  // Example, spark area chart in a DataGrid
                                *  DataGrid.setCellContent(0, 0, {
                                *      type: 'spark-area',
                                *      data: [0, 10, 6, 4, 9, 8, 3, 6],
                                *  })
                                * ```
                                * @public
                                */
                               export declare type SparkAreaChart = {
                                   /**
                                    * Identifier that is used to select the spark chart type.
                                    */
                                   type: 'spark-area';
                                   /**
                                    * Data for spark area chart as a list of XY data points.
                                    *
                                    * ```ts
                                    *  // Example
                                    *  data: [{ x: 0, y: 100 }, { x: 1, y: 200 }, ...]
                                    * ```
                                    */
                                   data: Point[];
                                   /**
                                    * Optional fill style for area.
                                    */
                                   fillStyle?: FillStyle;
                                   /**
                                    * Optional style for area stroke.
                                    */
                                   strokeStyle?: LineStyle;
                                   /**
                                    * Optional list of XY markers for including extra data visualization components along the spark chart.
                                    *
                                    * ```ts
                                    *  // Example, display line at Y axis coordinate
                                    *  markers: [{ type: 'constant-line', axis: 'y', value: 20 }]
                                    * ```
                                    *
                                    * See {@link SparkChartXYMarker} for more information.
                                    */
                                   markers?: SparkChartXYMarker[];
                               };
                               /**
                                * Description of a _Spark Bar Chart_.
                                *
                                * Displays a miniature bar chart.
                                *
                                * Can be used with {@link DataGrid}.
                                *
                                * ```ts
                                *  // Example, spark bar chart in a DataGrid
                                *  DataGrid.setCellContent(0, 0, {
                                *      type: 'spark-bar',
                                *      data: [0, 10, 6, 4, 9, 8, 3, 6]
                                *  })
                                * ```
                                * @public
                                */
                               export declare type SparkBarChart = {
                                   /**
                                    * Identifier that is used to select the spark chart type.
                                    */
                                   type: 'spark-bar';
                                   /**
                                    * Data for bars.
                                    *
                                    * ```ts
                                    *  // Example,
                                    *  data: [ 10, 5, 8, 5, 2 ]
                                    * ```
                                    */
                                   data: number[];
                                   /**
                                    * Size of bar relative to gap.
                                    *
                                    * ```ts
                                    *  // Example, bar = 2 times as wide as gap between bars.
                                    *  barSize: 2,
                                    *  gap: 1
                                    * ```
                                    */
                                   barSize?: number;
                                   /**
                                    * Size of gap between bars relative to width of each bar.
                                    *
                                    * ```ts
                                    *  // Example, bar = 2 times as wide as gap between bars.
                                    *  barSize: 2,
                                    *  gap: 1
                                    * ```
                                    */
                                   gap?: number;
                                   /**
                                    * Optional fill style for Bars.
                                    */
                                   fillStyle?: FillStyle;
                                   /**
                                    * Optional stroke style for Bars.
                                    */
                                   strokeStyle?: LineStyle;
                               };
                               /**
                                * Type definition for a description of a Spark Chart, a simple miniature chart.
                                *
                                * Can be used with {@link DataGrid}.
                                *
                                * ```ts
                                *  // Example, spark line chart in a DataGrid
                                *  DataGrid.setCellContent(0, 0, {
                                *      type: 'spark-line',
                                *      data: [0, 10, 6, 4, 9, 8, 3, 6]
                                *  })
                                * ```
                                *
                                * Supported types of Spark Charts:
                                *
                                * - {@link SparkLineChart}
                                * - {@link SparkBarChart}
                                * - {@link SparkWinLossChart}
                                * - {@link SparkAreaChart}
                                * - {@link SparkPieChart}
                                *
                                * @public
                                */
                               export declare type SparkChart = SparkLineChart | SparkBarChart | SparkWinLossChart | SparkAreaChart | SparkPieChart;
                               /**
                                * Type definition of a Spark Chart Axis Band Marker.
                                * Can be included to show extra information alongside {@link SparkChart | Spark Charts}.
                                * Highlights an interval along 1 Axis (either X or Y).
                                *
                                * ```ts
                                *  // Example, spark line chart with a axis band.
                                *  DataGrid.setCellContent(0, 0, {
                                *      type: 'spark-line',
                                *      data: [0, 10, 6, 4, 9, 8, 3, 6],
                                *      markers: [{
                                *          type: 'axis-band',
                                *          axis: 'x',
                                *          start: 10,
                                *          end: 15,
                                *      }]
                                *  })
                                * ```
                                * @public
                                */
                               export declare type SparkChartAxisBand = {
                                   /**
                                    * Identifier used to select the type of Marker.
                                    */
                                   type: 'axis-band';
                                   /**
                                    * Selection of Axis (X or Y).
                                    */
                                   axis: 'x' | 'y';
                                   /**
                                    * Start location on Axis.
                                    */
                                   start: number;
                                   /**
                                    * End location on Axis.
                                    */
                                   end: number;
                                   /**
                                    * Optional fill style of Band.
                                    */
                                   fillStyle?: FillStyle;
                                   /**
                                    * Optional stroke style of Band.
                                    */
                                   strokeStyle?: LineStyle;
                               };
                               /**
                                * Type definition of a Spark Chart Constant Line Marker.
                                * Can be included to show extra information alongside {@link SparkChart | Spark Charts}.
                                * Highlights an location along 1 Axis (either X or Y).
                                *
                                * ```ts
                                *  // Example, spark line chart with a constant line marker.
                                *  DataGrid.setCellContent(0, 0, {
                                *      type: 'spark-line',
                                *      data: [0, 10, 6, 4, 9, 8, 3, 6],
                                *      markers: [{
                                *          type: 'constant-line',
                                *          axis: 'x',
                                *          value: 10,
                                *      }]
                                *  })
                                * ```
                                * @public
                                */
                               export declare type SparkChartConstantLine = {
                                   /**
                                    * Identifier used to select the type of Marker.
                                    */
                                   type: 'constant-line';
                                   /**
                                    * Selection of Axis (X or Y).
                                    */
                                   axis: 'x' | 'y';
                                   /**
                                    * Location on Axis.
                                    */
                                   value?: number;
                                   /**
                                    * Optional stroke style of Constant line.
                                    */
                                   strokeStyle?: LineStyle;
                               };
                               /**
                                * Type definition of a Spark Chart Point Marker.
                                * Can be included to show extra information alongside {@link SparkChart | Spark Charts}.
                                * Highlights a single XY coordinate with a marker.
                                * Coordinate can be hard defined with data values or automatically assigned from peak value, start, end, etc.
                                *
                                * ```ts
                                *  // Example, spark line chart with a point marker at max Y peak.
                                *  DataGrid.setCellContent(0, 0, {
                                *      type: 'spark-line',
                                *      data: [0, 10, 6, 4, 9, 8, 3, 6],
                                *      markers: [{
                                *          type: 'point',
                                *          value: 'max'
                                *      }]
                                *  })
                                * ```
                                * @public
                                */
                               export declare interface SparkChartPointMarker {
                                   /**
                                    * Identifier used to select the type of Marker.
                                    */
                                   type: 'point';
                                   /**
                                    * Location of the Point Marker. Following values are supported:
                                    *
                                    * - `'start'`: Position marker at the first XY coordinate of the Spark Chart.
                                    * - `'end'`: Position marker at the last XY coordinate of the Spark Chart.
                                    * - `'min'`: Position marker at the lowest XY coordinate of the Spark Chart (along Y axis).
                                    * - `'max'`: Position marker at the highest XY coordinate of the Spark Chart (along Y axis).
                                    * - `{ x: 5, y: 10 }`: Position marker at exactly X = 5, Y = 10.
                                    */
                                   value: Point | 'start' | 'end' | 'min' | 'max';
                                   /**
                                    * Optional shape of marker.
                                    */
                                   shape?: PointShape;
                                   /**
                                    * Optional size of marker.
                                    */
                                   size?: number;
                                   /**
                                    * Optional rotation of marker.
                                    */
                                   rotation?: number;
                                   /**
                                    * Optional fill style of marker.
                                    */
                                   fillStyle?: FillStyle;
                               }
                               /**
                                * Type definition of a Spark Chart XY Marker.
                                * These can be included to show extra information alongside {@link SparkChart | Spark Charts}.
                                *
                                * The following types of markers are supported:
                                *
                                * - {@link SparkChartPointMarker | Point Marker} Highlights a single XY coordinate with a marker. Coordinate can be hard defined with data values or automatically assigned from peak value, start, end, etc.
                                * - {@link SparkChartAxisBand | Axis Band} Highlights an interval along a single Axis (either X or Y).
                                * - {@link SparkChartConstantLine | Constant Line} Highlights a location along a single Axis (either X or Y).
                                *
                                * @public
                                */
                               export declare type SparkChartXYMarker = SparkChartPointMarker | SparkChartAxisBand | SparkChartConstantLine;
                               /**
                                * Description of a _Spark Line Chart_.
                                *
                                * Displays a miniature XY line chart.
                                *
                                * Can be used with {@link DataGrid}.
                                *
                                * ```ts
                                *  // Example, spark line chart in a DataGrid
                                *  DataGrid.setCellContent(0, 0, {
                                *      type: 'spark-line',
                                *      data: [0, 10, 6, 4, 9, 8, 3, 6]
                                *  })
                                * ```
                                * @public
                                */
                               export declare interface SparkLineChart {
                                   /**
                                    * Identifier that is used to select the spark chart type.
                                    */
                                   type: 'spark-line';
                                   /**
                                    * Data for spark line chart as a list of XY data points.
                                    *
                                    * ```ts
                                    *  // Example
                                    *  data: [{ x: 0, y: 100 }, { x: 1, y: 200 }, ...]
                                    * ```
                                    */
                                   data: Point[];
                                   /**
                                    * Optional style for line.
                                    */
                                   strokeStyle?: LineStyle;
                                   /**
                                    * Optional list of XY markers for including extra data visualization components along the spark chart.
                                    *
                                    * ```ts
                                    *  // Example, display line at Y axis coordinate
                                    *  markers: [{ type: 'constant-line', axis: 'y', value: 20 }]
                                    * ```
                                    *
                                    * See {@link SparkChartXYMarker} for more information.
                                    */
                                   markers?: SparkChartXYMarker[];
                               }
                               /**
                                * Description of a _Spark Pie Chart_.
                                *
                                * Displays a miniature pie chart.
                                *
                                * Can be used with {@link DataGrid}.
                                *
                                * ```ts
                                *  // Example, spark pie chart in a DataGrid
                                *  DataGrid.setCellContent(0, 0, {
                                *      type: 'spark-pie',
                                *      data: [0, 10, 6, 4, 9, 8, 3, 6]
                                *  })
                                * ```
                                *
                                * Alternatively, each slice can be assigned an individual fill style:
                                *
                                * ```ts
                                *  // Example, spark pie chart in a DataGrid
                                *  DataGrid.setCellContent(0, 0, {
                                *      type: 'spark-pie',
                                *      data: [
                                *          { value: 5, fillStyle: new SolidFill({ color: ColorCSS('red') }) },
                                *          { value: 8, fillStyle: new SolidFill({ color: ColorCSS('green') }) },
                                *          { value: 3, fillStyle: new SolidFill({ color: ColorCSS('blue') }) },
                                *      ]
                                *  })
                                * ```
                                *
                                * @public
                                */
                               export declare type SparkPieChart = {
                                   /**
                                    * Identifier that is used to select the spark chart type.
                                    */
                                   type: 'spark-pie';
                                   /**
                                    * Data for pie slices as either list of numbers or list of numbers and fill styles.
                                    *
                                    * ```ts
                                    *  // Example, all slices same style
                                    *  data: [0, 10, 6, 4, 9, 8, 3, 6]
                                    * ```
                                    *
                                    * ```ts
                                    *  // Example, individual styles
                                    *  data: [
                                    *      { value: 5, fillStyle: new SolidFill({ color: ColorCSS('red') }) },
                                    *      { value: 8, fillStyle: new SolidFill({ color: ColorCSS('green') }) },
                                    *      { value: 3, fillStyle: new SolidFill({ color: ColorCSS('blue') }) },
                                    *  ]
                                    * ```
                                    */
                                   data: number[] | {
                                       value: number;
                                       fillStyle: FillStyle;
                                   }[];
                                   /**
                                    * Optional stroke style for slices.
                                    */
                                   strokeStyle?: LineStyle;
                               };
                               /**
                                * Description of a _Spark Win-Loss Chart_.
                                *
                                * Displays a miniature win-loss chart.
                                *
                                * Can be used with {@link DataGrid}.
                                *
                                * ```ts
                                *  // Example, win-loss chart in a DataGrid
                                *  DataGrid.setCellContent(0, 0, {
                                *      type: 'spark-win-loss',
                                *      data: [0, 10, 6, 4, 9, 8, 3, 6],
                                *      threshold: 5,
                                *  })
                                * ```
                                * @public
                                */
                               export declare type SparkWinLossChart = {
                                   /**
                                    * Identifier that is used to select the spark chart type.
                                    */
                                   type: 'spark-win-loss';
                                   /**
                                    * Data as list of numbers.
                                    *
                                    * ```ts
                                    *  // Example,
                                    *  data: [ 10, 5, 8, 5, 2 ]
                                    * ```
                                    */
                                   data: number[];
                                   /**
                                    * Size of bar relative to gap.
                                    *
                                    * ```ts
                                    *  // Example, bar = 2 times as wide as gap between bars.
                                    *  barSize: 2,
                                    *  gap: 1
                                    * ```
                                    */
                                   barSize?: number;
                                   /**
                                    * Size of gap between bars relative to width of each bar.
                                    *
                                    * ```ts
                                    *  // Example, bar = 2 times as wide as gap between bars.
                                    *  barSize: 2,
                                    *  gap: 1
                                    * ```
                                    */
                                   gap?: number;
                                   /**
                                    * Win-loss threshold. Data values above this are considered as "win" and below "loss".
                                    */
                                   threshold?: number;
                                   /**
                                    * Optional fill style for "win" bars.
                                    */
                                   winFillStyle?: FillStyle;
                                   /**
                                    * Optional fill style for "loss" bars.
                                    */
                                   lossFillStyle?: FillStyle;
                                   /**
                                    * Optional stroke style bars.
                                    */
                                   strokeStyle?: LineStyle;
                               };
                               /**
                                * Container for shapes of spider axes and drawing logic.
                                * @public
                                */
                               export declare class SpiderAxis {
                                   /**
                                    * @public
                                    */
                                   readonly scale: LinearScaleXY;
                                   /**
                                    * @public
                                    */
                                   readonly chart: SpiderChart;
                                   /**
                                    * @public
                                    */
                                   readonly tag: string;
                                   /**
                                    * @public
                                    */
                                   readonly axisScale: LinearScale1D;
                                   /**
                                    * Format a value along axis to string.
                                    * @param value - Value along axis
                                    * @returns Value formated to string
                                    * @public
                                    */
                                   readonly formatValue: (value: number) => string;
                                   /**
                                    * Update axis label style and return its computed size.
                                    * Used for computation of chart margins before drawing.
                                    * @public
                                    */
                                   getLabelSize(): Point;
                                   /**
                                    * **Permanently** destroy the component.
                                    *
                                    * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                    * **to the component and its children** in application code.
                                    * ```javascript
                                    * let chart = ...Spider()
                                    * let axis = chart.addAxis(category)
                                    * axis.dispose()
                                    * ```
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   dispose(): void;
                                   /**
                                    * Get the axis tag.
                                    * @returns String tag
                                    * @public
                                    */
                                   getTag(): string;
                                   /**
                                    * Set the interval of Spider Axis.
                                    * @param interval - Object containing interval start and end values.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setInterval(opts: AxisIntervalConfiguration): this;
                                   /**
                                    * Get the currently applied Spider Axis interval.
                                    * @returns Object containing the current start and end of axis.
                                    * @public
                                    */
                                   getInterval(): {
                                       start: number;
                                       end: number;
                                   };
                                   /**
                                    * Set strategy for formatting scale labels.
                                    *
                                    * ```javascript
                                    *  axis.setScaleLabelFormatter((value) => `${value} km`)
                                    * ```
                                    * @param formatter - cb function that formats the values of scale
                                    * @returns Object itself
                                    * @public
                                    */
                                   setScaleLabelFormatter(formatter: FormattingFunction): this;
                                   /**
                                    * Sets the AxisScrollStrategy of Spider Axis
                                    * @param scrollStrategy - AxisScrollStrategy or undefined to disable automatic scrolling.
                                    *                          See {@link AxisScrollStrategies} for a collection of options.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setScrollStrategy(scrollStrategy?: AxisScrollStrategy | (() => AxisScrollStrategy)): this;
                                   /**
                                    * Gets the AxisScrollStrategy of Spider Axis
                                    * @public
                                    */
                                   getScrollStrategy(): AxisScrollStrategy | undefined;
                               }
                               /**
                                * Type of data-structure that defines how an axis label is positioned.
                                * @public
                                */
                               export declare interface SpiderAxisLabelPosition {
                                   /**
                                    * Alignment X [-1, 1], where -1 is left and 1 is right extreme
                                    */
                                   alignmentX: number;
                                   /**
                                    * Alignment Y [-1, 1], where -1 is bottom and 1 is top extreme
                                    */
                                   alignmentY: number;
                                   /**
                                    * Padding in X direction as pixels
                                    */
                                   paddingX: number;
                                   /**
                                    * Padding in Y direction as pixels
                                    */
                                   paddingY: number;
                               }
                               /**
                                * Type of an axis label strategy function.
                                * Defines how axis labels are aligned.
                                * @param result - DataStructure that is used to pass result
                                * @param axisIndex - Index of axis. 0 is always directly up
                                * @param axisCount - Amount of axes in chart
                                * @param axisTag - Name of axis
                                * @param axisAngle - Angle of axis in radians
                                * @param labelPadding - Label padding as set in chart
                                * @returns SpiderAxisLabelPosition (modified first parameter of function)
                                * @public
                                */
                               export declare type SpiderAxisLabelStrategy = (result: SpiderAxisLabelPosition, axisIndex: number, axisCount: number, axisTag: string, axisAngle: number, labelPadding: number) => SpiderAxisLabelPosition;
                               /**
                                * Chart for visualizing data in a radial form as dissected by named axes.
                                *
                                * *Charts* are created by methods of {@link LightningChart} interface or a {@link Dashboard}.
                                *
                                * A **SpiderChart** can have any number of {@link SpiderSeries} added to it using {@link SpiderChart.addSeries}.
                                * Data can then be pushed in with {@link SpiderSeries.addPoints}
                                *
                                * By default, *SpiderChart* automatically creates *Axes* based on the data that are pushed to its *Series*.
                                * @public
                                */
                               export declare class SpiderChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithSeries<SpiderSeries> implements ChartWithCursor<CursorResultTableBackgroundType, CursorPosition2D, Cursor2D<CursorResultTableBackgroundType>, SolveResult2D> {
                                   /**
                                    * Get series of a chart.
                                    * @returns Array of series
                                    * @public
                                    */
                                   getSeries(): SpiderSeries[];
                                   /**
                                    * Get all axes of a chart.
                                    * @returns Array of axes
                                    * @public
                                    */
                                   getAxes(): SpiderAxis[];
                                   /**
                                    * Get axis by tag.
                                    * @returns SpiderAxis or undefined
                                    * @public
                                    */
                                   getAxis(tag: string): SpiderAxis;
                                   setCursor(mutator: Mutator<Cursor2D<CursorResultTableBackgroundType>>): this;
                                   getCursor(): Cursor2D<CursorResultTableBackgroundType>;
                                   setCursorMode(mode: SolveNearestMode | undefined): this;
                                   getCursorMode(): SolveNearestMode | undefined;
                                   setCustomCursor(clbk: undefined | ((event: CursorTargetChangedEvent<SolveResultSpider>) => unknown)): this;
                                   setCursorDynamicBehavior(value: CursorDynamicBehavior): this;
                                   /**
                                    * Set cursor formatting, controlling the text displayed in built-in cursor.
                                    *
                                    * ```ts
                                    *  chart.setCursorFormatting((_, hit, hits) => {
                                    *      return [
                                    *          ['Cursor pointing at'],
                                    *          [hit.series], // returning a series will display the series color and its name automatically.
                                    *          ['X', '', hit.axisX.formatValue(hit.x)], // utilizing axis formatValue is useful for considering active zoom level and type of axis
                                    *          ['Y', '', hit.y.toFixed(2)], // empty string '' results in gap between cells
                                    *          [{ text: 'Example', font: { weight: 'bold' }, fillStyle: fillRed }] // any cell can also be styled individually
                                    *      ]
                                    *  })
                                    * ```
                                    *
                                    * Before overriding default cursor formatting, it is recommended to check if using {@link GenericAxis.setUnits} or configuring Axis cursor formatting would be enough.
                                    *
                                    * In order to use series specific data properties (e.g. Heatmap sample "intensity"),
                                    * you should use type guards to assert the type of the `SolveResult`:
                                    *
                                    * ```ts
                                    *  // Example of using type guard in cursor formatter
                                    *  Chart.setCursorFormatting((chart, hit, hits) => {
                                    *      if (!isHitHeatmap(hit)) return undefined
                                    *      return [hit.intensity.toFixed(1)]
                                    *  })
                                    * ```
                                    *
                                    * More details in Developer documentation (Features \> Cursor).
                                    * @param   formatter -     Callback function for cursor formatting.
                                    * @returns     Object itself
                                    * @public
                                    */
                                   setCursorFormatting(formatter: CursorFormatterSpiderChart): this;
                                   /**
                                    * Get active cursor formatter.
                                    * @returns     Cursor formatter.
                                    * @public
                                    */
                                   getCursorFormatting(): CursorFormatterSpiderChart;
                                   /**
                                    * Add manually controlled Cursor object.
                                    * These have exactly same functions as built-in cursors but they can be freely controlled by application logic.
                                    *
                                    * ```ts
                                    *  const cursor = chart.addCursor()
                                    * ```
                                    *
                                    * Styling works same as built-in cursors (e.g. {@link setCursor}).
                                    *
                                    * Position is set using `setPosition` method and displayed content using `setResultTable(table => table.setContent(...))`
                                    * For more details, see Developer documentation \> Features \> Cursor \> Manual cursors
                                    *
                                    * @param   cursorBuilder -     Builder for cursor. Can be used to tweak a handful of properties which can't be changed during runtime.
                                    * @returns     Cursor object.
                                    * @public
                                    */
                                   addCursor<ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: CursorBuilder2D<ResultTableBackgroundType>): Cursor2D<ResultTableBackgroundType>;
                                   /**
                                    * Add a new axis to Spider Chart
                                    * @param axis - Axis tag
                                    * @returns Object itself
                                    * @public
                                    */
                                   addAxis(tag: string): SpiderAxis;
                                   /**
                                    * Check if Chart has an Axis with specified tag
                                    * @param tag - Name of desirable axis
                                    * @returns True if axis exists, false if not.
                                    * @public
                                    */
                                   hasAxis: (tag: string) => boolean;
                                   /**
                                    * Adds a new SpiderSeries to the SpiderChart.
                                    * @param options -  Optional object with readonly configuration arguments for SpiderSeries.
                                    *
                                    * ```typescript
                                    *  // Example,
                                    *   SpiderChart.addSeries()
                                    *   SpiderChart.addSeries({ automaticColorIndex: 5 })
                                    *   SpiderChart.addSeries({ pointShape: PointShape.Triangle, automaticColorIndex: 10 })
                                    * ```
                                    *
                                    * @returns SpiderSeries instance
                                    * @public
                                    */
                                   addSeries(options?: SpiderSeriesOptions): SpiderSeries;
                                   /**
                                    * Get number of series inside chart.
                                    * @returns Amount of series inside chart
                                    * @public
                                    */
                                   getSeriesCount(): number;
                                   /**
                                    * Set mode of SpiderCharts web and background.
                                    * @param webMode - Enum SpiderWebMode
                                    * @returns Object itself
                                    * @public
                                    */
                                   setWebMode(webMode: SpiderWebMode): this;
                                   /**
                                    * Get mode of SpiderCharts web and background.
                                    * @returns Enum SpiderWebMode
                                    * @public
                                    */
                                   getWebMode(): SpiderWebMode;
                                   /**
                                    * Set count of 'webs' displayed.
                                    * @param webCount - Count of web lines
                                    * @returns Object itself
                                    * @public
                                    */
                                   setWebCount(webCount: number): this;
                                   /**
                                    * Get count of 'webs' displayed
                                    * @returns Count of web lines
                                    * @public
                                    */
                                   getWebCount(): number;
                                   /**
                                    * Set style of spider charts webs as LineStyle.
                                    * @param value - LineStyle object or mutator to modify existing one
                                    * @returns Object itself
                                    * @public
                                    */
                                   setWebStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get fill style of web lines.
                                    * @returns LineStyle object
                                    * @public
                                    */
                                   getWebStyle(): LineStyle;
                                   /**
                                    * Set fill style of scale labels.
                                    * @param value - FillStyle object or mutator to modify existing one
                                    * @public
                                    */
                                   setScaleLabelStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of scale labels.
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getScaleLabelStyle(): FillStyle;
                                   /**
                                    * Not to be confused with {@link GlowEffect}
                                    * @public
                                    * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
                                    */
                                   setScaleLabelShadow(color: Color | undefined): this;
                                   /**
                                    * Not to be confused with {@link GlowEffect}
                                    * @public
                                    * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
                                    */
                                   getScaleLabelShadow(): Color | undefined;
                                   /**
                                    * Set font of scale labels.
                                    * @param value - FontSettings or mutator function for existing settings
                                    * @returns Object itself
                                    * @public
                                    */
                                   setScaleLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get font of scale labels.
                                    * @returns FontSettings
                                    * @public
                                    */
                                   getScaleLabelFont(): FontSettings;
                                   /**
                                    * Set padding of scale labels.
                                    * @param padding - Padding in pixels
                                    * @returns Object itself
                                    * @public
                                    */
                                   setScaleLabelPadding(padding: pixel): this;
                                   /**
                                    * Get padding of scale labels.
                                    * @returns Padding in pixels
                                    * @public
                                    */
                                   getScaleLabelPadding(): pixel;
                                   /**
                                    * Set strategy for drawing scale labels.
                                    * Defines on which positions labels are drawn and whether they are flipped or not.
                                    * @param scaleLabelStrategy - SpiderScaleLabelStrategy or undefined to never show scale labels
                                    * @returns Object itself
                                    * @public
                                    */
                                   setScaleLabelStrategy(scaleLabelStrategy?: SpiderScaleLabelStrategy): this;
                                   /**
                                    * Set strategy for formatting scale labels.
                                    * This will override all existing and future axes scale label formatters.
                                    *
                                    * ```javascript
                                    *  chart.setScaleLabelFormatter((value) => `${value} km`)
                                    * ```
                                    * @param formatter - cb function that formats the values of scale
                                    * @returns Object itself
                                    * @public
                                    */
                                   setScaleLabelFormatter(formatter: FormattingFunction): this;
                                   /**
                                    * Set fill style of axis labels.
                                    * @param value - FillStyle object or mutator to modify existing one
                                    * @returns Object itself
                                    * @public
                                    */
                                   setAxisLabelStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of axis labels.
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getAxisLabelStyle(): FillStyle;
                                   /**
                                    * Set font of axis labels.
                                    * @param value - FontSettings or mutator function for existing settings
                                    * @returns Object itself
                                    * @public
                                    */
                                   setAxisLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get font of axis labels.
                                    * @returns FontSettings object
                                    * @public
                                    */
                                   getAxisLabelFont(): FontSettings;
                                   /**
                                    * Set theme effect enabled on component or disabled.
                                    *
                                    * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                    * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                    *
                                    * ```ts
                                    *  // Example, disable theme effect from a particular component.
                                    *  Component.setEffect(false)
                                    * ```
                                    *
                                    * For the most part, theme effects are **enabled** by default on most components.
                                    *
                                    * Theme effect is configured with {@link Theme.effect} property.
                                    *
                                    * @param enabled - Theme effect enabled
                                    * @returns          Object itself.
                                    * @public
                                    */
                                   setAxisLabelEffect(enabled: boolean): this;
                                   /**
                                    * Get theme effect enabled on component or disabled.
                                    *
                                    * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                    * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                    *
                                    * ```ts
                                    *  // Example, disable theme effect from a particular component.
                                    *  Component.setEffect(false)
                                    * ```
                                    *
                                    * For the most part, theme effects are **enabled** by default on most components.
                                    *
                                    * Theme effect is configured with {@link Theme.effect} property.
                                    *
                                    * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                                    * @public
                                    */
                                   getAxisLabelEffect(): boolean;
                                   /**
                                    * Set padding of axis labels.
                                    * NOTE: The value of this padding is simply passed to the axis label strategy of chart,
                                    * so overriding the default strategy will naturally leave the handling of padding logic up to you.
                                    * @param padding - Padding in pixels
                                    * @returns Object itself
                                    * @public
                                    */
                                   setAxisLabelPadding(padding: pixel): this;
                                   /**
                                    * Get padding of axis labels.
                                    * NOTE: The value of this padding is simply passed to the axis label strategy of chart,
                                    * so overriding the default strategy will naturally leave the handling of padding logic up to you.
                                    * @returns Padding in pixels
                                    * @public
                                    */
                                   getAxisLabelPadding(): pixel;
                                   /**
                                    * Set strategy for drawing axis labels.
                                    * Defines how axis labels are aligned.
                                    * @param axisLabelStrategy - SpiderAxisLabelStrategy or undefined to never show axis labels
                                    * @returns Object itself
                                    * @public
                                    */
                                   setAxisLabelStrategy(axisLabelStrategy?: SpiderAxisLabelStrategy): this;
                                   /**
                                    * Set style of axes as LineStyle.
                                    * @param value - LineStyle object or mutator to modify existing one
                                    * @returns Object itself
                                    * @public
                                    */
                                   setAxisStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get style of axes as LineStyle.
                                    * @returns LineStyle object
                                    * @public
                                    */
                                   getAxisStyle(): LineStyle;
                                   /**
                                    * Set style of axis nibs as LineStyle.
                                    * @param value - LineStyle object or mutator to modify existing one
                                    * @returns Object itself
                                    * @public
                                    */
                                   setNibStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get style of axis nibs as LineStyle.
                                    * @returns LineStyle object
                                    * @public
                                    */
                                   getNibStyle(): LineStyle;
                                   /**
                                    * Set length of axis nibs in pixels.
                                    * @param length - Sum length of nibs in pixels (both directions)
                                    * @public
                                    */
                                   setNibLength(length: number): this;
                                   /**
                                    * Get length of axis nibs in pixels.
                                    * @returns Length of nibs in pixels
                                    * @public
                                    */
                                   getNibLength(): number;
                                   /**
                                    * Specifies if auto creation of axis is turned on or not
                                    * @param createAxesAutomatically - State of automatic axis creation
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setAutoAxis(createAxesAutomatically: boolean): this;
                                   /**
                                    * @returns Automatic axis creation state
                                    * @public
                                    */
                                   getAutoAxis(): boolean;
                                   /**
                                    * Sets the AxisScrollStrategy of Spider Axes.
                                    * This will override all existing and future axes scroll strategies.
                                    *
                                    * @param scrollStrategy - AxisScrollStrategy or undefined to disable automatic scrolling.
                                    *                          See {@link AxisScrollStrategies} for a collection of options.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setScrollStrategy(scrollStrategy?: AxisScrollStrategy | (() => AxisScrollStrategy)): this;
                                   /**
                                    * Set the default interval of Charts Axes
                                    * @param interval - Object containing interval start and end values.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setAxisInterval(opts: AxisIntervalConfiguration): this;
                                   /**
                                    * **Permanently** destroy the component.
                                    *
                                    * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                    * **to the component and its children** in application code.
                                    * ```javascript
                                    * let chart = ...ChartXY()
                                    * let axisX = chart.getDefaultAxisX()
                                    * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                    * chart.dispose()
                                    * chart = undefined
                                    * axisX = undefined
                                    * ```
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   dispose(): this;
                                   /**
                                    * Get minimum size of Panel.
                                    * Depending on the type of class this value might be automatically computed to fit different elements.
                                    * @returns Vec2 minimum size or undefined if unimplemented
                                    * @public
                                    */
                                   getMinimumSize(): Point | undefined;
                                   addEventListener<K extends keyof SpiderChartEventMap>(type: K, listener: (event: SpiderChartEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof SpiderChartEventMap>(type: K, listener: (event: SpiderChartEventMap[K], info: unknown) => unknown): void;
                               }
                               /**
                                * Interface of events trackable by {@link SpiderChart.addEventListener} and the respective Event types.
                                * @public
                                */
                               export declare interface SpiderChartEventMap extends ChartWithSeriesEventMap<SpiderSeries>, ChartWithCursorEventMap<SolveResultSpider> {
                               }
                               /**
                                * Interface for readonly configuration of {@link SpiderChart}.
                                *
                                * Some properties of `SpiderChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
                                *
                                * ```typescript
                                *  // Example, create chart with specified color theme.
                                *  const chart = LightningChart.Spider({
                                *      theme: Themes.light,
                                *  })
                                * ```
                                *
                                * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
                                *
                                * For *standalone* `SpiderChart`, more parameters are documented in {@link LightningChart.Spider}.
                                *
                                * For *dashboard* `SpiderChart`, more parameters are documented in {@link Dashboard.createSpiderChart}.
                                *
                                *
                                * **Commonly used properties:**
                                *
                                * - {@link SpiderChartOptions.theme}: Specify chart color *theme*.
                                * - {@link SpiderChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
                                *
                                * **Example usage:**
                                *
                                * ```typescript
                                *  // Example 1, create chart with default configuration.
                                *  const chart = LightningChart.Spider({})
                                * ```
                                *
                                * ```typescript
                                *  // Example 2, create chart with specified color theme.
                                *  const chart = LightningChart.Spider({
                                *      theme: Themes.light,
                                *  })
                                * ```
                                * @public
                                */
                               export declare interface SpiderChartOptions<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
                                   /**
                                    * Builder for the charts' *auto cursor*. Use {@link CursorBuilders | CursorBuilders.Spider} to modify the default builder, using methods of {@link Cursor2DBuilder}.
                                    *
                                    * ```typescript
                                    *  // Example, change cursor ResultTable background shape.
                                    *  const chart = LightningChart.Spider({
                                    *      cursorBuilder: CursorBuilders.Spider
                                    *          .setResultTableBackground(UIBackgrounds.Circle)
                                    *  })
                                    * ```
                                    * @public
                                    */
                                   cursorBuilder?: CursorBuilder2D<CursorResultTableBackgroundType>;
                               }
                               /**
                                * Interface that can be used to define {@link SpiderChart} configurations, when inside a  {@link Dashboard},
                                * that can't be changed after creation.
                                *
                                *  Example usage:
                                *```javascript
                                * // Specified Cursor ResultTable Background
                                * { spiderChartOptions: { cursorBuilder: CursorBuilders.Spider.setResultTableBackground(UIBackgrounds.Circle) } }
                                * ```
                                * @public
                                */
                               export declare interface SpiderOptions<CursorResultTableBackgroundType extends UIBackground> extends DashboardCellOptions, SpiderChartOptions<CursorResultTableBackgroundType> {
                               }
                               /**
                                * Interface for data-structure that is used to pass data-points to SpiderSeries.
                                * @public
                                */
                               export declare interface SpiderPoint {
                                   /**
                                    * Name of Axis in SpiderChart.
                                    */
                                   axis: string;
                                   /**
                                    * Numeric data value.
                                    */
                                   value: number;
                               }
                               /**
                                * Type of data-structure that defines how an axis label is positioned on a Spider Chart.
                                * @public
                                */
                               export declare interface SpiderScaleLabelPosition {
                                   /**
                                    * Alignment X [-1, 1], where -1 is left and 1 is right extreme
                                    */
                                   alignmentX: number;
                                   /**
                                    * Alignment Y [-1, 1], where -1 is bottom and 1 is top extreme
                                    */
                                   alignmentY: number;
                                   /**
                                    * Padding in X direction as pixels
                                    */
                                   paddingX: number;
                                   /**
                                    * Padding in Y direction as pixels
                                    */
                                   paddingY: number;
                               }
                               /**
                                * Type of a scale label strategy function.
                                * Defines how scale labels are aligned.
                                *
                                * Supported property types:
                                * - `alignmentX` - Alignment X [-1, 1], where -1 is left and 1 is right extreme
                                * - `alignmentY` - Alignment Y [-1, 1], where -1 is bottom and 1 is top extreme
                                * - `paddingX` - Padding in X direction as pixels
                                * - `paddingY` - Padding in Y direction as pixels
                                * - `chart` - The SpiderChart instance used in the chart.
                                * - `axis` - The SpiderAxis instance representing the axis.
                                * - `axisIndex` - Index of the axis. 0 is always directly up.
                                * - `axisCount` - Total number of axes in the chart.
                                * - `axisTag` - Name of the axis.
                                * - `axisAngle` - Angle of the axis in radians.
                                * - `webIndex` - Index of the web. 0 is always the outer-edge of the spider.
                                * - `webCount` - Total number of webs in the chart.
                                * - `labelPadding` - Padding of the label as set in the chart.
                                *
                                * @param labelInfo - Object containing label position and additional chart, axis, and label information.
                                * @returns SpiderScaleLabelPosition (modified position object) or undefined to not display the label.
                                * @public
                                */
                               export declare type SpiderScaleLabelStrategy = (labelInfo: SpiderScaleLabelPosition & {
                                   chart: SpiderChart;
                                   axis: SpiderAxis;
                                   axisIndex: number;
                                   axisCount: number;
                                   axisTag: string;
                                   axisAngle: number;
                                   webIndex: number;
                                   webCount: number;
                                   labelPadding: number;
                               }) => Partial<SpiderScaleLabelPosition> | undefined;
                               /**
                                * Class that represents a collection of linked data-points inside a {@link SpiderChart}.
                                *
                                * Given data is visualized in the form of a *polygon*, where each {@link SpiderPoint} is an edge
                                * along an *Axis*. This *polygon* can be styled with 3 independent areas:
                                * - fill
                                * - border
                                * - points
                                *
                                * Data is pushed with {@link SpiderSeries.addPoints} in form: **\{ axis: string, value: number \}**
                                * @public
                                */
                               export declare class SpiderSeries extends Series2D<SolveResultSpider> {
                                   /**
                                    * @public
                                    */
                                   readonly scale: LinearScaleXY;
                                   /**
                                    * Adds an arbitrary amount of SpiderPoints to the Series.
                                    *
                                    * Animates transition if its enabled on owning chart.
                                    * @param points - List of SpiderPoints as \{'axis': string, 'value': number\}
                                    * @returns Object itself
                                    * @public
                                    */
                                   addPoints(...points: SpiderPoint[]): this;
                                   /**
                                    * Returns the respective value of a data-point with the given tag (if any)
                                    * @param animated - If set to true, will take series animating into account for result
                                    * @public
                                    */
                                   getValue(tag: string, animated?: boolean): number | undefined;
                                   /**
                                    * Set animation for adding points.
                                    * @param easing - Type of easing for animation or undefined to disable animations
                                    * @param duration - Custom duration for animation in milliseconds.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setAnimationAddPoints(easing?: AnimationEasing, duration?: number): this;
                                   /**
                                    * Set animation for when series visibility changes.
                                    *
                                    * This refers to default interaction when attached LegendEntry is toggled, or alternatively when `setVisible()` method is used.
                                    *
                                    * ```ts
                                    *  // Example, disable animation when visibility changes
                                    *  SpiderSeries.setVisibleStateChangedAnimation(undefined)
                                    * ```
                                    *
                                    * ```ts
                                    *  // Example, specify animation easing and duration
                                    *  SpiderSeries.setVisibleStateChangedAnimation(AnimationEasings.linear, 2000)
                                    * ```
                                    *
                                    * @param easing - Type of easing for animation or undefined to disable animations
                                    * @param duration - Custom duration for animation in milliseconds.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setVisibleStateChangedAnimation(easing?: AnimationEasing, duration?: number): this;
                                   /**
                                    * Set fill style of the Polygon that represents the shape of the Series.
                                    *
                                    * Example use:
                                    *```javascript
                                    * // Create a new style
                                    * SpiderSeries.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                    * // Change transparency
                                    * SpiderSeries.setFillStyle((solidFill) => solidFill.setA(80))
                                    * // Set hidden
                                    * SpiderSeries.setFillStyle(emptyFill)
                                    * ```
                                    *
                                    * @param value - FillStyle which has to be used for recoloring or mutator to modify existing one.
                                    * @returns Series itself for fluent interface.
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * @returns Current series fill style
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set stroke style of the Polygon that represents the shape of the Series.
                                    *
                                    * Supported line styles:
                                    * - {@link SolidLine}
                                    * - {@link emptyLine}
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Specified LineStyle
                                    * SpiderSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                    * // Changed thickness
                                    * SpiderSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
                                    * // Hidden
                                    * SpiderSeries.setStrokeStyle(emptyLine)
                                    * ```
                                    * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
                                    * @returns Chart itself
                                    * @public
                                    */
                                   setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Gets the stroke style of the Polygon that represents the shape of this Series
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                                   /**
                                    * Set point fill style of Series.
                                    * Use {@link IndividualPointFill} object to enable individual coloring of points.
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Create a new style
                                    * SpiderSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                    * // Change transparency
                                    * SpiderSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
                                    * // Set hidden
                                    * SpiderSeries.setPointFillStyle(emptyFill)
                                    * ```
                                    *
                                    * @param fillStyle - FillStyle which has to be used for recoloring or mutator to modify existing one.
                                    * @returns Series itself for fluent interface.
                                    * @public
                                    */
                                   setPointFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * @returns Current point fill style
                                    * @public
                                    */
                                   getPointFillStyle(): FillStyle;
                                   /**
                                    * Set size of point in pixels
                                    * @param size - Size of point in pixels
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setPointSize(size: number): this;
                                   /**
                                    * @returns Size of point in pixels
                                    * @public
                                    */
                                   getPointSize(): number;
                                   /**
                                    * Get shape of points.
                                    *
                                    * This is defined upon creation of series, and cannot be changed afterwards.
                                    * @returns PointShape
                                    * @public
                                    */
                                   getPointShape(): PointShape;
                                   /**
                                    * Set the rotation of points in degrees.
                                    * @param angle - Rotation angle in degrees
                                    * @public
                                    */
                                   setPointRotation(angle: number): this;
                                   /**
                                    * Get the current rotation of points.
                                    * @public
                                    */
                                   getPointRotation(): number;
                                   /**
                                    * Set element visibility.
                                    *
                                    * @param state - `true` when element should be visible and `false` when element should be hidden.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setVisible(state: boolean): this;
                                   addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultSpider) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultSpider) => unknown): void;
                               }
                               /**
                                * Interface describing options for Spider series that can be specified during creation time.
                                *
                                * Used with {@link SpiderChart.addSeries} method.
                                *
                                * @returns          Object itself.
                                * @public
                                */
                               export declare interface SpiderSeriesOptions extends SeriesOptions {
                                   /**
                                    * Points shape of the spider series.
                                    *
                                    * ```ts
                                    *  // Example
                                    *  pointShape: PointShape.Circle
                                    * ```
                                    */
                                   pointShape?: PointShape;
                               }
                               /**
                                * Enum for selecting shape of {@link SpiderChart} "webs" - background, GridStrokes and nibs.
                                *
                                * Use with {@link SpiderChart.setWebMode}
                                * @public
                                */
                               export declare enum SpiderWebMode {
                                   /**
                                    * Traditional Spider Chart with non-curved edges.
                                    */
                                   Normal = 0,
                                   /**
                                    * Background, GridStrokes and nibs will be drawn circular.
                                    */
                                   Circle = 1
                               }
                               /**
                                * Type to describe the icon position on sprite image.
                                * @public
                                */
                               export declare type SpriteImagePosition = {
                                   x: number;
                                   y: number;
                               };
                               /**
                                * Data structure of a **state**.
                                * @public
                                */
                               export declare interface State {
                                   /**
                                    * Name of the state. Eq. 'Florida'. This is case insensitive.
                                    */
                                   name: string;
                               }
                               /**
                                * Description of a _stipple pattern_. This is used with {@link DashedLine} to describe a repeating pattern of ON and OFF sections.
                                *
                                * For majority of use cases, utilizing preset options is heavily recommended: {@link StipplePatterns}.
                                *
                                * For example, a traditional _Dashed_ pattern could be described like ON - OFF - repeat.
                                *
                                * The stipple pattern is defined as an list of numbers. Each number should be an integer that describes a relative length of that ON or OFF section.
                                * The first number of the pattern describes the first ON section, and after that it is alternated.
                                *
                                * ```ts
                                *  // Example stipple pattern
                                *  const stipplePattern = [
                                *      // ON for 1 length
                                *      1,
                                *      // OFF for 2 length
                                *      2,
                                *      // ...
                                *  ]
                                * ```
                                * @public
                                */
                               export declare type StipplePattern = Array<number>;
                               /**
                                * Collection of default {@link StipplePattern}s. These are used with {@link DashedLine} to style a line that repeats a pattern of ON and OFF sections.
                                *
                                * Use `StipplePatterns` when creating a new {@link DashedLine}.
                                *
                                * ```typescript
                                *  // Example, set line series stroke style to 1px dashed red.
                                *  LineSeries.setStrokeStyle(new DashedLine({
                                *      thickness: 1,
                                *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }),
                                *      patternScale: StipplePatterns.DashedEqual,
                                *      patternScale: 1,
                                *  }))
                                * ```
                                *
                                * ```ts
                                *  // Example, change stroke style to DashedLine without changing color / thickness
                                *  LineSeries.setStrokeStyle((stroke) => new DashedLine({
                                *      thickness: stroke.getThickness(),
                                *      fillStyle: stroke.getFillStyle(),
                                *      pattern: StipplePatterns.Dashed,
                                *      patternScale: 2,
                                *  }))
                                * ```
                                * @public
                                */
                               export declare const StipplePatterns: {
                                   Dotted: number[];
                                   DottedDense: number[];
                                   Dashed: number[];
                                   DashedEqual: number[];
                                   DashedLoose: number[];
                                   DashDotted: number[];
                               };
                               /**
                                * @public
                                */
                               export declare interface StylableAxisLine {
                                   /**
                                    * Specifies axis stroke
                                    * @param value - Axis stroke style
                                    * @returns Axis itself for fluent interface
                                    * @public
                                    */
                                   setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * @returns Axis stroke as a LineStyle object
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                               }
                               /**
                                * @public
                                */
                               export declare interface StylableAxisTitle {
                                   /**
                                    * @returns Axis title string
                                    * @public
                                    */
                                   getTitle(): string;
                                   /**
                                    * Specifies an Axis title string
                                    * @param title - Axis title as a string
                                    * @returns Axis itself for fluent interface
                                    * @public
                                    */
                                   setTitle(title: string): this;
                                   /**
                                    * @returns Axis title fillstyle
                                    * @public
                                    */
                                   getTitleFillStyle(): FillStyle;
                                   /**
                                    * Specifies Axis title FillStyle
                                    * @param fillStyle - FillStyle of Axis title or mutator to modify existing one
                                    * @returns Axis itself for fluent interface
                                    * @public
                                    */
                                   setTitleFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get font of axis labels.
                                    * @returns FontSettings
                                    * @public
                                    */
                                   getTitleFont(): FontSettings;
                                   /**
                                    * Set font of Axis title.
                                    * @param value - FontSettings or mutator function for existing settings
                                    * @returns Object itself
                                    * @public
                                    */
                                   setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Set theme effect enabled on component or disabled.
                                    *
                                    * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                    * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                    *
                                    * ```ts
                                    *  // Example, disable theme effect from a particular component.
                                    *  Component.setEffect(false)
                                    * ```
                                    *
                                    * For the most part, theme effects are **enabled** by default on most components.
                                    *
                                    * Theme effect is configured with {@link Theme.effect} property.
                                    *
                                    * @param enabled - Theme effect enabled
                                    * @returns          Object itself.
                                    * @public
                                    */
                                   setTitleEffect(enabled: boolean): this;
                                   /**
                                    * Get theme effect enabled on component or disabled.
                                    *
                                    * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                    * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                    *
                                    * ```ts
                                    *  // Example, disable theme effect from a particular component.
                                    *  Component.setEffect(false)
                                    * ```
                                    *
                                    * For the most part, theme effects are **enabled** by default on most components.
                                    *
                                    * Theme effect is configured with {@link Theme.effect} property.
                                    *
                                    * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                                    * @public
                                    */
                                   getTitleEffect(): boolean;
                               }
                               /**
                                * Interface for an object that has stylable background.
                                * @public
                                */
                               export declare interface StylableBackground<BackgroundType extends UIBackground = UIBackground> extends Highlightable {
                                   /**
                                    * Method for mutating Background of object.
                                    *
                                    * Type of Background is generic, see {@link UIBackground} for minimum interface.
                                    * @param mutator - Mutator function for Background
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setBackground(mutator: Mutator<BackgroundType>): this;
                                   /**
                                    * Get elements Background object
                                    *
                                    * Type of Background is generic, see {@link UIBackground} for minimum interface.
                                    * @returns Background object
                                    * @public
                                    */
                                   getBackground(): BackgroundType;
                                   /**
                                    * Set padding around object in pixels.
                                    * Padding is empty space between the UiElements content and Background
                                    * @param padding - Number with pixel margins for all sides or datastructure with individual pixel paddings
                                    *                      for each side. Any side can be omitted, only passed values will be overridden.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setPadding(padding: Partial<Margin> | number): this;
                                   /**
                                    * Get padding around object in pixels.
                                    * Padding is empty space between the UiElements content and Background
                                    * @returns Margin datastructure
                                    * @public
                                    */
                                   getPadding(): Margin;
                               }
                               /**
                                * Interface for object that has configurations for style of button.
                                * @public
                                */
                               export declare interface StylableButton {
                                   /**
                                    * Set fill style of Button when state is OFF
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setButtonOffFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Button when state is OFF
                                    * @returns Fill style object
                                    * @public
                                    */
                                   getButtonOffFillStyle(): FillStyle;
                                   /**
                                    * Set fill style of Button when state is ON
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setButtonOnFillStyle(value: FillStyle | Mutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Button when state is ON
                                    * @returns Fill style object
                                    * @public
                                    */
                                   getButtonOnFillStyle(): FillStyle;
                                   /**
                                    * @param value - Line style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setButtonStrokeStyle(value: LineStyle | Mutator<LineStyle>): this;
                                   /**
                                    * @returns Line style object
                                    * @public
                                    */
                                   getButtonStrokeStyle(): LineStyle;
                                   /**
                                    * Set size of Button
                                    * @param size - Point or pixel for squared button size
                                    * @returns Object itself
                                    * @public
                                    */
                                   setButtonSize(size: Point | pixel): this;
                                   /**
                                    * Get size of Button
                                    * @returns Size of button as Point
                                    * @public
                                    */
                                   getButtonSize(): Point;
                                   /**
                                    * Set button shape.
                                    *
                                    * ```ts
                                    *  // Example
                                    *  setButtonShape(PointShape.Star)
                                    * ```
                                    *
                                    * See {@link PointShape} for all available options.
                                    *
                                    * @public
                                    */
                                   setButtonShape(shape: PointShape | Icon): this;
                                   /**
                                    * Get button shape.
                                    * @public
                                    */
                                   getButtonShape(): PointShape | Icon;
                               }
                               /**
                                * Interface that provides styling methods for some component.
                                * @public
                                */
                               export declare interface StylableComponent {
                                   /**
                                    * Set fill style
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * @returns Current fill style
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                               }
                               /**
                                * Interface that provides styling methods for some text component.
                                * @public
                                */
                               export declare interface StylableTextComponent extends StylableComponent {
                                   /**
                                    * Set font of text.
                                    * @param value - FontSettings or mutator function for existing settings
                                    * @returns Object itself
                                    * @public
                                    */
                                   setFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get font of text.
                                    * @returns FontSettings
                                    * @public
                                    */
                                   getFont(): FontSettings;
                                   /**
                                    * Set rotation of text.
                                    * @param value - Rotation in degrees
                                    * @returns Object itself
                                    * @public
                                    */
                                   setTextRotation(value: number): this;
                                   /**
                                    * Get rotation of text.
                                    * @returns Rotation in degrees
                                    * @public
                                    */
                                   getTextRotation(): number;
                               }
                               /**
                                * Helper type for any `get<Thing>` getter functions
                                * @public
                                */
                               export declare type StyleGetter<T extends string> = `get${Capitalize<T>}`;
                               /**
                                * Helper type to create getter function type definitions for all keys in given type.
                                *
                                * Used to create getter functions for all properties form a property interface definition.
                                * @public
                                */
                               export declare type StyleGetterPropFuncs<Type> = {
                                   [Key in keyof Type as StyleGetter<Key extends string ? Key : never>]: () => Type[Key];
                               };
                               /**
                                * Enforce consistent style property function generation, naming and types.
                                *
                                * Creates type definitions for setters and getters based on a given property interface.
                                * @public
                                */
                               export declare type StylePropFuncs<Self, Type> = StyleSetterPropFuncs<Self, Type> & StyleGetterPropFuncs<Type>;
                               /**
                                * Helper type for any `set<Thing>` setter functions
                                * @public
                                */
                               export declare type StyleSetter<T extends string> = `set${Capitalize<T>}`;
                               /**
                                * Helper type to create setter function type definitions for all keys in given type.
                                *
                                * Used to create setter functions for all properties form a property interface definition.
                                * @public
                                */
                               export declare type StyleSetterPropFuncs<Self, Type> = {
                                   [Key in keyof Type as StyleSetter<Key extends string ? Key : never>]: (v: Type[Key] | ImmutableMutator<Type[Key]>) => Self;
                               };
                               /**
                                * Styling API for "Text" component.
                                * @public
                                */
                               export declare interface StyleTextAPI {
                                   /**
                                    * Set text fill style object
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * @returns Current text fill style object
                                    * @public
                                    */
                                   getTextFillStyle(): FillStyle;
                                   /**
                                    * Set font of Label.
                                    * @param value - FontSettings or mutator function for existing settings
                                    * @returns Object itself
                                    * @public
                                    */
                                   setTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get font of Label.
                                    * @returns FontSettings
                                    * @public
                                    */
                                   getTextFont(): FontSettings;
                                   /**
                                    * Set rotation of Label.
                                    * @param value - Rotation in degrees
                                    * @returns Object itself
                                    * @public
                                    */
                                   setTextRotation(rotation: number): this;
                                   /**
                                    * Get rotation of Label.
                                    * @returns Rotation in degrees
                                    * @public
                                    */
                                   getTextRotation(): number;
                               }
                               /**
                                * Interface to a single subrange between two LUT steps.
                                * This internal data-structure is used to optimize lookup.
                                * @public
                                */
                               export declare interface SubRange {
                                   /**
                                    * The lowest border of the range.
                                    */
                                   min: LUTStep;
                                   /**
                                    * The highest border of the range.
                                    */
                                   max: LUTStep;
                               }
                               /**
                                * @public
                                */
                               export declare interface SurfaceContourConfiguration {
                                   valueSource: 'intensity' | 'y';
                                   levels: Array<SurfaceContourLevel>;
                               }
                               /**
                                * @public
                                */
                               declare interface _SurfaceContourConfiguration {
                                   valueSource: 'intensity' | 'y';
                                   levels: Array<_SurfaceContourLevel>;
                               }
                               /**
                                * @public
                                */
                               export declare interface SurfaceContourLevel {
                                   value: number;
                                   strokeStyle?: LineStyle;
                               }
                               /**
                                * @public
                                */
                               declare interface _SurfaceContourLevel {
                                   value: number;
                                   strokeStyle: LineStyle;
                               }
                               /**
                                * Interface to update contour lines for surface series.
                                * @public
                                */
                               export declare interface SurfaceContourLines {
                                   /**
                                    * Set contour lines.
                                    *
                                    * ```ts
                                    *  // Example syntax
                                    *  heatmap.setContours({
                                    *      valueSource: 'y',
                                    *      levels: [
                                    *          { value: 10 },
                                    *          {
                                    *              value: 40,
                                    *              strokeStyle: new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(0, 0, 0) }) })
                                    *          }
                                    *      ]
                                    *  })
                                    * ```
                                    * @param   config - Contour config
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setContours(config: SurfaceContourConfiguration | undefined): this;
                                   /**
                                    * Get contour lines configuration.
                                    * @returns Contour config
                                    * @public
                                    */
                                   getContours(): SurfaceContourConfiguration | undefined;
                               }
                               /**
                                * Series for visualizing a 3D Surface Grid inside {@link Chart3D}.
                                *
                                * The grid is defined by imagining a plane along X and Z axis, split to \< COLUMNS \> (cells along X axis) and \< ROWS \> (cells along Z axis)
                                *
                                * The total amount of \< CELLS \> in a surface grid is calculated as `columns * rows`. Each \< CELL \> can be associated with DATA from an user data set.
                                *
                                * This series is optimized for *massive* amounts of data - here are some reference specs to give an idea:
                                *
                                * - A static data set in tens of millions range is rendered in a matter of seconds.
                                * - A data set in tens of millions range can be updated in less than a second.
                                * - Maximum data set size is entirely limited by available memory (RAM). Even billion (1 000 000 000) data points have been visualized on a personal computer.
                                *
                                * **Creating Surface Grid Series:**
                                *
                                * `SurfaceGridSeries3D` are created with {@link Chart3D.addSurfaceGridSeries} method.
                                *
                                * Some properties of `SurfaceGridSeries3D` can only be configured when it is created. Some of these arguments are optional, while some are required.
                                * They are all wrapped in a single object parameter:
                                *
                                * ```typescript
                                *  // Example,
                                *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
                                *      columns: 100,
                                *      rows: 200,
                                *  })
                                * ```
                                *
                                * To learn about these properties, refer to {@link SurfaceGridSeries3DOptions}.
                                *
                                * **Frequently used methods:**
                                *
                                * - Specify cell height data | {@link invalidateHeightMap}
                                * - Specify cell intensity data {@link invalidateIntensityValues}
                                * - Configure fill style | {@link setFillStyle}
                                * - Configure wireframe style | {@link setWireframeStyle}
                                * - Configure intensity interpolation | {@link setIntensityInterpolation}
                                * - Configure cull mode | {@link setCullMode}
                                * - Destroy series permanently | {@link dispose}
                                *
                                * `SurfaceGridSeries3D` is suitable for visualizing a surface with unchanging locations along X and Z axes.
                                *
                                * For visualizing continuous sampling in 3D surface, refer to {@link SurfaceScrollingGridSeries3D}.
                                * @public
                                */
                               export declare class SurfaceGridSeries3D extends Series3D<SolveResultSurface3D> {
                                   /**
                                    * Set start coordinate of Heatmap on its X and Z axis.
                                    * @param   start - Coordinate on axis where 1st heatmap sample will be positioned.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setStart(start: PointXZ | undefined): this;
                                   /**
                                    * Get start coordinate of Heatmap on its X and Z axis.
                                    * @returns     Coordinate on axis where 1st heatmap sample will be positioned.
                                    * @public
                                    */
                                   getStart(): PointXZ;
                                   /**
                                    * Set Step between each consecutive heatmap value on the X and Z Axes.
                                    *
                                    * @param   step - Axis offset between heatmap samples.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setStep(step: PointXZ | undefined): this;
                                   /**
                                    * Get Step between each consecutive heatmap value on the X and Z Axes.
                                    * @returns     Axis offset between heatmap samples.
                                    * @public
                                    */
                                   getStep(): PointXZ;
                                   /**
                                    * Set end coordinate of Heatmap on its X and Z axis.
                                    * @param   end - Coordinate on axis where last heatmap sample will be positioned.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setEnd(end: PointXZ | undefined): this;
                                   /**
                                    * Get end coordinate of Heatmap on its X and Z axis.
                                    * @returns     Coordinate on axis where last heatmap sample will be positioned.
                                    * @public
                                    */
                                   getEnd(): PointXZ;
                                   /**
                                    * Set contour lines. Note that labels are not supported.
                                    *
                                    * ```ts
                                    *  // Example syntax
                                    *  heatmap.setContours({
                                    *      valueSource: 'y'
                                    *      levels: [
                                    *          { value: 10 },
                                    *          {
                                    *              value: 40,
                                    *              strokeStyle: new SolidLine({ thickness: 1, fillStyle: new SolidFill({ color: ColorRGBA(0, 0, 0) }) })
                                    *          }
                                    *      ]
                                    *  })
                                    * ```
                                    * @param   config - Contour config
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setContours(config: SurfaceContourConfiguration | undefined): this;
                                   /**
                                    * Get contour lines configuration.
                                    * @returns Contour config
                                    * @public
                                    */
                                   getContours(): SurfaceContourConfiguration | undefined;
                                   /**
                                    * Set fill style of Surface Grid.
                                    *
                                    * **Supported fill styles:**
                                    *
                                    * {@link PalettedFill}:
                                    *
                                    * Look-up dynamic per-CELL color based on a _look up property_ and a color look up table ({@link LUT}).
                                    *
                                    * `SurfaceGridSeries3D` supports several different look-up modes:
                                    *
                                    * `lookUpProperty: 'value'`:
                                    *
                                    * Color each CELL based on its INTENSITY value. Cell intensity values can be specified with {@link invalidateIntensityValues}.
                                    *
                                    * ```ts
                                    *  // Example, enable dynamic coloring based on cell intensity data.
                                    *  surfaceGridSeries
                                    *      .setFillStyle(new PalettedFill({
                                    *          lookUpProperty: 'value',
                                    *          lut: new LUT({
                                    *              interpolate: true,
                                    *              steps: [
                                    *                  { value: 0, color: ColorRGBA(0, 0, 0) },
                                    *                  { value: 100, color: ColorRGBA(255, 0, 0) }
                                    *              ]
                                    *          })
                                    *      }))
                                    * ```
                                    *
                                    * Note, Surface grid series doesn't currently support {@link LUT.color} (fallback color).
                                    *
                                    * `lookUpProperty: 'x' | 'y' | 'z'`:
                                    *
                                    * Color each CELL based on one of its axis coordinates.
                                    *
                                    * ```ts
                                    *  // Example, enable dynamic coloring based on cell Y coordinate.
                                    *  surfaceGridSeries
                                    *      .setFillStyle(new PalettedFill({
                                    *          lookUpProperty: 'y',
                                    *          lut: new LUT({
                                    *              interpolate: true,
                                    *              steps: [
                                    *                  { value: 0, color: ColorRGBA(0, 0, 0) },
                                    *                  { value: 100, color: ColorRGBA(255, 0, 0) }
                                    *              ]
                                    *          })
                                    *      }))
                                    * ```
                                    *
                                    * Intensity based dynamic coloring can further be configured with {@link setIntensityInterpolation} to enable or disable automatic interpolation of Intensity values.
                                    * This is enabled by default.
                                    *
                                    * {@link SolidFill}:
                                    *
                                    * Solid color for entire Surface Grid fill.
                                    *
                                    * ```ts
                                    *  // Example, solid surface grid fill.
                                    *  heatmapSeries.setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                                    * ```
                                    *
                                    * If only wireframe rendering is desired, using `emptyFill` is recommended for better performance.
                                    *
                                    * {@link emptyFill}:
                                    *
                                    * Disables Surface Grid fill.
                                    *
                                    * ```js
                                    *  // Example, hide heatmap fill and show wireframe.
                                    *  heatmapSeries
                                    *      .setFillStyle(emptyFill)
                                    *      .setWireframeStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                                    * ```
                                    *
                                    * **Related functionality:**
                                    *
                                    * - Color shading style can affect the general coloring of 3D shapes | {@link setColorShadingStyle}.
                                    *
                                    * @param value - FillStyle object or function which modifies current value.
                                    *                  Supported FillStyle types: {@link SolidFill}, {@link PalettedFill}, {@link emptyFill}
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of series.
                                    * @returns FillStyle.
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set wireframe style of Surface Grid.
                                    *
                                    * Wireframe consists of thin lines drawn around the borders of each surface CELL.
                                    * They are generally enabled to improve the perception of surface shape.
                                    *
                                    * Wireframe style is defined as {@link LineStyle}.
                                    *
                                    * ```ts
                                    *  // Example 1, enable wireframe.
                                    *  heatmapSeries.setWireframeStyle(new SolidLine({
                                    *      thickness: 1,
                                    *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                                    *  }))
                                    * ```
                                    *
                                    * ```ts
                                    *  // Example 2, disable wireframe.
                                    *  heatmapSeries.setWireframeStyle(emptyLine)
                                    * ```
                                    *
                                    * At this time, only solid wireframe rendering is supported.
                                    * In future, this could be extended to coloring wireframe based on some dynamic properties (X, Y, Z, Intensity) similarly as surface fill.
                                    *
                                    * **Related functionality:**
                                    *
                                    * - Color shading style can affect the general coloring of 3D shapes | {@link setColorShadingStyle}.
                                    *
                                    * @param value - LineStyle object or function which modifies current value.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get surface grid wireframe style.
                                    * @returns LineStyle object.
                                    * @public
                                    */
                                   getWireframeStyle(): LineStyle;
                                   /**
                                    * Set surface intensity interpolation mode.
                                    *
                                    * **This only affects surface grid with INTENSITY based dynamic coloring**, see {@link setFillStyle} for more information.
                                    *
                                    * This feature is enabled by default (`'bilinear'`).
                                    *
                                    * `'disabled'` or `undefined`: Interpolation disabled; draw data exactly as it is.
                                    *
                                    * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
                                    *
                                    * @param interpolationMode - Surface intensity interpolation mode selection.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setIntensityInterpolation(interpolationMode: IntensityInterpolationMode | undefined): this;
                                   /**
                                    * Get surface intensity interpolation mode.
                                    * @public
                                    */
                                   getIntensityInterpolation(): IntensityInterpolationMode;
                                   /**
                                    * Invalidate range of surface INTENSITY values starting from first column and row,
                                    * updating coloring if a Color look up table ({@link LUT}) has been attached to the series (see {@link SurfaceGridSeries3D.setFillStyle}).
                                    *
                                    * See the other overload of this method for invalidating a surface grid section which doesn't start from the first column and row.
                                    *
                                    * ```js
                                    *  // Example, 3x3 surface full invalidation.
                                    *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
                                    *      dataOrder: 'columns',
                                    *      columns: 3,
                                    *      rows: 3
                                    *  })
                                    *
                                    *  surfaceGridSeries.invalidateIntensityValues([
                                    *      // Column 1 intensity values.
                                    *      [0, 0, 0],
                                    *      // Column 2 intensity values.
                                    *      [1, 1, 1],
                                    *      // Column 3 intensity values.
                                    *      [0, 2, 0],
                                    *  ])
                                    * ```
                                    *
                                    * Data interpretation basis is defined by {@link SurfaceGridSeries3DOptions.dataOrder} property from when the series was created.
                                    * Can be either list of *columns*, or list of *rows*.
                                    *
                                    * `invalidateIntensityValues` can trigger warnings when used controversially.
                                    * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                    *
                                    * @param value - Matrix (array of arrays) of intensity values.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   invalidateIntensityValues(value: number[][] | TypedArray[]): this;
                                   /**
                                    * Invalidate a partial range of surface INTENSITY values, updating coloring if a Color look up table ({@link LUT}) has been attached to the series (see {@link SurfaceGridSeries3D.setFillStyle}).
                                    *
                                    * ```js
                                    *  // Example, 100x10 surface invalidate partial section of surface.
                                    *
                                    *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
                                    *      dataOrder: 'columns',
                                    *      columns: 100,
                                    *      rows: 10
                                    *  })
                                    *
                                    *  surfaceGridSeries.invalidateIntensityValues({
                                    *      // Index of first invalidated column.
                                    *      iColumn: 50,
                                    *      // Index of first invalidated row.
                                    *      iRow: 2,
                                    *      // Intensity values matrix. It's dimensions imply the amount of invalidated columns & rows.
                                    *      values: [
                                    *          // 1st invalidated column intensity values.
                                    *          [1, 1, 1, 1, 1],
                                    *          // 2nd invalidated column intensity values.
                                    *          [2, 2, 2, 2, 2],
                                    *          // 3rd invalidated column intensity values.
                                    *          [1, 0, 0, 0, 1],
                                    *          // 4th invalidated column intensity values.
                                    *          [0, 1, 0, 1, 0],
                                    *          // 5th invalidated column intensity values.
                                    *          [0, 0, 1, 0, 0],
                                    *      ],
                                    *  })
                                    * ```
                                    *
                                    * `invalidateIntensityValues` can trigger warnings when used controversially.
                                    * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                    *
                                    * @param value - Partial invalidation information, where `values` is an intensity value matrix, `iColumn` the first affected column and `iRow` the first affected row.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   invalidateIntensityValues(value: {
                                       iColumn: number;
                                       iRow: number;
                                       values: number[][] | TypedArray[];
                                   }): this;
                                   /**
                                    * Invalidate range of surface HEIGHT values starting from first column and row.
                                    * These values correspond to coordinates along the Y axis.
                                    *
                                    * See the other overload of this method for invalidating a surface grid section which doesn't start from the first column and row.
                                    *
                                    * ```js
                                    *  // Example, 3x3 surface full invalidation.
                                    *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
                                    *      dataOrder: 'columns',
                                    *      columns: 3,
                                    *      rows: 3
                                    *  })
                                    *
                                    *  surfaceGridSeries.invalidateHeightMap([
                                    *      // Column 1 height (Y) values.
                                    *      [0, 0, 0],
                                    *      // Column 2 height (Y) values.
                                    *      [1, 1, 1],
                                    *      // Column 3 height (Y) values.
                                    *      [0, 2, 0],
                                    *  ])
                                    * ```
                                    *
                                    * Data interpretation basis is defined by {@link SurfaceGridSeries3DOptions.dataOrder} property from when the series was created.
                                    * Can be either list of *columns*, or list of *rows*.
                                    *
                                    * `invalidateHeightMap` can trigger warnings when used controversially.
                                    * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                    *
                                    * @param value - Matrix (array of arrays) of height values.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   invalidateHeightMap(value: number[][] | TypedArray[]): this;
                                   /**
                                    * Invalidate a partial range of surface HEIGHT values.
                                    * These values correspond to coordinates along the Y axis.
                                    *
                                    * ```js
                                    *  // Example, 100x10 surface invalidate partial section of surface.
                                    *
                                    *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
                                    *      dataOrder: 'columns',
                                    *      columns: 100,
                                    *      rows: 10
                                    *  })
                                    *
                                    *  surfaceGridSeries.invalidateHeightMap({
                                    *      // Index of first invalidated column.
                                    *      iColumn: 50,
                                    *      // Index of first invalidated row.
                                    *      iRow: 2,
                                    *      // Height (Y) values matrix. It's dimensions imply the amount of invalidated columns & rows.
                                    *      values: [
                                    *          // 1st invalidated column height (Y) values.
                                    *          [1, 1, 1, 1, 1],
                                    *          // 2nd invalidated column height (Y) values.
                                    *          [2, 2, 2, 2, 2],
                                    *          // 3rd invalidated column height (Y) values.
                                    *          [1, 0, 0, 0, 1],
                                    *          // 4th invalidated column height (Y) values.
                                    *          [0, 1, 0, 1, 0],
                                    *          // 5th invalidated column height (Y) values.
                                    *          [0, 0, 1, 0, 0],
                                    *      ],
                                    *  })
                                    * ```
                                    *
                                    * `invalidateIntensityValues` can trigger warnings when used controversially.
                                    * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                    *
                                    * @param value - Partial invalidation information, where `values` is an height (Y) value matrix, `iColumn` the first affected column and `iRow` the first affected row.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   invalidateHeightMap(value: {
                                       iColumn: number;
                                       iRow: number;
                                       values: number[][] | TypedArray[];
                                   }): this;
                                   /**
                                    * Set culling of this Surface grid series.
                                    *
                                    * Culling means skipping drawing of specific geometry parts, based on its orientation.
                                    *
                                    * `'disabled'` -\> full geometry is drawn.
                                    *
                                    * `'cull-back'` -\> the behind of geometry is **not** drawn.
                                    *
                                    * `'cull-front'` -\> the front of geometry is **not** drawn.
                                    *
                                    * Surface series default cull mode is `'disabled'` to show both sides of the surface.
                                    *
                                    * @param mode - `CullMode3D` or `false` | `true` to disable/enable culling respectively.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setCullMode(mode: CullMode3D | boolean): this;
                                   /**
                                    * Get cull mode for this Surface grid series.
                                    *
                                    * Culling means skipping drawing of specific geometry parts, based on its orientation.
                                    *
                                    * `'disabled'` -\> full geometry is drawn.
                                    *
                                    * `'cull-back'` -\> the behind of geometry is **not** drawn.
                                    *
                                    * `'cull-front'` -\> the front of geometry is **not** drawn.
                                    *
                                    * Surface series default cull mode is `'disabled'` to show both sides of the surface.
                                    * @returns Active cull mode.
                                    * @public
                                    */
                                   getCullMode(): CullMode3D;
                                   addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultSurface3D) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultSurface3D) => unknown): void;
                               }
                               /**
                                * Interface for readonly configuration of {@link SurfaceGridSeries3D}.
                                *
                                * **Required properties:**
                                * - {@link SurfaceGridSeries3DOptions.columns}: Amount of cells along X axis.
                                * - {@link SurfaceGridSeries3DOptions.rows}: Amount of cells along Z axis.
                                *
                                * **Optional properties:**
                                *
                                * All or any of these can be omitted or set to `undefined`, in which case a default value is used.
                                *
                                * - {@link SurfaceGridSeries3DOptions.dataOrder}: Specifies interpretation order for Height and Intensity data.
                                * - {@link SurfaceGridSeries3DOptions.start}: Specifies location of first cell on X and Z axes.
                                * - {@link SurfaceGridSeries3DOptions.step}: Specifies step between cells on X and Z axes.
                                * - {@link SurfaceGridSeries3DOptions.end}: Specifies location of last cell on X and Z axes.
                                *
                                * **Example usage:**
                                *
                                * ```typescript
                                *  // Example 1, create surface grid series with minimum configuration.
                                *  const surfaceGrid = Chart3D.addSurfaceGridSeries({
                                *      columns: 100,
                                *      rows: 50,
                                *  })
                                * ```
                                *
                                * See also {@link Chart3D.addSurfaceScrollingGridSeries}.
                                * @public
                                */
                               export declare interface SurfaceGridSeries3DOptions extends SeriesOptions {
                                   /**
                                    * Amount of cells along X axis.
                                    *
                                    * **Required!**
                                    *
                                    * Surface grid data amount is specified as `columns * rows`.
                                    *
                                    * Larger data sets require more memory (RAM) to work. With nearly any setup, tens of millions data points can easily be reached and with good setups even
                                    * billion (1 000 000 000) data points have been properly visualized.
                                    */
                                   columns: number;
                                   /**
                                    * Amount of cells along Z axis.
                                    *
                                    * **Required!**
                                    *
                                    * Surface grid data amount is specified as `columns * rows`.
                                    *
                                    * Larger data sets require more memory (RAM) to work. With nearly any setup, tens of millions data points can easily be reached and with good setups even
                                    * billion (1 000 000 000) data points have been properly visualized.
                                    */
                                   rows: number;
                                   /**
                                    * Specifies interpretation order for Height and Intensity data when using {@link SurfaceGridSeries3D.invalidateHeightMap} or {@link SurfaceGridSeries3D.invalidateIntensityValues}.
                                    *
                                    * `'columns'` -\> Supply lists of "columns"
                                    *
                                    * ```typescript
                                    *  const intensityValues = [
                                    *      [
                                    *          0, // Intensity value column = 0, row = 0
                                    *          0, // Intensity value column = 0, row = 1
                                    *          0, // Intensity value column = 0, row = n
                                    *      ],
                                    *      [
                                    *          0, // Intensity value column = 1, row = 0
                                    *          0, // Intensity value column = 1, row = 1
                                    *          0, // Intensity value column = 1, row = n
                                    *      ],
                                    *  ]
                                    * ```
                                    *
                                    * `'rows'` -\> Supply lists of "rows"
                                    *
                                    * ```typescript
                                    *  const intensityValues = [
                                    *      [
                                    *          0, // Intensity value row = 0, column = 0
                                    *          0, // Intensity value row = 0, column = 1
                                    *          0, // Intensity value row = 0, column = n
                                    *      ],
                                    *      [
                                    *          0, // Intensity value row = 1, column = 0
                                    *          0, // Intensity value row = 1, column = 1
                                    *          0, // Intensity value row = 1, column = n
                                    *      ],
                                    *  ]
                                    * ```
                                    *
                                    * Optional, defaults to `'columns'`.
                                    */
                                   dataOrder?: 'columns' | 'rows';
                               }
                               /**
                                * Series for visualizing a 3D Surface Grid inside {@link Chart3D}, with API for pushing data in a scrolling manner (append new data on top of existing data).
                                *
                                * The grid is defined by imagining a plane along X and Z axis, split to \< COLUMNS \> (cells along X axis) and \< ROWS \> (cells along Z axis)
                                *
                                * The total amount of \< CELLS \> in a surface grid is calculated as `columns * rows`. Each \< CELL \> can be associated with DATA from an user data set.
                                *
                                * This series is optimized for *massive* amounts of data - here are some reference specs to give an idea:
                                *
                                * - A data set of tens of millions data points is rendered in a matter of seconds.
                                * - Maximum data set size is entirely limited by available memory (RAM).
                                *   Even billion (1 000 000 000) data points have been visualized on a personal computer.
                                *   Interacting with massive surface charts (more than tens of millions data points) requires a powerful GPU !
                                * - Scrolling Surface Grid input stream rate is virtually unlimited - even 10 million incoming data points **per second** can easily be processed.
                                *   Application limitations usually come from previously mentioned RAM and/or GPU bottlenecks.
                                *
                                * **Creating Surface Scrolling Grid Series:**
                                *
                                * `SurfaceScrollingGridSeries3D` are created with {@link Chart3D.addSurfaceScrollingGridSeries} method.
                                *
                                * Some properties of `SurfaceScrollingGridSeries3D` can only be configured when it is created. Some of these arguments are optional, while some are required.
                                * They are all wrapped in a single object parameter:
                                *
                                * ```typescript
                                *  // Example,
                                *  const surfaceScrollingGridSeries = Chart3D.addSurfaceScrollingGridSeries({
                                *      columns: 100,
                                *      rows: 200,
                                *  })
                                * ```
                                *
                                * To learn about these properties, refer to {@link SurfaceScrollingGridSeries3DOptions}.
                                *
                                * **Frequently used methods:**
                                *
                                * - Append data | {@link addValues}
                                * - Configure fill style | {@link setFillStyle}
                                * - Configure wireframe style | {@link setWireframeStyle}
                                * - Configure intensity interpolation | {@link setIntensityInterpolation}
                                * - Configure cull mode | {@link setCullMode}
                                * - Destroy series permanently | {@link dispose}
                                *
                                * `SurfaceScrollingGridSeries3D` is designed for visualizing real-time data sources, where either new columns or rows are pushed in periodically.
                                *
                                * For visualizing 3D surface grid with static columns and rows amount, refer to {@link SurfaceGridSeries3D}.
                                * @public
                                */
                               export declare class SurfaceScrollingGridSeries3D extends Series3D<SolveResultSurface3D> {
                                   /**
                                    * Set start coordinate of Heatmap on its X and Z axis.
                                    * @param   start - Coordinate on axis where 1st heatmap sample will be positioned.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setStart(start: PointXZ | undefined): this;
                                   /**
                                    * Get start coordinate of Heatmap on its X and Z axis.
                                    * @returns     Coordinate on axis where 1st heatmap sample will be positioned.
                                    * @public
                                    */
                                   getStart(): PointXZ;
                                   /**
                                    * Set Step between each consecutive heatmap value on the X and Z Axes.
                                    *
                                    * @param   step - Axis offset between heatmap samples.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setStep(step: PointXZ | undefined): this;
                                   /**
                                    * Get Step between each consecutive heatmap value on the X and Z Axes.
                                    * @returns     Axis offset between heatmap samples.
                                    * @public
                                    */
                                   getStep(): PointXZ;
                                   /**
                                    * Set fill style of Surface Grid.
                                    *
                                    * **Supported fill styles:**
                                    *
                                    * {@link PalettedFill}:
                                    *
                                    * Look-up dynamic per-CELL color based on a _look up property_ and a color look up table ({@link LUT}).
                                    *
                                    * `SurfaceScrollingGridSeries3D` supports several different look-up modes:
                                    *
                                    * `lookUpProperty: 'value'`:
                                    *
                                    * Color each CELL based on its INTENSITY value. Cell intensity values can be specified with {@link SurfaceScrollingGridSeries3D.addValues}.
                                    *
                                    * ```ts
                                    *  // Example, enable dynamic coloring based on cell intensity data.
                                    *  surfaceGridSeries
                                    *      .setFillStyle(new PalettedFill({
                                    *          lookUpProperty: 'value',
                                    *          lut: new LUT({
                                    *              interpolate: true,
                                    *              steps: [
                                    *                  { value: 0, color: ColorRGBA(0, 0, 0) },
                                    *                  { value: 100, color: ColorRGBA(255, 0, 0) }
                                    *              ]
                                    *          })
                                    *      }))
                                    * ```
                                    *
                                    * Note, Surface grid series doesn't currently support {@link LUT.color} (fallback color).
                                    *
                                    * `lookUpProperty: 'x' | 'y' | 'z'`:
                                    *
                                    * Color each CELL based on one of its axis coordinates.
                                    *
                                    * ```ts
                                    *  // Example, enable dynamic coloring based on cell Y coordinate.
                                    *  surfaceGridSeries
                                    *      .setFillStyle(new PalettedFill({
                                    *          lookUpProperty: 'y',
                                    *          lut: new LUT({
                                    *              interpolate: true,
                                    *              steps: [
                                    *                  { value: 0, color: ColorRGBA(0, 0, 0) },
                                    *                  { value: 100, color: ColorRGBA(255, 0, 0) }
                                    *              ]
                                    *          })
                                    *      }))
                                    * ```
                                    *
                                    * Intensity based dynamic coloring can further be configured with {@link setIntensityInterpolation} to enable or disable automatic interpolation of Intensity values.
                                    * This is enabled by default.
                                    *
                                    * {@link SolidFill}:
                                    *
                                    * Solid color for entire Surface Grid fill.
                                    *
                                    * ```ts
                                    *  // Example, solid surface grid fill.
                                    *  heatmapSeries.setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                                    * ```
                                    *
                                    * If only wireframe rendering is desired, using `emptyFill` is recommended for better performance.
                                    *
                                    * {@link emptyFill}:
                                    *
                                    * Disables Surface Grid fill.
                                    *
                                    * ```js
                                    *  // Example, hide heatmap fill and show wireframe.
                                    *  heatmapSeries
                                    *      .setFillStyle(emptyFill)
                                    *      .setWireframeStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                                    * ```
                                    *
                                    * **Related functionality:**
                                    *
                                    * - Color shading style can affect the general coloring of 3D shapes | {@link setColorShadingStyle}.
                                    *
                                    * @param value - FillStyle object or function which modifies current value.
                                    *                  Supported FillStyle types: {@link SolidFill}, {@link PalettedFill}, {@link emptyFill}
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of series.
                                    * @returns FillStyle.
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set wireframe style of Surface Grid.
                                    *
                                    * Wireframe consists of thin lines drawn around the borders of each surface CELL.
                                    * They are generally enabled to improve the perception of surface shape.
                                    *
                                    * Wireframe style is defined as {@link LineStyle}.
                                    *
                                    * ```ts
                                    *  // Example 1, enable wireframe.
                                    *  heatmapSeries.setWireframeStyle(new SolidLine({
                                    *      thickness: 1,
                                    *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                                    *  }))
                                    * ```
                                    *
                                    * ```ts
                                    *  // Example 2, disable wireframe.
                                    *  heatmapSeries.setWireframeStyle(emptyLine)
                                    * ```
                                    *
                                    * At this time, only solid wireframe rendering is supported.
                                    * In future, this could be extended to coloring wireframe based on some dynamic properties (X, Y, Z, Intensity) similarly as surface fill.
                                    *
                                    * **Related functionality:**
                                    *
                                    * - Color shading style can affect the general coloring of 3D shapes | {@link setColorShadingStyle}.
                                    *
                                    * @param value - LineStyle object or function which modifies current value.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get surface grid wireframe style.
                                    * @returns LineStyle object.
                                    * @public
                                    */
                                   getWireframeStyle(): LineStyle;
                                   /**
                                    * Set surface intensity interpolation mode.
                                    *
                                    * **This only affects surface grid with INTENSITY based dynamic coloring**, see {@link setFillStyle} for more information.
                                    *
                                    * This feature is enabled by default (`'bilinear'`).
                                    *
                                    * `'disabled'` or `undefined`: Interpolation disabled; draw data exactly as it is.
                                    *
                                    * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
                                    *
                                    * @param interpolationMode - Surface intensity interpolation mode selection.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setIntensityInterpolation(interpolationMode: IntensityInterpolationMode | undefined): this;
                                   /**
                                    * Get surface intensity interpolation mode.
                                    * @public
                                    */
                                   getIntensityInterpolation(): IntensityInterpolationMode;
                                   /**
                                    * Clear all values added into the series.
                                    *
                                    * ```ts
                                    *  // Example syntax,
                                    *  surfaceScrollingGridSeries.clear()
                                    * ```
                                    *
                                    * This only affects Y and Intensity data. Other than any styles, etc. this will make the series behave as if it was just created.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   clear(): this;
                                   /**
                                    * Append values to the Surface Scrolling Grid Series.
                                    *
                                    * The series type can contain between 1 and 2 different data sets (Y values and Intensity values).
                                    * This same method is used for managing both types of data;
                                    *
                                    * When `addValues` is called, the parameter is wrapped in an object `{ }`, and one of (or both) `yValues` and `intensityValues` can be supplied.
                                    *
                                    * ```ts
                                    *  // Example syntax,
                                    *  surfaceScrollingGridSeries.addValues({
                                    *      yValues: ...
                                    *      intensityValues ...
                                    *  })
                                    * ```
                                    *
                                    * The type of `yValues` and `intensityValues` is a *number matrix*. At first level, it is a list of samples to add.
                                    *
                                    * ```ts
                                    *  yValues: [
                                    *      // Sample 1,
                                    *      // Sample 2
                                    *  ]
                                    * ```
                                    *
                                    * If both `yValues` and `intensityValues` are specified, then their length should be exactly same!
                                    *
                                    * Order of sample data is selected when the series is created;
                                    *
                                    * `scrollDimension: 'columns'` -\>
                                    *
                                    * ```typescript
                                    *  yValues: [
                                    *      [
                                    *          0, // column = 0, row = 0
                                    *          0, // column = 0, row = 1
                                    *          0, // column = 0, row = n
                                    *      ],
                                    *      [
                                    *          0, // column = 1, row = 0
                                    *          0, // column = 1, row = 1
                                    *          0, // column = 1, row = n
                                    *      ],
                                    *  ]
                                    * ```
                                    *
                                    * `scrollDimension: 'rows'` -\>
                                    *
                                    * ```typescript
                                    *  yValues: [
                                    *      [
                                    *          0, // row = 0, column = 0
                                    *          0, // row = 0, column = 1
                                    *          0, // row = 0, column = n
                                    *      ],
                                    *      [
                                    *          0, // row = 1, column = 0
                                    *          0, // row = 1, column = 1
                                    *          0, // row = 1, column = n
                                    *      ],
                                    *  ]
                                    * ```
                                    *
                                    * Example usage:
                                    *
                                    * ```typescript
                                    *  // Create X-scrolling surface series.
                                    *  const scrollingSurfaceSeries = Chart3D.addSurfaceScrollingGridSeries({
                                    *      scrollDimension: 'columns',
                                    *      rows: 5,
                                    *      columns: 50,
                                    *  })
                                    *
                                    *  // Push two Y columns into the series.
                                    *  scrollingSurfaceSeries.addValues({
                                    *      yValues: [
                                    *          [0, 0, 0, 0, 0],
                                    *          [0, 10, 0, 20, 0]
                                    *      ]
                                    *  })
                                    * ```
                                    *
                                    * `addValues` can trigger warnings when used controversially (for example, data overflow).
                                    * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                    *
                                    * @param arg - Object with `yValues` and/or `intensityValues` matrixes to append on top of previously added data.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   addValues(arg: {
                                       yValues?: number[][] | TypedArray[];
                                       intensityValues?: number[][] | TypedArray[];
                                   }): this;
                                   /**
                                    * Invalidate existing and/or add new intensity values in the Surface grid.
                                    * The location along scrolling dimension is identified by a **sample index**.
                                    *
                                    * Sample index `0` would reference the first sample in the grid, whereas `1` the second sample.
                                    * This allows, for example, the modification of previously pushed samples.
                                    *
                                    * This method is also capable of adding new samples into the grid, which happens if the sample index exceeds the currently existing sample count
                                    * (this can be received with {@link getSampleCount} method).
                                    *
                                    * If this method is used to push new samples into the surface grid in a manner where **gaps** form between the new samples and previous ones,
                                    * the gaps are automatically filled by duplicating the previous last surface grid sample!
                                    *
                                    * ```ts
                                    *  // Example, modify last sample pushed to surface grid
                                    *  surfaceSeries.invalidateValues({
                                    *      iSample: surfaceSeries.getSampleCount() - 1,
                                    *      yValues: [[0, 0, 0, 0, 0]]
                                    *  })
                                    * ```
                                    *
                                    * ```ts
                                    *  // Example, update 5 samples starting at sample index 2
                                    *  surfaceSeries.invalidateValues({
                                    *      iSample: 2,
                                    *      yValues: [
                                    *          [0, 0, 0],
                                    *          [0, 0, 0],
                                    *          [0, 0, 0],
                                    *          [0, 0, 0],
                                    *          [0, 0, 0],
                                    *      ]
                                    *  })
                                    * ```
                                    *
                                    * Allows modification of Y and intensity values separately.
                                    *
                                    * @param   arg - Object with sample index and intensity or Y values parameters.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   invalidateValues(arg: {
                                       iSample: number;
                                       yValues?: number[][] | TypedArray[];
                                       intensityValues?: number[][] | TypedArray[];
                                   }): this;
                                   /**
                                    * Get number of samples that have been pushed into the scrolling surface series.
                                    * For empty series this will be `0`.
                                    * @returns     Number of samples in the surface.
                                    * @public
                                    */
                                   getSampleCount(): number;
                                   /**
                                    * Set culling of this Surface grid series.
                                    *
                                    * Culling means skipping drawing of specific geometry parts, based on its orientation.
                                    *
                                    * `'disabled'` -\> full geometry is drawn.
                                    *
                                    * `'cull-back'` -\> the behind of geometry is **not** drawn.
                                    *
                                    * `'cull-front'` -\> the front of geometry is **not** drawn.
                                    *
                                    * Surface series default cull mode is `'disabled'` to show both sides of the surface.
                                    *
                                    * @param mode - `CullMode3D` or `false` | `true` to disable/enable culling respectively.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setCullMode(mode: CullMode3D | boolean): this;
                                   /**
                                    * Get cull mode for this Surface grid series.
                                    *
                                    * Culling means skipping drawing of specific geometry parts, based on its orientation.
                                    *
                                    * `'disabled'` -\> full geometry is drawn.
                                    *
                                    * `'cull-back'` -\> the behind of geometry is **not** drawn.
                                    *
                                    * `'cull-front'` -\> the front of geometry is **not** drawn.
                                    *
                                    * Surface series default cull mode is `'disabled'` to show both sides of the surface.
                                    * @returns Active cull mode.
                                    * @public
                                    */
                                   getCullMode(): CullMode3D;
                                   addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultSurface3D) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultSurface3D) => unknown): void;
                               }
                               /**
                                * Interface for readonly configuration of {@link SurfaceScrollingGridSeries3D}.
                                *
                                * **Required properties:**
                                * - {@link SurfaceScrollingGridSeries3DOptions.columns}: Amount of cells along X axis.
                                * - {@link SurfaceScrollingGridSeries3DOptions.rows}: Amount of cells along Z axis.
                                *
                                * **Optional properties:**
                                *
                                * All or any of these can be omitted or set to `undefined`, in which case a default value is used.
                                *
                                * - {@link SurfaceScrollingGridSeries3DOptions.scrollDimension}: Specifies which dimension (columns or rows) is scrolling.
                                * - {@link SurfaceScrollingGridSeries3DOptions.start}: Specifies location of first cell on X and Z axes.
                                * - {@link SurfaceScrollingGridSeries3DOptions.step}: Specifies step between cells on X and Z axes.
                                *
                                * **Example usage:**
                                *
                                * ```typescript
                                *  // Example 1, create surface grid series with minimum configuration.
                                *  const surfaceGrid = Chart3D.addSurfaceScrollingGridSeries({
                                *      columns: 100,
                                *      rows: 50,
                                *  })
                                * ```
                                *
                                * See also {@link Chart3D.addSurfaceGridSeries}.
                                * @public
                                */
                               export declare interface SurfaceScrollingGridSeries3DOptions extends SeriesOptions {
                                   /**
                                    * Amount of cells along X axis.
                                    *
                                    * **Required!**
                                    *
                                    * If {@link SurfaceScrollingGridSeries3DOptions.scrollDimension} is `'columns'`, then this will specify the amount of cells to keep before the oldest sample is shifted out.
                                    *
                                    * Surface grid data amount is specified as `columns * rows`.
                                    *
                                    * Larger data sets require more memory (RAM) to work. With nearly any setup, tens of millions data points can easily be reached and with good setups even
                                    * billion (1 000 000 000) data points have been properly visualized.
                                    */
                                   columns: number;
                                   /**
                                    * Amount of cells along Z axis.
                                    *
                                    * **Required!**
                                    *
                                    * If {@link SurfaceScrollingGridSeries3DOptions.scrollDimension} is `'rows'`, then this will specify the amount of cells to keep before the oldest sample is shifted out.
                                    *
                                    * Surface grid data amount is specified as `columns * rows`.
                                    *
                                    * Larger data sets require more memory (RAM) to work. With nearly any setup, tens of millions data points can easily be reached and with good setups even
                                    * billion (1 000 000 000) data points have been properly visualized.
                                    */
                                   rows: number;
                                   /**
                                    * Select scrolling dimension, as well as how to interpret grid matrix values supplied by user.
                                    *
                                    * If `columns` is selected, then there will be no limit on how many *columns* can be pushed to the series, but *rows* amount will be static.
                                    *
                                    * If `rows` is selected, then there will be no limit on how many *rows* can be pushed to the series, but *columns* amount will be static.
                                    *
                                    * Data order:
                                    *
                                    * `'columns'` -\> Supply lists of "columns"
                                    *
                                    * ```typescript
                                    *  const intensityValues = [
                                    *      [
                                    *          0, // Intensity value column = 0, row = 0
                                    *          0, // Intensity value column = 0, row = 1
                                    *          0, // Intensity value column = 0, row = n
                                    *      ],
                                    *      [
                                    *          0, // Intensity value column = 1, row = 0
                                    *          0, // Intensity value column = 1, row = 1
                                    *          0, // Intensity value column = 1, row = n
                                    *      ],
                                    *  ]
                                    * ```
                                    *
                                    * `'rows'` -\> Supply lists of "rows"
                                    *
                                    * ```typescript
                                    *  const intensityValues = [
                                    *      [
                                    *          0, // Intensity value row = 0, column = 0
                                    *          0, // Intensity value row = 0, column = 1
                                    *          0, // Intensity value row = 0, column = n
                                    *      ],
                                    *      [
                                    *          0, // Intensity value row = 1, column = 0
                                    *          0, // Intensity value row = 1, column = 1
                                    *          0, // Intensity value row = 1, column = n
                                    *      ],
                                    *  ]
                                    * ```
                                    *
                                    * Optional, defaults to `'columns'`.
                                    */
                                   scrollDimension?: 'columns' | 'rows';
                               }
                               /**
                                * Interface for object that can be switched on/off and that can have respective event-subscriptions
                                * @public
                                */
                               export declare interface Switchable extends EventInterface<SwitchEventMap> {
                                   /**
                                    * Set state of switchable object.
                                    *
                                    * **NOTE: If *Switchable*.getLocked() == true, this method will not do anything.!**
                                    * @param isOn - State as boolean flag
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setOn(isOn: boolean): this;
                                   /**
                                    * @returns State as boolean flag
                                    * @public
                                    */
                                   getOn(): boolean;
                                   /**
                                    * Set whether *Switchable* is locked or not. When locked, clicking on the UI component will not switch its state.
                                    * @param isLocked - state
                                    * @returns State as boolean flag
                                    * @public
                                    */
                                   setLocked(isLocked: boolean): this;
                                   /**
                                    * @returns State of isLocked boolean flag
                                    * @public
                                    */
                                   getLocked(): boolean;
                               }
                               /**
                                * @public
                                */
                               export declare interface SwitchEvent {
                                   state: boolean;
                               }
                               /**
                                * Interface of events trackable by {@link Switchable.addEventListener} and the respective Event types.
                                * @public
                                */
                               export declare interface SwitchEventMap {
                                   switch: SwitchEvent;
                               }
                               /**
                                * Convenience function for synchronizing the intervals of `n` amount of Axis.
                                *
                                * ```ts
                                *  // Example, usage syntax.
                                *  synchronizeAxisIntervals(
                                *      chart1.getDefaultAxisX(),
                                *      // Any number of Axis can be passed one after another.
                                *      chart2.getDefaultAxisX()
                                *  )
                                * ```
                                *
                                * `synchronizeAxisIntervals` uses {@link Axis.onIntervalChange}, {@link Axis.onStoppedStateChanged} and {@link Axis.setInterval} methods internally for its logic.
                                *
                                * The return value can be used for removing the synchronization logic at any time.
                                *
                                * @param axes - List of Axis to synchronize. These can be Axis from {@link ChartXY}, {@link Chart3D} or {@link PolarChart}.
                                * @returns Handle for removing created side effects.
                                * @public
                                */
                               export declare const synchronizeAxisIntervals: (...axes: GenericAxis[]) => SynchronizeAxisIntervalsHandle;
                               /**
                                * Handle returned by {@link synchronizeAxisIntervals} for removing created side effects.
                                *
                                * ```ts
                                *  // Example usage.
                                *  // Synchronize Axis intervals.
                                *  const handle = synchronizeAxisIntervals(axis1, axis2)
                                *
                                *  // When you want to remove the synchronization logic, call handle.remove.
                                *  handle.remove()
                                * ```
                                * @public
                                */
                               export declare type SynchronizeAxisIntervalsHandle = {
                                   /**
                                    * Remove side effects created by {@link synchronizeAxisIntervals},
                                    * removing the synchronization logic.
                                    *
                                    * ```ts
                                    *  // Example syntax,
                                    *  SynchronizeAxisIntervalsHandle.remove()
                                    * ```
                                    * @public
                                    */
                                   remove: () => void;
                               };
                               /**
                                * 1 Figure object inside a {@link TextSeries} which can house any number of text objects.
                                * Created with {@link TextSeries.add}
                                * @public
                                */
                               export declare class TextFigure extends Figure<SolveResultTextSeries> {
                                   /**
                                    * Get boundaries that contain figure.
                                    * @returns Interval<Point>
                                    * @public
                                    */
                                   _getBoundaries(): Interval<Point>;
                                   /**
                                    * Get size of text as pixels according to current configuration.
                                    * @returns Size of text as pixels.
                                    * @public
                                    */
                                   getSizePixels(): Point;
                                   /**
                                    * Get bounding box of text in axis coordinates according to current configuration.
                                    *
                                    * The returned value is also widely affected by the overall state of the chart and its axes.
                                    * If chart state has been changed, waiting for the next animation frame might be necessary before this method would return the correct value.
                                    *
                                    * ```ts
                                    *  // Example
                                    *  requestAnimationFrame(() => {
                                    *      console.log(textFigure.getBoundingBox())
                                    *  })
                                    * ```
                                    *
                                    * @returns     Bounding box as `{ min: { x: number, y: number }, max: { x: number, y: number } }`
                                    * @public
                                    */
                                   getBoundingBox(): Interval<Point>;
                                   /**
                                    * Set text to display.
                                    * @param text - Text string to display
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setText(text: string): this;
                                   /**
                                    * Get text that is displayed.
                                    * @returns     Displayed text.
                                    * @public
                                    */
                                   getText(): string;
                                   /**
                                    * Set text location.
                                    * @param location - Location on axis
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setLocation(location: Point): this;
                                   /**
                                    * Get text location
                                    * @returns     Location on axis.
                                    * @public
                                    */
                                   getLocation(): Point;
                                   /**
                                    * Set text alignment (which corner of text is position at configured location)
                                    *
                                    * ```ts
                                    *  // Example, position text by center
                                    *  TextFigure.setAlignment({ x: 0, y: 0 })
                                    * ```
                                    *
                                    * ```ts
                                    *  // Example, position text by center horizontally but bottom vertically
                                    *  TextFigure.setAlignment({ x: 0, y: -1 })
                                    * ```
                                    *
                                    * @param alignment - Alignment, where 0 = center, -1 is left/bottom, +1 is right/top
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setAlignment(alignment: Point): this;
                                   /**
                                    * Get text alignment
                                    * @returns     Alignment, where 0 = center, -1 is left/bottom, +1 is right/top
                                    * @public
                                    */
                                   getAlignment(): Point;
                                   /**
                                    * Set text rotation.
                                    * @param rotation - Rotation as degrees.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setRotation(rotation: number): this;
                                   /**
                                    * Get text rotation
                                    * @returns     Rotation as degrees.
                                    * @public
                                    */
                                   getRotation(): number;
                                   /**
                                    * Set text margin as pixels. This can be used to tweak Text position with pixel based offsets.
                                    * @param margin - Margins as pixels.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setMargin(margin: Partial<Margin>): this;
                                   /**
                                    * Get text margin
                                    * @returns     Margins as pixels.
                                    * @public
                                    */
                                   getMargin(): Margin;
                                   /**
                                    * Not to be confused with {@link GlowEffect}
                                    * @public
                                    * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
                                    */
                                   setLabelShadow(value: Color | undefined): this;
                                   /**
                                    * Not to be confused with {@link GlowEffect}
                                    * @public
                                    * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
                                    */
                                   getLabelShadow(): Color | undefined;
                                   /**
                                    * Set fill style of Text.
                                    * @param value - FillStyle object or mutator to modify existing one
                                    * @returns Object itself
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Text.
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set font of Text.
                                    * @param value - FontSettings object or mutator to modify existing one
                                    * @returns Object itself
                                    * @public
                                    */
                                   setFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get font of Text.
                                    * @returns FontSettings object
                                    * @public
                                    */
                                   getFont(): FontSettings;
                                   /**
                                    * @public
                                    */
                                   getDominantStyle(): FillStyle;
                               }
                               /**
                                * @public
                                */
                               export declare interface TextFigureOptions {
                                   text?: string;
                                   font?: FontSettings;
                                   fillStyle?: FillStyle;
                                   location?: Point;
                                   alignment?: Point;
                                   rotation?: number;
                                   margin?: Margin;
                               }
                               /**
                                * @public
                                * @beta    Introduced in v7.1.0. API may be changed according to user feedback, reports and further development.
                                */
                               export declare interface TextObject {
                                   uid: string;
                                   text: string;
                                   font: string;
                                   color: string;
                                   position: 'absolute';
                                   left: number;
                                   top: number;
                                   padding: string;
                                   alignmentX: number;
                                   alignmentY: number;
                                   rotation: number;
                                   identifier: TextObjectIdentifier;
                                   visible: boolean;
                               }
                               /**
                                * @public
                                * @beta    Introduced in v7.1.0. API may be changed according to user feedback, reports and further development.
                                */
                               export declare enum TextObjectIdentifier {
                                   Other = 0,
                                   CursorResultTable = 1,
                                   CursorTickMarker = 2,
                                   ChartTitle = 3,
                                   AxisTitle = 4
                               }
                               /**
                                * Type of text renderer that can be plugged in using {@link EngineOptions.textRenderer}
                                * @public
                                * @beta    Introduced in v7.1.0. API may be changed according to user feedback, reports and further development.
                                */
                               export declare type TextRenderer = {
                                   update: (info: {
                                       textList: TextObject[];
                                       engine: PublicEngine;
                                       obstructingOverlays: Array<{
                                           p1: CoordinateClient;
                                           p2: CoordinateClient;
                                           blacklist: TextObjectIdentifier[];
                                       }>;
                                   }) => unknown;
                                   measureText?: (text: TextObject) => {
                                       x: number;
                                       y: number;
                                   } | undefined;
                                   getTextBoundingBox?: (text: TextObject) => DOMRect | undefined;
                                   dispose?: (info: {
                                       textList: TextObject[];
                                       engine: PublicEngine;
                                   }) => unknown;
                               };
                               /**
                                * Type of text renderer factory that can be plugged in using {@link EngineOptions.textRenderer}
                                * @public
                                * @beta    Introduced in v7.1.0. API may be changed according to user feedback, reports and further development.
                                */
                               export declare type TextRendererFactory = {
                                   init: (info: {
                                       engine: PublicEngine;
                                       handleEvent: (text: TextObject, event: Event) => void;
                                   }) => TextRenderer;
                               };
                               /**
                                * Series that lets user draw large numbers of individual Text objects in a {@link ChartXY}.
                                *
                                * ```ts
                                *  // Example usage
                                *  const fillText = new SolidFill({ color: ColorRGBA(255, 255, 255) })
                                *  const font = new FontSettings({ font: 'Segoe UI', size: 20 })
                                *  const textSeries = chart.addTextSeries()
                                *      .setEffect(false)
                                *      .setCursorEnabled(false)
                                *      .setHighlightOnHover(false)
                                *      .setDefaultStyle((fig) => fig.setFillStyle(fillText).setFont(font))
                                *
                                *  const textFigure = textSeries.add({ location: { x: 0, y: 0 }, alignment: { x: 0, y: 1 } })
                                * ```
                                *
                                * For all options of text figures, see {@link TextFigureOptions}.
                                * These options can also be later modified freely using methods of {@link TextFigure}.
                                *
                                * Frequently used APIs:
                                *  - {@link TextFigure.getBoundingBox} - get bounding box of a text figure in axis coordinates
                                *  - {@link TextFigure.getSizePixels} - get text size as pixels
                                *
                                * @public
                                */
                               export declare class TextSeries extends FigureSeries<SolveResultTextSeries, TextFigure, TextFigureOptions, LinearScaleXY | MixedScaleXY> {
                                   /**
                                    * Add new figure to the series.
                                    * @returns Created figure
                                    * @public
                                    */
                                   add(options?: TextFigureOptions): TextFigure;
                                   solveNearest(from: CoordinateClient, solveMode?: SolveNearestMode): SolveResultTextSeries | undefined;
                                   addEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultTextSeries) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof ChartComponentEventMap>(type: K, listener: (event: ChartComponentEventMap[K], info: SolveResultTextSeries) => unknown): void;
                               }
                               /**
                                * Interface for supplying readonly configurations to a {@link TextSeries}.
                                * @public
                                */
                               export declare interface TextSeriesOptions extends SeriesOptionsXY {
                               }
                               /**
                                * Interface for all properties of a *library color theme*.
                                *
                                * A collection of default implementations can be accessed by {@link Themes}.
                                *
                                * Color theme of components must be specified when it is created, and can't be changed afterwards (without destroying and recreating the component).
                                *
                                * ```ts
                                *  // Example syntax, select Theme of component
                                *  const chart = lightningChart().ChartXY({
                                *      theme: Themes.light
                                *  })
                                * ```
                                *
                                * All charts within a Dashboard must always have the same theme. Thus, it is configured only when the Dashboard is created.
                                *
                                * ```ts
                                *  // Example syntax, Dashboard theme
                                *  const chart = lightningChart().Dashboard({
                                *      theme: Themes.light,
                                *      numberOfColumns: 1,
                                *      numberOfRows: 3,
                                *  })
                                * ```
                                *
                                * For custom color themes, refer to Developer Documentation \> Themes section.
                                * @public
                                */
                               export declare interface Theme {
                                   /**
                                    * Properties of {@link Theme} that are optional, and officially only used in LightningChart JS Online Examples and projects.
                                    *
                                    * These are guaranteed to be included in all official Library Themes provided by LightningChart, but not required in custom Themes defined by users.
                                    *
                                    * If you want to use example theme properties in your application, then make sure to do these two things:
                                    *
                                    * 1) Use an official Theme supplied by LightningChart.
                                    * 2) If your project requires type safety, then add a sanity check that throws an error if the `Theme.examples` property is `undefined`, like this:
                                    *
                                    * ```ts
                                    *  // Example, ensure official LightningChart JS theme is in use.
                                    *  const theme = chart.getTheme()
                                    *  if (!theme.examples) {
                                    *      throw new Error(`LightningChart JS Theme.examples is undefined. You are probably using an unofficial theme and attempting to access example theme properties!`)
                                    *  }
                                    * ```
                                    */
                                   readonly examples?: ThemeExampleProperties;
                                   /**
                                    * Flag if Theme is dark or not.
                                    *
                                    * For user defined themes, it doesn't have large consequences. However, incorrect use can have a slight negative effect on text sharpness.
                                    * For a Theme with dominantly dark backgrounds, should set the value to `false`.
                                    */
                                   isDark: boolean;
                                   /**
                                    * Selection of Theme effect.
                                    * Either none (`undefined`) or a `GlowEffect`.
                                    *
                                    * For performance reasons only 1 configuration of a glow effect is allowed within an application at the moment.
                                    */
                                   effect: Effect | undefined;
                                   /**
                                    * Convenience flag for controlling whether theme effect should be shown in different Text components by default.
                                    *
                                    * `false` -\> Text components will have disabled theme effect by default.
                                    */
                                   effectsText: boolean;
                                   /**
                                    * Convenience flag for controlling whether theme effect should be shown in dashboard splitters by default.
                                    *
                                    * `false` -\> Dashboard splitters will have disabled theme effect by default.
                                    */
                                   effectsDashboardSplitters: boolean;
                                   lcjsBackgroundFillStyle: FillStyle | ((resourcesBaseUrl: string) => FillStyle);
                                   lcjsBackgroundStrokeStyle: LineStyle;
                                   /**
                                    * Color offset for chart components when highlighted.
                                    *
                                    * ```ts
                                    *  // Example, highlighted components shift towards red.
                                    *  highlightColorOffset: ColorRGBA(100, -50, -50, 0)
                                    * ```
                                    *
                                    * ```ts
                                    *  // Example, highlighted components are darkened.
                                    *  highlightColorOffset: ColorRGBA(-100, -100, -100, 0)
                                    * ```
                                    */
                                   highlightColorOffset: Color;
                                   /**
                                    * Override of {@link highlightColorOffset} for axis overlays (mouse interaction areas).
                                    */
                                   highlightColorOffsetAxisOverlay?: Color;
                                   dashboardSplitterStyle: LineStyle;
                                   panelPadding?: number;
                                   chartXYBackgroundFillStyle: FillStyle;
                                   chartXYBackgroundStrokeStyle: LineStyle;
                                   chartXYTitleFont: FontSettings;
                                   chartXYTitleFillStyle: FillStyle;
                                   chartXYTitleShadow?: Color | undefined;
                                   chartXYTitleMargin?: number;
                                   chartXYSeriesBackgroundFillStyle: FillStyle;
                                   chartXYSeriesBackgroundStrokeStyle: LineStyle;
                                   chartXYZoomingRectangleFillStyle: FillStyle;
                                   chartXYZoomingRectangleStrokeStyle: LineStyle;
                                   lineSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   pointLineSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   pointLineSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   pointSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   pointSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   ellipseSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   ellipseSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   polygonSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   polygonSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   rectangleSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   rectangleSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   segmentSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   boxSeriesBodyFillStyle: FillStyle;
                                   boxSeriesBodyStrokeStyle: LineStyle;
                                   boxSeriesStrokeStyle: LineStyle;
                                   boxSeriesMedianStrokeStyle: LineStyle;
                                   textSeriesFillStyle?: ThemePropertyWithCallbackOption<FillStyle>;
                                   textSeriesFont?: FontSettings;
                                   textSeriesShadow?: Color | undefined;
                                   ohlcCandleThicknessPixels: number;
                                   ohlcCandleBodyFillStylePositive: FillStyle;
                                   ohlcCandleBodyFillStyleNegative: FillStyle;
                                   ohlcCandleTailStrokeStylePositive: LineStyle;
                                   ohlcCandleTailStrokeStyleNegative: LineStyle;
                                   ohlcBarThicknessPixels: number;
                                   ohlcBarStrokeStylePositive: LineStyle;
                                   ohlcBarStrokeStyleNegative: LineStyle;
                                   heatmapGridSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   heatmapGridSeriesWireframeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   heatmapGridSeriesContourStrokeStyle?: LineStyle;
                                   heatmapGridSeriesContourLabelColor?: Color;
                                   heatmapGridSeriesContourLabelFont?: FontSettings;
                                   heatmapGridSeriesContourLabelShadow?: Color | undefined;
                                   heatmapScrollingGridSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   heatmapScrollingGridSeriesWireframeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   areaRangeSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   areaRangeSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   areaRangeSeriesFillStyleInverted: ThemePropertyWithCallbackOption<FillStyle>;
                                   areaRangeSeriesStrokeStyleInverted: ThemePropertyWithCallbackOption<LineStyle>;
                                   areaSeriesBipolarHighFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   areaSeriesBipolarHighStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   areaSeriesBipolarLowFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   areaSeriesBipolarLowStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   areaSeriesPositiveFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   areaSeriesPositiveStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   areaSeriesNegativeFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   areaSeriesNegativeStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   xAxisTitleFont: FontSettings;
                                   xAxisTitleFillStyle: FillStyle;
                                   xAxisStrokeStyle: LineStyle;
                                   xAxisOverlayStyle: FillStyle;
                                   xAxisZoomingBandFillStyle: FillStyle;
                                   xAxisZoomingBandStrokeStyle: LineStyle;
                                   xAxisNumericTicks: NumericTickStrategy;
                                   xAxisDateTimeTicks: DateTimeTickStrategy;
                                   xAxisTimeTicks: TimeTickStrategy;
                                   xAxisMarginAfterTicks?: number;
                                   xAxisMarginAfterTitle?: number;
                                   yAxisTitleFont: FontSettings;
                                   yAxisTitleFillStyle: FillStyle;
                                   yAxisStrokeStyle: LineStyle;
                                   yAxisOverlayStyle: FillStyle;
                                   yAxisZoomingBandFillStyle: FillStyle;
                                   yAxisZoomingBandStrokeStyle: LineStyle;
                                   yAxisNumericTicks: NumericTickStrategy;
                                   yAxisDateTimeTicks: DateTimeTickStrategy;
                                   yAxisTimeTicks: TimeTickStrategy;
                                   yAxisMarginAfterTicks?: number;
                                   yAxisMarginAfterTitle?: number;
                                   bandFillStyle: FillStyle;
                                   bandStrokeStyle: LineStyle;
                                   constantLineStrokeStyle: LineStyle;
                                   barChartBackgroundFillStyle: FillStyle;
                                   barChartBackgroundStrokeStyle: LineStyle;
                                   barChartTitleFont: FontSettings;
                                   barChartTitleFillStyle: FillStyle;
                                   barChartTitleShadow?: Color | undefined;
                                   barChartSeriesBackgroundFillStyle: FillStyle;
                                   barChartSeriesBackgroundStrokeStyle: LineStyle;
                                   barChartBarFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   barChartBarStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   barChartValueAxisTitleFont: FontSettings;
                                   barChartValueAxisTitleFillStyle: FillStyle;
                                   barChartValueAxisStrokeStyle: LineStyle;
                                   barChartValueAxisTicks: NumericTickStrategy;
                                   barChartCategoryAxisTitleFont: FontSettings;
                                   barChartCategoryAxisTitleFillStyle: FillStyle;
                                   barChartCategoryAxisStrokeStyle: LineStyle;
                                   barChartCategoryLabels: BarChartCategoryLabels;
                                   barChartValueLabelsAfterBars: BarChartValueLabelsAfterBars;
                                   barChartValueLabelsInsideBars: BarChartValueLabelsInsideBars;
                                   barChartCornerRadius?: number | undefined;
                                   chart3DBackgroundFillStyle: FillStyle;
                                   chart3DBackgroundStrokeStyle: LineStyle;
                                   chart3DTitleFont: FontSettings;
                                   chart3DTitleFillStyle: FillStyle;
                                   chart3DTitleShadow?: Color | undefined;
                                   chart3DSeriesBackgroundFillStyle: FillStyle;
                                   chart3DSeriesBackgroundStrokeStyle: LineStyle;
                                   chart3DBoundingBoxStrokeStyle: LineStyle;
                                   xAxis3DTitleFont: FontSettings;
                                   xAxis3DTitleFillStyle: FillStyle;
                                   xAxis3DStrokeStyle: LineStyle;
                                   xAxis3DNumericTicks: NumericTickStrategy;
                                   xAxis3DDateTimeTicks: DateTimeTickStrategy;
                                   xAxis3DTimeTicks: TimeTickStrategy;
                                   yAxis3DTitleFont: FontSettings;
                                   yAxis3DTitleFillStyle: FillStyle;
                                   yAxis3DStrokeStyle: LineStyle;
                                   yAxis3DNumericTicks: NumericTickStrategy;
                                   yAxis3DDateTimeTicks: DateTimeTickStrategy;
                                   yAxis3DTimeTicks: TimeTickStrategy;
                                   zAxis3DTitleFont: FontSettings;
                                   zAxis3DTitleFillStyle: FillStyle;
                                   zAxis3DStrokeStyle: LineStyle;
                                   zAxis3DNumericTicks: NumericTickStrategy;
                                   zAxis3DDateTimeTicks: DateTimeTickStrategy;
                                   zAxis3DTimeTicks: TimeTickStrategy;
                                   lineSeries3DStrokeStyle: ThemePropertyWithCallbackOption<SolidLine>;
                                   pointLineSeries3DStrokeStyle: ThemePropertyWithCallbackOption<SolidLine>;
                                   pointLineSeries3DPointStyle: ThemePropertyWithCallbackOption<TriangulatedPoints3D>;
                                   pointSeries3DPointStyle: ThemePropertyWithCallbackOption<TriangulatedPoints3D>;
                                   pointCloudSeries3DPointStyle: ThemePropertyWithCallbackOption<PixelatedPoints3D>;
                                   surfaceGridSeries3DFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   surfaceGridSeries3DWireframeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   surfaceGridSeriesContourStrokeStyle?: LineStyle;
                                   surfaceScrollingGridSeries3DFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   surfaceScrollingGridSeries3DWireframeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   boxSeries3DFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   meshModel3DFillStyle?: FillStyle;
                                   polarChartBackgroundFillStyle: FillStyle;
                                   polarChartBackgroundStrokeStyle: LineStyle;
                                   polarChartTitleFont: FontSettings;
                                   polarChartTitleFillStyle: FillStyle;
                                   polarChartTitleShadow?: Color | undefined;
                                   polarChartSeriesBackgroundFillStyle: FillStyle;
                                   polarChartSeriesBackgroundStrokeStyle: LineStyle;
                                   polarSectorFillStyle: FillStyle;
                                   polarSectorStrokeStyle: LineStyle;
                                   polarAmplitudeAxisTitleFont: FontSettings;
                                   polarAmplitudeAxisTitleFillStyle: FillStyle;
                                   polarAmplitudeAxisTitleShadow?: Color | undefined;
                                   polarAmplitudeAxisStrokeStyle: LineStyle;
                                   polarAmplitudeAxisNumericTicks: NumericTickStrategy;
                                   polarAmplitudeAxisDateTimeTicks: DateTimeTickStrategy;
                                   polarAmplitudeAxisTimeTicks: TimeTickStrategy;
                                   polarRadialAxisTitleFont: FontSettings;
                                   polarRadialAxisTitleFillStyle: FillStyle;
                                   polarRadialAxisStrokeStyle: LineStyle;
                                   polarRadialAxisTickStyle: TickStyle;
                                   polarRadialAxisMarginAfterTicks?: number;
                                   polarLineSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   polarPointLineSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   polarPointLineSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   polarPointSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   polarPointSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   polarPolygonSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   polarPolygonSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   polarAreaSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   polarAreaSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   polarHeatmapSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   mapChartBackgroundFillStyle: FillStyle;
                                   mapChartBackgroundStrokeStyle: LineStyle;
                                   mapChartTitleFont: FontSettings;
                                   mapChartTitleFillStyle: FillStyle;
                                   mapChartTitleShadow?: Color | undefined;
                                   mapChartFillStyle: FillStyle;
                                   mapChartStrokeStyle: LineStyle;
                                   mapChartOutlierRegionFillStyle: FillStyle;
                                   mapChartOutlierRegionStrokeStyle: LineStyle;
                                   mapChartSeparateRegionFillStyle: FillStyle;
                                   mapChartSeparateRegionStrokeStyle: LineStyle;
                                   dataGridBackgroundFillStyle: FillStyle;
                                   dataGridBackgroundStrokeStyle: LineStyle;
                                   dataGridTitleFont: FontSettings;
                                   dataGridTitleFillStyle: FillStyle;
                                   dataGridTextFont: FontSettings;
                                   dataGridTextFillStyle: FillStyle;
                                   dataGridCellBackgroundFillStyle: FillStyle;
                                   dataGridBorderStrokeStyle: LineStyle;
                                   dataGridScrollBarBackgroundFillStyle: FillStyle;
                                   dataGridScrollBarBackgroundStrokeStyle: LineStyle;
                                   dataGridScrollBarFillStyle: FillStyle;
                                   dataGridScrollBarStrokeStyle: LineStyle;
                                   dataGridScrollBarButtonFillStyle: FillStyle;
                                   dataGridScrollBarButtonStrokeStyle: LineStyle;
                                   dataGridScrollBarButtonArrowFillStyle: FillStyle;
                                   dataGridScrollBarThickness: number;
                                   sparkLineChartStrokeStyle: LineStyle;
                                   sparkPointChartFillStyle: FillStyle;
                                   sparkBarChartFillStyle: FillStyle;
                                   sparkBarChartStrokeStyle: LineStyle;
                                   sparkAreaChartFillStyle: FillStyle;
                                   sparkAreaChartStrokeStyle: LineStyle;
                                   sparkPieChartFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   sparkPieChartStrokeStyle: LineStyle;
                                   sparkChartBandFillStyle: FillStyle;
                                   sparkChartBandStrokeStyle: LineStyle;
                                   sparkChartConstantLineStrokeStyle: LineStyle;
                                   dataGridTextShadow?: Color | undefined;
                                   dataGridTitleShadow?: Color | undefined;
                                   dataGridCellPadding?: number;
                                   spiderChartBackgroundFillStyle: FillStyle;
                                   spiderChartBackgroundStrokeStyle: LineStyle;
                                   spiderChartTitleFont: FontSettings;
                                   spiderChartTitleFillStyle: FillStyle;
                                   spiderChartTitleShadow?: Color | undefined;
                                   spiderChartSeriesBackgroundFillStyle: FillStyle;
                                   spiderChartSeriesBackgroundStrokeStyle: LineStyle;
                                   spiderChartWebStyle: LineStyle;
                                   spiderChartScaleLabelFillStyle: FillStyle;
                                   spiderChartScaleLabelFont: FontSettings;
                                   spiderChartAxisLabelFillStyle: FillStyle;
                                   spiderChartAxisLabelFont: FontSettings;
                                   spiderChartAxisStrokeStyle: LineStyle;
                                   spiderChartAxisNibStrokeStyle: LineStyle;
                                   spiderSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   spiderSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                   spiderSeriesPointFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                   spiderChartScaleLabelShadow?: Color | undefined;
                                   pieChartBackgroundFillStyle: FillStyle;
                                   pieChartBackgroundStrokeStyle: LineStyle;
                                   pieChartTitleFont: FontSettings;
                                   pieChartTitleFillStyle: FillStyle;
                                   pieChartTitleShadow?: Color | undefined;
                                   pieChartSliceFillStylePalette: Palette<FillStyle>;
                                   pieChartSliceStrokeStyle: LineStyle;
                                   pieChartSliceLabelFont: FontSettings;
                                   pieChartSliceLabelFillStyle: FillStyle;
                                   pieChartConnectorStrokeStyle: LineStyle;
                                   pieChartSliceLabelShadow?: Color | undefined;
                                   funnelChartBackgroundFillStyle: FillStyle;
                                   funnelChartBackgroundStrokeStyle: LineStyle;
                                   funnelChartTitleFont: FontSettings;
                                   funnelChartTitleFillStyle: FillStyle;
                                   funnelChartTitleShadow?: Color | undefined;
                                   funnelChartSliceFillStylePalette: Palette<FillStyle>;
                                   funnelChartSliceStrokeStyle: LineStyle;
                                   funnelChartSliceLabelFont: FontSettings;
                                   funnelChartSliceLabelFillStyle: FillStyle;
                                   funnelChartConnectorStrokeStyle: LineStyle;
                                   funnelChartSliceLabelShadow?: Color | undefined;
                                   pyramidChartBackgroundFillStyle: FillStyle;
                                   pyramidChartBackgroundStrokeStyle: LineStyle;
                                   pyramidChartTitleFont: FontSettings;
                                   pyramidChartTitleFillStyle: FillStyle;
                                   pyramidChartTitleShadow?: Color | undefined;
                                   pyramidChartSliceFillStylePalette: Palette<FillStyle>;
                                   pyramidChartSliceStrokeStyle: LineStyle;
                                   pyramidChartSliceLabelFont: FontSettings;
                                   pyramidChartSliceLabelFillStyle: FillStyle;
                                   pyramidChartConnectorStrokeStyle: LineStyle;
                                   pyramidChartSliceLabelShadow?: Color | undefined;
                                   gaugeChartBarThickness: number;
                                   gaugeChartValueIndicatorThickness: number;
                                   gaugeChartRoundedEdges: boolean;
                                   gaugeChartNeedleLength: number;
                                   gaugeChartNeedleAlignment: number;
                                   gaugeChartNeedleFillStyle: FillStyle;
                                   gaugeChartNeedleThickness: number;
                                   gaugeChartNeedleStrokeStyle: LineStyle;
                                   gaugeChartStartAngle: number;
                                   gaugeChartEndAngle: number;
                                   gaugeChartGapBetweenBarAndValueIndicators: number;
                                   gaugeChartBarColor: Color;
                                   gaugeChartGlowColor: Color;
                                   gaugeChartBackgroundFillStyle: FillStyle;
                                   gaugeChartBackgroundStrokeStyle: LineStyle;
                                   gaugeChartTitleFont: FontSettings;
                                   gaugeChartTitleFillStyle: FillStyle;
                                   gaugeChartTitleShadow?: Color | undefined;
                                   gaugeChartValueLabelFont: FontSettings;
                                   gaugeChartUnitLabelFont: FontSettings;
                                   gaugeChartTickFont: FontSettings;
                                   gaugeChartTickFillStyle: FillStyle;
                                   gaugeChartBarGradient: boolean;
                                   gaugeChartBarStrokeStyle: LineStyle;
                                   gaugeChartUnitLabelFillStyle: FillStyle;
                                   gaugeChartValueLabelFillStyle: FillStyle;
                                   treeMapChartBackgroundFillStyle?: FillStyle;
                                   treeMapChartBackgroundStrokeStyle?: LineStyle;
                                   treeMapChartParentColor?: Color;
                                   treeMapChartNodeColors?: Color[];
                                   treeMapChartNodeStrokeStyle?: LineStyle;
                                   treeMapChartTitleFillStyle?: FillStyle;
                                   treeMapChartTitleShadow?: Color | undefined;
                                   treeMapChartTitleFont?: FontSettings;
                                   treeMapChartPathLabelFillStyle?: FillStyle;
                                   treeMapChartPathLabelFont?: FontSettings;
                                   treeMapChartLabelHeaderFillStyle?: FillStyle;
                                   treeMapChartLabelHeaderFont?: FontSettings;
                                   treeMapChartLabelFillStyle?: FillStyle;
                                   treeMapChartLabelFont?: FontSettings;
                                   treeMapChartCornerRadius?: number | undefined;
                                   uiPanelBackgroundFillStyle: FillStyle;
                                   uiPanelBackgroundStrokeStyle: LineStyle;
                                   zoomBandChartDefocusOverlayFillStyle: FillStyle;
                                   zoomBandChartSplitterStrokeStyle: LineStyle;
                                   zoomBandChartKnobFillStyle: FillStyle | ((resourcesBaseUrl: string) => FillStyle);
                                   zoomBandChartKnobSize: {
                                       x: number;
                                       y: number;
                                   };
                                   onScreenMenuBackgroundColor: Color;
                                   parallelCoordinateChartBackgroundFillStyle?: FillStyle;
                                   parallelCoordinateChartBackgroundStrokeStyle?: LineStyle;
                                   parallelCoordinateChartTitleFont?: FontSettings;
                                   parallelCoordinateChartTitleFillStyle?: FillStyle;
                                   parallelCoordinateChartTitleShadow?: Color | undefined;
                                   parallelCoordinateChartSeriesBackgroundFillStyle?: FillStyle;
                                   parallelCoordinateChartSeriesBackgroundStrokeStyle?: LineStyle;
                                   parallelCoordinateChartSeriesColor?: ThemePropertyWithCallbackOption<Color>;
                                   parallelCoordinateChartSeriesColorUnselected?: Color;
                                   parallelCoordinateChartSeriesLineThickness?: number;
                                   parallelCoordinateChartPointedSeriesLineStyle?: LineStyle;
                                   parallelCoordinateAxisTitleFont?: FontSettings;
                                   parallelCoordinateAxisTitleFillStyle?: FillStyle;
                                   parallelCoordinateAxisNumericTicks?: NumericTickStrategy;
                                   parallelCoordinateAxisDateTimeTicks?: DateTimeTickStrategy;
                                   parallelCoordinateAxisTimeTicks?: TimeTickStrategy;
                                   parallelCoordinateAxisStrokeStyle?: LineStyle;
                                   parallelCoordinateAxisRangeSelectorFillStyle?: FillStyle;
                                   parallelCoordinateAxisRangeSelectorStrokeStyle?: LineStyle;
                                   parallelCoordinateAxisBackgroundFillStyle?: FillStyle;
                                   uiButtonFillStyle: FillStyle;
                                   uiButtonFillStyleHidden: FillStyle;
                                   uiButtonStrokeStyle: LineStyle;
                                   uiButtonSize: number;
                                   uiBackgroundFillStyle: FillStyle;
                                   uiBackgroundStrokeStyle: LineStyle;
                                   uiTextFillStyle: FillStyle;
                                   uiTextFillStyleHidden: FillStyle;
                                   uiTextFont: FontSettings;
                                   uiTextPadding?: number;
                                   legendTitleFillStyle: FillStyle;
                                   legendTitleFont: FontSettings;
                                   legendBorderRadius?: number | undefined;
                                   legendPadding?: number;
                                   legendLUTLengthHorizontal?: number;
                                   legendLUTThicknessHorizontal?: number;
                                   legendLUTLengthVertical?: number;
                                   legendLUTThicknessVertical?: number;
                                   legendLUTLabelMargin?: number;
                                   legendLUTUnitLabelMargin?: number;
                                   legendLUTCornerRadius?: number | undefined;
                                   cursorTickMarkerXBackgroundFillStyle: FillStyle;
                                   cursorTickMarkerXBackgroundStrokeStyle: LineStyle;
                                   cursorTickMarkerXTextFillStyle: FillStyle;
                                   cursorTickMarkerXTextFont: FontSettings;
                                   cursorTickMarkerYBackgroundFillStyle: FillStyle;
                                   cursorTickMarkerYBackgroundStrokeStyle: LineStyle;
                                   cursorTickMarkerYTextFillStyle: FillStyle;
                                   cursorTickMarkerYTextFont: FontSettings;
                                   /**
                                    * NOTE: Overridden by `cursorDynamicBehavior` if defined.
                                    */
                                   cursorPointMarkerFillStyle: FillStyle;
                                   /**
                                    * NOTE: Overridden by `cursorDynamicBehavior` if defined.
                                    */
                                   cursorPointMarkerStrokeStyle: LineStyle;
                                   cursorPointMarkerSize: Point;
                                   cursorPointMarkerShape: PointShape;
                                   cursorResultTableFillStyle: FillStyle;
                                   cursorResultTableStrokeStyle: LineStyle;
                                   cursorResultTableTextFillStyle: FillStyle;
                                   cursorResultTableTextFont: FontSettings;
                                   cursorGridStrokeStyleX: LineStyle;
                                   cursorGridStrokeStyleY: LineStyle;
                                   cursorResultTableHeaderBackgroundFillStyle?: FillStyle;
                                   cursorResultTableBorderRadius?: number | undefined;
                                   cursorDynamicBehavior?: CursorDynamicBehavior;
                                   cursor3DGridStrokeStyleX: LineStyle;
                                   cursor3DGridStrokeStyleY: LineStyle;
                                   cursor3DGridStrokeStyleZ: LineStyle;
                                   cursor3DTickStrokeStyleX: LineStyle;
                                   cursor3DTickStrokeStyleY: LineStyle;
                                   cursor3DTickStrokeStyleZ: LineStyle;
                                   cursor3DTickLabelFillStyleX: FillStyle;
                                   cursor3DTickLabelFillStyleY: FillStyle;
                                   cursor3DTickLabelFillStyleZ: FillStyle;
                                   cursor3DTickLabelFontX: FontSettings;
                                   cursor3DTickLabelFontY: FontSettings;
                                   cursor3DTickLabelFontZ: FontSettings;
                                   cursor3DTickLabelBackgroundFillStyleX: FillStyle;
                                   cursor3DTickLabelBackgroundFillStyleY: FillStyle;
                                   cursor3DTickLabelBackgroundFillStyleZ: FillStyle;
                                   cursor3DTickLabelBackgroundStrokeStyleX: LineStyle;
                                   cursor3DTickLabelBackgroundStrokeStyleY: LineStyle;
                                   cursor3DTickLabelBackgroundStrokeStyleZ: LineStyle;
                                   cursor3DTickLabelPaddingX: Margin;
                                   cursor3DTickLabelPaddingY: Margin;
                                   cursor3DTickLabelPaddingZ: Margin;
                               }
                               /**
                                * Properties of {@link Theme} that are optional, and officially only used in LightningChart JS Online Examples and projects.
                                *
                                * These are guaranteed to be included in all official Library Themes provided by LightningChart, but not required in custom Themes defined by users.
                                *
                                * If you want to use example theme properties in your application, then make sure to do these two things:
                                *
                                * 1) Use an official Theme supplied by LightningChart.
                                * 2) If your project requires type safety, then add a sanity check that throws an error if the `Theme.examples` property is `undefined`, like this:
                                *
                                * ```ts
                                *  // Example, ensure official LightningChart JS theme is in use.
                                *  const theme = chart.getTheme()
                                *  if (!theme.examples) {
                                *      throw new Error(`LightningChart JS Theme.examples is undefined. You are probably using an unofficial theme and attempting to access example theme properties!`)
                                *  }
                                * ```
                                *
                                * @public
                                * @beta    Theme example properties are primarly intended to be used by official LCJS applications and examples.
                                *          As such, users should be aware that they may change even in minor version releases.
                                */
                               export declare interface ThemeExampleProperties {
                                   positiveTextFillStyle: FillStyle;
                                   negativeTextFillStyle: FillStyle;
                                   positiveFillStyle: FillStyle;
                                   negativeFillStyle: FillStyle;
                                   positiveAreaFillStyle: FillStyle;
                                   negativeAreaFillStyle: FillStyle;
                                   positiveBackgroundFillStyle: FillStyle;
                                   negativeBackgroundFillStyle: FillStyle;
                                   /**
                                    * @privateRemarks  http://localhost:8080/map-example-1.html
                                    */
                                   badGoodColorPalette: Color[];
                                   /**
                                    * @privateRemarks  http://localhost:8080/examples/1110-temperature-heatmap.html
                                    */
                                   coldHotColorPalette: Color[];
                                   /**
                                    * @privateRemarks  http://localhost:8080/xy-heatmapGrid.html
                                    */
                                   intensityColorPalette: Color[];
                                   /**
                                    * @privateRemarks  http://localhost:8080/impressive/dashboard.html
                                    */
                                   spectrogramColorPalette: Color[];
                                   bollingerFillStyle: FillStyle;
                                   bollingerBorderFillStyle: FillStyle;
                                   /**
                                    * @privateRemarks  0033-sweepingLineDashboard
                                    */
                                   highlightPointColor: Color;
                                   /**
                                    * @privateRemarks  1300-dataGridCrypto
                                    */
                                   highlightDataGridColor: Color;
                                   /**
                                    * @privateRemarks  0503-dashboardBusiness
                                    */
                                   unfocusedDataColor: Color;
                                   mainDataColor: Color;
                                   header1Font: FontSettings;
                                   header2Font: FontSettings;
                                   header3Font: FontSettings;
                               }
                               /**
                                * Type definition for property of {@link Theme} that can either be a hard defined value, or a callback function which provides a different value based on how many times it is requested.
                                *
                                * Can be used for example to set different color for 2nd series, 3rd series, etc.
                                *
                                * ```ts
                                *  // Example, hard defined value
                                *  lineSeriesStrokeStyle: new SolidLine({ thickness: 2, fillStyle: ColorRGBA(255, 0, 0) })
                                * ```
                                *
                                * ```ts
                                *  // Example, different color for each series
                                *  lineSeriesStrokeStyle: (index) => new SolidLine({ thickness: 2, fillStyle: ColorHSV(index * 90) })
                                * ```
                                *
                                * @public
                                */
                               export declare type ThemePropertyWithCallbackOption<T> = T | Palette<T>;
                               /**
                                * A collection of default *library color theme* implementations.
                                *
                                * Color theme of components must be specified when it is created, and can't be changed afterwards (without destroying and recreating the component):
                                *
                                * ```js
                                *  // Example syntax, create ChartXY with specific color theme.
                                *  const chart = lightningChart().ChartXY({
                                *      theme: Themes.light,
                                *  })
                                * ```
                                *
                                * LCJS default theme is {@link Themes.darkGold}.
                                * @public
                                */
                               export declare interface Themes {
                                   /**
                                    * A built-in dark color Theme.
                                    *
                                    * **DarkGold Theme is the current default LightningChart JS color theme**.
                                    */
                                   darkGold: OfficialTheme;
                                   /**
                                    * A built-in light color Theme.
                                    */
                                   light: OfficialTheme;
                                   /**
                                    * A built-in light nature-inspired color Theme.
                                    */
                                   lightNature: OfficialTheme;
                                   /**
                                    * A built-in dark, turquoise color Theme.
                                    *
                                    * This theme is based on a background picture (`turquoiseHexagon.jpg`) that is distributed along-side LightningChart JS in its `resources` folder
                                    * (`node_modules/@lightningchart/lcjs/dist/resources`). In order to use this Theme, you have to host the resources in a file server and inform LightningChart of the URL of this file server.
                                    *
                                    * For more information, see {@link LightningChartOptions.resourcesBaseUrl}.
                                    */
                                   turquoiseHexagon: OfficialTheme;
                                   /**
                                    * A built-in dark, violet color Theme.
                                    *
                                    * This theme is based on a background picture (`cyberSpace.jpg`) that is distributed along-side LightningChart JS in its `resources` folder
                                    * (`node_modules/@lightningchart/lcjs/dist/resources`). In order to use this Theme, you have to host the resources in a file server and inform LightningChart of the URL of this file server.
                                    *
                                    * For more information, see {@link LightningChartOptions.resourcesBaseUrl}.
                                    */
                                   cyberSpace: OfficialTheme;
                               }
                               /**
                                *
                                * A collection of default *library color theme* implementations.
                                *
                                * Color theme of components must be specified when it is created, and can't be changed afterwards (without destroying and recreating the component):
                                *
                                * ```js
                                *  // Example syntax, create ChartXY with specific color theme.
                                *  const chart = lightningChart().ChartXY({
                                *      theme: Themes.light,
                                *  })
                                * ```
                                *
                                * LCJS default theme is {@link Themes.darkGold}.
                                *
                                * Available themes:
                                * - `darkGold`
                                * - `light`
                                * - `lightNature`
                                * - `cyberSpace`
                                * - `turquoiseHexagon`
                                * @public
                                */
                               export declare const Themes: Themes;
                               /**
                                * Implementation of 2D Axis Tick.
                                * @public
                                * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                */
                               export declare class Tick extends _AbstractAxisTick {
                               }
                               /**
                                * @public
                                * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                */
                               declare class _Tick3D extends _AbstractAxisTick {
                               }
                               /**
                                * Interface for *TickMarker*, a part of {@link CustomTick} that represents the label and pointer attached to the Axis.
                                *
                                * Most styling of CustomTicks can be managed directly via {@link CustomTick} API, but for some rare cases
                                * its *TickMarker* has to be mutated. TickMarker is accessed via {@link CustomTick.setMarker} method, using a callback function:
                                *
                                * ```typescript
                                *  CustomTick.setMarker((tickMarker) =>
                                *      // ... mutate TickMarker.
                                *  )
                                *
                                *  //
                                * ```
                                * @public
                                */
                               export declare interface TickMarker extends UIPart, GettableText, StyleTextAPI, Pointable {
                               }
                               /**
                                * @public
                                * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                */
                               declare interface _TickPlottingVariablesXY extends _GenericTickPlottingVariables {
                               }
                               /**
                                * Type map of valid parameter combinations for Axis.setTickStrategy().
                                * @public
                                */
                               export declare type TickStrategyParameters = {
                                   type: 'Empty';
                                   styler: ImmutableMutator<EmptyTickStrategy>;
                               } | {
                                   type: 'Numeric';
                                   styler: ImmutableMutator<NumericTickStrategy>;
                               } | {
                                   type: 'DateTime';
                                   styler: ImmutableMutator<DateTimeTickStrategy>;
                               } | {
                                   type: 'Time';
                                   styler: ImmutableMutator<TimeTickStrategy>;
                               };
                               /**
                                * @public
                                */
                               export declare type TickStrategyStyler<A, T> = A extends {
                                   type: T;
                                   styler: any;
                               } ? A['styler'] : never;
                               /**
                                * @public
                                */
                               export declare type TickStrategyType = TickStrategyParameters['type'];
                               /**
                                * Class which is used to style *Axis* *Ticks*.
                                *
                                * Instances of TickStyle are *immutable*, meaning that its setters don't modify the object,
                                * but instead return a completely new modified object.
                                *
                                * When creating a new TickStyle object from scratch, parameters can be passed like follows:
                                * - `new TickStyle({ labelFillStyle: new SolidFill({ color: ColorHEX('#F00'), tickLength: 8 })`
                                * @public
                                */
                               export declare class TickStyle extends TickStyleRecord {
                                   /**
                                    * Construct a new TickStyle object based on this one, but with modified gridstroke length.
                                    * @param length - Length of GridStroke, where 1 = full and 0 = zero.
                                    * @returns New TickStyle object
                                    * @public
                                    */
                                   setGridStrokeLength(length: number): this;
                                   /**
                                    * Get length of GridStroke.
                                    * @returns Length of GridStroke, where 1 = full and 0 = zero.
                                    * @public
                                    */
                                   getGridStrokeLength(): number;
                                   /**
                                    * Construct a new TickStyle object based on this one, but with modified GridStroke style.
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Specified SolidLine
                                    * TickStyle.setGridStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                    * // Changed thickness
                                    * TickStyle.setGridStrokeStyle((solidLine) => solidLine.setThickness(5))
                                    * // Hidden
                                    * TickStyle.setGridStrokeStyle(emptyLine)
                                    * ```
                                    *
                                    * Supported line styles:
                                    * - {@link SolidLine}
                                    * - {@link DashedLine}
                                    * - {@link emptyLine}
                                    *
                                    * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
                                    * @returns New TickStyle object
                                    * @public
                                    */
                                   setGridStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get style of GridStrokes.
                                    * @returns LineStyle object
                                    * @public
                                    */
                                   getGridStrokeStyle(): LineStyle;
                                   /**
                                    * Set length of Ticks.
                                    * @param length - Length of Ticks as pixels.
                                    * @returns New TickStyle object
                                    * @public
                                    */
                                   setTickLength(length: pixel): this;
                                   /**
                                    * Get length of Ticks.
                                    * @returns Length of Ticks as pixels
                                    * @public
                                    */
                                   getTickLength(): pixel;
                                   /**
                                    * Construct a new TickStyle object based on this one, but with modified Tick style.
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Specified SolidLine
                                    * TickStyle.setGridStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                    * // Changed thickness
                                    * TickStyle.setGridStrokeStyle((solidLine) => solidLine.setThickness(5))
                                    * // Hidden
                                    * TickStyle.setGridStrokeStyle(emptyLine)
                                    * ```
                                    * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
                                    * @returns New TickStyle object
                                    * @public
                                    */
                                   setTickStyle(style: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get style of Ticks.
                                    * @returns LineStyle object
                                    * @public
                                    */
                                   getTickStyle(): LineStyle;
                                   /**
                                    * Set padding after Tick as pixels.
                                    * @param padding - Padding after Tick as pixels.
                                    * @returns New TickStyle object with modified Tick padding
                                    * @public
                                    */
                                   setTickPadding(padding: pixel): this;
                                   /**
                                    * Get padding after Tick as pixels.
                                    * @returns Padding after Tick as pixels.
                                    * @public
                                    */
                                   getTickPadding(): pixel;
                                   /**
                                    * Set fill style of Labels.
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Specified FillStyle
                                    * TickStyle.setLabelFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                    * // Changed transparency
                                    * TickStyle.setLabelFillStyle((solidFill) => solidFill.setA(80))
                                    * // Hidden
                                    * TickStyle.setLabelFillStyle(emptyFill)
                                    * ```
                                    * @param style - Either a VisibleFill object or a function, which will be used to create a new VisibleFill based on current value.
                                    * @returns New TickStyle object
                                    * @public
                                    */
                                   setLabelFillStyle(style: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Label.
                                    * @returns Fill style of Label as a VisibleFill object
                                    * @public
                                    */
                                   getLabelFillStyle(): FillStyle;
                                   /**
                                    * Not to be confused with {@link GlowEffect}
                                    * @public
                                    * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
                                    */
                                   setLabelShadow(color: Color | undefined): this;
                                   /**
                                    * @public
                                    * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
                                    */
                                   getLabelShadow(): Color | undefined;
                                   /**
                                    * Construct a new TickStyle object based on this one, but with modified Label font.
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Specified FontSettings
                                    * TickStyle.setLabelFont(new FontSettings({ size: 24, style: 'italic' }))
                                    * // Set to bold
                                    * TickStyle.setLabelFont((fontSettings) => fontSettings.setWeight('bold'))
                                    * ```
                                    * @param value - Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
                                    * @returns New TickStyle object
                                    * @public
                                    */
                                   setLabelFont(font: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get font of Labels.
                                    * @returns FontSettings object
                                    * @public
                                    */
                                   getLabelFont(): FontSettings;
                                   /**
                                    * Set alignment of Label respective to tick line.
                                    *
                                    * **after**: -1
                                    *
                                    * **center**: 0
                                    *
                                    * **before**: +1
                                    *
                                    * With XY axes, a second alignment value can additionally be passed, which is used along the other dimension (i.e. X for Y axes).
                                    *
                                    * @param alignment - Label alignment [-1, 1].
                                    * @param alignment2 - Opposite dimension label alignment [-1, 1], supported only by XY axes.
                                    * @returns New TickStyle object with modified Label alignment
                                    * @public
                                    */
                                   setLabelAlignment(alignment: number, alignment2?: number): this;
                                   /**
                                    * Get horizontal alignment of Label respective to tick line.
                                    * @returns Horizontal alignment [-1, 1].
                                    * @public
                                    */
                                   getLabelAlignment(): number;
                                   /**
                                    * Set rotation of Label title.
                                    * @param value - Rotation in degrees
                                    * @returns Object itself
                                    * @public
                                    */
                                   setLabelRotation(rotation: number): this;
                                   /**
                                    * Get rotation of Label title.
                                    * @returns Rotation in degrees
                                    * @public
                                    */
                                   getLabelRotation(): number;
                               }
                               /**
                                * Properties of a TickStyle.
                                * @public
                                */
                               export declare interface TickStyleProperties {
                                   type: 'tick-style';
                                   /**
                                    * Length of GridStroke, where 1 = full and 0 = zero.
                                    * @public
                                    */
                                   gridStrokeLength: number;
                                   /**
                                    * Style of GridStroke as a SolidLine object.
                                    * @public
                                    */
                                   gridStrokeStyle: LineStyle;
                                   /**
                                    * Length of Tick itself as pixels.
                                    * @public
                                    */
                                   tickLength: pixel;
                                   /**
                                    * Style of Tick itself as a SolidLine object.
                                    * @public
                                    */
                                   tickStyle: LineStyle;
                                   /**
                                    * Padding after Tick as pixels.
                                    * @public
                                    */
                                   tickPadding: pixel;
                                   /**
                                    * Font of Label as FontSettings.
                                    * @public
                                    */
                                   labelFont: FontSettings;
                                   /**
                                    * FillStyle of Label.
                                    * @public
                                    */
                                   labelFillStyle: FillStyle;
                                   /**
                                    * Not to be confused with {@link GlowEffect}
                                    * @public
                                    * @beta    Introduced in v7.0. API may be changed according to user feedback and reports.
                                    */
                                   labelShadow: Color | undefined;
                                   /**
                                    * alignment of Label respective to tick line.
                                    *
                                    * **after**: -1
                                    *
                                    * **center**: 0
                                    *
                                    * **before**: +1
                                    * @public
                                    */
                                   labelAlignment: number;
                                   /**
                                    * With XY axes, a second alignment value can additionally be passed, which is used along the other dimension (i.e. X for Y axes).
                                    *
                                    * [-1, 1]
                                    * @public
                                    */
                                   labelAlignmentOpposite: number | undefined;
                                   /**
                                    * Label rotation in degrees.
                                    * @public
                                    */
                                   labelRotation: number;
                               }
                               /**
                                * Record contractor for TickStyle.
                                * @public
                                */
                               declare const TickStyleRecord: Record_2.Factory<TickStyleProperties>;
                               /**
                                * @public
                                * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                */
                               declare interface _TickXYInfo extends _GenericTickInfo {
                               }
                               /**
                                * Collection of formatting functions used with {@link TimeTickStrategy}.
                                *
                                * Can be referenced in user applications for convenience.
                                * @public
                                */
                               export declare const TimeFormattingFunctions: {
                                   /**
                                    * Display hours, minutes and seconds.
                                    *
                                    * `'00:00:00'`
                                    */
                                   hhmmss: (value: number) => string;
                                   /**
                                    * Display hours, minutes, seconds and milliseconds.
                                    *
                                    * `'00:00:00.000'`
                                    */
                                   hhmmssmmm: (value: number) => string;
                                   /**
                                    * Display hours, minutes, seconds, milliseconds and microseconds.
                                    *
                                    * `'00:00:00.000000'`
                                    */
                                   hhmmssmmmuuu: (value: number) => string;
                                   /**
                                    * Display hours, minutes, seconds, milliseconds, microseconds and nanoseconds.
                                    *
                                    * `'00:00:00.000000000'`
                                    */
                                   hhmmssmmmuuunnn: (value: number) => string;
                               };
                               /**
                                * *Axis Tick Strategy* that is designed for depicting time ranges between hundreds of hours to individual nanoseconds.
                                *
                                * Axis values are interpreted as milliseconds, for example:
                                * - `0` -\> `00:00:00`
                                * - `1 000` -\> `00:00:01`
                                * - `3 600 000` -\> `01:00:00`
                                * - `1` -\> `00:00:00.001`
                                * - `0.001` -\> `00:00:00.000001`
                                *
                                * Axis interval ranges supported by `TimeTickStrategy`:
                                * - Minimum: 100 nanoseconds (`0.0001`).
                                * - Maximum: 100 hours (`8 640 000 000`)
                                *
                                * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to {@link Axis} documentation for more information.
                                *
                                * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
                                *
                                * ```js
                                *  Axis.setTickStrategy(AxisTickStrategies.Time, (timeTicks) => timeTicks)
                                * ```
                                *
                                * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
                                * see example below for the idea:
                                *
                                * ```js
                                *  // Specify TickStrategy and use callback to style automatic ticks.
                                *  Axis.setTickStrategy(AxisTickStrategies.Time, (timeTicks) => timeTicks
                                *      // All methods of `TimeTickStrategy` can be used here for styling ticks.
                                *      .setMajorTickStyle((majorTicks) => majorTicks
                                *          .setLabelFont((font) => font
                                *              .setWeight('bold')
                                *          )
                                *      )
                                *  )
                                * ```
                                *
                                * All available strategies for automatic Axis ticks creation can be referenced via {@link AxisTickStrategies}.
                                * @public
                                */
                               export declare class TimeTickStrategy extends TimeTickStrategyRecord implements MutableAxisTickStrategy {
                                   /**
                                    * This is a convenience function which simultaneously applies both {@link setMajorTickStyle} and {@link setMinorTickStyle}.
                                    *
                                    * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
                                    * @returns New *NumericTickStrategy* object.
                                    * @public
                                    */
                                   setTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
                                   /**
                                    * Construct a new *TimeTickStrategy* object based on this one, but with modified major tick style.
                                    *
                                    * Example usage:
                                    *
                                    * **Set font of major ticks**:
                                    * ```javascript
                                    * Axis.setTickStrategy(
                                    *     AxisTickStrategies.Time,
                                    *     ( tickStrategy: TimeTickStrategy ) => tickStrategy
                                    *         .setMajorTickStyle(( tickStyle ) => tickStyle
                                    *             .setLabelFont(( font ) => font
                                    *                 .setWeight( 'bold' )
                                    *             )
                                    *         )
                                    * )
                                    * ```
                                    * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
                                    * @returns New *TimeTickStrategy* object.
                                    * @public
                                    */
                                   setMajorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
                                   /**
                                    * Get major tick style of this *TimeTickStrategy* object.
                                    * @returns Major tick style.
                                    * @public
                                    */
                                   getMajorTickStyle(): TickStyle;
                                   /**
                                    * Construct a new *TimeTickStrategy* object based on this one, but with modified minor tick style.
                                    *
                                    * Example usage:
                                    *
                                    * **Disable minor ticks**:
                                    * ```javascript
                                    * Axis.setTickStrategy(
                                    *     AxisTickStrategies.Time,
                                    *     ( tickStrategy: TimeTickStrategy ) => tickStrategy
                                    *         .setMinorTickStyle( emptyTick )
                                    * )
                                    * ```
                                    *
                                    * **Set font of minor ticks**:
                                    * ```javascript
                                    * Axis.setTickStrategy(
                                    *     AxisTickStrategies.Time,
                                    *     ( tickStrategy: TimeTickStrategy ) => tickStrategy
                                    *         .setMinorTickStyle(( tickStyle: TickStyle ) => tickStyle
                                    *             .setLabelFont(( font ) => font
                                    *                 .setWeight( 'bold' )
                                    *             )
                                    *         )
                                    * )
                                    * ```
                                    * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
                                    *                              Passing a function only works if the existing style is **not** *emptyTick*.
                                    * @returns New *TimeTickStrategy* object.
                                    * @public
                                    */
                                   setMinorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
                                   /**
                                    * Get minor tick style of this *TimeTickStrategy* object.
                                    * @returns Minor tick style.
                                    * @public
                                    */
                                   getMinorTickStyle(): TickStyle;
                                   /**
                                    * Set cursor formatter for this `TimeTickStrategy` object.
                                    *
                                    * This will override the date time formatting used by:
                                    * - Default cursor result table formatters.
                                    * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
                                    * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
                                    *
                                    * ```ts
                                    *  // Example syntax, custom cursor formatting.
                                    *  Axis.setTickStrategy(AxisTickStrategies.Time, (ticks) => ticks
                                    *      .setCursorFormatter((value, range, locale) =>
                                    *          value.toFixed(3)
                                    *      )
                                    *  )
                                    * ```
                                    * @param formatter - `FormattingFunction` or `undefined` to use default time cursor formatting.
                                    * @returns New *TimeTickStrategy* object.
                                    * @public
                                    */
                                   setCursorFormatter(formatter: FormattingFunction | undefined): this;
                                   /**
                                    * Get cursor formatter of this `TimeTickStrategy` object.
                                    *
                                    * @returns `FormattingFunction` as set by user, or `undefined` to indicate that the default time cursor formatting is configured.
                                    * @public
                                    */
                                   getCursorFormatter(): FormattingFunction | undefined;
                                   /**
                                    * Construct a new *TimeTickStrategy* object based on this one, but with modified timeOrigin.
                                    *
                                    * If a **timeOrigin** is defined, data-points will instead be interpreted as **milliseconds** since **timeOrigin**.
                                    *
                                    * Example usage:
                                    *
                                    * **Application with 24 hour time origin offset**:
                                    * ```javascript
                                    * Axis.setTickStrategy(AxisTickStrategies.Time,
                                    *     (tickStrategy) => tickStrategy.setTimeOrigin(24 * 60 * 60 * 1000)
                                    * )
                                    * ```
                                    *
                                    * @param timeOrigin - Millisecond offset or `undefined` to disable time origin offsetting.
                                    * @returns New *TimeTickStrategy* object.
                                    * @public
                                    */
                                   setTimeOrigin(timeOrigin: number | undefined): this;
                                   /**
                                    *  Get the *timeOrigin* of this *TimeTickStrategy* object.
                                    * @returns Current time origin milliseconds or *undefined*.
                                    * @public
                                    */
                                   getTimeOrigin(): number | undefined;
                                   /**
                                    * Utility method for setting *formatting function* of all numeric tick levels (major, minor) as well as cursor.
                                    *
                                    * Each formatting target can be individually overridden with following methods:
                                    * - {@link setMajorFormattingFunction} | major ticks
                                    * - {@link setMinorFormattingFunction} | minor ticks
                                    * - {@link setCursorFormatter} | cursor result table and ticks
                                    * @param formattingFunction - Function that formats a tick value to text.
                                    * @returns New *TimeTickStrategy* object.
                                    * @public
                                    */
                                   setFormattingFunction(formattingFunction: FormattingFunction): this;
                                   /**
                                    * Get major ticks formatting function of this *TimeTickStrategy* object.
                                    * @returns Formatting Function.
                                    * @public
                                    */
                                   getMajorFormattingFunction(): FormattingFunction | undefined;
                                   /**
                                    * Set major ticks formatting function of this *TimeTickStrategy* object.
                                    * @param formattingFunction - Formatting function to use with this *TimeTickStrategy* object.
                                    * @returns New *TimeTickStrategy* object.
                                    * @public
                                    */
                                   setMajorFormattingFunction(formattingFunction: FormattingFunction): this;
                                   /**
                                    * Get minor ticks formatting function of this *TimeTickStrategy* object.
                                    * @returns Formatting Function.
                                    * @public
                                    */
                                   getMinorFormattingFunction(): FormattingFunction | undefined;
                                   /**
                                    * Set minor ticks formatting function of this *TimeTickStrategy* object.
                                    * @param formattingFunction - Formatting function to use with this *TimeTickStrategy* object.
                                    * @returns New *TimeTickStrategy* object.
                                    * @public
                                    */
                                   setMinorFormattingFunction(formattingFunction: FormattingFunction): this;
                               }
                               /**
                                * @public
                                */
                               export declare interface TimeTickStrategyProperties {
                                   type: 'time-ticks';
                                   /**
                                    * Style of Major ticks.
                                    */
                                   readonly majorTickStyle: TickStyle;
                                   /**
                                    * Style of Minor ticks.
                                    *
                                    * To disable minor ticks, set to **emptyTick**.
                                    */
                                   readonly minorTickStyle: TickStyle;
                                   /**
                                    * Formatting function used for major ticks.
                                    *
                                    * Use FormattingFunctions to select available ones or define custom function.
                                    *
                                    * **undefined** will result in default selection.
                                    */
                                   readonly majorFormattingFunction?: FormattingFunction;
                                   /**
                                    * Formatting function used for minor ticks.
                                    *
                                    * Use FormattingFunctions to select available ones or define custom function.
                                    *
                                    * **undefined** will result in default selection.
                                    */
                                   readonly minorFormattingFunction?: FormattingFunction;
                                   /**
                                    * Cursor formatter.
                                    *
                                    * This controls the formatting used by:
                                    * - Default cursor result table formatters.
                                    * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
                                    * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
                                    *
                                    * `undefined` means to use default Time cursor formatting.
                                    *
                                    * ```ts
                                    *  // Example value, custom cursor formatter
                                    *  cursorFormatter: (value, range, locale) => value.toFixed(3)
                                    * ```
                                    */
                                   readonly cursorFormatter: FormattingFunction | undefined;
                                   /**
                                    * optional "Time origin"  value.
                                    * If a **timeOrigin** is defined, data-points will instead be interpreted as milliseconds since **timeOrigin**.
                                    */
                                   readonly timeOrigin: number | undefined;
                               }
                               /**
                                * @public
                                */
                               declare const TimeTickStrategyRecord: Record_2.Factory<TimeTickStrategyProperties>;
                               /**
                                * A {@link SolidFill} singleton for a completely transparent fill.
                                * Can be useful in at least following cases:
                                *
                                * 1) User wants to hide something but still have it interactable by mouse/touch
                                *
                                * 2) User wants to hide something that does not support {@link emptyFill}
                                *
                                * Otherwise, {@link emptyFill} should be preferred for better performance.
                                * @public
                                */
                               export declare const transparentFill: SolidFill;
                               /**
                                * A {@link SolidLine} singleton for a completely transparent line.
                                * Can be useful in at least following cases:
                                *
                                * 1) User wants to hide something but still have it interactable by mouse/touch
                                *
                                * 2) User wants to hide something that does not support {@link emptyFill}
                                *
                                * Otherwise, {@link emptyLine} should be preferred for better performance.
                                * @public
                                */
                               export declare const transparentLine: SolidLine;
                               /**
                                * Chart class for visualizing a TreeMap Chart.
                                *
                                * ** Creating TreeMap Chart **
                                *
                                * To create a TreeMap Chart, call {@link LightningChart.TreeMapChart} method.
                                *
                                * ```js *
                                * // Create a TreeMap Chart with specific options.
                                * const chart = lightningChart().TreeMapChart({
                                *    // Chart options
                                * })
                                * ```
                                *
                                * **TreeMapChart features**
                                *
                                * - Display hierarchical data in a TreeMap.
                                * - Drill down into nodes.
                                * - Set colors for nodes.
                                * - Set labels for nodes.
                                * - Set animations for nodes.
                                * - Set cursor for nodes.
                                * - Set events for nodes.
                                *
                                * **TreeMapChart API*
                                * - {@link TreeMapChart.setData} - Set data to display in the chart.
                                * - {@link TreeMapChart.setAnimationValues} - Enable/disable animation of Nodes positions.
                                * - {@link TreeMapChart.setInitPathButtonText} - Set the text for the back button that returns to the 1st level of Nodes.
                                * - {@link TreeMapChart.setDisplayedLevelsCount} - Set the amount of levels of children nodes to display.
                                * - {@link TreeMapChart.setDrillDownNode} - Set the node to drill down to.
                                *
                                * **TreeMapChart Style API**
                                * - {@link TreeMapChart.setNodeColoring} - Set the color of the nodes.
                                * - {@link TreeMapChart.setPathLabelFillStyle} - Set Color of the path labels.
                                * - {@link TreeMapChart.setPathLabelFont} - Set Font of the path labels.
                                * - {@link TreeMapChart.setHeaderFont} - Set Font of the node labels.
                                * - {@link TreeMapChart.setHeaderFillStyle} - Set FillStyle of the node labels.
                                * - {@link TreeMapChart.setLabelFont} - Set Font of the node labels.
                                * - {@link TreeMapChart.setLabelFillStyle} - Set FillStyle of the node labels.
                                * - {@link TreeMapChart.setNodeBorderStyle} - Set LineStyle of the node labels.
                                * - {@link TreeMapChart.setNodeEffect} - Set theme effect enabled on component or disabled.
                                *
                                * **TreeMapChart Cursor API**
                                * - {@link TreeMapChart.setAutoCursor} - Mutator function for charts auto cursor.
                                * - {@link TreeMapChart.setAutoCursorMode} - Set mode of charts Auto cursor.
                                *
                                * @public
                                * */
                               export declare class TreeMapChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends Chart implements ChartWithCursor<CursorResultTableBackgroundType, CursorPosition2D, Cursor2D<CursorResultTableBackgroundType>, SolveResultTreeMapChart>, RoundableCorners {
                                   /**
                                    * Configure rounded-ness of corners.
                                    *
                                    * ```ts
                                    *  obj.setCornerRadius(10)             // 10 px rounding radius
                                    *  obj.setCornerRadius(undefined)     // straight corners
                                    * ```
                                    *
                                    * @param radius -  Number (pixel radius) or undefined.
                                    * @public
                                    * @beta    Introduced in v7.0. API might be changed depending on user feedback.
                                    */
                                   setCornerRadius(radius: number | undefined): this;
                                   /**
                                    * Get rounded-ness of corners.
                                    * @returns     Number or undefined.
                                    * @public
                                    * @beta    Introduced in v7.0. API might be changed depending on user feedback.
                                    */
                                   getCornerRadius(): number | undefined;
                                   /**
                                    *
                                    * ```js
                                    *  // Example usage
                                    *  treeMap.setData([
                                    *      { name: 'Category 1', value: 10 },
                                    *      { name: 'Category 2', value: 12 },
                                    *      { name: 'Category 3', children: [
                                    *        { name: 'Category 3.1', value: 6 },
                                    *        { name: 'Category 3.2', value: 12 },
                                    *     ]},
                                    *  ])
                                    * ```
                                    *
                                    * @param   arg     - Array of objects with category and value properties.
                                    * @returns         Object itself
                                    * @public
                                    */
                                   setData(arg: TreeMapUserNode | TreeMapUserNode[]): this;
                                   /**
                                    * Enable/disable animation of Nodes positions.
                                    * This is enabled by default.
                                    *
                                    * ```js
                                    *  // Example, enable category position animation and increase speed.
                                    *  chart.setAnimationValues(true, 2)
                                    * ```
                                    * ```js
                                    *  // Example, disable value animation.
                                    *  chart.setAnimationValues(false)
                                    * ```
                                    *
                                    * @param   enabled -   Boolean
                                    * @param   speedMultiplier     - Optional multiplier for category animation speed. `1` matches default speed.
                                    * @returns  Object itself.
                                    * @public
                                    */
                                   setAnimationValues(enabled: boolean, speedMultiplier?: number): this;
                                   /**
                                    * Set the text for the back button that returns to the 1st level of Nodes.
                                    *
                                    * ```js
                                    *  chart.setInitPathButtonText('Reset')
                                    * ```
                                    * @param text - Text for the button.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setInitPathButtonText(text: string): this;
                                   /**
                                    * Set the amount of levels of children nodes to display.
                                    * ```js
                                    *  chart.setDisplayedLevelsCount(2)
                                    * ```
                                    * @param level - Amount of levels to display.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setDisplayedLevelsCount(level: number): this;
                                   /**
                                    * Set the node to drill down to.
                                    * Pass node for automatic drill down to that node.
                                    * ```js
                                    * // Pass any child of the main node to drill down.
                                    * setTimeout(() => {
                                    *    chart.setDrillDownNode(node[0])
                                    * }, 4000)
                                    * ```
                                    * Pass undefined to reset drill down.
                                    * ```js
                                    * setTimeout(() => {
                                    *   chart.setDrillDownNode(undefined)
                                    * }, 8000)
                                    * ```
                                    * @param userNode - Node to drill down to.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setDrillDownNode(userNode: TreeMapUserNode[] | TreeMapUserNode | undefined): this;
                                   /**
                                    * Set the color of the nodes.
                                    * ```js
                                    * // Example usage of PalettedFill by value .
                                    * chart.setNodeColoring(
                                    *      new PalettedFill({
                                    *          lut: new LUT({
                                    *              steps: [
                                    *                  { value: 0, color: ColorCSS('red') },
                                    *                  { value: 20, color: ColorCSS('blue') },
                                    *              ],
                                    *              interpolate: true,
                                    *          }),
                                    *      }),
                                    * )
                                    * ```
                                    *
                                    * @param value -  FillStyle.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setNodeColoring(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Set the color of the nodes.
                                    * ```js
                                    * // Example, set colors of nodes to purple and blue only.
                                    * chart.setNodeColoring([ColorCSS('purple'), ColorCSS('blue')])
                                    * ```
                                    * @param value - Array of colors
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setNodeColoring(value: Color[]): this;
                                   /**
                                    * Set Color of the parent node.
                                    * ```js
                                    * // Example, set parent node color to red.
                                    * chart.setParentNodeColor(ColorCSS('red'))
                                    * ```
                                    * @param value - Color
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setParentNodeColor(value: Color): this;
                                   /**
                                    * Set Color of the path labels.
                                    * ```js
                                    * // Example, set path label color to red.
                                    * chart.setPathLabelFillStyle(new SolidFill({ color: ColorCSS('red') }))
                                    * ```
                                    * @param value - FillStyle
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setPathLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get the color of the path labels.
                                    * @returns FillStyle
                                    * @public
                                    */
                                   getPathLabelFillStyle(): FillStyle;
                                   /**
                                    * Set Font of the path labels.
                                    * ```js
                                    * // Example, set path label font to 20px.
                                    * chart.setPathLabelFont((font) => font.setSize(20))
                                    * ```
                                    * @param font - FontSettings
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setPathLabelFont(font: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get the font of the path labels.
                                    * @returns FontSettings
                                    * @public
                                    */
                                   getPathLabelFont(): FontSettings;
                                   /**
                                    * Set Font of the node labels.
                                    * ```js
                                    * // Example, set node label font to 20px.
                                    * chart.setHeaderFont((font) => font.setSize(20))
                                    * ```
                                    * @param font - FontSettings
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setHeaderFont(font: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get the font of the node labels.
                                    * @returns FontSettings
                                    * @public
                                    */
                                   getHeaderFont(): FontSettings;
                                   /**
                                    *  Set FillStyle of the node labels.
                                    * ```js
                                    * // Example, set node label color to red.
                                    * chart.setHeaderFillStyle(new SolidFill({ color: ColorCSS('red') }))
                                    * ```
                                    * @param value - FillStyle
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setHeaderFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get the FillStyle of the node labels.
                                    * @returns FillStyle
                                    * @public
                                    */
                                   getHeaderFillStyle(): FillStyle;
                                   /**
                                    * Set Font of the node labels.
                                    * ```js
                                    * // Example, set node label font to 20px.
                                    * chart.setLabelFont((font) => font.setSize(20))
                                    * ```
                                    * @param value - FillStyle
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setLabelFont(font: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get the font of the node labels.
                                    * @returns FontSettings
                                    * @public
                                    */
                                   getLabelFont(): FontSettings;
                                   /**
                                    * Set FillStyle of the node labels.
                                    * ```js
                                    * // Example, set node label color to red.
                                    * chart.setLabelFillStyle(new SolidFill({ color: ColorCSS('red') }))
                                    * ```
                                    * @param value - FillStyle
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get the FillStyle of the node labels.
                                    * @returns FillStyle
                                    * @public
                                    */
                                   getLabelFillStyle(): FillStyle;
                                   /**
                                    * Set LineStyle of the node labels.
                                    * ```js
                                    * // Example, set node label color to red.
                                    * chart.setNodeBorderStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorCSS('blue') }) }))
                                    * ```
                                    * @param value - LineStyle
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setNodeBorderStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get the LineStyle of the node labels.
                                    * @returns LineStyle
                                    * @public
                                    */
                                   getNodeBorderStyle(): LineStyle;
                                   /**
                                    * Set theme effect enabled on component or disabled.
                                    *
                                    * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                    * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                    *
                                    * ```js
                                    *  // Example, disable theme effect from a particular component.
                                    *  Component.setEffect(false)
                                    * ```
                                    *
                                    * For the most part, theme effects are **enabled** by default on most components.
                                    *
                                    * Theme effect is configured with {@link Theme.effect} property.
                                    *
                                    * @param enabled - Theme effect enabled
                                    * @returns          Object itself.
                                    * @public
                                    */
                                   setNodeEffect(enabled: boolean): this;
                                   /**
                                    * Get theme effect enabled on component or disabled.
                                    *
                                    * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                    * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                    *
                                    * ```js
                                    *  // Example, disable theme effect from a particular component.
                                    *  Component.setEffect(false)
                                    * ```
                                    *
                                    * For the most part, theme effects are **enabled** by default on most components.
                                    *
                                    * Theme effect is configured with {@link Theme.effect} property.
                                    *
                                    * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                                    * @public
                                    */
                                   getNodeEffect(): boolean;
                                   setCursor(mutator: Mutator<Cursor2D<CursorResultTableBackgroundType>>): this;
                                   getCursor(): Cursor2D<CursorResultTableBackgroundType>;
                                   setCursorMode(mode: SolveNearestMode | undefined): this;
                                   getCursorMode(): SolveNearestMode | undefined;
                                   setCustomCursor(clbk: undefined | ((event: CursorTargetChangedEvent<SolveResultTreeMapChart>) => unknown)): this;
                                   setCursorDynamicBehavior(value: CursorDynamicBehavior): this;
                                   /**
                                    * Set cursor formatting, controlling the text displayed in built-in cursor.
                                    *
                                    * ```ts
                                    *  chart.setCursorFormatting((_, hit, hits) => {
                                    *      return [
                                    *          ['Cursor pointing at'],
                                    *          [hit.series], // returning a series will display the series color and its name automatically.
                                    *          ['X', '', hit.axisX.formatValue(hit.x)], // utilizing axis formatValue is useful for considering active zoom level and type of axis
                                    *          ['Y', '', hit.y.toFixed(2)], // empty string '' results in gap between cells
                                    *          [{ text: 'Example', font: { weight: 'bold' }, fillStyle: fillRed }] // any cell can also be styled individually
                                    *      ]
                                    *  })
                                    * ```
                                    *
                                    * Before overriding default cursor formatting, it is recommended to check if using {@link GenericAxis.setUnits} or configuring Axis cursor formatting would be enough.
                                    *
                                    * In order to use series specific data properties (e.g. Heatmap sample "intensity"),
                                    * you should use type guards to assert the type of the `SolveResult`:
                                    *
                                    * ```ts
                                    *  // Example of using type guard in cursor formatter
                                    *  Chart.setCursorFormatting((chart, hit, hits) => {
                                    *      if (!isHitHeatmap(hit)) return undefined
                                    *      return [hit.intensity.toFixed(1)]
                                    *  })
                                    * ```
                                    *
                                    * More details in Developer documentation (Features \> Cursor).
                                    * @param   formatter -     Callback function for cursor formatting.
                                    * @returns     Object itself
                                    * @public
                                    */
                                   setCursorFormatting(formatter: CursorFormatterTreeMapChart): this;
                                   /**
                                    * Get active cursor formatter.
                                    * @returns     Cursor formatter.
                                    * @public
                                    */
                                   getCursorFormatting(): CursorFormatterTreeMapChart;
                                   /**
                                    * Add manually controlled Cursor object.
                                    * These have exactly same functions as built-in cursors but they can be freely controlled by application logic.
                                    *
                                    * ```ts
                                    *  const cursor = chart.addCursor()
                                    * ```
                                    *
                                    * Styling works same as built-in cursors (e.g. {@link setCursor}).
                                    *
                                    * Position is set using `setPosition` method and displayed content using `setResultTable(table => table.setContent(...))`
                                    * For more details, see Developer documentation \> Features \> Cursor \> Manual cursors
                                    *
                                    * @param   cursorBuilder -     Builder for cursor. Can be used to tweak a handful of properties which can't be changed during runtime.
                                    * @returns     Cursor object.
                                    * @public
                                    */
                                   addCursor<ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: CursorBuilder2D<ResultTableBackgroundType>): Cursor2D<ResultTableBackgroundType>;
                                   /**
                                    * Set component highlight animations enabled or not.
                                    * For most components this is enabled by default.
                                    *
                                    * ```js
                                    *  // Example usage, disable highlight animations.
                                    *  component.setAnimationHighlight(false)
                                    * ```
                                    *
                                    * This method does not work before map data is loaded. See {@link onMapDataReady}
                                    *
                                    * @param   enabled    - Animation enabled?
                                    * @returns            Object itself
                                    * @public
                                    */
                                   setAnimationHighlight(enabled: boolean): this;
                                   /**
                                    * Get component highlight animations enabled or not.
                                    *
                                    * @returns Boolean
                                    * @public
                                    */
                                   getAnimationHighlight(): boolean;
                                   /**
                                    * Set highlight on mouse hover enabled or disabled.
                                    *
                                    * Mouse interactions have to be enabled on the component for this to function as expected.
                                    * See {@link setMouseInteractions} for more information.
                                    *
                                    * @param state - True if highlighting on mouse hover, false if no highlight on mouse hover
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setHighlightOnHover(state: boolean): this;
                                   /**
                                    * Get boolean flag for whether object should highlight on mouse hover
                                    * @returns Boolean for if object should highlight on mouse hover or not.
                                    * @public
                                    */
                                   getHighlightOnHover(): boolean;
                                   /**
                                    * Get minimum size of Panel.
                                    * Depending on the type of class this value might be automatically computed to fit different elements.
                                    * @returns Vec2 minimum size or undefined if unimplemented
                                    * @public
                                    */
                                   getMinimumSize(): Point | undefined;
                                   /**
                                    * **Permanently** destroy the component.
                                    *
                                    * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                    * **to the component and its children** in application code.
                                    * ```javascript
                                    * let chart = ...ChartXY()
                                    * let axisX = chart.getDefaultAxisX()
                                    * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                    * chart.dispose()
                                    * chart = undefined
                                    * axisX = undefined
                                    * ```
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   dispose(): this;
                                   /**
                                    * Configure user interactions from a set of preset options.
                                    *
                                    * Without any explicit configuration, the charts select the default user interaction scheme based on available information,
                                    * such as axis types, attached series and data supplied to series.
                                    *
                                    * The `setUserInteraction` methods allow explicitly configuring the used interaction scheme.
                                    *
                                    * ```ts
                                    *  // Example, disable all user interactions
                                    *  chart.setUserInteractions(undefined)
                                    * ```
                                    *
                                    * @param   config -    Option with any set of properties of {@link TreeMapChartChartInteractions} or `undefined` to disable all interactions.
                                    * @returns     Object itself.
                                    * @public
                                    * @beta    Introduced in v7.0.0. API may change according to user feedback.
                                    */
                                   setUserInteractions(config: Partial<TreeMapChartChartInteractions> | undefined): this;
                                   /**
                                    * Get currently active user interaction scheme.
                                    * This does NOT return the last value supplied to {@link setUserInteractions}.
                                    * Rather, it considers the current structure of the chart, all built-in defaults as well as overrides supplied by the user
                                    * and returns the currently used interaction scheme.
                                    *
                                    * @returns     TreeMapChartChartInteractions
                                    * @public
                                    * @beta    Introduced in v7.0.0. API may change according to user feedback.
                                    */
                                   getUserInteractions(): TreeMapChartChartInteractions;
                                   /**
                                    * Interface for attaching listeners to user interaction events (`click`, `pointerenter`, etc.) on nodes of the treemap chart.
                                    *
                                    * ```ts
                                    *  // Example syntax
                                    *  chart.nodes.addEventListener('click', (event, node) => {
                                    *      console.log(event, node)
                                    *  })
                                    * ```
                                    *
                                    * For more syntax examples, refer to {@link EventInterface}.
                                    * Available event keys are listed under {@link LCJSInteractionEventMap}
                                    * @public
                                    */
                                   readonly nodes: Eventer<LCJSInteractionEventMap, TreeMapUserNode>;
                                   addEventListener<K extends keyof TreeMapChartEventMap>(type: K, listener: (event: TreeMapChartEventMap[K], info: SolveResultTreeMapChart) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof TreeMapChartEventMap>(type: K, listener: (event: TreeMapChartEventMap[K], info: SolveResultTreeMapChart) => unknown): void;
                               }
                               /**
                                * @public
                                * @beta    Introduced in v7.0.0. API may change according to user feedback.
                                */
                               export declare interface TreeMapChartChartInteractions {
                                   drillDown?: {
                                       click?: boolean;
                                   };
                               }
                               /**
                                * Interface of events trackable by {@link TreeMapChart.addEventListener} and the respective Event types.
                                * @public
                                */
                               export declare interface TreeMapChartEventMap extends PanelEventMap, ChartWithCursorEventMap<SolveResultTreeMapChart> {
                                   /**
                                    * Event fired when the visible nodes change
                                    *
                                    * ```ts
                                    *  // Example usage
                                    *  chart.addEventListener('viewchange', (event) => {
                                    *      console.log(event)
                                    *  })
                                    * ```
                                    */
                                   viewchange: TreeMapChartViewChangeEvent;
                               }
                               /**
                                * @public
                                */
                               export declare interface TreeMapChartOptions<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
                                   /**
                                    * Builder for the charts' *auto cursor*.
                                    *
                                    * For most use cases, it is not recommended to use this, but rather {@link TreeMapChart.setCursor} for a more convenient API.
                                    * @public
                                    */
                                   readonly cursorBuilder?: CursorBuilder2D<CursorResultTableBackgroundType>;
                               }
                               /**
                                * @public
                                */
                               export declare interface TreeMapChartViewChangeEvent {
                                   nodes: TreeMapUserNode[];
                               }
                               /**
                                * The input data format for End User
                                * @public
                                */
                               export declare interface TreeMapUserNode {
                                   name: string;
                                   value?: number | string;
                                   children?: TreeMapUserNode[];
                                   [key: string]: unknown;
                               }
                               /**
                                * A style class used to specify style of 3D points rendering as triangulated shapes.
                                *
                                * Supports specifying shape as a **cube** or a **sphere**.
                                * @public
                                */
                               export declare class TriangulatedPoints3D extends TriangulatedPoints3DRecord {
                                   /**
                                    * When creating a new TriangulatedPoints3D object, any amount of its default parameters can be *overriden*, by supplying the
                                    * values to its constructor:
                                    * ```javascript
                                    *  new PointStyle3D.Triangulated({
                                    *      size: 10,
                                    *      fillStyle: new SolidFill({ color: ColorHex('#FFF') }),
                                    *  })
                                    * ```
                                    * @param props - Optional object containing any amount of parameters of TriangulatedPoints3D
                                    * @public
                                    */
                                   constructor(props?: Partial<TriangulatedPoints3DProperties>);
                                   /**
                                    * Construct a new TriangulatedPoints3D object based on this one, but with different size.
                                    *
                                    * Two size definitions are supported: `number` and `Coord3D`:
                                    *
                                    * `number`:
                                    *
                                    * Symmetric size as _normalized World Units_ (roughly equal to pixels).
                                    *
                                    * {@link Coord3D}:
                                    *
                                    * User supplies size on each Axis, X, Y and Z individually, as Axis coordinates.
                                    *
                                    * ```js
                                    *  // Example syntax, 3D point size in Axis dimensions.
                                    *  pointSeries3D.setPointStyle(new TriangulatedPoints3D({
                                    *      size: { x: 10, y: 5, z: 200 },
                                    *      shape: 'sphere',
                                    *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                                    *  }))
                                    * ```
                                    *
                                    * @param size - Points size.
                                    * @returns New TriangulatedPoints3D object
                                    * @public
                                    */
                                   setSize(size: number | Coord3D): this;
                                   /**
                                    * Get size of points rendered with this style object.
                                    * @returns Point size.
                                    * @public
                                    */
                                   getSize(): number | Coord3D;
                                   /**
                                    * Construct a new TriangulatedPoints3D object based on this one, but with modified fill style.
                                    *
                                    * Example usage:
                                    *
                                    * | Desired result         | Argument                                      |
                                    * | :--------------------- | :-------------------------------------------- |
                                    * | Specified FillStyle    | new SolidFill(\{ color: ColorHex('#F00') \})    |
                                    *
                                    * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                                    * @returns New TriangulatedPoints3D object
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of TriangulatedPoints3D.
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Construct a new TriangulatedPoints3D object based on this one, but with modified wireframe style.
                                    *
                                    * ```js
                                    *  // Example syntax,
                                    *  pointSeries3D.setPointStyle((style) => style
                                    *      .setWireframeStyle(new SolidLine({
                                    *          thickness: 1,
                                    *          fillStyle: new SolidFill({ color: ColorRGBA(255, 215, 0, 25) })
                                    *      }))
                                    *  )
                                    * ```
                                    *
                                    * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
                                    * @returns New TriangulatedPoints3D object
                                    * @public
                                    */
                                   setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get wireframe style of TriangulatedPoints3D.
                                    * @returns LineStyle object
                                    * @public
                                    */
                                   getWireframeStyle(): LineStyle;
                               }
                               /**
                                * Interface for all properties of a TriangulatedPoints3D.
                                * @public
                                */
                               export declare interface TriangulatedPoints3DProperties {
                                   type: 'triangulated-points-3d';
                                   /**
                                    * Shape of rendered points.
                                    */
                                   shape: 'cube' | 'sphere';
                                   /**
                                    * Points size.
                                    *
                                    * Supports two types `number` or `Coord3D`:
                                    *
                                    * `number`:
                                    *
                                    * Symmetric size as _normalized World Units_ (roughly equal to pixels).
                                    *
                                    * {@link Coord3D}:
                                    *
                                    * User supplies size on each Axis, X, Y and Z individually, as Axis coordinates.
                                    *
                                    * ```js
                                    *  // Example syntax, 3D point size in Axis dimensions.
                                    *  pointSeries3D.setPointStyle(new TriangulatedPoints3D({
                                    *      size: { x: 10, y: 5, z: 200 },
                                    *      shape: 'sphere',
                                    *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                                    *  }))
                                    * ```
                                    */
                                   size: number | Coord3D;
                                   /**
                                    * *FillStyle* for rendering the points.
                                    */
                                   fillStyle: FillStyle;
                                   /**
                                    * *LineStyle* for rendering geometry wireframe.
                                    */
                                   wireframeStyle: LineStyle;
                               }
                               /**
                                * Record contractor for TriangulatedPoints3DProperties.
                                * @public
                                */
                               declare const TriangulatedPoints3DRecord: Record_2.Factory<TriangulatedPoints3DProperties>;
                               /**
                                * Type union of all JavaScript typed arrays.
                                *
                                * Read more [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays)
                                * @public
                                */
                               export declare type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;
                               /**
                                * Type union for all constructors of a {@link TypedArray}.
                                * @public
                                */
                               export declare type TypedArrayConstructor = Int8ArrayConstructor | Uint8ArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Uint8ClampedArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor;
                               /**
                                * Public interface of Background.
                                * Type of UiElement that can be used as a Background of another element.
                                * @public
                                */
                               export declare interface UIBackground {
                                   /**
                                    * Set FillStyle of Background.
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * @returns Current Background FillStyle
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set stroke style of Background.
                                    * @param value - LineStyle object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * @returns Current Background LineStyle
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                               }
                               /**
                                * Collection of available {@link UIBackgrounds} Can be used to customize the *background* of an *UIElement*.
                                *
                                * *Background* must be specified when the *UIElement* is created by method of its *builder*.
                                *
                                * Example usage:
                                *```javascript
                                * // Create TextBox with specified Background
                                * Chart.addUIElement(UIElementBuilders.TextBox.setBackground(UIBackgrounds.Circle))
                                * ```
                                * @public
                                */
                               export declare const UIBackgrounds: {
                                   /**
                                    * No background.
                                    */
                                   None: typeof UIEmptyBackground;
                                   /**
                                    * Rectangular background.
                                    */
                                   Rectangle: typeof UIRectangle;
                                   /**
                                    * Circular background.
                                    */
                                   Circle: typeof UICircle;
                                   /**
                                    * 45 degree rotated rectangle background.
                                    */
                                   Diamond: typeof UIDiamond;
                                   /**
                                    * Arrow-like background.
                                    *
                                    * The *Pointers* direction can be modified by, for example:
                                    *
                                    * *UIElement*.setBackground((pointer) =\> pointer.setDirection(**UIDirections.Up**))
                                    *
                                    * This will throw an *error* if used on an *UIElement* with any other *Background*!
                                    */
                                   Pointer: typeof UIPointer;
                               };
                               /**
                                * Interface for 'CheckBox'.
                                * @public
                                */
                               export declare interface UICheckBox<BackgroundType extends UIBackground = UIBackground> extends UIPartWithBackground<BackgroundType>, CustomizableText, StylableButton, Switchable {
                                   /**
                                    * Set text fill style when check box is OFF
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setTextFillStyleHidden(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * @returns Current text fill style
                                    * @public
                                    */
                                   getTextFillStyleHidden(): FillStyle;
                                   addEventListener<K extends keyof UICheckBoxEventMap>(key: K, listener: (event: UICheckBoxEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof UICheckBoxEventMap>(key: K, listener: (event: UICheckBoxEventMap[K], info: unknown) => unknown): void;
                               }
                               /**
                                * Interface for 'CheckBox'-builder.
                                * @public
                                */
                               export declare interface UICheckBoxBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UICheckBox<BackgroundType>> {
                                   /**
                                    * Make new CheckBoxBuilder with different background.
                                    * @param newBackground - Constructor for desired Background. See {@link UIBackgrounds} for a collection of options.
                                    * @public
                                    */
                                   setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: BackgroundConstructor<NewBackgroundType>): UICheckBoxBuilder<NewBackgroundType>;
                                   /**
                                    * Set button shape.
                                    *
                                    * NOTE: It is recommended to use {@link UICheckBox.setButtonShape} method instead, as it provides more flexibility (can be called during run-time after check box is created).
                                    *
                                    * ```ts
                                    *  // Example
                                    *  setButtonShape(PointShape.Star)
                                    * ```
                                    *
                                    * See {@link PointShape} for all available options.
                                    *
                                    * @public
                                    */
                                   setButtonShape(shape: PointShape | Icon): UICheckBoxBuilder<BackgroundType>;
                               }
                               /**
                                * Interface of events trackable by {@link UICheckBox.addEventListener} and the respective Event types.
                                * @public
                                */
                               export declare interface UICheckBoxEventMap extends UIElementEventMap, SwitchEventMap {
                               }
                               /**
                                * Circular UI shape that can be used as Background and as Button picture.
                                * @public
                                */
                               export declare class UICircle extends BorderedPicture implements InternalBackground {
                                   /**
                                    * Set fill style of Picture
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Picture
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set stoke style of Picture
                                    * @param value - LineStyle object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get stroke style of Picture
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                                   /**
                                    * Fit object to bounding box.
                                    * @param bounds - Bounds in pixels
                                    * @returns Object itself
                                    * @public
                                    */
                                   fitTo(bounds: Point): this;
                               }
                               /**
                                * Interface for builder of UiColumn layout
                                * @public
                                */
                               export declare interface UIColumnBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UIElementColumn<BackgroundType>> {
                                   /**
                                    * Make new ColumnBuilder with different background
                                    * @public
                                    */
                                   setBackground<NewBackgroundType extends BackgroundType>(newBackground: BackgroundConstructor<NewBackgroundType>): UIColumnBuilder<NewBackgroundType>;
                               }
                               /**
                                * 45 degrees rotated Rectangle background.
                                * @public
                                */
                               export declare class UIDiamond extends UIPolygon implements InternalBackground {
                                   /**
                                    * Set fill style of Picture
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Picture
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set stoke style of Picture
                                    * @param value - LineStyle object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get stroke style of Picture
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                                   /**
                                    * Fit object to bounding box.
                                    * @param bounds - Bounds in pixels
                                    * @returns Object itself
                                    * @public
                                    */
                                   fitTo(bounds: Point): this;
                               }
                               /**
                                * Enum for specifying a direction. Used for styling *Pointable* *UIElements*.
                                * @public
                                */
                               export declare enum UIDirections {
                                   Up = 0,
                                   Right = 1,
                                   Down = 2,
                                   Left = 3
                               }
                               /**
                                * Enum for selecting behavior of dragging interactions of *UIElements*. Dragging can be done by both mouse and touch.
                                *
                                * Use with {@link UIElement.setDraggingMode}
                                * @public
                                */
                               export declare enum UIDraggingModes {
                                   /**
                                    * *UIElement* is not draggable.
                                    */
                                   notDraggable = 0,
                                   /**
                                    * *UIElement* is draggable.
                                    */
                                   draggable = 1,
                                   /**
                                    * *UIElement* is only draggable on horizontal plane.
                                    */
                                   onlyHorizontal = 2,
                                   /**
                                    * *UIElement* is only draggable on vertical plane.
                                    */
                                   onlyVertical = 3
                               }
                               /**
                                * Interface for a stand-alone *UIElement*.
                                *
                                * Adds ability for:
                                * - Setting position
                                * - Specifying draggability
                                * @public
                                */
                               export declare interface UIElement extends UIObject, UIPart, Draggable, Plotable {
                                   /**
                                    * Sets the position of this UiElement relative to its origin
                                    * @param position - Position
                                    * @public
                                    */
                                   setPosition(position: Point): this;
                                   /**
                                    * Returns the position of this UiElement at given location relative to elements size.
                                    * @param relativePosition - Relative position vector (-1 to 1 which specifies position of origin, 0 is center of the object)
                                    * @param spaceOfInterest - Parameter to disregard parts of object when calculating the asked position. Defaults to Margin.
                                    * @returns Object itself for fluent itself
                                    * @public
                                    */
                                   getPosition(relativePosition?: Point, spaceOfInterest?: UISpace): Point;
                                   /**
                                    * Sets the position origin of this UiElement.
                                    * @param origin - Relative position vector (-1 to 1, where 0 is center of the object).
                                    *                  UIOrigins, enum-like object can be used for easy selection of common values
                                    * @public
                                    */
                                   setOrigin(origin: Point): this;
                                   /**
                                    * Returns the position origin of this UiElement.
                                    * @returns Relative position vector (-1 to 1, where 0 is center of the object).
                                    * @public
                                    */
                                   getOrigin(): Point;
                                   /**
                                    * Returns the size of the UiElements in pixels including any Margins or Paddings
                                    * @param spaceOfInterest - Parameter to disregard parts of object when calculating the position. Defaults to Margin,
                                    *                              which includes everything. Should only ever be necessary for sub-classes
                                    * @returns Object size in pixels
                                    * @public
                                    */
                                   getSize(spaceOfInterest?: UISpace): Point;
                                   /**
                                    * Set auto dispose behavior for this UI element.
                                    *
                                    * Can be used to set a condition, where the UI element is automatically *disposed*, removing it from view.
                                    *
                                    * ```ts
                                    *  // Example, remove UI element when it is larger than 20% of viewport.
                                    *  UIElement.setAutoDispose({
                                    *      type: 'max-width',
                                    *      maxWidth: 0.20,
                                    *  })
                                    * ```
                                    * @param autoDisposeMode - Auto dispose mode.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setAutoDispose(autoDisposeMode: AutoDisposeMode): this;
                                   /**
                                    * Get auto dispose behavior for this UI element.
                                    * @returns Auto dispose mode.
                                    * @public
                                    */
                                   getAutoDispose(): AutoDisposeMode;
                                   addEventListener<K extends keyof UIElementEventMap>(key: K, listener: (event: UIElementEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof UIElementEventMap>(key: K, listener: (event: UIElementEventMap[K], info: unknown) => unknown): void;
                               }
                               /**
                                * Interface for abstract UiElement builder
                                * @public
                                */
                               export declare interface UIElementBuilder<UIElementType extends UIPart = UIPart> {
                                   /**
                                    * Make new Builder with an additional styler.
                                    * @param styler - UiElementStyler for specific type
                                    * @returns New Builder
                                    * @public
                                    */
                                   addStyler(styler: UIElementStyler<UIElementType>): this;
                               }
                               /**
                                * Collection of available *UIElement* *builders*. To build *UIElements* you must pass one of these to method: **addUIElement()**.
                                * This method can be accessed through *Charts*, {@link Dashboard}, Etc.
                                *
                                * Example usage:
                                *```javascript
                                * // Create a TextBox on a ChartXY
                                * ChartXY.addUIElement(UIElementBuilders.TextBox)
                                * // Create a CheckBox on a Dashboard
                                * Dashboard.addUIElement(UIElementBuilders.CheckBox)
                                * ```
                                * @public
                                */
                               export declare const UIElementBuilders: {
                                   /**
                                    * *UIElement* that displays text over a *Background*.
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Create a TextBox
                                    * Chart.addUIElement(UIElementBuilders.TextBox)
                                    * ```
                                    */
                                   TextBox: UITextBoxBuilder;
                                   /**
                                    * *UIElement* that displays a toggleable checkbox and text over a *Background*.
                                    *
                                    * By default, *Background* is empty. To show it you must specify it using method of the *builder*, **setBackground**
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Create a CheckBox
                                    * Chart.addUIElement(UIElementBuilders.CheckBox)
                                    * // Create a CheckBox with specified Background
                                    * Chart.addUIElement(UIElementBuilders.CheckBox.setBackground(UIBackgrounds.Circle))
                                    * // Create a CheckBox with specified ButtonPicture
                                    * Chart.addUIElement(UIElementBuilders.CheckBox.setButtonShape(PointShape.Diamond))
                                    * ```
                                    */
                                   CheckBox: UICheckBoxBuilder;
                                   /**
                                    * *UIElement* that displays a button and text over a *Background*.
                                    *
                                    * By default, *Background* is empty. To show it you must specify it using method of the *builder*, **setBackground**
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Create a ButtonBox
                                    * Chart.addUIElement(UIElementBuilders.ButtonBox)
                                    * // Create a ButtonBox with specified Background
                                    * Chart.addUIElement(UIElementBuilders.ButtonBox.setBackground(UIBackgrounds.Circle))
                                    * // Create a ButtonBox with specified ButtonPicture
                                    * Chart.addUIElement(UIElementBuilders.ButtonBox.setButtonShape(PointShape.Diamond))
                                    * ```
                                    */
                                   ButtonBox: UICheckBoxBuilder;
                                   /**
                                    * *UIElement builder* that is intended to be used with *custom axis ticks*.
                                    * See {@link Axis.addCustomTick} for example usage, and more information.
                                    *
                                    * *PointableTextBox* is a text label enclosed within a background shaped in the form of an *arrow*.
                                    */
                                   PointableTextBox: UIPointableTextBoxBuilder;
                                   /**
                                    * *UIElement builder* that is intended to be used with *custom axis ticks*.
                                    * See {@link Axis.addCustomTick} for example usage, and more information.
                                    *
                                    * *AxisTick* is a text label connected to a *tick line* - fundamentally equal to a *default axis tick* shape.
                                    */
                                   AxisTickMajor: UITickBuilder;
                                   /**
                                    * *UIElement builder* that is intended to be used with *custom axis ticks*.
                                    * See {@link Axis.addCustomTick} for example usage, and more information.
                                    *
                                    * *AxisTick* is a text label connected to a *tick line* - fundamentally equal to a *default minor axis tick* shape.
                                    */
                                   AxisTickMinor: UITickBuilder;
                                   /**
                                    * *UIElement builder* that can be used to build a {@link UILUTRange} component.
                                    * which displays a color lookup table range with labels.
                                    *
                                    * ```js
                                    *  // Example usage,
                                    *  const lutRange = chart.addUIElement(UIElementBuilders.LUTRange)
                                    *      .setLUT(myLut)
                                    * ```
                                    */
                                   LUTRange: UILUTRangeBuilder;
                               };
                               /**
                                * UI Layout for positioning UIElements in a column.
                                * @public
                                */
                               export declare class UIElementColumn<BackgroundClass extends UIBackground = UIBackground> extends UIElementLine<BackgroundClass> {
                                   /**
                                    * Add gap to Column.
                                    * Gap can have fixed height and it also has custom logic which makes it occupy any extra space
                                    * caused by setting the minimum size for Line.
                                    * @param fixedSize - Optional fixed size to set gap
                                    * @returns Gap object
                                    * @public
                                    */
                                   addGap(fixedSize?: pixel, index?: number): UILayoutGap;
                               }
                               /**
                                * Interface of events trackable by {@link UIElement.addEventListener} and the respective Event types.
                                * @public
                                */
                               export declare interface UIElementEventMap extends UIObjectEventMap, DisposableEventMap, HighlightableEventMap {
                               }
                               /**
                                * Base class for positioning of UiElements in a line
                                * @public
                                */
                               export declare abstract class UIElementLine<BackgroundType extends UIBackground = UIBackground> extends UIElementWithBackground<BackgroundType> {
                                   /**
                                    * Returns list of UiElements inside Line
                                    * @public
                                    */
                                   getMembers(): Array<UIPart>;
                                   /**
                                    * Get amount of members in group.
                                    * @returns Number
                                    * @public
                                    */
                                   getMemberCount(): number;
                                   /**
                                    * Set minimum size Layout should occupy (in direction of layout).
                                    * If set, Layout will distribute any extra space to UiLayoutGaps among its members.
                                    * @param minSize - Min size Layout should occupy (in direction of layout) or undefined to disable feature
                                    * @returns Object itself
                                    * @public
                                    */
                                   setMinimumSize(minSize: pixel | undefined): this;
                                   /**
                                    * Get minimum size Layout should occupy (in direction of layout).
                                    * If set, Layout will distribute any extra space to UiLayoutGaps among its members.
                                    * @returns Min size Layout should occupy (in direction of layout) or undefined to disable feature
                                    * @public
                                    */
                                   getMinimumSize(): pixel | undefined;
                                   /**
                                    * Add any UiElement using a builder
                                    * @param builder - Builder for any UiElement
                                    * @param index - Index position or \< 0 to push
                                    * @returns Created UiElement
                                    * @public
                                    */
                                   addElement<UiElementType extends UIPart>(builder: UIElementBuilder<UiElementType>, index?: number): UiElementType;
                                   /**
                                    * Add gap to line.
                                    * Gap can have fixed size and it also has custom logic which makes it occupy any extra space
                                    * caused by setting the minimum size for Line.
                                    * @param fixedSize - Optional fixed size to set gap
                                    * @param index - Index position or \< 0 to push
                                    * @returns Object itself
                                    * @public
                                    */
                                   abstract addGap(fixedSize?: pixel, index?: number): UILayoutGap;
                                   /**
                                    * **Permanently** destroy the component.
                                    *
                                    * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                    * **to the component and its children** in application code.
                                    * ```javascript
                                    * let chart = ...ChartXY()
                                    * let axisX = chart.getDefaultAxisX()
                                    * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                    * chart.dispose()
                                    * chart = undefined
                                    * axisX = undefined
                                    * ```
                                    * @returns  Object itself for fluent interface
                                    * @public
                                    */
                                   dispose(): this;
                                   /**
                                    * Set element visibility.
                                    *
                                    * @param state - `true` when element should be visible and `false` when element should be hidden.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setVisible(state: boolean): this;
                                   /**
                                    * Set mouse interactions enabled.
                                    * This will set the states of all members inside the Layout, overriding any previous settings.
                                    * @param state - Mouse interactions enabled
                                    * @public
                                    */
                                   setPointerEvents(state: boolean): this;
                                   /**
                                    * Get mouse interactions enabled.
                                    * @returns True if any member of Layout has mouse interactions enabled.
                                    * @public
                                    */
                                   getPointerEvents(): boolean;
                                   /**
                                    * Set state of component highlighting.
                                    *
                                    * ```ts
                                    *  // Example usage
                                    *
                                    *  component.setHighlight(true)
                                    *
                                    *  component.setHighlight(0.5)
                                    * ```
                                    *
                                    * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setHighlight(highlight: boolean | number): this;
                               }
                               /**
                                * UI Layout for positioning UIElements in a row.
                                * @public
                                */
                               export declare class UIElementRow<BackgroundClass extends UIBackground = UIBackground> extends UIElementLine<BackgroundClass> {
                                   /**
                                    * Add gap to Row.
                                    * Gap can have fixed width and it also has custom logic which makes it occupy any extra space
                                    * caused by setting the minimum size for Line.
                                    * @param fixedSize - Optional fixed size to set gap
                                    * @returns Object itself
                                    * @public
                                    */
                                   addGap(fixedSize?: pixel, index?: number): UILayoutGap;
                               }
                               /**
                                * Type of function for styling a generic UIElement.
                                * @public
                                */
                               export declare type UIElementStyler<T = UIElement> = (object: T, theme: Theme) => unknown;
                               /**
                                * Public interface for a UiElement with background.
                                * @public
                                */
                               export declare abstract class UIElementWithBackground<BackgroundType extends UIBackground = UIBackground> extends InternalUIElement implements UIPartWithBackground<UIBackground> {
                                   /**
                                    * Set mouse interactions enabled.
                                    * This will set the states of all members inside the Layout, overriding any previous settings.
                                    * @param state - Mouse interactions enabled
                                    * @public
                                    */
                                   setPointerEvents(state: boolean): this;
                                   /**
                                    * Method for mutating Background of object.
                                    *
                                    * Type of Background is generic, see {@link UIBackground} for minimum interface.
                                    * @param mutator - Mutator function for Background
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setBackground(mutator: Mutator<BackgroundType>): this;
                                   /**
                                    * Get Background of object.
                                    *
                                    * Type of Background is generic, see {@link UIBackground} for minimum interface.
                                    * @returns Background object
                                    * @public
                                    */
                                   getBackground(): BackgroundType;
                                   /**
                                    * **Permanently** destroy the component.
                                    *
                                    * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                    * **to the component and its children** in application code.
                                    * ```javascript
                                    * let chart = ...ChartXY()
                                    * let axisX = chart.getDefaultAxisX()
                                    * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                    * chart.dispose()
                                    * chart = undefined
                                    * axisX = undefined
                                    * ```
                                    * @returns  Object itself for fluent interface
                                    * @public
                                    */
                                   dispose(): this;
                                   /**
                                    * Set element visibility.
                                    *
                                    * @param state - `true` when element should be visible and `false` when element should be hidden.
                                    * @returns Object itself.
                                    */
                                   setVisible(state: boolean): this;
                                   private _padding;
                                   /**
                                    * Set padding around object in pixels.
                                    * Padding is empty space between the UiElements content and Background
                                    * @param padding - Number with pixel margins for all sides or datastructure with individual pixel paddings
                                    *                      for each side. Any side can be omitted, only passed values will be overridden.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setPadding(padding: Partial<Margin> | number): this;
                                   /**
                                    * Get padding around object in pixels.
                                    * Padding is empty space between the UiElements content and Background
                                    * @returns Margin datastructure
                                    * @public
                                    */
                                   getPadding(): Margin;
                                   /**
                                    * Returns the size of the UiElements in pixels including any Margins or Paddings
                                    * @param spaceOfInterest - Parameter to disregard parts of object when calculating the position. Defaults to Margin,
                                    *                              which includes everything. Should only ever be necessary for sub-classes
                                    * @returns Object size in pixels
                                    * @public
                                    */
                                   getSize(spaceOfInterest?: UISpace): Point;
                                   /**
                                    * Returns the position of this UiElement at given location relative to elements size.
                                    * @param relativePosition - Relative position vector (-1 to 1 which specifies position of origin, 0 is center of the object)
                                    * @param spaceOfInterest - Parameter to disregard parts of object when calculating the asked position.
                                    * @returns Object itself for fluent itself
                                    * @public
                                    */
                                   getPosition(relativePosition?: Point, spaceOfInterest?: UISpace): Point;
                                   /**
                                    * @returns 1 for highlighted state of object and 0 for basic
                                    * @public
                                    */
                                   getHighlight(): number;
                                   /**
                                    * Set highlighted state of the Object.
                                    * Implementations should also remember to highlight themselves here.
                                    * @param highlight - Highlight state of the object
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setHighlight(highlight: boolean | number): this;
                               }
                               /**
                                * Empty background.
                                *
                                * Indicates that the *Background* can't and shouldn't be styled as it won't be rendered.
                                * @public
                                */
                               export declare class UIEmptyBackground extends EmptyUIElement implements InternalBackground {
                                   /**
                                    * Set state of component highlighting.
                                    *
                                    * ```ts
                                    *  // Example usage
                                    *
                                    *  component.setHighlight(true)
                                    *
                                    *  component.setHighlight(0.5)
                                    * ```
                                    *
                                    * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setHighlight(highlight: boolean | number): this;
                                   /**
                                    * Get state of component highlighting.
                                    *
                                    * @returns Number between 0 and 1, where 1 is fully highlighted.
                                    * @public
                                    */
                                   getHighlight(): number;
                                   /**
                                    * Set fill style object
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setFillStyle(): this;
                                   /**
                                    * @returns Current fill style object
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set stroke style object
                                    * @param value - LineStyle object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setStrokeStyle(): this;
                                   /**
                                    * @returns Current stroke style object
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                                   /**
                                    * Set stroke thickness in pixels
                                    * @param thickness - Stroke thickness in pixels
                                    * @returns Icon itself for fluent interface
                                    * @public
                                    */
                                   setStrokeThickness(): this;
                                   /**
                                    * @returns Object stroke thickness
                                    * @public
                                    */
                                   getStrokeThickness(): number;
                               }
                               /**
                                * Collection of *UIElementBuilder*s for *Layout*s. These allow positioning multiple *UIElements* relative to each other.
                                * @public
                                */
                               export declare const UILayoutBuilders: {
                                   /**
                                    * *UIElement* for column layout, added *UIElements* will be layed out after one another **vertically**. Has a *Background*.
                                    *
                                    * By default, *Background* is hidden (style = {@link emptyFill}). To show it you must give it a style with: **UIColumn.setFillStyle**
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Create a Column
                                    * Chart.addUIElement(UILayouts.Column)
                                    * // Create a Column with specified Background
                                    * Chart.addUIElement(UILayouts.Column.setBackground(UIBackgrounds.Circle))
                                    * ```
                                    */
                                   Column: UIColumnBuilder;
                                   /**
                                    * *UIElement* for row layout, added *UIElements* will be layed out after one another **horizontally**. Has a *Background*.
                                    *
                                    * By default, *Background* is hidden (style = {@link emptyFill}). To show it you must give it a style with: **UIRow.setFillStyle**
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Create a Row
                                    * Chart.addUIElement(UILayouts.Row)
                                    * // Create a Row with specified Background
                                    * Chart.addUIElement(*UILayouts.Row.setBackground(UIBackgrounds.Circle))
                                    * ```
                                    */
                                   Row: UIRowBuilder;
                               };
                               /**
                                * UiElement class that marks a 'gap' in line-layouts.
                                * Positioning logic will make it so these gaps occupy all extra space.
                                * @public
                                */
                               export declare class UILayoutGap extends EmptyUIElement {
                                   /**
                                    * Set size of gap.
                                    * @param size - Size of gap as Vec2 of pixels
                                    * @returns Object itself
                                    * @public
                                    */
                                   setSize(size: Point): this;
                               }
                               /**
                                * Component that can be added to a {@link Dashboard}, with method {@link Dashboard.createLegendPanel}.
                                *
                                * It is a convenience component for placing *legend items* from multiple different *charts* into a single *row layout*.
                                *
                                * **Example usage:**
                                *
                                * ```typescript
                                *  // Add a UILegendPanel to a Dashboard.
                                *  const legendPanel = dashboard.createLegendPanel({
                                *      columnIndex: 0,
                                *      rowIndex: 0,
                                *      columnSpan: 1,
                                *      rowSpan: 1,
                                *  })
                                *
                                *  // Add charts to shared Legend.
                                *  legendPanel
                                *      .add(myChart1)
                                *      .add(myChart2)
                                * ```
                                *
                                * **Frequently used methods:**
                                * - {@link UILegendPanel.add}
                                *
                                * **Related APIs**:
                                * - {@link Legend}
                                *
                                * For more application specific Legend requirements, it is recommended to:
                                * - Use {@link UIPanel} and manage UI layouts and checkboxes on user application side.
                                * - Craft the *user interface* outside LCJS, with *HTML* for example.
                                * @public
                                */
                               export declare class UILegendPanel extends UIPanel {
                                   legend: Legend;
                                   /**
                                    * Attach a *Chart* or collection of *Charts* to the *legend panel*.
                                    *
                                    * This appends a new *legend* to the panel, which will contain *entries* for all the attachable components in the supplied *chart*.
                                    *
                                    * The supplied argument can be either a single *chart*, or a *dashboard*, in which case all
                                    * currently existing charts inside the dashboard will be attached.
                                    *
                                    * **Example usage**:
                                    *
                                    * ```typescript
                                    *  // Add charts to LegendPanel.
                                    *  legendPanel
                                    *      .add(myChart1)
                                    *      .add(myChart2)
                                    *
                                    *  // ... or add all charts inside a Dashboard with a single call.
                                    *  legendPanel.add(dashboard)
                                    * ```
                                    *
                                    * @param value - Chart or Dashboard.
                                    * @param opts - Optional extra configuration arguments.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   add(value: Attachable | Chart | Dashboard | LUT): this;
                                   /**
                                    * Get minimum size of UIPanel in pixels as set by user.
                                    * @returns Point minimum size in pixels or undefined
                                    */
                                   getMinimumSize(): Point | undefined;
                               }
                               /**
                                * Interface for 'LUTCheckBox'.
                                * @public
                                */
                               export declare interface UILUTCheckBox<BackgroundType extends UIBackground = UIBackground> extends UICheckBox<BackgroundType> {
                                   /**
                                    * Set attached LUT (color look up table).
                                    * @param lut - LUT (color look up table).
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setLUT(lut: LUT): this;
                                   /**
                                    * Get attached LUT (color look up table).
                                    * @returns (color look up table).
                                    * @public
                                    */
                                   getLUT(): LUT | undefined;
                                   /**
                                    * Set length of LUT box as pixels.
                                    * @param lengthPixels - Length as pixels.
                                    * @public
                                    */
                                   setLUTLength(lengthPixels: number): this;
                                   /**
                                    * Get length of LUT box as pixels.
                                    * @returns Length as pixels.
                                    * @public
                                    */
                                   getLUTLength(): number;
                                   /**
                                    * Set thickness of LUT box as pixels.
                                    * @param thicknessPixels - Thickness as pixels.
                                    * @public
                                    */
                                   setLUTThickness(thicknessPixels: number): this;
                                   /**
                                    * Get thickness of LUT box as pixels.
                                    * @returns Thickness as pixels.
                                    * @public
                                    */
                                   getLUTThickness(): number;
                                   /**
                                    * Set displayed unit of Look Up Values. For example, "mm/h" (millimetres per hour).
                                    * @param unit - String to display next to Look Up Values.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setLookUpUnit(unit: string): this;
                                   /**
                                    * Get displayed unit of Look Up Values. For example, "mm/h" (millimetres per hour).
                                    * @returns String to display next to Look Up Values.
                                    * @public
                                    */
                                   getLookUpUnit(unit: string): this;
                                   /**
                                    * Specify step value formatting of LUT Legend.
                                    *
                                    * **Example usage:**
                                    *
                                    * ```ts
                                    *  // Display one fraction.
                                    *  setStepValueFormatter((step, lut) => step.value.toFixed(1))
                                    * ```
                                    * @param formatter - Callback function that receives the {@link LUTStep} object created by user, and maps it into a string that is displayed in the label.
                                    * @public
                                    */
                                   setLUTStepValueFormatter(formatter: (step: LUTStep, lut: LUT) => string): this;
                                   /**
                                    * Set whether distances between LUT step values are displayed, or if the displayed LUT steps should be split equal distances apart.
                                    *
                                    * By default this is disabled.
                                    * @param enabled - enabled Boolean.
                                    * @returns              Object itself.
                                    */
                                   setLUTDisplayProportionalSteps(enabled: boolean): this;
                                   /**
                                    * Get whether distances between LUT step values are displayed, or if the displayed LUT steps should be split equal distances apart.
                                    *
                                    * By default this is disabled.
                                    * @returns              Boolean.
                                    */
                                   getLUTDisplayProportionalSteps(): boolean;
                                   /**
                                    * Set fill style of LUT color steps and unit.
                                    *
                                    * Note that this style is overridden by calls to `setTextFillStyle`, which affects all text of the component.
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setLUTTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * @returns Current fill style of LUT color steps and unit
                                    * @public
                                    */
                                   getLUTTextFillStyle(): FillStyle;
                                   /**
                                    * Set font of LUT color steps and unit text.
                                    *
                                    * Note that this style is overridden by calls to `setTextFont`, which affects all text of the component.
                                    * @param value - FontSettings or mutator function for existing settings
                                    * @returns Object itself
                                    * @public
                                    */
                                   setLUTTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get font of LUT color steps and unit text.
                                    * @returns FontSettings
                                    * @public
                                    */
                                   getLUTTextFont(): FontSettings;
                               }
                               /**
                                * Interface for 'LUTCheckBox'-builder.
                                * @public
                                */
                               export declare interface UILUTCheckBoxBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UILUTCheckBox<BackgroundType>> {
                                   /**
                                    * Make new UILUTCheckBoxBuilder with different background.
                                    * @param newBackground - Constructor for desired Background. See {@link UIBackgrounds} for a collection of options.
                                    * @public
                                    */
                                   setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: BackgroundConstructor<NewBackgroundType>): UILUTCheckBoxBuilder<NewBackgroundType>;
                                   /**
                                    * Set button shape.
                                    *
                                    * NOTE: It is recommended to use {@link UILUTCheckBox.setButtonShape} method instead, as it provides more flexibility (can be called during run-time after check box is created).
                                    *
                                    * ```ts
                                    *  // Example
                                    *  setButtonShape(PointShape.Star)
                                    * ```
                                    *
                                    * See {@link PointShape} for all available options.
                                    *
                                    * @public
                                    */
                                   setButtonShape(shape: PointShape | Icon): UILUTCheckBoxBuilder<BackgroundType>;
                                   /**
                                    * Make new UILUTCheckBoxBuilder with different alignment.
                                    * @param alignment - Alignment for UILUTCheckBox
                                    * @returns New UILUTCheckBoxBuilder
                                    * @public
                                    */
                                   setAlignment(alignment: 'horizontal' | 'vertical'): UILUTCheckBoxBuilder<BackgroundType>;
                               }
                               /**
                                * Interface for `UILUTRange`, UI element which displays a color lookup table range with labels.
                                * @public
                                */
                               export declare interface UILUTRange<BackgroundType extends UIBackground = UIBackground> extends UIPartWithBackground<BackgroundType>, StyleTextAPI {
                                   /**
                                    * Set attached LUT (color look up table).
                                    * @param lut - LUT (color look up table).
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setLUT(lut: LUT): this;
                                   /**
                                    * Get attached LUT (color look up table).
                                    * @returns (color look up table).
                                    * @public
                                    */
                                   getLUT(): LUT | undefined;
                                   /**
                                    * Set length of LUT box as pixels.
                                    * @param lengthPixels - Length as pixels.
                                    * @public
                                    */
                                   setLUTLength(lengthPixels: number): this;
                                   /**
                                    * Get length of LUT box as pixels.
                                    * @returns Length as pixels.
                                    * @public
                                    */
                                   getLUTLength(): number;
                                   /**
                                    * Set thickness of LUT box as pixels.
                                    * @param thicknessPixels - Thickness as pixels.
                                    * @public
                                    */
                                   setLUTThickness(thicknessPixels: number): this;
                                   /**
                                    * Get thickness of LUT box as pixels.
                                    * @returns Thickness as pixels.
                                    * @public
                                    */
                                   getLUTThickness(): number;
                                   /**
                                    * Set displayed unit of Look Up Values. For example, "mm/h" (millimetres per hour).
                                    * @param unit - String to display next to Look Up Values.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setLookUpUnit(unit: string): this;
                                   /**
                                    * Get displayed unit of Look Up Values. For example, "mm/h" (millimetres per hour).
                                    * @returns String to display next to Look Up Values.
                                    * @public
                                    */
                                   getLookUpUnit(unit: string): string;
                                   /**
                                    * Specify step value formatting of LUT Legend.
                                    *
                                    * **Example usage:**
                                    *
                                    * ```ts
                                    *  // Display one fraction.
                                    *  setStepValueFormatter((step, lut) => step.value.toFixed(1))
                                    * ```
                                    * @param formatter - Callback function that receives the {@link LUTStep} object created by user, and maps it into a string that is displayed in the label.
                                    * @public
                                    */
                                   setLUTStepValueFormatter(formatter: (step: LUTStep, lut: LUT) => string): this;
                               }
                               /**
                                * Interface for `UILUTRange` builder.
                                * @public
                                */
                               export declare interface UILUTRangeBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UILUTRange> {
                                   /**
                                    * Make new UILUTRangeBuilder with different background
                                    * @param newBackground - Constructor for desired Background. See {@link UIBackgrounds} for a collection of options.
                                    * @public
                                    */
                                   setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: BackgroundConstructor<NewBackgroundType>): UILUTRangeBuilder<NewBackgroundType>;
                                   /**
                                    * Make new UILUTRangeBuilder with different alignment.
                                    * @param alignment - Alignment for UILUTRange
                                    * @returns New UILUTRangeBuilder
                                    * @public
                                    */
                                   setAlignment(alignment: 'horizontal' | 'vertical'): UILUTRangeBuilder;
                               }
                               /**
                                * Type definition for a mouse style setting. This tells how mouse should look when hovering over an UIElement.
                                *
                                * For a collection of mouse styles, see {@link MouseStyles}.
                                * @public
                                */
                               export declare type UIMouseStyle = string | DynamicUIMouseStyle<UIElement>;
                               /**
                                * Translate a {@link Color} object to Uint32 value, which can be used for per-data point coloring with LightningChart JS.
                                * ```ts
                                *  // Example
                                *  const colorUint32 = uint32ColorFromObject(ColorRGBA(255, 0, 0))
                                * ```
                                *
                                * **Note,** that `Color` objects are considerably heavy immutable classes.
                                * For this reason, it is strongly suggested to avoid using them in large numbers (~1000+).
                                *
                                * Instead, you should work directly with uint32 numbers, or use other methods that avoid `Color` objects, like:
                                *  - {@link uint32ColorFromRGBA}
                                * @param   colorObject - Color
                                * @returns     Number that represents a Uint32 rgba color
                                */
                               export declare const uint32ColorFromObject: (colorObject: Color) => number;
                               /**
                                * Translate RGBA notation to Uint32 color description, which can be used for per-data point coloring with LightningChart JS.
                                * ```ts
                                *  // Example
                                *  const colorUint32 = uint32ColorFromRGBA(255, 0, 0, 255)
                                * ```
                                *
                                * Values are in range [0, 255].
                                *
                                * @param   r - Red channel [0, 255]
                                * @param   g - Green channel [0, 255]
                                * @param   b - Blue channel [0, 255]
                                * @param   a - Alpha channel [0, 255]
                                * @returns     Number that represents a Uint32 rgba color
                                */
                               export declare const uint32ColorFromRGBA: (r: number, g: number, b: number, a?: number) => number;
                               /**
                                * Base class for Mouse-interactable ui-objects.
                                * @public
                                */
                               export declare abstract class UIObject implements Hideable, HideableEvents, Interactable {
                                   abstract addEventListener<K extends keyof UIObjectEventMap>(key: K, listener: (event: UIObjectEventMap[K], info: any) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   abstract removeEventListener<K extends keyof UIObjectEventMap>(type: K, listener: (event: UIObjectEventMap[K], info: any) => unknown): void;
                                   set draggable(state: boolean);
                                   get draggable(): boolean;
                                   /**
                                    * Set mouse interactions enabled.
                                    * Implementations should update the mouse-interactions of any Shapes they may contain here.
                                    * @param state -
                                    * @public
                                    */
                                   setPointerEvents(state: boolean): this;
                                   /**
                                    * @returns Mouse interactions state
                                    * @public
                                    */
                                   getPointerEvents(): boolean;
                                   /**
                                    * Set element visibility.
                                    *
                                    * @param state - `true` when element should be visible and `false` when element should be hidden.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   setVisible(state: boolean): this;
                                   /**
                                    * Get element visibility.
                                    *
                                    * @returns `true` when element is set to be visible and `false` otherwise.
                                    * @public
                                    */
                                   getVisible(): boolean;
                               }
                               /**
                                * Interface of events trackable by {@link UIObject.addEventListener} and the respective Event types.
                                * @public
                                */
                               export declare interface UIObjectEventMap extends LCJSInteractionEventMap, HideableEventMap {
                               }
                               /**
                                * Collection of fast-access *arguments* for {@link UIElement.setOrigin}
                                * @public
                                */
                               export declare const UIOrigins: {
                                   LeftBottom: Point;
                                   CenterBottom: Point;
                                   RightBottom: Point;
                                   LeftCenter: Point;
                                   Center: Point;
                                   RightCenter: Point;
                                   LeftTop: Point;
                                   CenterTop: Point;
                                   RightTop: Point;
                               };
                               /**
                                * Class for a panel that can have UI elements added into it.
                                * @public
                                */
                               export declare class UIPanel extends Panel {
                                   /**
                                    * Set minimum size of UIPanel in pixels.
                                    * This will affect its resizability by dragging dashboard splitters.
                                    * @param minimumSize - Minimum size as Point pixels
                                    * @public
                                    */
                                   setMinimumSize(minimumSize: Point): this;
                                   /**
                                    * Get minimum size of UIPanel in pixels as set by user.
                                    * @returns Point minimum size in pixels or undefined
                                    * @public
                                    */
                                   getMinimumSize(): Point | undefined;
                                   addEventListener<K extends keyof PanelEventMap>(type: K, listener: (event: PanelEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof PanelEventMap>(type: K, listener: (event: PanelEventMap[K], info: unknown) => unknown): void;
                               }
                               /**
                                * Interface for abstract part of an *UIElement*, that does not manage its own location (for example, part of a *layout*).
                                * @public
                                */
                               export declare interface UIPart extends Marginable, Disposable, DisposableEvents, ComponentWithEffects, Interactable {
                                   /**
                                    * Set mouse style when hovering over UI object.
                                    * @param mouseStyle - Interface for defining how mouse should look when hovering over UI object
                                    * @returns Object itself
                                    * @public
                                    */
                                   setMouseStyle(mouseStyle: UIMouseStyle): this;
                                   /**
                                    * Get mouse style.
                                    * @returns Interface for defining how mouse should look when hovering over UI object
                                    * @public
                                    */
                                   getMouseStyle(): UIMouseStyle;
                                   addEventListener<K extends keyof UIElementEventMap>(key: K, listener: (event: UIElementEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof UIElementEventMap>(key: K, listener: (event: UIElementEventMap[K], info: unknown) => unknown): void;
                               }
                               /**
                                * Public interface for a UiElement that has background, but is not responsible for its own positioning.
                                * @public
                                */
                               export declare interface UIPartWithBackground<BackgroundType extends UIBackground> extends UIPart, StylableBackground<BackgroundType> {
                                   addEventListener<K extends keyof UIElementEventMap>(key: K, listener: (event: UIElementEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof UIElementEventMap>(key: K, listener: (event: UIElementEventMap[K], info: unknown) => unknown): void;
                               }
                               /**
                                * UI Shape that can be used as button picture
                                * @public
                                */
                               export declare class UIPoint extends Picture implements PointMarker {
                                   /**
                                    * Set displayed shape.
                                    *
                                    * ```ts
                                    *  // Example
                                    *  setShape(PointShape.Star)
                                    * ```
                                    *
                                    * See {@link PointShape} for all available options.
                                    *
                                    * @public
                                    */
                                   setShape(shape: PointShape | Icon): this;
                                   /**
                                    * Get displayed shape.
                                    * @public
                                    */
                                   getShape(): PointShape | Icon;
                                   /**
                                    * Set rotation of point shape in degrees.
                                    * @param   rotationDeg - Rotation in degrees.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setRotation(rotationDeg: number): this;
                                   /**
                                    * Get rotation of point shape in degrees.
                                    * @returns     Rotation as degrees
                                    * @public
                                    */
                                   getRotation(): number;
                                   /**
                                    * Set fill style of Picture
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Picture
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set stroke style of Picture
                                    * @param value - line style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get stroke style of Picture
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                                   /**
                                    * Fit object to bounding box.
                                    * @param bounds - Bounds in pixels
                                    * @returns Object itself
                                    * @public
                                    */
                                   fitTo: (size: Point) => this;
                                   /**
                                    * Set size of PointMarker
                                    * @param size - Size of PointMarker in pixels
                                    * @returns Object itself
                                    * @public
                                    */
                                   setSize: (size: Point) => this;
                               }
                               /**
                                * @public
                                */
                               export declare interface UIPointableBuilder<T extends UIPart = UIPart> extends UIElementBuilder<T> {
                                   /**
                                    * @public
                                    */
                                   setDirection(direction: UIDirections): UIPointableBuilder<T>;
                               }
                               /**
                                * Interface for 'PointableTextBox'.
                                * @public
                                */
                               export declare interface UIPointableTextBox<BackgroundType extends UIBackground = UIBackground> extends UITextBox<BackgroundType>, Pointable {
                               }
                               /**
                                * Interface for 'PointableTextBox'-builder.
                                * @public
                                */
                               export declare interface UIPointableTextBoxBuilder<BackgroundType extends PointableBackground = PointableBackground> extends UIElementBuilder<UIPointableTextBox<BackgroundType>>, UIPointableBuilder<UIPointableTextBox<BackgroundType>> {
                                   /**
                                    * Make new PointableTextBoxBuilder with different background.
                                    * @param newBackground - Constructor for desired PointableBackground. Currently only UIBackgrounds.Arrow is available.
                                    */
                                   setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: PointableBackgroundConstructor<NewBackgroundType>): UIPointableTextBoxBuilder<NewBackgroundType>;
                                   /**
                                    * @public
                                    */
                                   setDirection(direction: UIDirections): UIPointableTextBoxBuilder<BackgroundType>;
                               }
                               /**
                                * Background that has a pointable 'arrow'
                                * @public
                                */
                               export declare class UIPointer extends UIPolygon implements InternalBackground {
                                   /**
                                    * Set fill style of Picture
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Picture
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set stoke style of Picture
                                    * @param value - LineStyle object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get stroke style of Picture
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                                   /**
                                    * Set direction.
                                    * @param direction - Enum Direction
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setDirection(direction: UIDirections): this;
                                   /**
                                    * Get direction.
                                    * @returns Enum Direction
                                    * @public
                                    */
                                   getDirection(): UIDirections;
                                   /**
                                    * Set length of Pointable head in pixels.
                                    * @param length - Head length in pixels
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setPointerLength(length: pixel): this;
                                   /**
                                    * Get length of Pointable head in pixels.
                                    * @returns Pixel length
                                    * @public
                                    */
                                   getPointerLength(): pixel;
                                   /**
                                    * Set angle of Pointable in degrees.
                                    * @param angle - Angle of pointer or undefined to match head & body size
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setPointerAngle(angle?: number): this;
                                   /**
                                    * Get angle of Pointable in degrees.
                                    * @returns Angle in degrees
                                    * @public
                                    */
                                   getPointerAngle(): pixel;
                               }
                               /**
                                * Abstract background formed with a polygon shape
                                * @public
                                */
                               export declare abstract class UIPolygon extends BorderedPicture {
                                   /**
                                    * Set element visibility.
                                    *
                                    * @param state - `true` when element should be visible and `false` when element should be hidden.
                                    * @returns Object itself.
                                    */
                                   setVisible(state: boolean): this;
                               }
                               /**
                                * Rectangular UI shape that can be used as Background or Button picture.
                                * @public
                                */
                               export declare class UIRectangle extends BorderedPicture implements InternalBackground, RoundableCorners {
                                   setCornerRadius(radius: number | undefined, opts?: {
                                       bottomLeft: boolean;
                                       bottomRight: boolean;
                                       topLeft: boolean;
                                       topRight: boolean;
                                   }): this;
                                   getCornerRadius(): number | undefined;
                                   /**
                                    * Set fill style of Picture
                                    * @param value - Fill style object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Picture
                                    * @public
                                    */
                                   getFillStyle(): FillStyle;
                                   /**
                                    * Set stoke style of Picture
                                    * @param value - LineStyle object or function which modifies it
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get stroke style of Picture
                                    * @public
                                    */
                                   getStrokeStyle(): LineStyle;
                                   /**
                                    * Fit object to bounding box.
                                    * @param bounds - Bounds in pixels
                                    * @returns Object itself
                                    * @public
                                    */
                                   fitTo: (size: Point) => this;
                                   /**
                                    * Set size of PointMarker
                                    * @param size - Size of PointMarker in pixels
                                    * @returns Object itself
                                    * @public
                                    */
                                   setSize: (size: Point) => this;
                               }
                               /**
                                * Interface for builder of UiRow layout
                                * @public
                                */
                               export declare interface UIRowBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UIElementRow<BackgroundType>> {
                                   /**
                                    * Make new RowBuilder with different background
                                    * @public
                                    */
                                   setBackground<NewBackgroundType extends BackgroundType>(newBackground: BackgroundConstructor<NewBackgroundType>): UIRowBuilder<NewBackgroundType>;
                               }
                               /**
                                * Class which represents a grid of abstract UiElements.
                                * Grid is formed from horizontal lines, 'rows', that can have individual member anchoring.
                                * @public
                                */
                               export declare class UIRowGrid<BackgroundClass extends UIBackground = UIBackground> extends UIElementColumn<BackgroundClass> {
                                   /**
                                    * Add new row to grid
                                    * @public
                                    */
                                   addRow(): UIElementRow;
                                   /**
                                    * Get row at specified index
                                    * @param index - Index to look for
                                    * @param ensure - ? If true, grid adds the row and any missing ones if it doesn't exist
                                    * @returns UiElementRow at given index
                                    * @public
                                    */
                                   getRow(index: number, ensure?: boolean): UIElementRow;
                               }
                               /**
                                * Enum that is used to specify a relative area inside an UI element.
                                *
                                * Probably not needed in user applications.
                                * @public
                                */
                               export declare enum UISpace {
                                   /**
                                    * Smallest area, equal to the UiElements respective visual content
                                    */
                                   Content = 0,
                                   /**
                                    * Content + Padding, area that should be contained within Backgrounds border
                                    */
                                   PaddedContent = 1,
                                   /**
                                    * Content + Padding + Background padding
                                    */
                                   PaddedBackground = 2,
                                   /**
                                    * Content + Padding + Background padding + Margin
                                    */
                                   Everything = 3
                               }
                               /**
                                * Interface for 'TextBox'.
                                * @public
                                */
                               export declare interface UITextBox<BackgroundType extends UIBackground = UIBackground> extends UIPartWithBackground<BackgroundType>, CustomizableText {
                               }
                               /**
                                * Interface for 'TextBox'-builder.
                                * @public
                                */
                               export declare interface UITextBoxBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UITextBox<BackgroundType>> {
                                   /**
                                    * Make new TextBoxBuilder with different background
                                    * @param newBackground - Constructor for desired Background. See {@link UIBackgrounds} for a collection of options.
                                    * @public
                                    */
                                   setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: BackgroundConstructor<NewBackgroundType>): UITextBoxBuilder<NewBackgroundType>;
                               }
                               /**
                                * *UIElement* that looks like an Axis tick (tick line + label) and can be used as an Axis CustomTick Marker,
                                * by passing its *builder* as an argument to {@link Axis.addCustomTick}:
                                *
                                * ```typescript
                                *  // Specify builder for CustomTick Marker.
                                *  const customTick = Axis.addCustomTick(UIElementBuilders.AxisTickMajor)
                                *
                                *  // TickMarker can be accessed via mutator method of CustomTick.
                                *  customTick.setMarker((marker: UITick) => marker
                                *      // ... do stuff
                                *  )
                                * ```
                                * @public
                                */
                               export declare interface UITick extends UIPart, CustomizableText, Pointable {
                                   /**
                                    * Set tick line style.
                                    * @param value - LineStyle or function that modifies current LineStyle value.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setTickStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get tick line style.
                                    * @returns LineStyle.
                                    * @public
                                    */
                                   getTickStyle(): LineStyle;
                               }
                               /**
                                * Interface for builder for {@link UITick}.
                                * @public
                                */
                               export declare type UITickBuilder = UIPointableBuilder<UITick>;
                               /**
                                * Enum for selecting visibility of parts of *Marker*s. Each part can be configured individually:
                                *
                                * Example usage:
                                * ```javascript
                                * // Hide part
                                * SeriesMarkerXY.setTickMarkerYVisibility( UIVisibilityModes.never )
                                * // Show part when pointed
                                * ChartMarkerXY.setResultTableVisibility( UIVisibilityModes.whenHovered )
                                * ```
                                * @public
                                */
                               export declare enum UIVisibilityModes {
                                   /**
                                    * Part is never visible
                                    */
                                   never = 0,
                                   /**
                                    * Part is always visible
                                    */
                                   always = 1,
                                   /**
                                    * Part is visible when Marker is hovered with mouse and not being dragged
                                    */
                                   whenHovered = 2,
                                   /**
                                    * Part is visible when Marker is being dragged with mouse
                                    */
                                   whenDragged = 3,
                                   /**
                                    * Part is visible when Marker is not being dragged with mouse
                                    */
                                   whenNotDragged = 4,
                                   /**
                                    * Part is visible when Marker is hovered with mouse or dragged
                                    */
                                   whenHoveredOrDragged = 5
                               }
                               /**
                                * Special type of "Scale" used with 3D Axes. Basically equal to Scale,
                                * except most of its functionality has been stripped, as there is no
                                * concept of "pixels" in a 3D Scale.
                                *
                                * This class only serves as a container for FormattingRange values, and associated invalidation logic.
                                *
                                * @public
                                */
                               declare class UnitScale extends Validator implements Validatable {
                                   /**
                                    * Get min value on range
                                    * @returns Number
                                    * @public
                                    */
                                   getInnerStart(): number;
                                   /**
                                    * Get max value on range
                                    * @returns Number
                                    * @public
                                    */
                                   getInnerEnd(): number;
                                   /**
                                    * Get absolute range of Scale interval as
                                    *
                                    * ```javascript
                                    * Math.abs( this.getInnerEnd() - this.getInnerStart() )
                                    * ```
                                    * @returns Number
                                    * @public
                                    */
                                   getInnerInterval(): number;
                               }
                               /**
                                * @public
                                * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                */
                               declare interface _UpdateInputAxisXY extends _GenericAxisInput {
                                   anyPreviousAxisUpdated: boolean;
                               }
                               /**
                                * @public
                                * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                */
                               declare interface _UpdateOutputAxisPolar extends _GenericAxisOutput<PolarAxisTick, _GenericTickInfo> {
                               }
                               /**
                                * @public
                                * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                */
                               declare interface _UpdateOutputAxisXY extends _GenericAxisOutput<Tick, _TickXYInfo> {
                               }
                               /**
                                * Utility function that can be used in cursor formatters to fetch data point specific colors.
                                *
                                * **This does NOT support all series or use cases**. Primarily support has been added for the most important XY series, especially {@link PointLineAreaSeries}.
                                *
                                * @public
                                */
                               export declare const useCursorDataPointColor: (hit: SolveResult) => Color | undefined;
                               /**
                                * Utility function that can be used when defining cursor formatters (`setCursorFormatting`) to add compatibility with per-series formatting overrides {@link Series2D.setCursorFormattingOverride}.
                                * @public
                                */
                               export declare const useCursorFormatterSeriesOverride: <SolveResultType extends SolveResult<unknown>>(hit: SolveResultType, before: ResultTableCellContent[][]) => ResultTableCellContent[][];
                               /**
                                * Type union for supported ways for users to define a Scale for positioning UI elements and Legend Boxes.
                                * @public
                                */
                               export declare type UserScaleDefinition = ScaleXY | Vec2<Axis | BarChartCategoryAxis | BarChartValueAxis | LinearScaleXY> | CoordinateSystemRelative;
                               /**
                                * Interface defines methods for invalidation and validation of private state
                                * @public
                                */
                               declare interface Validatable {
                               }
                               /**
                                * Class keep track of private state's validation status by invalid flag.
                                * @public
                                */
                               declare class Validator {
                               }
                               /**
                                * Interface to define secondary miscellaneous properties of a LUT.
                                * @public
                                */
                               export declare interface ValuePaletteOptions {
                                   /**
                                    * Title of the LUT, which describes the visualization.
                                    *
                                    * Default value: Empty string.
                                    */
                                   title: string;
                                   /**
                                    * Units of the data-values in the LUT, which describes the data domain.
                                    *
                                    * Default value: Empty string.
                                    */
                                   units: string;
                                   /**
                                    * Interpolation behavior of the LUT, which describes the distribution of color for the data:
                                    * - True: LUT creates a ***gradient*** LUT using linear-interpolation (LERP) between colors,
                                    * which were defined in the collection of steps.
                                    * - False: LUT creates a ***uniform*** LUT using step-function for each color
                                    * to describe the range of values where this color is used.
                                    *
                                    * Default value: true.
                                    */
                                   interpolate: boolean;
                                   /**
                                    * Fallback color, which is used if LUT steps are defined as empty or defined incorrectly.
                                    *
                                    * Default value: Black.
                                    */
                                   color: Color;
                                   /**
                                    * Whether values represent percentages or explicit values.
                                    *
                                    * This is a beta feature, which mainly means that it is not supported by all chart features yet.
                                    * The most important features should have support for it:
                                    *
                                    * - Point series
                                    * - Heatmap series
                                    * - Surface series
                                    *
                                    * This feature is currently not optimized for real-time applications where the value range may change frequently.
                                    * Thus, if you are supplying data updates frequently, there is a large performance down side to having `percentageValues` enabled compared to disabled.
                                    * This can be optimized in the future, so please contact your account manager if you have an use case where this is relevant.
                                    *
                                    * ```ts
                                    *  // Example of percentage LUT
                                    *  const lut = new LUT({
                                    *      interpolate: true,
                                    *      percentageValues: true,
                                    *      steps: [
                                    *          { value: 0, color: ColorCSS('black') }, // lowest value will be black
                                    *          { value: 1, color: ColorCSS('red') },   // highest value will be red
                                    *      ]
                                    *  })
                                    * ```
                                    */
                                   percentageValues: boolean;
                                   /**
                                    * Formatter for LUT values. Affects:
                                    *
                                    * - Default cursor formatters.
                                    * - Default legend LUT formatters.
                                    *
                                    * ```ts
                                    *  // Example, specify decimal count for LUT values
                                    *  const lut = new LUT({
                                    *      ..., // other options
                                    *      formatter: (value) => value.toFixed(1)
                                    *  })
                                    * ```
                                    *
                                    * Recommended way to display units (e.g. "5.14 V") is by using {@link Axis.setUnits}.
                                    * Alternatively, units can also be added to LUT formatter.
                                    */
                                   formatter: (value: number, info: {
                                       min: number;
                                       max: number;
                                       percentageValues: boolean;
                                   }) => string;
                               }
                               /**
                                * Datastructure with generic X and Y properties.
                                * @public
                                */
                               export declare interface Vec2<T> {
                                   readonly x: T;
                                   readonly y: T;
                               }
                               /**
                                * Type definition of a generic 3-dimensional Vector datastructure.
                                * @public
                                */
                               export declare interface Vec3<T> {
                                   readonly x: T;
                                   readonly y: T;
                                   readonly z: T;
                               }
                               /**
                                * Collection of math utilities for numeric Vec3s.
                                * @public
                                */
                               export declare const vec3Utils: {
                                   /**
                                    * Add a single value to all values of a 3-dimensional Vector.
                                    * @param v - 3-dimensional Vector to add to.
                                    * @param value - Value to add to all 3-dimensional Vector's values.
                                    * @returns Result as a new 3-dimensional Vector as 3D Point.
                                    * @public
                                    */
                                   add(v: Point3D, value: number): Point3D;
                                   /**
                                    * Add two or more 3-dimensional Vectors together.
                                    * @param v1 - First 3-dimensional Vector to add to.
                                    * @param v2 - One or multiple 3-dimensional Vectors to add.
                                    * @returns New 3-dimensional Vector as 3D Point.
                                    * @public
                                    */
                                   addVec(v1: Point3D, ...v2: Point3D[]): Point3D;
                                   /**
                                    * Subtract a single value from all values of a 3-dimensional Vector.
                                    * @param v - 3-dimensional Vector to subtract from.
                                    * @param value - Value to subtract from all 3-dimensional Vector's values.
                                    * @returns Result as a new 3-dimensional Vector as 3D Point.
                                    * @public
                                    */
                                   subtract(v: Point3D, value: number): Point3D;
                                   /**
                                    * Subtract one or more 3-dimensional Vector from another.
                                    * @param v1 - 3-dimensional Vector to subtract from.
                                    * @param v2 - One or multiple 3-dimensional Vectors to subtract.
                                    * @returns Result as a new 3-dimensional Vector as 3D Point.
                                    * @public
                                    */
                                   subtractVec(v1: Point3D, ...v2: Point3D[]): Point3D;
                                   /**
                                    * Multiply values of a 3-dimensional Vector by a single value.
                                    * @param v - 3-dimensional Vector to multiply.
                                    * @param multiplier - Number to multiply the 3-dimensional Vectors values with.
                                    * @returns Result as a new 3-dimensional Vector as 3D Point.
                                    * @public
                                    */
                                   multiply(v: Point3D, multiplier: number): Point3D;
                                   /**
                                    * Divide values of a 3-dimensional Vector by a single value.
                                    * @param v - 3-dimensional Vector to divide.
                                    * @param divisor - Number to divide the 3-dimensional Vectors values with.
                                    * @returns Result as a new 3-dimensional Vector as 3D Point.
                                    * @public
                                    */
                                   divide(v: Point3D, divisor: number): Point3D;
                                   /**
                                    * Multiply one 3-dimensional Vector with one or more 3-dimensional Vectors
                                    * in the order they were provided.
                                    * @param v1 - 3-dimensional Vector.
                                    * @param v2 - One or multiple 3-dimensional Vectors to multiply with.
                                    * @returns Result as a new 3-dimensional Vector as 3D Point.
                                    * @public
                                    */
                                   multiplyVec(v1: Point3D, ...v2: Point3D[]): Point3D;
                                   /**
                                    * Divide one 3-dimensional Vector with one or more 3-dimensional Vectors
                                    * in the order they were provided.
                                    * @param v1 - 3-dimensional Vector to divide.
                                    * @param v2 - One or multiple 3-dimensional Vector to divide with.
                                    * @returns Result as a new 3-dimensional Vector as 3D Point.
                                    * @public
                                    */
                                   divideVec(v1: Point3D, ...v2: Point3D[]): Point3D;
                                   /**
                                    * Get the length of a 3-dimensional Vector.
                                    * @param v - 3-dimensional Vector.
                                    * @returns Length of a 3-dimensional Vector.
                                    * @public
                                    */
                                   length(v: Point3D): number;
                                   /**
                                    * Get the normal of a 3-dimensional Vector.
                                    * @param v - 3-dimensional Vector.
                                    * @returns Normal as a 3-dimensional Vector.
                                    * @public
                                    */
                                   normalize(v: Point3D): Point3D;
                                   /**
                                    * Get the dot product of two 3-dimensional Vectors.
                                    * @param v1 - 3-dimensional Vector.
                                    * @param v2 - 3-dimensional Vector.
                                    * @public
                                    */
                                   dot(v1: Point3D, v2: Point3D): number;
                                   /**
                                    * Get the cross product of two 3-dimensional Vectors.
                                    * @param v1 - Vector to compare towards
                                    * @param v2 - Vector to compare with
                                    * @public
                                    */
                                   cross(v1: Point3D, v2: Point3D): Point3D;
                                   /**
                                    * @returns Radian angle between v1 and v2.
                                    * @public
                                    */
                                   angle(v1: Point3D, v2: Point3D): number;
                                   /**
                                    * Rotate vector around another arbitrary axis, by amount 'theta' in radians.
                                    * @param v - Vector to rotate
                                    * @param axis - Vector of arbitrary rotation axis
                                    * @param theta - Rotation amount in radians
                                    * @public
                                    */
                                   rotateAroundAxis(v: Point3D, axis: Point3D, theta: number): Point3D;
                                   /**
                                    * Linear interpolation between two vectors and an arbitrary amount as %.
                                    * amount = 0 -\> returns a
                                    * amount = 1 -\> returns b
                                    * @param a - Vector a for interpolation
                                    * @param b - Vector b for interpolation
                                    * @param amount - Interpolation amount
                                    * @public
                                    */
                                   lerp(a: Point3D, b: Point3D, amount: number): Point3D;
                                   /**
                                    * Check two vectors are equal.
                                    * @param a - Vector a
                                    * @param b - Vector b
                                    * @public
                                    */
                                   equals(a: Point3D, b: Point3D): boolean;
                                   /**
                                    * Get vector as absolute.
                                    * @param v - Vector to get absolute value of
                                    * @returns `{ x: Math.abs( v.x ), y: Math.abs( v.y ), z: Math.abs( v.z ) }`
                                    * @public
                                    */
                                   abs(v: Point3D): Point3D;
                                   /**
                                    * Sign of Vector.
                                    * @param v - Vector.
                                    * @returns `{ x: Math.sign( v.x ), y: Math.sign( v.y ), z: Math.sign( v.z ) }`
                                    * @public
                                    */
                                   sign(v: Point3D): Point3D;
                               };
                               /**
                                * 1D Scale class that represents a plane of the viewport (e.g. Width or Height of monitor).
                                *
                                * Interfaces with dashboard resizing and adds concepts of
                                * - Pixel margins
                                * - Scale size (pixels) on viewport
                                * @public
                                */
                               declare abstract class ViewportScale1D extends Scale1D {
                                   /**
                                    * @param _cellIndex - Dashboard cell start location on Plane of Scale (X or Y).
                                    * @param _cellSpan - Dashboard cell size on Plane of Scale (X or Y).
                                    * @param _cellsAmount - Dashboard total cells amount on Plane of Scale (X or Y).
                                    * @param _observedAmount - ObservableValue for Dashboard cells amount on Plane of Scale (X or Y).
                                    */
                                   constructor(_cellIndex: number, _cellSpan: number, _cellsAmount: number, _observedAmount?: ObservableValue<number[]>);
                                   /**
                                    * Get active size of Scale in viewport as pixels scaled according to Dashboard division if any exists.
                                    * @public
                                    */
                                   getCellSize(): number;
                               }
                               /**
                                * @public
                                */
                               export declare interface VisibleChangedEvent {
                                   isVisible: boolean;
                               }
                               /**
                                * Abstract class that indicates some visible Filling.
                                * Used only for instanceOf check at Engine
                                * @public
                                */
                               export declare abstract class VisibleFill extends VisibleFillRecord implements FillStyle {
                                   /**
                                    * Get CSS representation of the FillStyle.
                                    * @public
                                    */
                                   abstract toCSS(): string;
                               }
                               /**
                                * Record contractor for VisibleFillStyleProperties.
                                * @public
                                */
                               declare const VisibleFillRecord: Record_2.Factory<VisibleFillStyleProperties>;
                               /**
                                * Interface for all properties of a visible FillStyle.
                                * @public
                                */
                               export declare interface VisibleFillStyleProperties {
                                   type: 'fillstyle';
                                   fillType: 'solid' | 'image' | 'radial-gradient' | 'linear-gradient' | 'individual' | 'palette';
                                   /**
                                    * For SolidFill: Color which is used to fill shape.
                                    *
                                    * For IndividualPointFill: Fallback Color for filling shape if individual Color was not given.
                                    *
                                    * For PalettedFill: Fallback Color for filling shape if palette was not given.
                                    */
                                   color: Color;
                               }
                               /**
                                * MultidimensionalStrategy for X Dimension
                                * @public
                                */
                               export declare const xDimensionStrategy: MultidimensionalStrategy;
                               /**
                                * Ordered tuple that contains values for:
                                * - X
                                * - Open
                                * - High
                                * - Low
                                * - Close
                                * @public
                                */
                               export declare type XOHLC = [number, number, number, number, number];
                               /**
                                * @public
                                */
                               export declare interface XYZDataInput {
                                   /**
                                    * Append a single `XYZ` coordinate or list of coordinates into the *series*.
                                    *
                                    * ```ts
                                    *  // Example syntax
                                    *  LineSeries3D.add({ x: 0, y: 0, z: 0 })
                                    *
                                    *  LineSeries3D.add([
                                    *      { x: 0, y: 100, z: 50 },
                                    *      { x: 10, y: 50, z: 150 },
                                    *      { x: 20, y: 75, z: 100 },
                                    *  ])
                                    * ```
                                    *
                                    * @param points - Single XYZ coordinate or list of coordinates.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   add(data: Point3D | Point3D[]): this;
                                   /**
                                    * Clear all previously pushed data points from the *series*.
                                    *
                                    * ```ts
                                    *  // Example usage
                                    *  LineSeries.clear()
                                    * ```
                                    *
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   clear(): this;
                                   /**
                                    * Get amount of points that series currently has.
                                    * @returns Number of points
                                    * @public
                                    */
                                   getPointAmount(): number;
                               }
                               /**
                                * MultidimensionalStrategy for X Dimension
                                * @public
                                */
                               export declare const yDimensionStrategy: MultidimensionalStrategy;
                               /**
                                * Chart that is used to display a fully zoomed out view of 1 or more charts or series.
                                * It also provides convenient built-in user interactions for interacting with the attached chart(s) that show the zoomed in view.
                                *
                                * By nature, ZoomBandChart does not host any original data. Rather, it is a duplicate of other data sets in order to simultaneously show both zoomed in view and fully zoomed out view.
                                *
                                * `ZoomBandChart` can be created in two different ways - to learn more about creation time configuration of `ZoomBandChart`, please refer to:
                                * - {@link LightningChart.ZoomBandChart} (stand-alone chart).
                                * - {@link Dashboard.createZoomBandChart} (zoom band chart inside *dashboard*).
                                *
                                * **ZoomBandChart features**
                                *
                                *  - Add series to ZoomBandChart with {@link add} method.
                                *      - This method returns a handle to the duplicated series in ZBC, which can be used to change its style, etc.
                                *  - Series can be removed from ZoomBandChart with {@link disposeSeries} method.
                                *  - ZoomBandChart axes can be modified via {@link getDefaultAxisX} and {@link getDefaultAxisY} methods.
                                *  - Display series along 1 shared value range {@link ZoomBandChartOptions.useSharedValueAxis}.
                                *  - Change orientation {@link ZoomBandChartOptions.orientation}
                                *  - Configure title {@link setTitle}.
                                *
                                * @public
                                */
                               export declare class ZoomBandChart implements Control, DashboardPanel, ChartAPI, ChartWithStylableSeriesBackground {
                                   /**
                                    * Selector for "relative" _Coordinate System_.
                                    *
                                    * This coordinate system is relative to the bottom left corner of the Control (chart/dashboard/etc.), and is measured as pixels.
                                    * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from bottom.
                                    *
                                    * This selector can be used for two purposes:
                                    *
                                    * **Positioning LCJS UI elements in pixels:**
                                    *
                                    * ```ts
                                    *  // Position UI element in pixels by supplying `Control.coordsRelative` as its positioning system.
                                    *  const textBox = Control.addUIElement(UIElementBuilders.TextBox, Control.coordsRelative)
                                    *      .setOrigin(UIOrigins.LeftBottom)
                                    *      .setPosition({ x: 100, y: 20 })
                                    * ```
                                    *
                                    * **Translations between coordinate systems:**
                                    *
                                    * Use with {@link translateCoordinate} method to translate coordinates from "relative" to another coordinate system.
                                    *
                                    * @public
                                    */
                                   readonly coordsRelative: CoordinateSystemRelative;
                                   /**
                                    * Selector for "client" _Coordinate System_.
                                    *
                                    * This references the coordinate system used in HTML.
                                    * It starts at top left of the web page and is measured in pixels.
                                    * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
                                    *
                                    * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
                                    *
                                    * This selector can be used for translating client coordinates to other coordinate systems and vice versa.
                                    * For example, in order to:
                                    * - Position LCJS UI elements in client coordinates
                                    * - Find client coordinate that matches a location along LCJS Axis or Chart.
                                    * - etc.
                                    *
                                    * See {@link translateCoordinate} for more detailed use case information and example usage.
                                    *
                                    * @public
                                    */
                                   readonly coordsClient: CoordinateSystemClient;
                                   /**
                                    * Public, safe interface of rendering engine.
                                    * @public
                                    */
                                   readonly engine: PublicEngine;
                                   /**
                                    * **Use it with caution!**
                                    *
                                    * `ZoomBandChart` is internally implemented by utilizing `ChartXY` itself and adding some functionality on top.
                                    * End user functionality should in all cases use `ZoomBandChart` API directly, as interacting with the underlying chart can result in unexpected conflicts.
                                    *
                                    * Regardless, the chart is still exposed just in case.
                                    */
                                   get chart(): ChartXY;
                                   /**
                                    * Configure user interactions from a set of preset options.
                                    *
                                    * Without any explicit configuration, the charts select the default user interaction scheme based on available information,
                                    * such as axis types, attached series and data supplied to series.
                                    *
                                    * The `setUserInteraction` methods allow explicitly configuring the used interaction scheme.
                                    *
                                    * ```ts
                                    *  // Example, disable all user interactions
                                    *  chart.setUserInteractions(undefined)
                                    * ```
                                    *
                                    * ```ts
                                    *  // Example, enable only specific interactions
                                    *  chart.setUserInteractions({
                                    *      pan: { drag: true, click: true },
                                    *      zoom: { wheel: undefined, dragKnob: false }
                                    *  })
                                    * ```
                                    *
                                    * @param   config -    Option with any set of properties of {@link ZoomBandChartInteractions} or `undefined` to disable all interactions.
                                    * @returns     Object itself.
                                    * @public
                                    * @beta    Introduced in v7.0.0. API may change according to user feedback.
                                    */
                                   setUserInteractions(config: Partial<ZoomBandChartInteractions> | undefined): this;
                                   /**
                                    * Get currently active user interaction scheme.
                                    * This does NOT return the last value supplied to {@link setUserInteractions}.
                                    * Rather, it considers the current structure of the chart, all built-in defaults as well as overrides supplied by the user
                                    * and returns the currently used interaction scheme.
                                    *
                                    * @returns     ParallelCoordinateChartInteractions
                                    * @public
                                    * @beta    Introduced in v7.0.0. API may change according to user feedback.
                                    */
                                   getUserInteractions(): ZoomBandChartInteractions;
                                   /**
                                    * Add a series to the ZoomBandChart.
                                    *
                                    * This creates a duplicate of the supplied series that is displayed in the ZoomBandChart.
                                    * The method returns a reference to the duplicate in ZBC that is usually the same type as the attached series (exception being OHLCSeries which is returned as LineSeries).
                                    * This duplicate reference can be styled separately from the original series.
                                    *
                                    * The ZoomBandChart automatically matches the data from the original series.
                                    *
                                    * ```ts
                                    *  // Example usage
                                    *  const zbcSeries = ZoomBandChart.add(myLineSeries)
                                    *      .setStrokeStyle((stroke) => stroke.setThickness(2))
                                    * ```
                                    *
                                    * Series can be removed from ZoomBandChart with {@link disposeSeries} method.
                                    *
                                    * @param series - Series to attach.
                                    * @returns     Reference to duplicate series created in ZoomBandChart.
                                    * @public
                                    */
                                   add<SeriesType extends ZoomBandChartSupportedSeries>(series: SeriesType): SeriesType extends OHLCSeries ? PointLineAreaSeries : SeriesType extends ZoomBandChartSupportedSeries ? SeriesType : never;
                                   /**
                                    * Remove series from being display in the ZoomBandChart.
                                    *
                                    * This method only needs to be called when you want to not display a series in the ZoomBandChart, but don't want to completely destroy it in the source chart.
                                    * You do not need to call this method if you are destroying the original series using the `dispose` method.
                                    *
                                    * @param series - Series object.
                                    * @returns Object itself.
                                    * @public
                                    */
                                   disposeSeries(series: ZoomBandChartSupportedSeries): this;
                                   /**
                                    * Set fill style of "defocus overlay". This is formed of 2 separate rectangles, 1 on left and another on right side of the visible data range.
                                    * By default its transparent dark to help user understand which part of data is visible.
                                    * @param   value -     FillStyle or function which modifies current fill style.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setDefocusOverlayFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of "defocus overlay". This is formed of 2 separate rectangles, 1 on left and another on right side of the visible data range.
                                    * By default its transparent dark to help user understand which part of data is visible.
                                    * @returns     FillStyle
                                    * @public
                                    */
                                   getDefocusOverlayFillStyle(): FillStyle;
                                   /**
                                    * Set Zoom band chart splitter stroke style.
                                    * This separates the visible data set from full data set.
                                    * @param   value -     LineStyle or function which modifies current LineStyle.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setSplitterStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get Zoom band chart splitter stroke style.
                                    * This separates the visible data set from full data set.
                                    * @returns     LineStyle
                                    * @public
                                    */
                                   getSplitterStrokeStyle(): LineStyle;
                                   /**
                                    * Set fill style of zoom band chart knobs. These are just UX indicators to help users understand you can drag the ZBC area left/right.
                                    * @param   value -     FillStyle or function which modifies current fill style.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setKnobFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of zoom band chart knobs. These are just UX indicators to help users understand you can drag the ZBC area left/right.
                                    * @returns     FillStyle
                                    * @public
                                    */
                                   getKnobFillStyle(): FillStyle;
                                   /**
                                    * Set stroke style of zoom band chart knobs. These are just UX indicators to help users understand you can drag the ZBC area left/right.
                                    * @param   value -     LineStyle or function which modifies current LineStyle.
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setKnobStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get stroke style of zoom band chart knobs. These are just UX indicators to help users understand you can drag the ZBC area left/right.
                                    * @returns     LineStyle
                                    * @public
                                    */
                                   getKnobStrokeStyle(): LineStyle;
                                   /**
                                    * Set size of zoom band chart knobs. These are just UX indicators to help users understand you can drag the ZBC area left/right.
                                    * @param   size - Size as pixels
                                    * @returns     Object itself.
                                    * @public
                                    */
                                   setKnobSize(size: Point): this;
                                   /**
                                    * Get size of zoom band chart knobs. These are just UX indicators to help users understand you can drag the ZBC area left/right.
                                    * @returns     Size as pixels.
                                    * @public
                                    */
                                   getKnobSize(): Point;
                                   /**
                                    * Get the X Axis of the ZoomBandChart.
                                    * @returns Axis
                                    * @public
                                    */
                                   getDefaultAxisX(): Axis;
                                   /**
                                    * Get the Y Axis of the ZoomBandChart.
                                    * @returns Axis
                                    * @public
                                    */
                                   getDefaultAxisY(): Axis;
                                   /**
                                    * Convenience getter property that does the same as {@link getDefaultAxisX}.
                                    * @public
                                    */
                                   get axisX(): Axis;
                                   /**
                                    * Convenience getter property that does the same as {@link getDefaultAxisX}.
                                    * @public
                                    */
                                   get xAxis(): Axis;
                                   /**
                                    * Convenience getter property that does the same as {@link getDefaultAxisX}.
                                    * @public
                                    */
                                   get axisY(): Axis;
                                   /**
                                    * Convenience getter property that does the same as {@link getDefaultAxisX}.
                                    * @public
                                    */
                                   get yAxis(): Axis;
                                   /**
                                    * Set whether ZBC should stop connected axis when ZBC is interacted with.
                                    * Defaults to `true`
                                    *
                                    * @param state  - Boolean
                                    * @returns Object itself
                                    * @public
                                    */
                                   setStopAxisOnInteraction(state: boolean): this;
                                   /**
                                    * Get whether ZBC should stop connected axis when ZBC is interacted with.
                                    * Defaults to `true`
                                    *
                                    * @returns Boolean
                                    * @public
                                    */
                                   getStopAxisOnInteraction(): boolean;
                                   /**
                                    * Get size of control as pixels.
                                    *
                                    * For stand-alone component, the size will be equal to the size of its containing HTML \<div\> (`Control.engine.container`)
                                    *
                                    * For component inside Dashboard, the size will only include the component itself, so size can be less than the size of containing HTML \<div\>.
                                    *
                                    * @returns     Object with x and y properties `{ x: number, y: number }`, where both are pixel values.
                                    * @public
                                    */
                                   getSizePixels(): Point;
                                   /**
                                    * Get minimum size of Panel.
                                    * Depending on the type of class this value might be automatically computed to fit different elements.
                                    * @returns Point minimum size or undefined if unimplemented
                                    * @public
                                    */
                                   getMinimumSize(): Point | undefined;
                                   /**
                                    * Set {@link FillStyle} of *series background* (area behind *series*).
                                    *
                                    * ```typescript
                                    *  // Example usage,
                                    *  ChartXY.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 60, 0, 0 ) }))
                                    * ```
                                    *
                                    * **Related API:**
                                    * - Use {@link SolidFill} to describe a solid fill color.
                                    * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
                                    *
                                    * **Transparent chart backgrounds:**
                                    *
                                    * LightningChart JS charts can be configured to be fully or partially transparent.
                                    *
                                    * ```ts
                                    *  // Example, partially transparent chart
                                    *
                                    *  // Engine background exists under all LCJS components. In case of Dashboard, there is only 1 shared engine background.
                                    *  chart.engine.setBackgroundFillStyle(emptyFill)
                                    *  // Chart background covers every 1 chart. In case of Dashboard, every chart has its own chart background.
                                    *  chart.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
                                    *  // Some charts also have a separate series background.
                                    *  chart.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
                                    * ```
                                    *
                                    * @param value - `FillStyle` or function which mutates the active `FillStyle`.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setSeriesBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get FillStyle of Series background area (area behind series).
                                    * @returns FillStyle
                                    * @public
                                    */
                                   getSeriesBackgroundFillStyle(): FillStyle;
                                   /**
                                    * Set {@link LineStyle} of series background border stroke.
                                    *
                                    * ```typescript
                                    *  // Example usage,
                                    *  ChartXY.setSeriesBackgroundStrokeStyle(new SolidLine({
                                    *      thickness: 2,
                                    *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
                                    *  }))
                                    * ```
                                    *
                                    * **Related API:**
                                    * - Use {@link SolidLine} to describe a solid line style.
                                    * - Use {@link SolidFill} to describe a solid fill color.
                                    * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
                                    *
                                    * @param value - `LineStyle` or function which mutates the active `LineStyle`.
                                    * @returns Object itself
                                    * @public
                                    */
                                   setSeriesBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get Stroke style of Series background area (area behind series).
                                    * @returns LineStyle
                                    * @public
                                    */
                                   getSeriesBackgroundStrokeStyle(): LineStyle;
                                   /**
                                    * Set theme effect enabled on component or disabled.
                                    *
                                    * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                    * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                    *
                                    * ```ts
                                    *  // Example, disable theme effect from a particular component.
                                    *  Component.setEffect(false)
                                    * ```
                                    *
                                    * For the most part, theme effects are **enabled** by default on most components.
                                    *
                                    * Theme effect is configured with {@link Theme.effect} property.
                                    *
                                    * @param enabled - Theme effect enabled
                                    * @returns          Object itself.
                                    * @public
                                    */
                                   setSeriesBackgroundEffect(enabled: boolean): this;
                                   /**
                                    * Get theme effect enabled on component or disabled.
                                    *
                                    * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                    * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                    *
                                    * ```ts
                                    *  // Example, disable theme effect from a particular component.
                                    *  Component.setEffect(false)
                                    * ```
                                    *
                                    * For the most part, theme effects are **enabled** by default on most components.
                                    *
                                    * Theme effect is configured with {@link Theme.effect} property.
                                    *
                                    * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                                    * @public
                                    */
                                   getSeriesBackgroundEffect(): boolean;
                                   /**
                                    * Returns the Theme currently being used.
                                    * @returns An object containing the Theme.
                                    * @public
                                    */
                                   getTheme(): Theme;
                                   /**
                                    * Set text of Chart title.
                                    * @param title - Chart title as a string.
                                    * @returns Object itself for fluent interface.
                                    * @public
                                    */
                                   setTitle(title: string): this;
                                   /**
                                    * Get text of Chart title.
                                    * @returns Chart title as a string.
                                    * @public
                                    */
                                   getTitle(): string;
                                   /**
                                    * Set fill style of Chart Title.
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Create a new style
                                    * ZoomBandChart.setTitleFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                    * // Change transparency
                                    * ZoomBandChart.setTitleFillStyle((solidFill) => solidFill.setA(80))
                                    * // Set hidden
                                    * ZoomBandChart.setTitleFillStyle(emptyFill)
                                    * ```
                                    * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                                    * @returns Chart itself
                                    * @public
                                    */
                                   setTitleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fill style of Chart Title.
                                    * @returns FillStyle object
                                    * @public
                                    */
                                   getTitleFillStyle(): FillStyle;
                                   /**
                                    * Set font of Chart Title.
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Create a new FontSettings
                                    * ZoomBandChart.setTitleFont(new FontSettings({ size: 24, style: 'italic' }))
                                    * // Change existing settings
                                    * ZoomBandChart.setTitleFont((fontSettings) => fontSettings.setWeight('bold'))
                                    * ```
                                    * @param value - Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
                                    * @returns Chart itself
                                    * @public
                                    */
                                   setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                   /**
                                    * Get font of Chart title.
                                    * @returns FontSettings object
                                    * @public
                                    */
                                   getTitleFont(): FontSettings;
                                   /**
                                    * Specifies Margins after chart title.
                                    *
                                    * This does not have an effect if title is hidden (empty FillStyle).
                                    *
                                    * ```typescript
                                    *  // Example 1, specify complete margin for Title (four sides).
                                    *  ZoomBandChart.setTitleMargin({ left: 16, right: 16, top: 32, bottom: 8 })
                                    * ```
                                    *
                                    * ```typescript
                                    *  // Example 2, specify only single margin for Title.
                                    *  ZoomBandChart.setTitleMargin({ right: 64 })
                                    * ```
                                    * ```typescript
                                    *  // Example 2, specify margins for all sides with same value for Title.
                                    *  ZoomBandChart.setTitleMargin(40)
                                    * ```
                                    * @param marginPixels - Gap after the chart title in pixels.
                                    * @returns Chart itself for fluent interface
                                    * @public
                                    */
                                   setTitleMargin(marginPixels: Partial<Margin> | pixel): this;
                                   /**
                                    * @returns Padding after Chart title
                                    * @public
                                    */
                                   getTitleMargin(): Partial<Margin>;
                                   /**
                                    * Set padding around Chart in pixels.
                                    *
                                    * `undefined` will restore default behavior, which is to match padding against charts attached to the zoom band chart.
                                    *
                                    * Other value will have the side effect of zoom band chart no longer aligning its padding with those of attached charts.
                                    * This is useful when ZBC and other charts are not aligned in the application.
                                    *
                                    * @param padding - Number with pixel margins for all sides or datastructure with individual pixel paddings
                                    *                      for each side. Any side can be omitted, only passed values will be overridden.
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   setPadding(padding: Partial<Margin> | number | undefined): this;
                                   /**
                                    * Get padding around Chart in pixels.
                                    * @returns Padding datastructure
                                    * @public
                                    */
                                   getPadding(): Margin;
                                   /**
                                    * Set fillStyle of panel background.
                                    * @param value - FillStyle or function which modifies it
                                    * @returns Object itself
                                    * @public
                                    */
                                   setBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                   /**
                                    * Get fillstyle of chart background.
                                    * @returns FillStyle
                                    * @public
                                    */
                                   getBackgroundFillStyle(): FillStyle;
                                   /**
                                    * Set stroke style of panel background.
                                    * @param value - LineStyle or function which modifies it
                                    * @returns Object itself
                                    * @public
                                    */
                                   setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                   /**
                                    * Get stroke style of chart background.
                                    * @returns LineStyle
                                    * @public
                                    */
                                   getBackgroundStrokeStyle(): LineStyle;
                                   /**
                                    * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
                                    *
                                    * ```ts
                                    *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
                                    *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
                                    *  // locationRelative is in pixels relative to bottom left corner of the chart
                                    * ```
                                    *
                                    * Relative coordinates can be used for positioning LightningChart JS UI components:
                                    *
                                    * ```ts
                                    *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
                                    *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
                                    *      .setOrigin(UIOrigins.LeftBottom)
                                    *      .setPosition({ x: 20, y: 20 })
                                    * ```
                                    *
                                    * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                                    * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                                    *
                                    * ```ts
                                    *  LineSeries.add(myData)
                                    *  requestAnimationFrame(() => {
                                    *      // translateCoordinate should now consider data added just now.
                                    *  })
                                    * ```
                                    *
                                    * @public
                                    */
                                   translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
                                   /**
                                    * Translate a coordinate from relative control coordinates to HTML client coordinate system.
                                    *
                                    * ```ts
                                    *  // 10 pixels left and 20 pixels up from controls bottom left corner
                                    *  const locationRelative = { x: 10, y: 20 }
                                    *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
                                    * ```
                                    *
                                    * Client coordinates can be used to absolute position HTML elements using CSS, for example.
                                    *
                                    * ```ts
                                    *  myHTMLElement.style.position = 'absolute'
                                    *  myHTMLElement.style.left = locationClient.clientX
                                    *  myHTMLElement.style.top = locationClient.clientY
                                    * ```
                                    *
                                    * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                                    * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                                    *
                                    * ```ts
                                    *  LineSeries.add(myData)
                                    *  requestAnimationFrame(() => {
                                    *      // translateCoordinate should now consider data added just now.
                                    *  })
                                    * ```
                                    *
                                    * @public
                                    */
                                   translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
                                   /**
                                    * Add a stand-alone *UIElement* using a *builder*.
                                    *
                                    * @typeParam UIElementType -   Type of *UIElement* that is specified by 'builder'-*parameter*.
                                    *
                                    * @param builder - *UIElementBuilder*. If omitted, *TextBoxBuilder* will be selected. Use {@link UIElementBuilders} for selection.
                                    * @param scale - Optional custom scale to position UIElement on. Defaults to whole component in percentages [0, 100].
                                    * @returns Object that fulfills *interfaces*:  *UIElementType* (typeparam) and *UIElement*
                                    * @public
                                    */
                                   addUIElement<UIElementType extends UIPart = UITextBox>(uiElementBuilder?: UIElementBuilder<UIElementType>, scale?: LinearScaleXY): UIElementType & UIElement;
                                   /**
                                    * Capture rendered state in an image file. Prompts the browser to download the created file.
                                    *
                                    * **NOTE: The download might be blocked by browser/plugins as harmful.**
                                    * To prevent this, only call the method in events tied to user-interactions.
                                    * From mouse-event handlers, for example.
                                    *
                                    * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
                                    * For supported image formats, compression quality, Etc. refer to:
                                    *
                                    * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
                                    *
                                    * Example usage:
                                    *```javascript
                                    * // Download 'screenshot.png'
                                    * saveToFile('screenshot')
                                    * // Attempt download 'maybeNotSupported.bmp'
                                    * saveToFile('maybeNotSupported', 'image/bmp')
                                    * // Attempt download jpeg.file with specified compression quality
                                    * saveToFile('fileName', 'image/jpeg', 0.50)
                                    * ```
                                    *
                                    * @remarks              **If 'type' is not supported by browser, an Error will be thrown.**
                                    *
                                    * @param fileName - Name of prompted download file as string. **File extension shouldn't be included**
                                    *                          as it is automatically detected from 'type'-argument.
                                    * @param type - A DOMString indicating the image format. The default format type is image/png.
                                    * @param encoderOptions - A Number between 0 and 1 indicating the image quality to use for image formats
                                    *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
                                    *                          the default value for image quality is used. The default value is 0.92.
                                    * @public
                                    */
                                   saveToFile(fileName: string, type?: string, encoderOptions?: number): this;
                                   /**
                                    * **Permanently** destroy the component.
                                    *
                                    * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                    * **to the component and its children** in application code.
                                    * ```javascript
                                    * let chart = ...ChartXY()
                                    * let axisX = chart.getDefaultAxisX()
                                    * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                    * chart.dispose()
                                    * chart = undefined
                                    * axisX = undefined
                                    * ```
                                    * @returns Object itself for fluent interface
                                    * @public
                                    */
                                   dispose(): this;
                                   /**
                                    * Check whether the object is disposed.
                                    * Disposed objects should not be used!
                                    *
                                    * @returns     `true` if object is disposed.
                                    * @public
                                    */
                                   isDisposed(): boolean;
                                   /**
                                    * Get chart layout information.
                                    * This is a getter variant of {@link ChartXYLayoutChangedEvent}. In most cases, `ChartXYLayoutChangedEvent` is more convenient as it fires whenever the layout changes.
                                    * For more information about the returned value and use cases, please read {@link ChartXYLayoutChangedEvent}.
                                    *
                                    * ```ts
                                    *  // Example syntax
                                    *  chart.getLayout().then(layout => {
                                    *      console.log(layout)
                                    *  })
                                    * ```
                                    *
                                    * @returns     Promise of layout information.
                                    * @public
                                    * @beta    Introduced in v7.0.0. API may be changed according to user feedback.
                                    */
                                   getLayout(): Promise<ChartXYLayoutInfo>;
                                   addEventListener<K extends keyof ZoomBandChartEventMap>(type: K, listener: (event: ZoomBandChartEventMap[K], info: unknown) => unknown, options?: LCJSAddEventListenerOptions): void;
                                   removeEventListener<K extends keyof ZoomBandChartEventMap>(type: K, listener: (event: ZoomBandChartEventMap[K], info: unknown) => unknown): void;
                               }
                               /**
                                * Interface that can be used to define {@link ZoomBandChart} configurations, when inside a {@link Dashboard}, that can't be changed after creation.
                                * @public
                                */
                               export declare interface ZoomBandChartDashboardOptions extends DashboardCellOptions, ZoomBandChartOptions {
                               }
                               /**
                                * Interface of events trackable by {@link ZoomBandChart.addEventListener} and the respective Event types.
                                * @public
                                */
                               export declare interface ZoomBandChartEventMap extends ChartXYEventMap {
                               }
                               /**
                                * @public
                                * @beta    Introduced in v7.0.0. API may change according to user feedback.
                                */
                               export declare interface ZoomBandChartInteractions {
                                   pan?: {
                                       drag?: boolean;
                                       click?: boolean;
                                   };
                                   zoom?: {
                                       wheel?: {
                                           sensitivity?: number;
                                       };
                                       dragKnob?: boolean;
                                   };
                               }
                               /**
                                * Interface that can be used to define {@link ZoomBandChart} configurations that can't be changed after creation.
                                * @public
                                */
                               export declare interface ZoomBandChartOptions extends CommonChartOptions {
                                   /**
                                    * Select orientation of ZoomBandChart.
                                    *
                                    * `'x'` = primary axis is X axis (commonly used when X = Time axis).
                                    *
                                    * `'y'` = opposite mode, for example when Time axis is Y and chart is rotated 90 degrees.
                                    *
                                    * Defaults to `'x'`
                                    * @public
                                    */
                                   orientation?: 'x' | 'y';
                                   /**
                                    * `ZoomBandChart` can display series belonging to several different axes.
                                    * By default, every unique value axis will have its own scale in the zoom band chart.
                                    * By setting this flag to `true`, the zoom band chart will display all its series with 1 shared scale.
                                    *
                                    * For example, imagine an use case where you have 3 temperature (celsius) time series.
                                    * Each trend has the same Time (X) view, but different ranges of values (1: 0 - 10 celsius, 2: 40 - 60 celsius, 3: -10 - 0 celsius)
                                    * If you need to be able to compare the temperatures in the zoom band chart, then you would set this flag to `true`.
                                    *
                                    * Defaults to `false`
                                    * @public
                                    */
                                   useSharedValueAxis?: boolean;
                                   /**
                                    * Interface for specifying Axis configurations that can't be changed after creation of the Zoom Band Chart.
                                    *
                                    * Mainly intended to be able to use high precision axis in time series use cases.
                                    *
                                    * ```ts
                                    *  // Example usage
                                    *  const zoomBandChart = lightningChart().ZoomBandChart({
                                    *      defaultAxis: { type: 'linear-highPrecision' },
                                    *  })
                                    * ```
                                    */
                                   defaultAxis?: AxisOptions;
                               }
                               /**
                                * Type union of Series supported by ZoomBandChart.
                                * @public
                                */
                               export declare type ZoomBandChartSupportedSeries = AreaRangeSeries | OHLCSeries | HeatmapGridSeriesIntensityValues | PointLineAreaSeries;
                               export { }

}